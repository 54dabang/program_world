shell / 2
安装（Windows） / 5
安装（Mac） / 9
安装（Linux） / 13
运行Scala / 19
注释 / 20
编写脚本 / 21
值 / 22
数据类型 / 24
变量 / 27
表达式 / 29
条件表达式 / 31
计算顺序 / 34
组合表达式 / 37
总结1 / 41
方法 / 45
类和对象 / 50
ScalaDoc / 54
创建类 / 55
类中的方法 / 58
导入和包 / 61
测试 / 65
域 / 70
for循环 / 72
Vector / 75
更多的条件表达式 / 79
总结2 / 82
模式匹配 / 91
类参数 / 94
具名参数和缺省参数 / 98
重载 / 101
构造器 / 104
辅助构造器 / 108
类的练习 / 110
case类 / 112
字符串插值 / 115
参数化类型 / 117
作为对象的函数 / 120
map和reduce / 125
推导 / 128
基于类型的模式匹配 / 133
基于case类的模式匹配 / 136
简洁性 / 139
风格拾遗 / 144
地道的Scala / 147
定义操作符 / 148
自动字符串转换 / 151
元组 / 153
伴随对象 / 157
继承 / 163
基类初始化 / 166
覆盖方法 / 170
枚举 / 173
抽象类 / 176
特征 / 179
统一访问方式和setter / 185
衔接Java / 187
应用 / 190
浅尝反射 / 192
多态 / 194
组合 / 200
使用特征 / 206
标记特征和case对象 / 209
类型参数限制 / 211
使用特征构建系统 / 214
序列 / 219
列表和递归 / 223
将序列与zip相结合 / 226
集 / 229
映射表 / 232
引用和可修改性 / 235
使用元组的模式匹配 / 238
用异常进行错误处理 / 242
构造器和异常 / 247
用Either进行错误报告 / 250
用Option对“非任何值”
进行处理 / 255
用Try来转换异常 / 261
定制错误报告机制 / 269
按契约设计 / 276
记日志 / 279
扩展方法 / 282
使用类型类的可扩展系统 / 285
接下来如何深入学习 / 290
附录A　AtomicTest / 291
附录B　从Java中调用
Scala / 293
索引 / 295

第1章 一门可伸缩的语言
第2章 Scala入门
第3章 Scala入门（续）
第4章 类和对象
第5章 基础类型和操作
第6章 函数式对象
第7章 内建的控制结构
第8章 函数和闭包
第9章 控制抽象
第10章 组合和继承
第11章 Scala的继承关系
第12章 特质
第13章 包和引入
第14章 断言和测试
第15章 样例类和模式匹配
第16章 使用列表
第17章 使用其他集合类
第18章 可变对象
第19章 类型参数化
第20章 抽象成员
第21章 隐式转换和隐式参数
第22章 实现列表
第23章 重访for表达式
第24章 深入集合类
第25章 Scala集合架构
第26章 提取器
第27章 注解
第28章 使用XML
第29章 用对象实现模块化编程
第30章 对象相等性
第31章 结合Scala与Java
第32章 Future和并发编程
第33章 组合子解析
第34章 GUI编程
第35章 SCells试算表
附录A Unix和Windows环境的Scala脚本

第1章　基础 A1 1
1．1　Scala解释器 1
1．2　声明值和变量 4
1．3　常用类型 5
1．4　算术和操作符重载 7
1．5　关于方法调用 8
1．6　apply方法 9
1．7　Scaladoc 11
练习 16
第2章　控制结构和函数 A1 19
2．1　条件表达式 20
2．2　语句终止 22
2．3　块表达式和赋值 22
2．4　输入和输出 23
2．5　循环 25
2．6　高级for循环 27
2．7　函数 28
2．8　默认参数和带名参数 L1 29
2．9　变长参数 L1 29
2．10　过程 31
2．11　懒值 L1 31
2．12　异常 32
练习 35
第3章　数组相关操作 A1 39
3．1　定长数组 39
3．2　变长数组：数组缓冲 40
3．3　遍历数组和数组缓冲 41
3．4　数组转换 42
3．5　常用算法 44
3．6　解读Scaladoc 45
3．7　多维数组 47
3．8　与Java的互操作 48
练习 49
第4章　映射和元组 A1 53
4．1　构造映射 53
4．2　获取映射中的值 54
4．3　更新映射中的值 55
4．4　迭代映射 56
4．5　已排序映射 57
4．6　与Java的互操作 57
4．7　元组 58
4．8　拉链操作 59
练习 60
第5章　类 A1 63
5．1　简单类和无参方法 63
5．2　带getter和setter的属性 64
5．3　只带getter的属性 67
5．4　对象私有字段 68
5．5　Bean属性 L1 69
5．6　辅助构造器 71
5．7　主构造器 72
5．8　嵌套类 L175
练习 78
第6章　对象 A1 81
6．1　单例对象 81
6．2　伴生对象 82
6．3　扩展类或特质的对象 83
6．4　apply方法 84
6．5　应用程序对象 85
6．6　枚举 86
练习 87
第7章　包和引入 A1 91
7．1　包 91
7．2　作用域规则 93
7．3　串联式包语句 95
7．4　文件顶部标记法 95
7．5　包对象 96
7．6　包可见性 97
7．7　引入 97
7．8　任何地方都可以声明引入 98
7．9　重命名和隐藏方法 99
7．10　隐式引入 99
练习 100
第8章　继承 A1 103
8．1　扩展类 103
8．2　重写方法 104
8．3　类型检查和转换 105
8．4　受保护字段和方法 106
8．5　超类的构造 106
8．6　重写字段 107
8．7　匿名子类 109
8．8　抽象类 109
8．9　抽象字段 110
8．10　构造顺序和提前定义 L3 110
8．11　Scala类继承关系 112
8．12　对象相等性 L1 114
8．13　值类 L2 116
练习 117
第9章　文件和正则表达式 A1 121
9．1　读取行 121
9．2　读取字符 122
9．3　读取词法单元和数字 123
9．4　从URL或其他源读取 124
9．5　读取二进制文件 124
9．6　写入文本文件 124
9．7　访问目录 125
9．8　序列化 125
9．9　进程控制 A2126
9．10　正则表达式 129
9．11　正则表达式组 130
练习 131
第10章　特质 A1135
10．1　为什么没有多重继承 135
10．2　当作接口使用的特质 137
10．3　带有具体实现的特质 138
10．4　带有特质的对象 139
10．5　叠加在一起的特质 140
10．6　在特质中重写抽象方法 141
10．7　当作富接口使用的特质 142
10．8　特质中的具体字段 143
10．9　特质中的抽象字段 144
10．10　特质构造顺序 145
10．11　初始化特质中的字段 147
10．12　扩展类的特质 148
10．13　自身类型 L2 149
10．14　背后发生了什么 151
练习 152
第11章　操作符 A1157
11．1　标识符 157
11．2　中置操作符 158
11．3　一元操作符 159
11．4　赋值操作符 160
11．5　优先级 161
11．6　结合性 162
11．7　apply和update方法 162
11．8　提取器 L2 164
11．9　带单个参数或无参数的提取器 L2166
11．10　unapplySeq方法 L2167
11．11　动态调用 L2 167
练习 171
第12章　高阶函数 L1 175
12．1　作为值的函数 175
12．2　匿名函数 177
12．3　带函数参数的函数 178
12．4　参数（类型）推断 179
12．5　一些有用的高阶函数 180
12．6　闭包 181
12．7　SAM转换 182
12．8　柯里化 183
12．9　控制抽象 185
12．10　return表达式 186
练习 187
第13章　集合 A2191
13．1　主要的集合特质 192
13．2　可变和不可变集合 193
13．3　序列 195
13．4　列表 196
13．5　集 197
13．6　用于添加或去除元素的操作符 198
13．7　常用方法 201
13．8　将函数映射到集合 203
13．9　化简、折叠和扫描 A3 205
13．10　拉链操作 209
13．11　迭代器 210
13．12　流 A3 211
13．13　懒视图 A3 213
13．14　与Java集合的互操作 213
13．15　并行集合 215
练习 217
第14章　模式匹配和样例类 A2 221
14．1　更好的switch 222
14．2　守卫 223
14．3　模式中的变量 223
14．4　类型模式 224
14．5　匹配数组、列表和元组 225
14．6　提取器 227
14．7　变量声明中的模式 227
14．8　for表达式中的模式 229
14．9　样例类 229
14．10　copy方法和带名参数 230
14．11　case语句中的中置表示法 231
14．12　匹配嵌套结构 232
14．13　样例类是邪恶的吗 233
14．14　密封类 234
14．15　模拟枚举 235
14．16　Option类型 235
14．17 偏函数 L2 236
练习 238
第15章　注解 A2243
15．1　什么是注解 243
15．2　什么可以被注解 244
15．3　注解参数 245
15．4　注解实现 246
15．5　针对Java特性的注解 247
15．5．1　Java修饰符 247
15．5．2　标记接口 248
15．5．3　受检异常 249
15．5．4　变长参数 249
15．5．5　JavaBeans 250
15．6　用于优化的注解 250
15．6．1　尾递归 ．250
15．6．2　跳转表生成与内联 252
15．6．3　可省略方法 253
15．6．4　基本类型的特殊化 254
15．7　用于错误和警告的注解 255
练习 256
第16章　XML处理 A2 259
16．1　XML字面量 260
16．2　XML节点 260
16．3　元素属性 262
16．4　内嵌表达式 263
16．5　在属性中使用表达式 264
16．6　特殊节点类型 265
16．7　类XPath表达式 266
16．8　模式匹配 267
16．9　修改元素和属性 268
16．10　XML变换 269
16．11　加载和保存 270
16．12　命名空间 273
练习 275
第17章　Future A2 277
17．1　在future中运行任务 278
17．2　等待结果 280
17．3　Try类 281
17．4　回调 282
17．5　组合future任务 283
17．6　其他future变换 286
17．7　Future对象中的方法 288
17．8　Promise 289
17．9　执行上下文 291
练习 292
第18章　类型参数 L2 297
18．1　泛型类 298
18．2　泛型函数 298
18．3　类型变量界定 298
18．4　视图界定 300
18．5　上下文界定 301
18．6　ClassTag上下文界定 301
18．7　多重界定 302
18．8　类型约束 L3302
18．9　型变 304
18．10　协变和逆变点 305
18．11　对象不能泛型 307
18．12　类型通配符 308
练习 309
第19章　高级类型 L2 313
19．1　单例类型 313
19．2　类型投影 315
19．3　路径 316
19．4　类型别名 317
19．5　结构类型 318
19．6　复合类型 319
19．7　中置类型 320
19．8　存在类型 321
19．9　Scala类型系统 322
19．10　自身类型 323
19．11　依赖注入 325
19．12　抽象类型 L3 327
19．13　家族多态 L3 329
19．14　高等类型 L3 333
练习 336
第20章　解析 A3 341
20．1　文法 342
20．2　组合解析器操作 343
20．3　解析器结果变换 345
20．4　丢弃词法单元 347
20．5　生成解析树 348
20．6　避免左递归 348
20．7　更多的组合子 350
20．8　避免回溯 352
20．9　记忆式解析器 353
20．10　解析器说到底是什么 354
20．11　正则解析器 355
20．12　基于词法单元的解析器 356
20．13　错误处理 358
练习 359
第21章　隐式转换和隐式参数 L3． 363
21．1　隐式转换 363
21．2　利用隐式转换丰富现有类库的功能 364
21．3　引入隐式转换 365
21．4　隐式转换规则 367
21．5　隐式参数 368
21．6　利用隐式参数进行隐式转换 370
21．7　上下文界定 371
21．8　类型类 372
21．9　类型证明 374
21．10　@implicitNotFound注解 376
21．11　CanBuildFrom解读 376

1什么是函数式编程
1．1 函数式编程的好处：一个简单的例子
1．1．1 一段带有副作用的程序
1．1．2 函数式的解法：去除副作用
1．2 （纯）函数究竟是什么
1．3 引用透明、纯粹度以及替代模型
1．4 小结
2在Scala中使用函数式编程
2．1 Scala语言介绍：
2．2 运行程序
2．3 模块、对象和命名空间
2．4 高阶函数：把函数传给函数
2．4．1 迂回做法：使用循环方式
2．4．2 第一个高阶函数
2．5 多态函数：基于类型的抽象
2．5．1 一个多态函数的例子
2．5．2 对高阶函数传入匿名函数
2．6 通过类型来实现多态
2．7 小结
3函数式数据结构
3．1 定义函数式数据结构
3．2 模式匹配
3．3 函数式数据结构中的数据共享
3．3．1 数据共享的效率
3．3．2 改进高阶函数的类型推导
3．4 基于list的递归并泛化为高阶函数
3．4．1 更多与列表相关的函数
3．4．2 用简单组件组合list函数时的效率损失
3．5 树
3．6 小结
4不是用异常来处理错误
4．1 异常的优点与劣势
4．2 异常的其他选择
4．3 Option数据类型
4．3．1 Option的使用模式
4．3．2 Option的组合、提升及对面向异常的API的包装
4．4 Either数据类型
4．5 小结
5严格求值和惰性求值
5．1 严格和非严格函数
5．2 一个扩展例子：惰性列表
5．2．1 对Stream保持记忆，避免重复运算
5．2．2 用于检测Stream的helper函数
5．3 把函数的描述与求值分离
5．4 无限流与共递归
5．5 小结
6纯函数式状态
6．1 以副作用方式生成随机数
6．2 纯函数式随机数生成器
6．3 用纯函数式实现带状态的API
6．4 状态行为的更好的API
6．4．1 组合状态行为
6．4．2 嵌套状态行为
6．5 更通用的状态行为数据类型
6．6 纯函数式命令编程
6．7 小结
功能设计和组合子库
7纯函数式的并行计算
7．1 选择数据类型和函数
7．1．1 一种用于并行计算的数据类型
7．1．2 组合并行计算
7．1．3 显性分流
7．2 确定表现形式
7．3 完善API
7．4 API与代数
7．4．1 映射法则
7．4．2 分流法则
7．4．3 打破法则：一个微妙的bug
7．4．4 用Actor实现一个完全无阻塞的Par
7．5 完善组合子为更通用的形式
7．6 小结
8基于性质的测试
8．1 基于性质测试概览
8．2 选择数据类型和函数
8．2．1 API的初始代码片段
8．2．2 性质的含义与API
8．2．3 生成器的意义和API
8．2．4 生成值决定生成器
8．2．5 精炼Prop的数据类型
8．3 最小化测试用例
8．4 使用库并改进其易用性
8．4．1 一些简单的例子
8．4．2 为并行计算编写测试套件
8．5 测试高阶函数及展望未来
8．6 生成器法则
8．7 小结
9语法分析器组合子
9．1 代数设计，走起
9．2 一种可能的代数
9．2．1 切片和非空重复
9．3 处理上下文的相关性
9．4 写一个JSON分析器
9．4．1 JSON格式
9．4．2 JSON分析器
9．5 错误提示
9．5．1 一种可行的设计
9．5．2 错误嵌套
9．5．3 控制分支和回溯轨迹
9．6 实现代数
9．6．1 一种可能的实现
9．6．2 串化分析器
9．6．3 标记分析器
9．6．4 故障转移和回溯
9．6．5 上下文相关的分析
9．7 小结
函数设计的通用结构
10Monoid
10．1 什么是monoid
10．2 使用monoid折叠列表
10．3 结合律和并行化
10．4 例子：并行解析
10．5 可折叠数据结构
10．6 组合monoid
10．6．1 组装更加复杂的monoid
10．6．2 使用组合的monoid融合多个遍历
10．7 小结 151
11Monad
11．1 函子：对map函数的泛化
11．1．1 函子法则
11．2 Monad：对flatMap和unit函数的泛化
11．3 Monadic组合子
11．4 单子定律
11．4．1 结合法则
11．4．2 为指定的monad证明结合法则
11．4．3 单位元法则
11．5 什么是monad
11．5．1 identity monad
11．5．2 状态monad和partial type application
11．6 小结
12可应用和可遍历函子
12．1 泛化单子
12．2 Applicative trait
12．3 单子与可应用函子的区别
12．3．1 对比Option applicative与Option monad
12．3．2 对比Parser applicative与Parser monad
12．4 可应用函子的优势
12．4．1 不是所有的可应用函子都是Monad
12．5 可应用法则
12．5．1 Left and right identity
12．5．2 结合律
12．5．3 Naturality of product
12．6 可遍历函子
12．7 使用Traverse
12．7．1 从monoid到可应用函子
12．7．2 带状态的遍历
12．7．3 组合可遍历结构
12．7．4 遍历融合
12．7．5 嵌套遍历
12．7．6 Monad组合
12．8 小结
作用与I/O
13外部作用和I/O
13．1 分解作用13．2 一个简单的IO类型
13．2．1 处理输入效果
13．2．2 简单IO类型的优缺点
13．3 避免栈溢出
13．3．1 将一个控制流转化为数据构造子
13．3．2 Trampolining：栈溢出的通用解决方法
13．4 一个更微妙的IO类型
13．4．1 合理的monad
13．4．2 一个支持控制台I/O的monad
13．4．3 纯解释器
13．5 非阻塞和异步I/O
13．6 一个通用的IO类型
13．6．1 最终的main程序
13．7 为什么IO类型不足以支撑流式I/O
13．8 小结
14本地影响和可变状态
14．1 纯函数式的可变状态
14．2 一种限制副作用范围的数据类型
14．2．1 受限可变性的语言表达
14．2．2 一种可变引用的代数表达
14．2．3 执行修改状态的行为
14．2．4 可变数组
14．2．5 一个纯函数的in-place快排实现
14．3 纯粹是相对于上下文的
14．3．1 副作用是什么？
14．4 小结
15流式处理与增量I/O
15．1 命令式I/O的问题示例
15．2 一个简单的流转换器
15．2．1 创建Process
15．2．2 组合和追加处理
15．2．3 处理文件
15．3 可扩展的处理类型
15．3．1 来源
15．3．2 保证资源安全
15．3．3 单一输入过程
15．3．4 多个输入流
15．3．5 去向
15．3．6 Effectful通道
15．3．7 动态资源分配
15．4 应用场景

