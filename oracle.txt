第1部分　用PL/SQL编程

第1章　PL/SQL介绍	3
1．1　什么是PL/SQL	3
1．2　PL/SQL的起源	4
1．2．1　早期的PL/SQL	4
1．2．2　提高应用的可移植性	4
1．2．3　提高执行权限控制和交易
完整性	5
1．2．4　低调开始，持续改进	5
1．3　这就是PL/SQL	6
1．3．1　与SQL的集成	6
1．3．2　控制和条件逻辑	7
1．3．3　出错处理	8
1．4　关于PL/SQL版本	9
1．4．1　Oracle数据库12c中PL/SQL
的新特性	10
1．5　可供PL/SQL开发者使用的
资源	12
1．5．1　O’Reilly的PL/SQL系列图书	13
1．5．2　网络上的PL/SQL资源	14
1．6　一些建议	15
1．6．1　别急，慢慢来	15
1．6．2　不要畏惧寻求帮助	16
1．6．3　采用有创造性的甚至激进的
方法	17
第2章　创建和运行PL/SQL
代码	18
2．1　在数据库中导航	18
2．2　创建和编辑源代码	19
2．3　SQL*Plus	19
2．3．1　启动SQL*Plus	21
2．3．2　运行SQL语句	22
2．3．3　运行PL/SQL程序	22
2．3．4　运行一个脚本	24
2．3．5　什么是“当前目录”	24
2．3．6　其他SQL*Plus任务	25
2．3．7　SQL*Plus中的异常处理	29
2．3．8　为什么SQL*Plus让我们
又爱又恨	30
2．4　执行基本的PL/SQL任务	30
2．4．1　创建存储程序	31
2．4．2　执行存储的程序	33
2．4．3　显示存储程序	34
2．4．4　存储程序的授权和别名	35
2．4．5　删除一个存储程序	36
2．4．6　隐藏存储程序的源代码	36
2．5　编辑PL/SQL的环境	37
2．6　从其他语言中调用PL/SQL	37
2．6．1　C语言，使用Oracle预编辑器
（Pro*C）	38
2．6．2　Java：使用JDBC	39
2．6．3　Perl：使用Perl DBI和DBD：：
Oracle	40
2．6．4　PHP：使用Oracle扩展	41
2．6．5　PL/SQL Server Pages	42
2．6．6　其他	43
第3章　语言基础	44
3．1　PL/SQL块结构	44
3．1．1　匿名块	46
3．1．2　命名块	47
3．1．3　嵌套块	47
3．1．4　作用范围	48
3．1．5　规范SQL语句中对变量和
列的引用	49
3．1．6　可见性	51
3．2　PL/SQL字符集	54
3．3　标识符	56
3．3．1　保留字	57
3．3．2　空白和关键字	58
3．4　直接量	59
3．4．1　NULL	60
3．4．2　在一个直接量字符串中嵌入
单引号	61
3．4．3　数字直接量	61
3．4．4　布尔直接量	62
3．5　分号分隔符	62
3．6　注释	63
3．6．1　单行注释语法	63
3．6．2　多行注释语法	63
3．7　PRAGMA关键字	64
3．8　标签	65

第2部分　PL/SQL程序结构
第4章　条件与顺序控制	69
4．1　IF语句	69
4．1．1　IF-THEN组合	69
4．1．2　IF-THEN-ELSE的组合	71
4．1．3　IF-THEN-ELSIF组合	73
4．1．4　避免IF语法陷阱	73
4．1．5　嵌套的IF语句	75
4．1．6　短路估算	75
4．2　CASE语句和表达式	77
4．2．1　简单的CASE语句	77
4．2．2　搜索CASE语句	79
4．2．3　嵌套CASE语句	81
4．2．4　CASE表达式	81
4．3　GOTO语句	83
4．4　NULL语句	84
4．4．1　提高程序的可读性	84
4．4．2　在标签后使用NULL	84
第5章　循环迭代处理	86
5．1　循环的基础知识	86
5．1．1　不同循环的示例	86
5．1．2　PL/SQL循环的结构	88
5．2　简单循环	89
5．2．1　终止简单循环：EXIT
和EXIT WHEN	89
5．2．2　模仿REPEAT UNTIL循环	90
5．2．3　故意的无限循环	91
5．3　WHILE循环	92
5．4　数值型FOR循环	93
5．4．1　数值型FOR循环的规则	94
5．4．2　数值型FOR循环的示例	94
5．4．3　处理特殊增量	95
5．5　游标FOR循环	96
5．5．1　游标FOR循环的示例	97
5．6　循环标签	98
5．7　CONTINUE语句	99
5．8　迭代处理技巧	102
5．8．1　为循环索引使用可理解的
名称	102
5．8．2　以正确的方式说再见	102
5．8．3　获取FOR循环执行的信息	103
5．8．4　循环SQL语句	104
第6章　异常处理	106
6．1　异常处理概念和术语	106
6．2　定义异常	108
6．2．1　声明命名异常	108
6．2．2　关联异常名称与错误代码	109
6．2．3　命名的系统异常	112
6．2．4　异常作用范围	114
6．3　引发异常	115
6．3．1　RAISE语句	115
6．3．2　使用RAISE_APPLICATION_
ERROR	116
6．4　处理异常	117
6．4．1　内置错误函数	118
6．4．2　单一处理句柄中结合多个
异常	122
6．4．3　未处理异常	123
6．4．4　未处理异常的传播	123
6．4．5　继续过去的异常	125
6．4．6　编写WHEN OTHERS处理
代码	127
6．5　构建有效的错误管理架构	129
6．5．1　确定我们的异常管理策略	129
6．5．2　对不同类型异常进行标准化
处理	130
6．5．3　程序特定错误代码的组织
使用	133
6．5．4　使用标准的错误管理程序	133
6．5．5　使用自己的异常“对象”	135
6．5．6　创建常见错误处理的标准
模板	137
6．6　充分利用PL/SQL错误
管理	138

第3部分　PL/SQL程序数据

第7章　使用程序数据	141
7．1　程序数据的命名	141
7．2　PL/SQL数据类型概述	143
7．2．1　字符数据	143
7．2．2　数字	144
7．2．3　日期、时间戳和时间间隔	145
7．2．4　布尔类型	145
7．2．5　二进制数据类型	146
7．2．6　ROWID	146
7．2．7　REF CURSOR	146
7．2．8　Internet数据类型	147
7．2．9 “Any”数据类型	147
7．2．10　用户自定义数据类型	147
7．3　程序数据的声明	147
7．3．1　声明一个变量	148
7．3．2　声明常量	148
7．3．3　NOT NULL语句	149
7．3．4　锚定声明	149
7．3．5　游标和表的锚	151
7．3．6　使用锚定声明的益处	152
7．3．7　NOT NULL数据类型的锚	153
7．4　程序员定义的子类型	153
7．5　数据类型转换	154
7．5．1　隐式类型转换	155
7．5．2　显式类型转换	156
第8章　字符串	162
8．1　字符串类型	162
8．1．1　VARCHAR2数据类型	163
8．1．2　CHAR数据类型	164
8．1．3　String子类型	164
8．2　使用字符串	165
8．2．1　指定字符串常量	165
8．2．2　不可打印字符	167
8．2．3　拼接字符串	168
8．2．4　处理大小写	169
8．2．5　传统的检索、提取和替换	172
8．2．6　填充	174
8．2．7　剪裁	176
8．2．8　正则表达式的检索、提取和
替换	177
8．2．9　使用空字符串	187
8．2．10　混用CHAR和
VARCHAR2	188
8．3　字符串函数快速参考	190
第9章　数字	199
9．1　数值型数字类型	199
9．1．1　NUMBER类型	200
9．1．2　PLS_INTEGER类型	204
9．1．3　BINARY_INTEGER类型	205
9．1．4　SIMPLE_INTEGER类型	205
9．1．5　BINARY_FLOAT和
BINARY_DOUBLE类型	207
9．1．6　SIMPLE_FLOAT和
SIMPLE_DOUBLE类型	212
9．1．7　数字子类型	212
9．2　数字转换	213
9．2．1　TO_NUMBER函数	213
9．2．2　TO_CHAR函数	216
9．2．3　CAST函数	221
9．2．4　隐式转换	222
9．3　数字运算符	224
9．4　数字函数	224
9．4．1　四舍五入和截断函数	224
9．4．2　三角函数	225
9．4．3　数字函数的快速参考	225
第10章　日期和时间戳	230
10．1　Datetime数据类型	230
10．1．1　声明日期时间变量	233
10．1．2　选择日期时间数据类型	233
10．2　获取当前日期和时间	234
10．3　INTERVAL数据类型	236
10．3．1　声明INTERVAL变量	237
10．3．2　什么时候使用INTERVAL	238
10．4　日期时间转换	240
10．4．1　从字符串到日期时间	240
10．4．2　从日期时间到字符串	242
10．4．3　使用时区	245
10．4．4　精确匹配需要格式掩码	247
10．4．5　让精确匹配更轻松	248
10．4．6　解释滑动窗口中两位数字的
年份	248
10．4．7　把时区转换成字符串	249
10．4．8　用填充模式把输出补齐	250
10．5　日期和时间戳直接量	251
10．6　时间间隔的转换	252
10．6．1　从数字到时间间隔的转换	252
10．6．2　把字符串转换成间隔	253
10．6．3　时间间隔的格式化显示	254
10．7　时间间隔直接量	254
10．8　CAST和EXTRACT	256
10．8．1　CAST函数	256
10．8．2　EXTRACT函数	258
10．9　日期时间的算法	258
10．9．1　时间间隔和日期时间的
算法	259
10．9．2　DATE数据类型的日期
算法	260
10．9．3　计算两个日期时间之间的
时间间隔	260
10．9．4　DATE和TIMESTAMP混合
计算	262
10．9．5　时间间隔的加减运算	263
10．9．6　时间间隔的乘除运算	264
10．9．7　使用不受限制的时间间隔
类型	264
10．10　日期/时间函数的快速
参考	266
第11章　记录类型	269
11．1　PL/SQL中的记录	269
11．1．1　使用记录的好处	270
11．1．2　声明记录	271
11．1．3　程序员自定义的记录类型	273
11．1．4　使用记录类型	275
11．1．5　记录的比较	281
11．1．6　触发器伪记录	282
第12章　集合	284
12．1　集合概述	285
12．1．1　集合概念和术语	285
12．1．2　集合类型	287
12．1．3　集合示例	288
12．1．4　使用集合的场合	291
12．1．5　选择一个集合类型	296
12．2　集合方法（内置）	297
12．2．1　COUNT方法	298
12．2．2　DELETE方法	299
12．2．3　EXISTS方法	300
12．2．4　EXTEND方法	300
12．2．5　FIRST和LAST方法	301
12．2．6　LIMIT方法	302
12．2．7　PRIOR和NEXT方法	303
12．2．8　TRIM方法	304
12．3　使用集合	305
12．3．1　声明集合类型	306
12．3．2　集合变量的声明和初始化	310
12．3．3　用数据填充集合	313
12．3．4　访问集合内的数据	318
12．3．5　使用字符串索引的集合	319
12．3．6　复杂数据类型的集合	324
12．3．7　多级集合	327
12．3．8　在SQL中使用集合	335
12．4　嵌套表的多重集合操作	342
12．4．1　测试嵌套表是否相等及成员
归属	343
12．4．2　检查元素是否是嵌套表的
成员	344
12．4．3　执行高级别集合操作	345
12．4．4　嵌套表中的去重	346
12．5　schema级别集合的维护	347
12．5．1　必需的权限	347
12．5．2　集合和数据字典	348
第13章　其他数据类型	349
13．1　BOOLEAN类型	349
13．2　RAW数据类型	350
13．3　UROWID和ROWID数据
类型	351
13．3．1　获取ROWID	352
13．3．2　使用ROWID	352
13．4　LOB数据类型	353
13．5　使用LOB	354
13．5．1　理解LOB定位符	356
13．5．2　LOB的空和NULL	357
13．5．3　向LOB中写入数据	359
13．5．4　读取LOB数据	361
13．5．5　BFILE的不同之处	363
13．5．6　SecureFiles和BasicFiles	367
13．5．7　临时LOB	369
13．5．8　原生的LOB操作	372
13．5．9　LOB转换函数	376
13．6　预定义的对象类型	376
13．6．1　XMLType类型	376
13．6．2　URI类型	379
13．6．3　Any类型	381

第4部分　PL/SQL中的SQL

第14章　DML和事务管理	387
14．1　PL/SQL中的DML	388
14．1．1　DML简介	388
14．1．2　DML操作符的游标属性	391
14．1．3　从DML语句返回信息	392
14．1．4　DML和异常处理	393
14．1．5　DML和记录	394
14．2　事务管理	397
14．2．1　COMMIT语句	397
14．2．2　ROLLBACK语句	398
14．2．3　SAVEPOINT语句	399
14．2．4　SET TRANSACTION语句	399
14．2．5　LOCK TABLE语句	400
14．3　自治事务	400
14．3．1　定义自治事务	401
14．3．2　自治事务的规则和限制	402
14．3．3　事务的可见性	403
14．3．4　何时使用自治事务	403
14．3．5　创建自治日志记录机制	404
第15章　数据提取	407
15．1　游标基础	408
15．1．1　一些数据提取术语	408
15．1．2　典型的查询操作	410
15．1．3　游标属性介绍	411
15．1．4　在游标中引用PL/SQL
变量	413
15．1．5　显式与隐式游标之间的
选择	414
15．2　使用隐式游标	414
15．2．1　隐式游标示例	415
15．2．2　隐式游标的异常处理	416
15．2．3　隐式SQL游标的属性	418
15．3　使用显式游标	419
15．3．1　声明显式游标	420
15．3．2　打开显式游标	423
15．3．3　从显式游标获取	424
15．3．4　显式游标中的列别名	425
15．3．5　关闭显式游标	426
15．3．6　显式游标属性	427
15．3．7　游标参数	429
15．4　SELECT…FOR UPDATE	432
15．4．1　COMMIT释放锁定	433
15．4．2　WHERE CURRENT
OF子句	434
15．5　游标变量和REF
CURSOR	435
15．5．1　为什么使用游标变量	436
15．5．2　与静态游标的相似之处	437
15．5．3　声明REF CURSOR类型	437
15．5．4　声明游标变量	438
15．5．5　打开游标变量	439

15．5．6　从游标变量中提取数据	440
15．5．7　游标变量的使用规则	442
15．5．8　将游标变量作为参数传递	445
15．5．9　游标变量的约束限制	447
15．6　游标表达式	447
15．6．1　使用游标表达式	448
15．6．2　游标表达式的约束限制	450
第16章　动态SQL和动态
PL/SQL	451
16．1　NDS语句	452
16．1．1　EXECUTE IMMEDIATE
语句	452
16．1．2　OPEN FOR语句	455
16．1．3　4种动态SQL方法	460
16．2　绑定变量	462
16．2．1　参数模式	463
16．2．2　重复的占位符	465
16．2．3　传递NULL值	465
16．3　使用对象和集合	466
16．4　动态PL/SQL	468
16．4．1　建立动态PL/SQL块	469
16．4．2　用动态块替换重复代码	470
16．5　NDS建议	471
16．5．1　对共享程序使用调用者
权限	471
16．5．2　预测并处理动态错误	472
16．5．3　使用绑定而非拼接	474
16．5．4　减少代码注入的危险	475
16．6　何时使用DBMS_SQL	478
16．6．1　获得查询列信息	478
16．6．2　实现第四种方法的动态
SQL需求	479
16．6．3　最小化动态游标解析	485
16．6．4　Oracle数据库11g新动态
SQL特性	486
16．6．5　DBMS_SQL增强安全	490

目录（下）
第5部分　构造PL/SQL应用程序
第17章　过程、函数和参数	497
17．1　代码模块化	497
17．2　过程	499
17．2．1　调用一个过程	501
17．2．2　过程头部	501
17．2．3　过程体	501
17．2．4　END标签	502
17．2．5　RETURN语句	502
17．3　函数	502
17．3．1　函数的结构	503
17．3．2　返回的数据类型	504
17．3．3　END标签	506
17．3．4　调用函数	506
17．3．5　不带参数的函数	507
17．3．6　函数头	508
17．3．7　函数体	508
17．3．8　RETURN语句	509
17．4　参数	510
17．4．1　定义参数	511
17．4．2　实参和形参	511
17．4．3　参数模式	512
17．4．4　在PL/SQL中显式地关联
实参和形参	515
17．4．5　NOCOPY参数模式限定符	519
17．4．6　缺省值	519
17．5　局部或者嵌套模块	520
17．5．1　使用局部模块的益处	521
17．5．2　局部模块的作用范围	523
17．5．3　用局部模块使得代码更
整洁	524
17．6　模块的重载	524
17．6．1　重载的益处	525
17．6．2　重载的限制	528
17．6．3　数字类型的重载	528
17．7　前置声明	529
17．8　高级主题	530
17．8．1　在SQL内部调用我们的
函数	530
17．8．2　表函数	536
17．8．3　确定性函数	545
17．8．4　隐式游标结果（Oracle
数据库12c）	546
17．9　将模块化进行到底	547
第18章　程序包	548
18．1　为什么使用程序包	548
18．1．1　演示程序包的能力	549
18．1．2　与程序包相关的一些概念	552
18．1．3　图示私有性	553
18．2　构建程序包的规则	554
18．2．1　程序包说明	554
18．2．2　包体	555
18．2．3　包的初始化	557
18．3　包元素的调用规则	561
18．4　使用包数据	562
18．4．1　在一个Oracle会话内全局
可见	562
18．4．2　全局公有数据	563
18．4．3　包游标	563
18．4．4　包的串行化	568
18．5　何时使用包	570
18．5．1　封装对数据的访问	570
18．5．2　避免直接量的硬编码	573
18．5．3　提高内置特性的可用性	575
18．5．4　把逻辑上相关的功能组织
在一起	576
18．5．5　缓存静态的会话数据	576
18．6　包和对象类型	577
第19章　触发器	578
19．1　DML触发器	579
19．1．1　DML触发器的概念	580
19．1．2　创建DML触发器	581
19．1．3　DML触发器的例子：严禁
作弊！	586
19．1．4　同一类型的多个触发器	591
19．1．5　如何对触发顺序排序	592
19．1．6　突变表的错误	594
19．1．7　复合触发器：聚在一处	595
19．2　DDL触发器	598
19．2．1　创建DDL触发器	598
19．2．2　可用事件	600
19．2．3　可用属性	601
19．2．4　使用事件和属性	602
19．2．5　删除不可删除的	606
19．2．6　INSTEAD OFCREATE
触发器	606
19．3　数据库事件触发器	607
19．3．1　创建数据库事件触发器	608
19．3．2　STARTUP触发器	609
19．3．3　SHUTDOWN触发器	610
19．3．4　LOGON触发器	610
19．3．5　LOGOFF触发器	610
19．3．6　SERVERERROR触发器	611
19．4　INSTEAD OF触发器	615
19．4．1　创建INSTEAD OF触发器	615
19．4．2　INSTEAD OF INSERT
触发器	616
19．4．3　INSTEAD OF UPDATE
触发器	618
19．4．4　INSTEAD OF DELETE
触发器	619
19．4．5　填充表	619
19．4．6　嵌套表的lNSTEAD OF
触发器	620
19．5　AFTER SUSPEND触发器	621
19．5．1　建立AFTER SUSPEND
触发器	622
19．5．2　看看真实的触发器	623
19．5．3　ORA_SPACE_ERROR_lNFO
函数	624
19．5．4　DBMS_RESUMABLE包	625
19．5．5　捕获多个时间	626
19．5．6　是否该处理？	627
19．6　维护触发器	628
19．6．1　禁用、启用以及删除
触发器	628
19．6．2　创建一个禁用的触发器	628
19．6．3　查看触发器	629
19．6．4　检查触发器的有效性	630
第20章　管理PL/SQL代码	631
20．1　管理数据库内的代码	632
20．1．1　数据字典视图概述	632
20．1．2　显示存储对象的信息	634
20．1．3　源代码的显示和搜索	635
20．1．4　根据程序的大小确定Pinning
需求	637
20．1．5　获得存储代码的属性	637
20．1．6　通过视图分析和更改触发器
状态	638
20．1．7　分析参数信息	639
20．1．8　分析标识符的使用（Oracle
数据库11g的PL/Scope）	640
20．2　管理依赖关系及重编译
代码	643
20．2．1　通过数据字典视图分析依赖
关系	643
20．2．2　细粒度依赖（Oracle
数据库11g）	647
20．2．3　远程依赖	648
20．2．4　Oracle的远程调用模式的
限制	650
20．2．5　重编译无效的程序单元	651
20．3　编译时刻警告	655
20．3．1　一个快速示例	655
20．3．2　开启编译时刻告警	656
20．3．3　一些有用的警告	657
20．4　测试PL/SQL程序	664
20．4．1　典型的、华而不实的测试
技术	665
20．4．2　PL/SQL代码测试的一般
建议	668
20．4．3　PL/SQL的自动测试选项	669
20．5　跟踪PL/SQL的执行	670
20．5．1　DBMS_UTILITY．FORMAT_
CALL_STACK	671
20．5．2　UTL_CALL_STACK（Oracle
数据库12c）	673
20．5．3　DBMS_APPLICATION_
INFO	676
20．5．4　使用opp_trace进行跟踪	677
20．5．5　DBMS_TRACE工具包	678
20．6　PL/SQL程序的调试	681
20．6．1　错误的调试方法	682
20．6．2　调试技巧和策略	683
20．7　使用白名单来控制对程序
单元的访问	687
20．8　存储代码的保护	689
20．8．1　封装的约束和局限	690
20．8．2　使用封装程序	690
20．8．3　使用DBMS_DDL进行动态
封装	690
20．8．4　封装代码的使用指导	691
20．9　基于版本的重定义（Oracle
数据库11g R2版本）	692
第21章　PL/SQL的性能优化	695
21．1　辅助优化的工具	696
21．1．1　内存使用分析	696
21．1．2　发现PL/SQL代码中的瓶颈	697
21．1．3　计算花费时间	701
21．1．4　选择最快的程序	703
21．1．5　避免无限循环	704
21．1．6　性能相关的警告	706
21．2　优化编译器	706
21．2．1　优化器工作原理	707
21．2．2　循环Fetch操作的运行
时优化	710
21．3　数据缓存技术	710
21．3．1　基于包的缓存	711
21．3．2　确定性函数的缓存	716
21．3．3　函数结果缓存（Oracle
数据库11g）	718
21．3．4　缓存总结	731
21．4　重复的SQL的语句批
处理	732
21．4．1　通过BULK COLLECT加速
查询	733
21．4．2　使用FORALL加速DML	739
21．5　利用管道化的表函数提升
性能	749
21．5．1　用基于管道化函数的加载
方式替换基于行的插入	750
21．5．2　用管道函数调优Merge
操作	756
21．5．3　用并行管道函数进行异步
数据导出	758
21．5．4　并行管道函数中的分区和
流子句对性能的影响	761
21．5．5　管道函数和基于成本的
优化器	763
21．5．6　用管道函数优化负载的数据
加载	768
21．5．7　管道函数结束语	775
21．6　专用的优化技术	775
21．6．1　使用NOCOPY参数模式
提示符	775
21．6．2　使用正确的数据类型	778
21．6．3　SQL（12．1及更高版本）的
函数性能优化	779
21．7　性能回顾	780
第22章　I/O操作和PL/SQL	781
22．1　显示信息	781
22．1．1　启用DBMS_OUTPUT	782
22．1．2　向缓存中写入行	782
22．1．3　从缓存中读取内容	783
22．2　文件的读写	784
22．2．1　UTL_FILE_DIR参数	784
22．2．2　使用Oracle目录	786
22．2．3　打开文件	787
22．2．4　文件已经打开了吗？	789
22．2．5　关闭文件	789
22．2．6　读取文件	790
22．2．7　向文件中写	792
22．2．8　复制文件	795
22．2．9　删除文件	795
22．2．10　改名和移动文件	796
22．2．11　提取文件属性	797
22．3　发送邮件	798
22．3．1　Oracle的前提条件	798
22．3．2　设置网络安全	799
22．3．3　发送一个短的（小于32767字
节）的纯文本消息	799
22．3．4　在邮件地址中加上“界面友
好的”的名字	801
22．3．5　发送任意长度的纯文本
消息	802
22．3．6　发送带有小附件（小于32767
字节）的消息	803
22．3．7　以附件形式发送一个小文件
（小于32767字节）	805
22．3．8　任意大小的附件	805

22．4　使用基于Web的数据
（HTTP）	808
22．4．1 “分片”获得一个Web页面	808
22．4．2　把页面提取到一个LOB中	809
22．4．3　使用HTTP的用户名/密码
验证	810
22．4．4　获取一个SSL加密的Web页面
（使用HTTPS）	811
22．4．5　通过GET或者POST向Web页
面提交数据	812
22．4．6　禁用cookie或者使cookie
持久化	816
22．4．7　从FTP服务器获取数据	816
22．4．8　使用代理服务器	817
22．5　PL/SQL中可用的其他I/O
类型	817
22．5．1　数据库管道、队列、告警	817
22．5．2　TCPSocket	818
22．5．3　Oracle的内置Web服务器	818


第6部分　高级PL/SQL主题
第23章　应用系统安全与
PL/SQL	821
23．1　安全概述	821
23．2　加密	822
23．2．1　密钥长度	823
23．2．2　算法	824
23．2．3　填补和连接	825
23．2．4　DBMS_CRYPTO包	825
23．2．5　数据加密	827
23．2．6　LOB的加密	830
23．2．7　安全文件	830
23．2．8　数据解密	831
23．2．9　生成密钥	832
23．2．10　密钥的管理	833
23．2．11　加密哈希	838
23．2．12　使用消息验证码	839
23．2．13　使用透明数据加密
（TDE）	841
23．2．14　透明的表空间加密	843
23．3　行级安全	844
23．3．1　为什么要学习RLS	846
23．3．2　一个简单的RLS示例	847
23．3．3　静态与动态策略	850
23．3．4　使用列敏感的RLS	854
23．3．5　RLS调试	857
23．4　应用程序上下文	861
23．4．1　使用应用程序上下文	862
23．4．2　上下文的安全	863
23．4．3　把上下文用作RLS的谓词
条件	863
23．4．4　识别出非数据库的用户	867
23．5　细粒度审计	868
23．5．1　为什么要学习FGA	869
23．5．2　一个简单的FGA示例	870
23．5．3　访问多少列	872
23．5．4　查看审计跟踪信息	873
23．5．5　使用绑定变量	874
23．5．6　使用句柄模块	875
第24章　PL/SQL架构	877
24．1　DIANA	877
24．2　Oracle如何执行PL/SQL
代码	878
24．2．1　一个示例	879
24．2．2　编译器的限制	881
24．3　PL/SQL的缺省包	882
24．4　执行权限模型	884
24．4．1　定义者权限模型	885
24．4．2　调用者权限模型	889
24．4．3　组合权限模型	891
24．4．4　给PL/SQL程序单元授予角色
（Oracle数据库12c）	892
24．4．5 “谁调用了我？”函数
（Oracle数据库12c）	895
24．4．6　视图的BEQUEATH CURRENT_
USER子句（Oracle数据库
12c）	895
24．4．7　调用者权限优点的限制
（Oracle数据库12c）	897
24．5　条件编译	898
24．5．1　条件编译的示例	899
24．5．2　查询指令	900
24．5．3　$IF指令	903
24．5．4　$ERROR指令	904
24．5．5　将代码与包常量同步	905
24．5．6　用查询指令实现程序专有
设置	906
24．5．7　使用预处理后的代码	907
24．6　PL/SQL和数据库实例
内存	908
24．6．1　SGA、PGA和UGA	908
24．6．2　游标、内存及其他	909
24．6．3　减少内存使用的技巧	910
24．6．4　内存用光了怎么办	920
24．7　原生式编译	922
24．7．1　什么时候使用解释模式	922
24．7．2　什么时候使用原生模式	922
24．7．3　原生编译和数据库版本	923
24．8　一些须知	923
第25章　PL/SQL的全球化和
本地化	925
25．1　概述和术语	926
25．2　Unicode入门	928
25．2．1　国家字符集的数据类型	929
25．2．2　字符编码	929
25．2．3　和全球化支持相关的参数	930
25．2．4　Unicode函数	931
25．3　字符语义	938
25．4　字符串排序顺序	941
25．4．1　二进制排序	942
25．4．2　单语言排序	943
25．4．3　多语言排序	945
25．5　多语言信息检索	946
25．5．1　信息检索和PL/SQL	948
25．6　日期/时间	950
25．6．1　时间戳数据类型	951
25．6．2　日期/时间格式	952
25．7　货币转换	955
25．8　PL/SQL的全球化开发
工具箱	957
25．8．1　UTL_I18N工具包	957
25．8．2　UTL_LMS异常处理包	960
25．8．3　GDK实现选项	961
第26章　PL/SQL的面向对象
特性	963
26．1　Oracle对象特性的介绍	963
26．2　对象类型示例	965
26．2．1　创建一个基类	966
26．2．2　创建子类型	967
26．2．3　方法	968
26．2．4　在Oracle数据库11g及以后
版本中调用父类的方法	972
26．2．5　保存、提取、使用持久化
对象	974
26．2．6　演变和创建	981
26．2．7　回到指针吗？	983
26．2．8　泛化数据：ANY类型	989
26．2．9　我们自己做	993
26．2．10　对象的比较	996
26．3　对象视图	1001
26．3．1　一个关系型系统的示例	1002
26．3．2　带有集合属性的对象视图	1003
26．3．3　对象子视图	1006
26．3．4　带有反关系的对象视图	1008
26．3．5　INSTEAD OF触发器	1008
26．3．6　对象视图和对象表的区别	1010
26．4　维护对象类型和对象视图	1012
26．4．1　数据字典	1012
26．4．2　权限	1013
26．5　来自一个关系开发者的总结
思考（C551， E1200）	1015
第27章　从PL/SQL中调用
Java	1017
27．1　Oracle和Java	1017
27．2　准备好在Oracle中使用
Java	1018
27．2．1　安装Java	1019
27．2．2　创建和编译我们的Java
代码	1019
27．2．3　设置Java开发和执行的
权限	1020
27．3　一个简单的演示	1022
27．3．1　查找Java功能	1023
27．3．2　创建一个自定义Java类	1023
27．3．3　编译和加载到Oracle	1025
27．3．4　创建一个PL/SQL的
包装器	1026
27．3．5　从PL/SQL删除文件	1027
27．4　使用loadjava	1028
27．5　使用dropjava	1030
27．6　管理数据库中的Java	1030
27．6．1　Oracle中的Java命名空间	1030
27．6．2　检查加载的Java元素	1031
27．7　使用DBMS_JAVA	1032
27．7．1　LONGNAME：转换Java
长名字	1032
27．7．2　GET_、SET_和RESET_
COMPILER_OPTION：
得到和设置（一些）
编译器选项	1033
27．7．3　SET_OUTPUT：允许从
Java中输出	1034
27．7．4　EXPORT_SOURCE、EXPORT_
RESOURCE和EXPORT_
CLASS：导出模式对象	1034
27．8　在PL/SQL中发布与
使用Java	1036
27．8．1　调用规范	1036
27．8．2　一些调用规范的规则	1037
27．8．3　映射数据类型	1038
27．8．4　在SQL中调用Java方法	1039
27．8．5　Java的异常处理	1040
27．8．6　扩展文件I/O功能	1042
27．8．7　其他示例	1046
第28章　外部过程	1049
28．1　外部过程介绍	1050
28．1．1　示例：调用一个系统命令	1050
28．1．2　外部过程的架构	1052
28．2　Oracle网络配置	1053
28．2．1　定义监听配置	1053
28．2．2　配置的安全特性	1055
28．3　设置多线程模式	1056
28．4　创建一个Oracle库	1058
28．5　编写调用规范	1059
28．5．1　调用规范：整体语法	1060
28．5．2　参数映射：示例重温	1061
28．5．3　参数映射：完整的内容	1063
28．5．4　更多的语法：参数子句	1064
28．5．5　参数属性	1065
28．6　从调用的C程序中引发
一个异常	1068
28．7　非默认的代理	1071
28．8　维护外部过程	1073
28．8．1　删除库	1073
28．8．2　数据字典	1074
28．8．3　规则和警示	1074
附录A　正则表达式元字符和函数
参数	1075
附录B　数字格式模型	1080
附录C　日期格式模型	1083

第0章Oracle的安装及相关配置
视频讲解：7集36分钟
0.1Oracle的安装
0.2Oracle11g和Oracle12c中的SQL*Plus
0.3scott用户及其对象维护
0.4虚拟环境的创建
0.5虚拟人物
第1章Oracle的体系结构
视频讲解：4集39分钟
1.1Oracle引入复杂的体系结构的原因
1.2Oracle数据库中常用的术语
1.3Oracle数据库管理系统的体系结构
1.4Oracle服务器
1.5Oracle实例
1.6Oracle数据库
1.7Oracle其他的关键文件
1.8建立与Oracle实例的连接
1.9各种不同的连接方式
1.10服务器进程
1.11Oracle执行SQL查询语句的步骤
1.12共享池
1.13数据库高速缓冲区
1.14内存缓冲区顾问
1.15重做日志缓冲区
1.16大池、Java池和Streams池
1.17内存缓冲区大小的设定
1.18内存缓冲区信息的获取
1.19重做日志写进程及快速提交
1.20数据库写进程
1.21系统监督进程
1.22进程监督进程
1.23校验（检查）点和校验点进程
1.24归档日志进程
1.25小结
1.26您应该掌握的内容
第2章数据库管理工具
视频讲解：9集38分钟
2.1Oracle通用安装程序
2.2交互式启动OracleUniversalInstaller
2.3非交互式启动OracleUniversalInstaller
2.4Oracle数据库配置助手
2.5使用Oracle数据库配置助手创建数据库
2.6数据库管理员用户sys和system
2.7SQL*Plus命令行工具
2.8Oracle10g企业管理器（EM）
2.9Oracle11g企业管理器（EM）
2.10将SYSDBA权限授予普通用户
2.11Oracle12cEMDatabaseExpress
2.12SQLDeveloper简介
2.13您应该掌握的内容
第3章Oracle实例的管理
视频讲解：3集22分钟
3.1初始化参数文件
3.2静态参数文件
3.3静态参数文件的创建和例子
3.4动态服务器参数文件
3.5动态服务器参数文件的创建和参数的浏览
3.6启动数据库
3.7将数据库置为限制模式
3.8关闭数据库
3.9关闭数据库的实际例子
3.10如何利用诊断文件来监督实例
3.11Oracle11g和Oracle12c诊断文件
3.12Oracle11g和Oracle12c的ADRCI
3.13您应该掌握的内容
第4章数据字典和控制文件
视频讲解：4集27分钟
4.1数据字典简介
4.2数据字典中所存的信息
4.3数据字典的操作和使用
4.4数据字典视图
4.5格式化数据字典视图的输出
4.6如何使用数据字典视图
4.7动态性能表（视图）
4.8数据字典应用实例
4.9控制文件的定义及引入的目的
4.10控制文件中所存的内容
4.11从控制文件中获取信息的数据字典
4.12如何限定控制文件的大小
4.13怎样查看控制文件的配置
4.14怎样添加和移动控制文件
4.15控制文件的备份
4.16移动控制文件的实例
4.17您应该掌握的内容
第5章重做日志文件
视频讲解：3集29分钟
5.1引入重做日志的目的
5.2重做日志组
5.3重做日志成员
5.4日志切换和检查点
5.5获取重做日志的信息
5.6添加和删除联机重做日志文件组
5.7添加和删除联机重做日志成员（文件）
5.8清除联机重做日志文件
5.9利用OMF来管理联机重做日志文件
5.10联机重做日志的配置
5.11重做日志配置的应用实例
5.12您应该掌握的内容
第6章表空间和数据文件的管理
视频讲解：5集44分钟
6.1Oracle引入逻辑结构的目的
6.2Oracle数据库中存储结构之间的关系
6.3表空间和数据文件之间的关系及表空间的分类
6.4表空间中的磁盘空间管理
6.5创建本地管理的表空间
6.6还原表空间
6.7临时表空间
6.8默认临时表空间
6.9设置表空间为脱机
6.10只读表空间
6.11重置表空间的大小
6.12手工重置数据文件的大小
6.13移动数据文件的方法
6.14移动数据文件的应用实例
6.15删除表空间
6.16利用OMF来管理表空间
6.17创建表空间的应用实例
6.18您应该掌握的内容
第7章存储结构和它们之间的关系
视频讲解：3集21分钟
7.1各种类型的段
7.2存储子句的优先级
7.3区段
7.4数据库块
7.5Oracle数据块的大小
7.6数据库块的内容和参数
7.7手工数据块的管理
7.8自动的段空间管理
7.9小结
7.10您应该掌握的内容
第8章管理还原数据
视频讲解：3集23分钟
8.1还原数据的管理方法
8.2Oracle使用还原段的目的
8.3还原段的类型
8.4自动还原数据管理的概念和配置
8.5还原表空间的创建与维护
8.6还原表空间之间的切换
8.7删除还原表空间
8.8自动还原数据管理的一些参数及应用实例
8.9获得还原数据的信息
8.10临时还原数据的管理
8.11您应该掌握的内容
第9章创建数据库
视频讲解：5集29分钟
9.1筹划和组织数据库优化而弹性的体系结构
9.2创建数据库的先决条件
9.3创建数据库的方法
9.4手工创建数据库
9.5创建数据库过程中的排错
9.6利用OracleManagedFiles（OMF）来创建数据库
9.7多租户容器数据库和可插入数据库简介
9.8与多租户容器数据库相关的数据字典和命令简介
9.9您应该掌握的内容
第10章表管理与维护
视频讲解：5集30分钟
10.1存储数据的方法和Oracle内置数据类型
10.2ROWID
10.3Oracle数据行的结构
10.4创建普通表
10.5创建临时表
10.6表的维护和管理
10.7非分区表的重组
10.8列的维护
10.9表的截断和删除
10.10高水线及直接装入数据
10.11收缩段
10.12表压缩
10.13创建表的应用实例
10.14您应该掌握的内容
第11章索引的管理与维护
视频讲解：3集28分钟
11.1Oracle引入索引的目的
11.2索引的分类
11.3B-树索引
11.4位图索引
11.5B-树索引和位图索引的比较
11.6创建索引
11.7重建和维护索引
11.8标识索引的使用情况
11.9删除索引
11.10不可见索引
11.11创建索引的应用实例
11.12您应该掌握的内容
第12章管理和维护数据完整性
视频讲解：3集18分钟
12.1数据的完整性
12.2完整性约束的类型
12.3完整性约束的状态
12.4完整性约束的检验与定义
12.5定义和维护约束的指导原则
12.6关闭（禁止）和开启（激活）约束
12.7重新命名和删除约束
12.8您应该掌握的内容
第13章用户及系统资源和安全的管理
视频讲解：4集30分钟
13.1创建用户
13.2数据库模式
13.3改变用户在表空间上的配额
13.4删除用户
13.5用户的安全控制域
13.6概要文件
13.7利用概要文件进行资源管理
13.8资源限制的设置
13.9创建资源限制的概要文件
13.10口令管理
13.11口令验证函数
13.12创建口令限制的概要文件
13.13修改和删除概要文件
13.14创建概要文件的应用实例
13.15您应该掌握的内容
第14章管理权限
视频讲解：3集19分钟
14.1权限的分类
14.2系统权限
14.3系统权限的限制
14.4授予系统权限
14.5回收系统权限
14.6对象权限
14.7对象权限的授权和回收
14.8与SelectAnyTable权限相关的应用实例
14.9您应该掌握的内容
第15章管理角色
视频讲解：3集21分钟
15.1引入角色的原因
15.2角色的创建
15.3角色的修改
15.4角色的授权
15.5建立默认角色
15.6激活和禁止角色
15.7角色的回收和删除
15.8创建和使用角色指南
15.9Oracle预定义的角色
15.10用户、概要文件、权限和角色的应用实例
15.11您应该掌握的内容
第16章非归档模式下的冷备份和恢复
视频讲解：2集12分钟
16.1实验环境的搭建
16.2数据库的非归档模式和备份的术语
16.3冷备份（脱机备份）
16.4冷恢复（脱机恢复）
16.5脱机备份和脱机恢复的优缺点
16.6脱机备份的应用实例
16.7脱机恢复到原来位置的应用实例
16.8脱机恢复到非原来位置的应用实例
16.9您应该掌握的内容
第17章数据库的归档模式
视频讲解：2集14分钟
17.1归档模式的特点和要求
17.2将数据库设置为归档模式
17.3归档进程和归档文件目录的设置
17.4归档文件和归档进程的管理与维护
17.5改变成归档模式的应用实例
17.6您应该掌握的内容
第18章数据库的联机备份及备份的自动化
视频讲解：2集13分钟
18.1联机备份的重要性和特点
18.2联机备份步骤的演示
18.3联机备份步骤的解释
18.4联机备份的其他问题
18.5联机备份的应用实例
18.6备份操作自动化的实例
18.7恢复管理器简介
18.8快速增量备份（块更改追踪）
18.9配置快速恢复区
18.10使用RMAN备份和恢复Oracle数据库
18.11您应该掌握的内容
第19章归档模式下的数据库恢复
视频讲解：3集22分钟
19.1在归档模式下的介质恢复
19.2数据库的完全恢复
19.3RECOVER命令及与恢复有关的数据字典
19.4RECOVER期间归档日志文件的使用
19.5获取SQL*Plus命令的信息和使用方法
19.6数据库完全恢复方法
19.7最初处于打开状态下进行的开启数据库恢复
19.8最初处于关闭状态下进行的开启数据库恢复
19.9恢复没有备份的数据文件
19.10在关闭的状态下进行数据库的恢复
19.11最初在关闭状态下进行开启数据库恢复的实例
19.12在关闭状态下进行数据库恢复的实例
19.13您应该掌握的内容
第20章数据的移动
视频讲解：2集14分钟
20.1Oracle导出和导入应用程序
20.2导出应用程序的用法
20.3导入应用程序的用法
20.4导出和导入程序的应用实例
20.5数据泵
20.6不同用户及不同表空间之间数据的移动
20.7将Oracle的数据传给其他软件（系统）
20.8将其他软件（系统）的数据导入Oracle
20.9数据泵操作的自动化
20.10您应该掌握的内容
第21章闪回技术、备份恢复与优化
视频讲解：2集13分钟
21.1闪回已经删除的表
21.2闪回错误的DML操作
21.3非当前的还原表空间的恢复
21.4只读表空间和临时表空间的恢复
21.5索引表空间的恢复
21.6加快数据表空间的恢复
21.7整个数据库的闪回
21.8配置数据库闪回的实例
21.9您应该掌握的内容
第22章设计、程序及内存的优化
视频讲解：5集40分钟
22.1优化概述
22.2优化系统设计的基本原理
22.3以命令行方式获取系统的设计
22.4优化应用程序和SQL语句的基本原理
22.5以命令行方式获取SQL语句执行的信息
22.6反转关键字索引
22.7基于函数的索引
22.8导出存储程序的源代码
22.9SGA内存的优化
22.10PGA内存的优化
22.11将程序常驻内存
22.12将数据缓存在内存中
22.13将数据常驻内存
22.14将查询的结果缓存在内存
22.15SGA和PGA内存的设置与它们之间内存的转换
22.16您应该掌握的内容
第23章I/O优化
视频讲解：3集22分钟
23.1输入/输出优化概述
23.2表空间与输入/输出优化
23.3数据文件量的监控与诊断
23.4表和索引一级的优化
23.5删除操作对还原段的冲击及解决方法
23.6重做日志的优化
23.7通过移动表和索引来减少I/O竞争的实例
23.8您应该掌握的内容
第24章EM、iSQL*Plus和数据库自动管理
视频讲解：4集25分钟
24.1Oracle10g和Oracle11g企业管理器简介
24.2Oracle10g、Oracle11g和Oracle12c数据库自动管理简介
24.3数据库自动管理中的常用术语和统计级别
24.4自动工作负荷资料档案库
24.5AWR基线
24.6获取快照的信息与创建基线
24.7AWR报告的创建与分析
24.8不同时间段的AWR数据的比较
24.9自动数据库诊断监视器
24.10利用EMDatabaseExpress12c获取优化信息
24.11您应该掌握的内容
第25章SQL语句追踪与优化
视频讲解：2集14分钟
25.1发现有问题的SQL语句及执行计划的概念
25.2利用AUTOTRACE追踪SQL语句
25.3执行计划的应用和EXPLAINPLAN命令
25.4DBMS_XPLAN软件包与编译树简介
25.5数据字典V$SQL与编译树应用实例
25.6位图连接索引
25.7手工设置排序区的实例
25.8您应该掌握的内容




第1篇 基础知识

第1章 Oracle 11g概述

视频讲解：116分钟

1.1 简述Oracle的发展史

1.2 关系型数据库的基本理论

1.2.1 关系型数据库与数据库管理系统

1.2.2 关系型数据库的E-R模型

1.2.3 关系型数据库的设计范式

1.3 Oracle 11g的新功能

1.4 Oracle 11g的安装与卸载

1.4.1 Oracle 11g的安装

1.4.2 Oracle 11g的卸载

1.5 Oracle 11g的管理工具

1.5.1 SQL*Plus工具

1.5.2 Oracle企业管理器

1.5.3 数据库配置助手

1.6 启动与关闭数据库实例

1.6.1 启动数据库实例

1.6.2 关闭数据库实例

1.7 小结

1.8 实践与练习



第2章 Oracle 11g体系结构

视频讲解：89分钟

2.1 Oracle 11g体系结构概述

2.2 逻辑存储结构

2.2.1 数据块（Data Blocks）

2.2.2 数据区（Extent）

2.2.3 段（Segment）

2.2.4 表空间（TableSpace）

2.3 物理存储结构

2.3.1 数据文件

2.3.2 控制文件

2.3.3 日志文件

2.3.4 服务器参数文件

2.3.5 密码文件、警告文件和跟踪文件

2.4 Oracle 11g服务器结构

2.4.1 系统全局区（SGA）

2.4.2 程序全局区（PGA）

2.4.3 前台进程

2.4.4 后台进程

2.5 数据字典

2.5.1 Oracle数据字典简介

2.5.2 Oracle常用数据字典

2.6 小结

2.7 实践与练习



第3章 SQL*Plus命令

视频讲解：71分钟

3.1 SQL*Plus与数据库的交互

3.2 设置SQL*Plus的运行环境

3.2.1 简介SET命令

3.2.2 使用SET命令设置运行环境

3.3 常用SQL*Plus命令

3.3.1 HELP命令

3.3.2 DESCRIBE命令

3.3.3 SPOOL命令

3.3.4 其他常用命令

3.4 格式化查询结果

3.4.1 COLUMN命令

3.4.2 TTITLE和BTITLE命令

3.5 小结

3.6 实践与练习



第4章 SQL语言基础

视频讲解：189分钟

4.1 SQL语言简介

4.1.1 SQL语言的特点

4.1.2 SQL语言的分类

4.1.3 SQL语言的编写规则

4.2 用户模式

4.2.1 模式与模式对象

4.2.2 示例模式SCOTT

4.3 检索数据

4.3.1 简单查询

4.3.2 筛选查询

4.3.3 分组查询

4.3.4 排序查询

4.3.5 多表关联查询

4.4 Oracle常用系统函数

4.4.1 字符类函数

4.4.2 数字类函数

4.4.3 日期和时间类函数

4.4.4 转换类函数

4.4.5 聚合类函数

4.5 子查询的用法

4.5.1 什么是子查询

4.5.2 单行子查询

4.5.3 多行子查询

4.5.4 关联子查询

4.6 操作数据库

4.6.1 插入数据（INSERT语句）

4.6.2 更新数据（UPDATE语句）

4.6.3 删除数据（DELETE语句和TRUNCATE语句）

4.7 小结

4.8 实践与练习



第5章 PL/SQL编程

视频讲解：102分钟

5.1 PL/SQL简介

5.1.1 PL/SQL块结构

5.1.2 代码注释和标示符

5.1.3 文本

5.2 数据类型、变量和常量

5.2.1 基本数据类型

5.2.2 特殊数据类型

5.2.3 定义变量和常量

5.2.4 PL/SQL表达式

5.3 流程控制语句

5.3.1 选择语句

5.3.2 循环语句

5.4 PL/SQL游标

5.4.1 基本原理

5.4.2 显式游标

5.4.3 隐式游标

5.4.4 游标的属性

5.4.5 游标变量

5.4.6 通过for语句循环游标

5.5 PL/SQL异常处理

5.5.1 异常处理方法

5.5.2 异常处理语法

5.5.3 预定义异常

5.5.4 自定义异常

5.6 小结

5.7 实践与练习



第6章 过程、函数、触发器和包

视频讲解：97分钟

6.1 存储过程

6.1.1 创建存储过程

6.1.2 存储过程的参数

6.1.3 IN参数的默认值

6.1.4 删除存储过程

6.2 函数

6.2.1 创建函数

6.2.2 调用函数

6.2.3 删除函数

6.3 触发器

6.3.1 触发器简介

6.3.2 语句级触发器

6.3.3 行级别触发器

6.3.4 替换触发器

6.3.5 用户事件触发器

6.3.6 删除触发器

6.4 程序包

6.4.1 程序包的规范

6.4.2 程序包的主体

6.4.3 删除包

6.5 小结

6.6 实践与练习

第2篇 核心技术

第7章 管理控制文件和日志文件

视频讲解：77分钟

7.1 管理控制文件

7.1.1 控制文件简介

7.1.2 控制文件的多路复用

7.1.3 创建控制文件

7.1.4 备份和恢复控制文件

7.1.5 删除控制文件

7.1.6 查询控制文件的信息

7.2 管理重做日志文件

7.2.1 重做日志文件概述

7.2.2 增加日志组及其成员

7.2.3 删除重做日志文件

7.2.4 更改重做日志文件的位置或名称

7.2.5 查看重做日志信息

7.3 管理归档日志文件

7.3.1 日志模式分类

7.3.2 管理归档操作

7.3.3 设置归档文件位置

7.3.4 查看归档日志信息

7.4 小结

7.5 实践与练习



第8章 管理表空间和数据文件

视频讲解：57分钟

8.1 表空间与数据文件的关系

8.2 Oracle 11g的默认表空间

8.2.1 SYSTEM表空间

8.2.2 SYSAUX表空间

8.3 创建表空间

8.3.1 创建表空间的语法

8.3.2 通过本地化管理方式创建表空间

8.3.3 通过段空间管理方式创建表空间

8.3.4 创建非标准块表空间

8.3.5 建立大文件表空间

8.4 维护表空间与数据文件

8.4.1 设置默认表空间

8.4.2 更改表空间的状态

8.4.3 重命名表空间

8.4.4 删除表空间

8.4.5 维护表空间中的数据文件

8.5 管理撤销表空间

8.5.1 撤销表空间的作用

8.5.2 撤销表空间的初始化参数

8.5.3 撤销表空间的基本操作

8.6 管理临时表空间

8.6.1 临时表空间简介

8.6.2 创建临时表空间

8.6.3 查询临时表空间的信息

8.6.4 关于临时表空间组

8.7 小结

8.8 实践与练习



第9章 数据表对象

视频讲解：71分钟

9.1 数据表概述

9.2 创建数据表

9.2.1 数据表的逻辑结构

9.2.2 创建一个数据表

9.2.3 数据表的特性

9.3 维护数据表

9.3.1 增加和删除字段

9.3.2 修改字段

9.3.3 重命名表

9.3.4 改变表空间和存储参数

9.3.5 删除表

9.3.6 修改表的状态

9.4 数据完整性和约束性

9.4.1 非空约束

9.4.2 主键约束

9.4.3 唯一性约束

9.4.4 外键约束

9.4.5 禁用和激活约束

9.4.6 删除约束

9.5 小结

9.6 实践与练习



第10章 其他数据对象

视频讲解：56分钟

10.1 索引对象

10.1.1 索引概述

10.1.2 创建索引

10.1.3 修改索引

10.1.4 删除索引

10.1.5 显示索引信息

10.2 视图对象

10.2.1 创建视图

10.2.2 管理视图

10.3 同义词对象

10.4 序列对象

10.4.1 创建序列

10.4.2 管理序列

10.5 小结

10.6 实践与练习



第11章 表分区与索引分区

视频讲解：47分钟

11.1 分区技术简介

11.2 创建表分区

11.2.1 范围分区

11.2.2 散列分区

11.2.3 列表分区


第0章Oracle的安装及相关配置
视频讲解：3集11分钟
0.1Oracle的安装
0.2Oracle11g和Oracle12c中的SQL*Plus
0.3scott用户及其对象维护
0.4本书中将用到的表
0.5SQL（StructuredQueryLanguage）
0.6本书所用的术语
0.7Oracle10g的SQL*Plus界面
0.8使用iSQL*Plus
0.9使用DOS窗口启动SQL*Plus
第1章PL/SQL程序设计语言概述
视频讲解：1集8分钟
1.1PL/SQL语言的体系结构
1.2模块化程序设计简介
1.3PL/SQL语言的优势
1.4PL/SQL程序块的结构
1.5使用SQL*Plus创建匿名程序块的步骤
1.6使用SQL*Plus创建、编辑和执行匿名块的实例
1.7您应该掌握的内容
第2章OracleSQLDeveloper简介
视频讲解：4集14分钟
2.1安装SQLDeveloper和创建数据库连接
2.2SQLDeveloper的菜单
2.3导出表的设计信息和源程序代码
2.4创建新对象和使用SQL工作表
2.5导出SQL语句的执行计划
2.6使用Oracle11g和12c自带的OracleSQLDeveloper
第3章常用的SQL*Plus命令
视频讲解：3集20分钟
3.1DESC[RIBE]命令
3.2SETLINE[SIZE]{80|n}命令
3.3L命令和ntext命令
3.4“/”命令
3.5n（设置当前行）命令和A[PPEND]（附加）命令
3.6DEL命令
3.7C[HANGE]命令
3.8生成脚本文件
3.9编辑脚本文件
3.10直接运行脚本文件
3.11SPOOL命令
3.12将Oracle数据库的数据导出给其他系统
3.13将数据导出操作自动化
3.14商业智能软件读取Oracle数据的简单方法
3.15利用AUTOTRACE追踪SQL语句
3.16获取SQL*Plus的帮助信息
3.17您应该掌握的内容
第4章PL/SQL变量的声明与使用
视频讲解：5集25分钟
4.1PL/SQL变量的使用
4.2PL/SQL变量的声明和初始化
4.3字符串分隔符的说明与使用
4.4变量的数据类型
4.5%TYPE属性
4.6布尔变量的声明与使用
4.7替代变量与绑定变量
4.8LOB类型的变量
4.9声明PL/SQL变量指南
4.10您应该掌握的内容
第5章编写PL/SQL语言的可执行语句
视频讲解：5集18分钟
5.1PL/SQL语言中的词法单元
5.2标识符和定界符
5.3文字的使用和应用实例
5.4为程序代码加注释
5.5SQL函数在PL/SQL中的应用
5.6Oracle11g和12c的PL/SQL对序列操作的改进
5.7数据类型的转换
5.8PL/SQL中的运算符
5.9程序块的嵌套和变量的作用域
5.10变量的作用域和可见性的进一步探讨
5.11程序设计的指导原则
5.12您应该掌握的内容
第6章PL/SQL与Oracle服务器之间的交互
视频讲解：3集20分钟
6.1PL/SQL中的SQL语句及使用SELECT语句提取数据
6.2在PL/SQL中使用SELECT语句提取数据的实例
6.3利用分组函数从表中提取数据
6.4PL/SQL变量与列同名的问题及命名惯例
6.5数据库中数据维护概述和准备工作
6.6插入数据、修改数据和删除数据
6.7MERGE语句
6.8合并数据库中的数据行
6.9您应该掌握的内容
第7章分支（条件）语句
视频讲解：4集20分钟
7.1PL/SQL中的布尔条件
7.2IF语句以及简单IF语句的实例
7.3IF-THEN-ELSE和IF-THEN-ELSIF语句的执行流程
7.4IF-THEN-ELSE语句的实例
7.5IF-THEN-ELSIF语句的实例
7.6CASE表达式
7.7CASE语句
7.8GOTO语句
7.9您应该掌握的内容
第8章PL/SQL语言的循环语句
视频讲解：7集22分钟
8.1重复控制——循环语句及基本循环语句的语法
8.2基本循环语句的实例
8.3WHILE循环
8.4FOR循环
8.5反向FOR循环及使用循环的指导原则
8.6循环的嵌套和标号
8.7Oracle11g和Oracle12c引入的CONTINUE语句
8.8您应该掌握的内容
第9章PL/SQL中常用的组合数据类型
视频讲解：10集32分钟
9.1组合数据类型概述
9.2PL/SQL记录类型数据以及创建它的语法
9.3PL/SQL语言中的%ROWTYPE属性
9.4使用%ROWTYPE属性声明记录
9.5利用%ROWTYPE属性插入和修改记录
9.6INDEXBY表或PL/SQL表
9.7INDEXBY表的应用实例
9.8INDEXBY表的方法及使用实例
9.9INDEXBY记录表
9.10您应该掌握的内容
第10章SQL游标（cursor）
视频讲解：6集27分钟
10.1SQL隐式cursor的属性及其应用实例
10.2显式cursor概述
10.3控制显式cursor
10.4声明（显式）cursor
10.5打开（显式）cursor及从中提取数据
10.6关闭显式cursor及使用它的属性
10.7利用循环及属性控制cursor的实例
10.8cursor与记录
10.9您应该掌握的内容
第11章显式cursor的高级功能
视频讲解：6集16分钟
11.1cursor的FOR循环
11.2在cursor的FOR循环中使用子查询
11.3在cursor定义中使用子查询
11.4带参数的cursor
11.5FORUPDATE子句
11.6WHERECURRENTOF子句
11.7您应该掌握的内容
第12章PL/SQL程序中的异常处理
视频讲解：7集25分钟
12.1异常处理概述
12.2PL/SQL中的异常处理
12.3如何捕获异常
12.4如何捕获预定义的Oracle服务器错误
12.5如何捕获非预定义的Oracle服务器错误
12.6捕获异常的两个函数
12.7捕获用户定义的异常
12.8在程序块中异常的捕获与传播
12.9RAISE_APPLICATION_ERROR过程
12.10您应该掌握的内容
第13章过程的创建、维护和删除
视频讲解：7集33分钟
13.1模块化与分层的子程序设计
13.2PL/SQL的子程序
13.3过程的定义及创建
13.4创建过程的语法
13.5过程的参数模式（方式）
13.6使用IN参数模式的实例
13.7使用OUT参数模式的实例
13.8使用INOUT参数模式的实例
13.9传递实参的表示法
13.10在PL/SQL程序中调用一个过程
13.11在SQLDeveloper中调用过程
13.12在过程中声明和调用另一个过程
13.13在过程中处理异常
13.14在过程中没有处理异常
13.15过程的发现与删除
13.16您应该掌握的内容
第14章函数的创建、维护和删除
视频讲解：6集23分钟
14.1函数的概述以及创建函数的语法
14.2使用SQL*Plus或SQLDeveloper创建函数
14.3创建和调用存储函数的实例
14.4在SQLDeveloper中开发、调试和调用函数
14.5在SQL表达式中使用用户定义的函数
14.6从SQL表达式中调用函数的限制
14.7从SQL中用名字表示法或混合表示法调用函数
14.8函数的发现与删除以及函数与过程的比较
14.9您应该掌握的内容
第15章PL/SQL软件包
视频讲解：5集21分钟
15.1PL/SQL软件包概述
15.2PL/SQL软件包的组件及可见性
15.3PL/SQL软件包的开发方法
15.4创建PL/SQL软件包的说明
15.5创建PL/SQL软件包体
15.6创建和使用无体的PL/SQL软件包
15.7软件包的发现与删除
15.8在SQLDeveloper中开发和编译软件包说明
15.9在SQLDeveloper中开发和编译软件包体
15.10在SQLDeveloper中运行软件包
15.11您应该掌握的内容
第16章PL/SQL软件包的高级特性和功能
视频讲解：9集32分钟
16.1在PL/SQL中子程序的重载
16.2创建带有重载过程的软件包的实例
16.3STANDARD软件包与子程序重载
16.4前向引用（ForwardReferences）所造成的问题
16.5前向声明（ForwardDeclarations）
16.6软件包的初始化
16.7在SQL中使用软件包中的函数
16.8软件包中变量的持续状态
16.9软件包变量持续状态的实例
16.10软件包中cursor的持续状态
16.11在软件包中使用PL/SQL记录表（记录数组）
16.12您应该掌握的内容
第17章数据库触发器
视频讲解：6集48分钟
17.1触发器概述
17.2触发器的应用范围、设计原则以及分类
17.3DML触发器的创建
17.4触发器触发的顺序
17.5创建和测试语句触发器的实例
17.6带有条件谓词的语句触发器的实例
17.7创建和测试DML行触发器
17.8在行触发器中使用OLD和NEW限定符
17.9在行触发器中使用OLD和NEW限定符的实例
17.10利用WHEN子句有条件触发行触发器
17.11触发器执行模型概要及实现完整性约束的准备
17.12利用触发器来实现完整性约束
17.13INSTEADOF触发器及实例的准备工作
17.14创建INSTEADOF触发器的实例
17.15INSTEADOF触发器的测试实例
17.16触发器的管理与维护及与过程的比较
17.17触发器的管理与维护的实例
17.18您应该掌握的内容
第18章批量绑定及高级触发器特性
视频讲解：7集40分钟
18.1批量绑定概述及批量绑定的语法
18.2批量绑定FORALL的实例
18.3cursor属性%BULK_ROWCOUNT的应用
18.4在查询语句中使用BULKCOLLECTINTO子句
18.5在FETCH语句中使用BULKCOLLECTINTO子句
18.6带有RETURNING和BULKCOLLECTINTO关键字的FORALL语句
18.7利用Index数组进行批量绑定
18.8利用RETURNING子句将DML语句的结果直接装入变量
18.9变异表及在变异表上触发器的限制
18.10复合触发器（compoundtrigger）概述
18.11利用复合触发器解决变异表的错误
18.12创建基于DDL语句或基于系统事件的触发器
18.13用户登录和退出触发器的创建和测试
18.14触发器中的CALL语句
18.15数据库事件触发器的优点以及设计、管理和维护触发器要注意的事项
18.16您应该掌握的内容
第19章PL/SQL程序代码设计上的考虑、Oracle自带软件包及数据库优化简介
视频讲解：8集46分钟
19.1常量和异常的标准化概述
19.2标准化异常和标准化异常处理
19.3标准化常量
19.4本地子程序的应用
19.5程序的定义者权限与调用者权限
19.6自治事物
19.7使用自治事物的实例
19.8Oracle提供（自带）的软件包简介
19.9计算机内外存以及系统优化简介
19.10将程序常驻内存
19.11将数据缓存在内存中
19.12将数据常驻内存
19.13将查询的结果缓存在内存
19.14跨会话的PL/SQL函数结果缓存
19.15您应该掌握的内容
第20章导出程序的源代码以及源代码加密
20.1以命令行方式获取数据库系统的设计
20.2导出存储程序的接口参数
20.3导出存储程序的源代码
20.4导出触发器的类型、触发事件、描述及源代码
20.5PL/SQL源代码加密及动态加密
20.6使用CREATE_WRAPPED过程加密PL/SQL源代码
20.7使用CREATE_WRAPPED过程加密较长的代码
20.8PL/SQL封装实用程序简介
20.9PL/SQL封装实用程序应用实例
20.10加密的原则及DBMS_DDL与Wrap的比较
20.11您应该掌握的内容
结束语
参考文献

第0章Oracle的安装及相关配置
视频讲解：7集36分钟
0.1Oracle的安装
0.2Oracle11g和Oracle12c中的SQL*Plus
0.3scott用户及其对象维护
0.4虚拟环境的创建
0.5虚拟人物
第1章Oracle的体系结构
视频讲解：4集39分钟
1.1Oracle引入复杂的体系结构的原因
1.2Oracle数据库中常用的术语
1.3Oracle数据库管理系统的体系结构
1.4Oracle服务器
1.5Oracle实例
1.6Oracle数据库
1.7Oracle其他的关键文件
1.8建立与Oracle实例的连接
1.9各种不同的连接方式
1.10服务器进程
1.11Oracle执行SQL查询语句的步骤
1.12共享池
1.13数据库高速缓冲区
1.14内存缓冲区顾问
1.15重做日志缓冲区
1.16大池、Java池和Streams池
1.17内存缓冲区大小的设定
1.18内存缓冲区信息的获取
1.19重做日志写进程及快速提交
1.20数据库写进程
1.21系统监督进程
1.22进程监督进程
1.23校验（检查）点和校验点进程
1.24归档日志进程
1.25小结
1.26您应该掌握的内容
第2章数据库管理工具
视频讲解：9集38分钟
2.1Oracle通用安装程序
2.2交互式启动OracleUniversalInstaller
2.3非交互式启动OracleUniversalInstaller
2.4Oracle数据库配置助手
2.5使用Oracle数据库配置助手创建数据库
2.6数据库管理员用户sys和system
2.7SQL*Plus命令行工具
2.8Oracle10g企业管理器（EM）
2.9Oracle11g企业管理器（EM）
2.10将SYSDBA权限授予普通用户
2.11Oracle12cEMDatabaseExpress
2.12SQLDeveloper简介
2.13您应该掌握的内容
第3章Oracle实例的管理
视频讲解：3集22分钟
3.1初始化参数文件
3.2静态参数文件
3.3静态参数文件的创建和例子
3.4动态服务器参数文件
3.5动态服务器参数文件的创建和参数的浏览
3.6启动数据库
3.7将数据库置为限制模式
3.8关闭数据库
3.9关闭数据库的实际例子
3.10如何利用诊断文件来监督实例
3.11Oracle11g和Oracle12c诊断文件
3.12Oracle11g和Oracle12c的ADRCI
3.13您应该掌握的内容
第4章数据字典和控制文件
视频讲解：4集27分钟
4.1数据字典简介
4.2数据字典中所存的信息
4.3数据字典的操作和使用
4.4数据字典视图
4.5格式化数据字典视图的输出
4.6如何使用数据字典视图
4.7动态性能表（视图）
4.8数据字典应用实例
4.9控制文件的定义及引入的目的
4.10控制文件中所存的内容
4.11从控制文件中获取信息的数据字典
4.12如何限定控制文件的大小
4.13怎样查看控制文件的配置
4.14怎样添加和移动控制文件
4.15控制文件的备份
4.16移动控制文件的实例
4.17您应该掌握的内容
第5章重做日志文件
视频讲解：3集29分钟
5.1引入重做日志的目的
5.2重做日志组
5.3重做日志成员
5.4日志切换和检查点
5.5获取重做日志的信息
5.6添加和删除联机重做日志文件组
5.7添加和删除联机重做日志成员（文件）
5.8清除联机重做日志文件
5.9利用OMF来管理联机重做日志文件
5.10联机重做日志的配置
5.11重做日志配置的应用实例
5.12您应该掌握的内容
第6章表空间和数据文件的管理
视频讲解：5集44分钟
6.1Oracle引入逻辑结构的目的
6.2Oracle数据库中存储结构之间的关系
6.3表空间和数据文件之间的关系及表空间的分类
6.4表空间中的磁盘空间管理
6.5创建本地管理的表空间
6.6还原表空间
6.7临时表空间
6.8默认临时表空间
6.9设置表空间为脱机
6.10只读表空间
6.11重置表空间的大小
6.12手工重置数据文件的大小
6.13移动数据文件的方法
6.14移动数据文件的应用实例
6.15删除表空间
6.16利用OMF来管理表空间
6.17创建表空间的应用实例
6.18您应该掌握的内容
第7章存储结构和它们之间的关系
视频讲解：3集21分钟
7.1各种类型的段
7.2存储子句的优先级
7.3区段
7.4数据库块
7.5Oracle数据块的大小
7.6数据库块的内容和参数
7.7手工数据块的管理
7.8自动的段空间管理
7.9小结
7.10您应该掌握的内容
第8章管理还原数据
视频讲解：3集23分钟
8.1还原数据的管理方法
8.2Oracle使用还原段的目的
8.3还原段的类型
8.4自动还原数据管理的概念和配置
8.5还原表空间的创建与维护
8.6还原表空间之间的切换
8.7删除还原表空间
8.8自动还原数据管理的一些参数及应用实例
8.9获得还原数据的信息
8.10临时还原数据的管理
8.11您应该掌握的内容
第9章创建数据库
视频讲解：5集29分钟
9.1筹划和组织数据库优化而弹性的体系结构
9.2创建数据库的先决条件
9.3创建数据库的方法
9.4手工创建数据库
9.5创建数据库过程中的排错
9.6利用OracleManagedFiles（OMF）来创建数据库
9.7多租户容器数据库和可插入数据库简介
9.8与多租户容器数据库相关的数据字典和命令简介
9.9您应该掌握的内容
第10章表管理与维护
视频讲解：5集30分钟
10.1存储数据的方法和Oracle内置数据类型
10.2ROWID
10.3Oracle数据行的结构
10.4创建普通表
10.5创建临时表
10.6表的维护和管理
10.7非分区表的重组
10.8列的维护
10.9表的截断和删除
10.10高水线及直接装入数据
10.11收缩段
10.12表压缩
10.13创建表的应用实例
10.14您应该掌握的内容
第11章索引的管理与维护
视频讲解：3集28分钟
11.1Oracle引入索引的目的
11.2索引的分类
11.3B-树索引
11.4位图索引
11.5B-树索引和位图索引的比较
11.6创建索引
11.7重建和维护索引
11.8标识索引的使用情况
11.9删除索引
11.10不可见索引
11.11创建索引的应用实例
11.12您应该掌握的内容
第12章管理和维护数据完整性
视频讲解：3集18分钟
12.1数据的完整性
12.2完整性约束的类型
12.3完整性约束的状态
12.4完整性约束的检验与定义
12.5定义和维护约束的指导原则
12.6关闭（禁止）和开启（激活）约束
12.7重新命名和删除约束
12.8您应该掌握的内容
第13章用户及系统资源和安全的管理
视频讲解：4集30分钟
13.1创建用户
13.2数据库模式
13.3改变用户在表空间上的配额
13.4删除用户
13.5用户的安全控制域
13.6概要文件
13.7利用概要文件进行资源管理
13.8资源限制的设置
13.9创建资源限制的概要文件
13.10口令管理
13.11口令验证函数
13.12创建口令限制的概要文件
13.13修改和删除概要文件
13.14创建概要文件的应用实例
13.15您应该掌握的内容
第14章管理权限
视频讲解：3集19分钟
14.1权限的分类
14.2系统权限
14.3系统权限的限制
14.4授予系统权限
14.5回收系统权限
14.6对象权限
14.7对象权限的授权和回收
14.8与SelectAnyTable权限相关的应用实例
14.9您应该掌握的内容
第15章管理角色
视频讲解：3集21分钟
15.1引入角色的原因
15.2角色的创建
15.3角色的修改
15.4角色的授权
15.5建立默认角色
15.6激活和禁止角色
15.7角色的回收和删除
15.8创建和使用角色指南
15.9Oracle预定义的角色
15.10用户、概要文件、权限和角色的应用实例
15.11您应该掌握的内容
第16章非归档模式下的冷备份和恢复
视频讲解：2集12分钟
16.1实验环境的搭建
16.2数据库的非归档模式和备份的术语
16.3冷备份（脱机备份）
16.4冷恢复（脱机恢复）
16.5脱机备份和脱机恢复的优缺点
16.6脱机备份的应用实例
16.7脱机恢复到原来位置的应用实例
16.8脱机恢复到非原来位置的应用实例
16.9您应该掌握的内容
第17章数据库的归档模式
视频讲解：2集14分钟
17.1归档模式的特点和要求
17.2将数据库设置为归档模式
17.3归档进程和归档文件目录的设置
17.4归档文件和归档进程的管理与维护
17.5改变成归档模式的应用实例
17.6您应该掌握的内容
第18章数据库的联机备份及备份的自动化
视频讲解：2集13分钟
18.1联机备份的重要性和特点
18.2联机备份步骤的演示
18.3联机备份步骤的解释
18.4联机备份的其他问题
18.5联机备份的应用实例
18.6备份操作自动化的实例
18.7恢复管理器简介
18.8快速增量备份（块更改追踪）
18.9配置快速恢复区
18.10使用RMAN备份和恢复Oracle数据库
18.11您应该掌握的内容
第19章归档模式下的数据库恢复
视频讲解：3集22分钟
19.1在归档模式下的介质恢复
19.2数据库的完全恢复
19.3RECOVER命令及与恢复有关的数据字典
19.4RECOVER期间归档日志文件的使用
19.5获取SQL*Plus命令的信息和使用方法
19.6数据库完全恢复方法
19.7最初处于打开状态下进行的开启数据库恢复
19.8最初处于关闭状态下进行的开启数据库恢复
19.9恢复没有备份的数据文件
19.10在关闭的状态下进行数据库的恢复
19.11最初在关闭状态下进行开启数据库恢复的实例
19.12在关闭状态下进行数据库恢复的实例
19.13您应该掌握的内容
第20章数据的移动
视频讲解：2集14分钟
20.1Oracle导出和导入应用程序
20.2导出应用程序的用法
20.3导入应用程序的用法
20.4导出和导入程序的应用实例
20.5数据泵
20.6不同用户及不同表空间之间数据的移动
20.7将Oracle的数据传给其他软件（系统）
20.8将其他软件（系统）的数据导入Oracle
20.9数据泵操作的自动化
20.10您应该掌握的内容
第21章闪回技术、备份恢复与优化
视频讲解：2集13分钟
21.1闪回已经删除的表
21.2闪回错误的DML操作
21.3非当前的还原表空间的恢复
21.4只读表空间和临时表空间的恢复
21.5索引表空间的恢复
21.6加快数据表空间的恢复
21.7整个数据库的闪回
21.8配置数据库闪回的实例
21.9您应该掌握的内容
第22章设计、程序及内存的优化
视频讲解：5集40分钟
22.1优化概述
22.2优化系统设计的基本原理
22.3以命令行方式获取系统的设计
22.4优化应用程序和SQL语句的基本原理
22.5以命令行方式获取SQL语句执行的信息
22.6反转关键字索引
22.7基于函数的索引
22.8导出存储程序的源代码
22.9SGA内存的优化
22.10PGA内存的优化
22.11将程序常驻内存
22.12将数据缓存在内存中
22.13将数据常驻内存
22.14将查询的结果缓存在内存
22.15SGA和PGA内存的设置与它们之间内存的转换
22.16您应该掌握的内容
第23章I/O优化
视频讲解：3集22分钟
23.1输入/输出优化概述
23.2表空间与输入/输出优化
23.3数据文件量的监控与诊断
23.4表和索引一级的优化
23.5删除操作对还原段的冲击及解决方法
23.6重做日志的优化
23.7通过移动表和索引来减少I/O竞争的实例
23.8您应该掌握的内容
第24章EM、iSQL*Plus和数据库自动管理
视频讲解：4集25分钟
24.1Oracle10g和Oracle11g企业管理器简介
24.2Oracle10g、Oracle11g和Oracle12c数据库自动管理简介
24.3数据库自动管理中的常用术语和统计级别
24.4自动工作负荷资料档案库
24.5AWR基线
24.6获取快照的信息与创建基线
24.7AWR报告的创建与分析
24.8不同时间段的AWR数据的比较
24.9自动数据库诊断监视器
24.10利用EMDatabaseExpress12c获取优化信息
24.11您应该掌握的内容
第25章SQL语句追踪与优化
视频讲解：2集14分钟
25.1发现有问题的SQL语句及执行计划的概念
25.2利用AUTOTRACE追踪SQL语句
25.3执行计划的应用和EXPLAINPLAN命令
25.4DBMS_XPLAN软件包与编译树简介
25.5数据字典V$SQL与编译树应用实例
25.6位图连接索引
25.7手工设置排序区的实例
25.8您应该掌握的内容

第1章　开发成功的Oracle应用　　1
1.1　我的方法　　2
1.2　黑盒方法　　3
1.3　开发数据库应用的正确（和不正确）方法　　11
1.3.1　了解Oracle体系结构　　11
1.3.2　理解并发控制　　21
1.3.3　多版本控制　　25
1.3.4　数据库独立性　　31
1.3.5　怎么能让应用运行得更快45
1.3.6　DBA与开发人员的关系　　48
1.4　小结　　48
第2章　体系结构概述　　50
2.1　定义数据库和实例　　51
2.2　连接Oracle　　59
2.2.1　专用服务器　　59
2.2.2　共享服务器　　61
2.2.3　TCP/IP连接的基本原理　　63
2.3　可插拔式数据库　　65
2.3.1　降低资源用量　　66
2.3.2　降低维护开销　　66
2.4　可插拔式数据库的不同之处　　67
2.5　小结　　67
第3章　文件　　68
3.1　参数文件　　69
3.1.1　什么是参数　　70
3.1.2　init.ora参数文件　　73
3.1.3　服务器参数文件　　75
3.2　跟踪文件　　82
3.2.1　计划内的、由用户请求所产生的跟踪文件　　83
3.2.2　针对内部错误生成的跟踪文件　　88
3.2.3　跟踪文件小结　　92
3.3　警告文件　　92
3.4　数据文件　　95
3.4.1　简要回顾文件系统机制　　96
3.4.2　Oracle数据库中的存储层次体系　　97
3.4.3　字典管理和本地管理的表空间　　100
3.5　临时文件　　102
3.6　控制文件　　104
3.7　重做日志文件　　104
3.7.1　在线重做日志　　105
3.7.2　归档重做日志　　107
3.8　密码文件　　108
3.9　修改跟踪文件　　111
3.10　闪回日志　　112
3.10.1　闪回数据库　　112
3.10.2　快速恢复区　　113
3.11　DMP文件（EXP/IMP 文件）　　114
3.12　数据泵文件　　115
3.13　平面文件　　117
3.14　小结　　118
第4章　内存结构　　119
4.1　进程全局区和用户全局区　　120
4.1.1　手动PGA内存管理　　121
4.1.2　自动PGA内存管理　　127
4.1.3　如何选择手动和自动内存管理　　137
4.1.4　PGA和UGA小结　　138
4.2　系统全局区　　138
4.2.1　固定SGA 区　　143
4.2.2　重做缓冲区　　143
4.2.3　块缓冲区缓存　　145
4.2.4　共享池　　151
4.2.5　大池　　153
4.2.6　Java池　　154
4.2.7　流池　　155
4.2.8　SGA内存管理　　155
4.3　小结　　160
第5章　Oracle 进程　　161
5.1　服务器进程　　161
5.1.1　专用服务器连接　　162
5.1.2　共享服务器连接　　164
5.1.3　数据库常驻连接池　　165
5.1.4　连接与会话　　165
5.1.5　专用服务器、共享服务器和数据库常驻连接池　　170
5.1.6　专用/共享服务器小结　　173
5.2　后台进程　　174
5.2.1　特定任务后台进程　　175
5.2.2　工具后台进程　　185
5.3　从属进程　　188
5.3.1　I/O从属进程　　188
5.3.2　Pnnn：并行查询执行服务器　　189
5.4　小结　　189
第6章　锁和闩　　190
6.1　什么是锁　　190
6.2　锁的问题　　193
6.2.1　丢失更新　　193
6.2.2　悲观锁　　194
6.2.3　乐观锁　　195
6.2.4　乐观锁还是悲观锁　　201
6.2.5　阻塞　　202
6.2.6　死锁　　205
6.2.7　锁升级　　209
6.3　锁类型　　209
6.3.1　DML锁　　210
6.3.2　DDL锁　　219
6.3.3　闩　　223
6.3.4　互斥锁　　231
6.3.5　手动锁定和用户定义锁　　232
6.4　小结　　233
第7章　并发与多版本控制　　234
7.1　什么是并发控制　　234
7.2　事务隔离级别　　235
7.2.1　READ UNCOMMITTED　　236
7.2.2　READ COMMITTED　　238
7.2.3　REPEATABLE READ　　239
7.2.4　SERIALIZABLE　　241
7.2.5　READ ONLY　　243
7.3　多版本读一致性的含义　　244
7.3.1　数据仓库中一种常见但有问题的方法　　244
7.3.2　解释热表上超出期望的I/O　　245
7.4　写一致性　　247
7.4.1　一致读和当前读　　248
7.4.2　查看重启动　　250
7.4.3　为什么重启动对我们很重要　　252
7.5　小结　　253
第8章　事务　　255
8.1　事务控制语句　　255
8.2　原子性　　257
8.2.1　语句级原子性　　257
8.2.2　过程级原子性　　259
8.2.3　事务级原子性　　262
8.2.4　DDL与原子性　　262
8.3　持久性　　263
8.3.1　COMMIT的WRITE扩展　　263
8.3.2　非分布式PL/SQL代码块中的COMMIT　　264
8.4　完整性约束和事务　　266
8.4.1　IMMEDIATE约束　　266
8.4.2　DEFERRABLE约束和级联更新　　266
8.5　不好的事务习惯　　270
8.5.1　在循环中提交　　270
8.5.2　使用自动提交　　276
8.6　分布式事务　　277
8.7　自治事务　　278
8.7.1　自治事务如何工作　　279
8.7.2　何时使用自治事务　　280
8.8　小结　　283
第9章　redo与undo　　284
9.1　什么是redo　　285
9.2　什么是undo　　286
9.3　redo和undo如何协作　　289
9.4　提交和回滚处理　　293
9.4.1　COMMIT做什么　　293
9.4.2　ROLLBACK做什么　　299
9.5　分析redo　　300
9.5.1　测量redo　　301
9.5.2　能关掉重做日志的生成吗　　302
9.5.3　为什么我拿不到日志空间　　305
9.5.4　块清除　　307
9.5.5　日志竞争　　310
9.5.6　临时表和redo/undo　　312
9.6　分析undo　　317
9.6.1　什么操作会生成最多和最少的undo　　317
9.6.2　ORA-01555: snapshot too old错误　　319
9.7　小结　　328
第10章　数据库表　　329
10.1　表类型　　329
10.2　术语　　331
10.2.1　段　　331
10.2.2　段空间管理　　333
10.2.3　高水位线　　334
10.2.4　FREELIST　　336
10.2.5　PCTFREE和PCTUSED　　339
10.2.6　LOGGING和NOLOGGING　　342
10.2.7　INITRANS和MAXTRANS　　343
10.3　堆组织表　　343
10.4　索引组织表　　346
10.5　索引聚簇表　　359
10.6　散列聚簇表　　366
10.7　有序散列聚簇表　　375
10.8　嵌套表　　377
10.8.1　嵌套表语法　　378
10.8.2　嵌套表存储　　384
10.8.3　嵌套表小结　　387
10.9　临时表　　387
10.9.1　12c之前的统计信息　　391
10.9.2　12c之后的统计信息　　395
10.9.3　临时表小结　　398
10.10　对象表　　399
10.11　小结　　405
第11章　索引　　406
11.1　Oracle索引概述　　406
11.2　B*Tree索引　　408
11.2.1　索引键压缩　　411
11.2.2　反向键索引　　413
11.2.3　降序索引　　418
11.2.4　什么情况下应该使用B*Tree索引　　420
11.2.5　B*Tree小结　　430
11.3　位图索引　　430
11.3.1　什么情况下应该使用位图索引　　431
11.3.2　位图联结索引　　435
11.3.3　位图索引小结　　437
11.4　基于函数的索引　　438
11.4.1　一个简单的例子　　438
11.4.2　只对部分行建立索引　　446
11.4.3　实现有选择的唯一性　　448
11.4.4　关于ORA-01743的警告　　448
11.4.5　基于函数的索引小结　　449
11.5　应用域索引　　450
11.6　不可见的索引　　451
11.7　同列上的多个索引　　452
11.8　在扩展列上使用索引　　453
11.8.1　使用虚拟列的方法　　454
11.8.2　使用基于函数索引的方法　　456
11.9　关于索引的常见问题和各种传言　　457
11.9.1　视图能使用索引吗　　457
11.9.2　Null和索引能协作吗　　457
11.9.3　外键是否应该加索引　　460
11.9.4　为什么没有使用我的索引　　461
11.9.5　传言：索引中从不重用空间　　466
11.9.6　传言：最有差别的元素应该在最前面　　469
11.10　小结　　472
第12章　数据类型　　473
12.1　Oracle数据类型概述　　473
12.2　字符和二进制串类型　　475
12.2.1　NLS概述　　476
12.2.2　字符串　　479
12.3　二进制串：RAW类型　　485
12.4　扩展的数据类型　　487
12.5　数值类型　　489
12.5.1　NUMBER类型的语法和用法　　491
12.5.2　BINARY_FLOAT/BINARY_DOUBLE类型的语法和用法　　494
12.5.3　非固有数值类型　　495
12.5.4　性能考虑　　495
12.6　LONG类型　　497
12.6.1　LONG 和LONG RAW类型的限制　　497
12.6.2　处理遗留的LONG类型　　498
12.7　DATE、TIMESTAMP和INTERVAL类型　　502
12.7.1　格式　　503
12.7.2　DATE类型　　504
12.7.3　TIMESTAMP类型　　509
12.7.4　INTERVAL类型　　515
12.8　LOB类型　　518
12.8.1　内部LOB　　518
12.8.2　BFILE　　531
12.9　ROWID/UROWID类型　　533
12.10　小结　　533
第13章　分区　　535
13.1　分区概述　　535
13.1.1　提高可用性　　536
13.1.2　减少管理负担　　538
13.1.3　增强语句性能　　541
13.2　表分区机制　　543
13.2.1　区间分区　　544
13.2.2　散列分区　　546
13.2.3　列表分区　　550
13.2.4　间隔分区　　552
13.2.5　引用分区　　557
13.2.6　间隔引用分区　　561
13.2.7　虚拟列分区　　563
13.2.8　组合分区　　564
13.2.9　行移动　　566
13.2.10　表分区机制小结　　568
13.3　索引分区　　569
13.3.1　本地索引与全局索引　　570
13.3.2　本地索引　　570
13.3.3　全局索引　　575
13.4　再论分区和性能　　590
13.5　一些简化维护的特性　　595
13.5.1　多分区管理操作　　595
13.5.2　级联截断　　597
13.5.3　级联交换　　599
13.6　审计和段空间压缩　　600
13.7　小结　　601
第14章　并行执行　　603
14.1　何时使用并行执行　　604
14.2　Oracle Exadata　　606
14.3　并行查询　　606
14.4　并行DML　　612
14.5　并行DDL　　615
14.5.1　并行DDL和使用外部表的数据加载　　616
14.5.2　并行DDL和扩展截断　　617
14.6　过程并行化　　625
14.6.1　并行管道函数　　626
14.6.2　DIY并行化　　629
14.6.3　老式DIY并行化　　632
14.7　小结　　635
第15章　数据加载和卸载　　637
15.1　外部表　　637
15.1.1　建立外部表　　638
15.1.2　处理错误　　645
15.1.3　使用外部表加载不同的文件　　648
15.1.4　多用户问题　　649
15.1.5　预处理　　650
15.1.6　外部表总结　　658
15.2　数据泵卸载　　659
15.3　SQLLDR　　660
15.3.1　用SQLLDR加载数据的常见问题　　664
15.3.2　SQLLDR警告　　686
15.3.3　SQLLDR小结　　686
15.4　平面文件卸载　　687
15.5　小结　　694

第Ⅰ部分 入门
第1章 安装Oracle数据库软件
1．1 规划Oracle数据库软件的安装
1．1．1 支持的平台
1．1．2 获得Oracle数据库软件
1．1．3 用户账户
1．1．4 磁盘空间和目录
1．1．5 检查先决条件
1．2 安装Oracle数据库软件
1．2．1 OUI产品清单
1．2．2 OUI对话框：交互式安装
1．2．3 静默安装和响应文件
1．2．4 Windows和Linux变体
1．3 本章知识点回顾
1．4 自测题
1．5 自测题答案
第2章 用DBCA创建Oracle数据库
2．1 使用DBCA创建数据库
2．1．1 实例、数据库和数据字典
2．1．2 使用DBCA创建数据库
2．1．3 DBCA对话框
2．2 使用DBCA生成数据库创建脚本
2．2．1 生成脚本
……

第Ⅱ部分 SQL
第Ⅲ部分 DBA1
第Ⅳ部分 DBA2
第Ⅴ部分 升级和多租户


第1章 单表查询 1

1.1 查询表中所有的行与列 1

1.2 从表中检索部分行 2

1.3 查找空值 3

1.4 空值与运算 3

1.5 处理空值 4

1.6 空值与函数 5

1.7 查找满足多个条件的行 6

1.8 从表中检索部分列 7

1.9 为列取有意义的名称 7

1.10 在WHERE子句中引用取别名的列 8

1.11 拼接列 8

1.12 在SELECT语句中使用条件逻辑 9

1.13 限制返回的行数 11



第2章 给查询结果排序 12

2.1 以指定的次序返回查询结果 12

2.2 按多个字段排序 14

2.3 按子串排序 15

2.4 从表中随机返回n条记录 16

2.5 TRANSLATE 18

2.6 按数字和字母混合字符串中的字母排序 19

2.7 处理排序空值 20

2.8 根据条件取不同列中的值来排序 21



第3章 操作多个表 23

3.1 UNION ALL与空字符串 23

3.2 UNION与OR 24

3.3 UNION与去重 26

3.4 组合相关的行 30

3.5 IN、EXISTS和INNER JOIN 30

3.6 INNER JOIN、LEFT JOIN、RIGHT JOIN和FULL JOIN解析 32

3.7 外连接与过滤条件 36

3.8 自关联 39

3.9 NOT IN、NOT EXISTS和LEFT JOIN 40

3.10 检测两个表中的数据及对应数据的条数是否相同 43

3.11 聚集与内连接 44



第4章 插入、更新与删除 49

4.1 插入新记录 49

4.2 阻止对某几列插入 50

4.3 复制表的定义及数据 51

4.4 用WITH CHECK OPTION限制数据录入 51

4.5 多表插入语句 52

4.6 用其他表中的值更新 56

4.7 合并记录 62

4.8 删除违反参照完整性的记录 64

4.9 删除名称重复的记录 64



第5章 使用字符串 67

5.1 生成连续数值 67

5.2 遍历字符串 68

5.3 计算字符在字符串中出现的次数 69

5.4 从字符串中删除不需要的字符 71

5.5 将字符和数字数据分离 72

5.6 查询只包含字母或数字型的数据 73

5.7 提取姓名的大写首字母缩写 78

5.8 根据表中的行创建一个分隔列表 79

5.9 提取第n个分隔的子串 80

5.10 分解IP地址 82

5.11 将分隔数据转换为多值IN列表 82

5.12 组合去重 83



第6章 使用数字 86

6.1 常用聚集函数 86

6.2 列转行 88

6.3 行转列 89

6.4 生成累计和 91

6.5 累计与重复值 95

6.6 生成排名 97

6.7 返回最值对应信息 98

6.8 求总和的百分比 99



第7章 日期运算 103

7.1 日期类型 103

7.2 日期计算 105

7.3 时间间隔类型 105

7.4 日期计算函数 106

7.5 间隔月份 108

7.6 获取记录间的间隔时间 108



第8章 日期操作 112

8.1 提取日期中的信息 112

8.2 提取间隔类型中的信息 115

8.3 周的计算 117

8.4 计算一年中周内各日期的次数 119

8.5 确定一年是否为闰年 123

8.6 创建本月日历 123

8.7 全年日历 126

8.8 补充范围内丢失的值 129

8.9 识别重叠的日期范围 131



第9章 范围处理 134

9.1 定位连续值的范围 134

9.2 合并连续区间 136

9.3 合并重叠区间 140

9.4 用WITH进行范围分组 143



第10章 高级查找 147

10.1 给结果集分页 147

10.2 使用管道函数把全表查询改为增量查询 149

10.3 内联视图与错误数据 153

10.4 正确使用分析函数 155

10.5 找到包含最大值和最小值的记录 157

10.6 提取维度信息 159



第11章 报表和数据仓库运算 162

11.1 行转列子句 162

11.2 列转行子句 165

11.3 将结果集反向转置为一列 168

11.4 打印小票与行列转换 169

11.5 数据分组 172

11.6 计算简单的小计 173

11.7 判别非小计的行 175

11.8 对不同组/分区同时实现聚集 177

11.9 移动范围取值分析 179

11.10 计算本期、新增、累加 182

11.11 listagg与小九九 186



第12章 分层查询 188

12.1 简单的树形查询 188

12.2 根节点、分支节点、叶子节点 190

12.3 sys_connect_by_path 191

12.4 树形查询中的排序 192

12.5 树形查询中的WHERE 193

12.6 查询树形的一个分支 195

12.7 剪去一个分支 196

12.8 多行字符串的拆分 196


第13章 应用案例实现 199

13.1 解析简单公式 199

13.2 匹配汉字 200

13.3 多表全外连接的问题 202

13.4 根据传入条件返回不同列中的数据 203

13.5 拆分字符串进行连接 205

13.6 用“行转列”来得到隐含信息 206

13.7 用隐藏数据进行行转列 208

13.8 用正则表达式提取clob里的文本格式记录集 210



第14章 改写调优案例分享 212

14.1 为什么不建议使用标量子查询 212

14.2 用LEFT JOIN优化标量子查询 215

14.3 用LEFT JOIN优化标量子查询之聚合改写 216

14.4 用LEFT JOIN及行转列优化标量子查询 217

14.5 标量中有ROWNUM=1 218

14.6 ROWNUM=1引起的逻辑问题 219

14.7 标量中有不等关联时改写的问题 222

14.8 标量中有聚合函数时改写的问题 226

14.9 用分析函数优化标量子查询（一） 229

14.10 用分析函数优化标量子查询（二） 231

14.11 用分析函数优化标量子查询（三） 233

14.12 标量中的树形查询 235

14.13 使用标量子查询优化取最值语句 238

14.14 用MERGE改写优化UPDATE 240

14.15 UPDATE中有ROWNUM=1 243

14.16 用MERGE使用左联 245

14.17 用MERGE改写UPDATE之多个子查询 249

14.18 将UPDATE改写为MERGE时遇到的问题 251

14.19 通过分页方式优化最值语句 254

14.20 让分页语句走正确的PLAN 256

14.21 去掉分页查询中的DISTINCT 257

14.22 优化有GROUP BY的分页语句 261

14.23 用WITH语句优化查询 264

14.24 用WITH辅助把OR改为UNION 265

14.25 错误的WITH改写 269

14.26 错误的分析函数用法 272

14.27 用LEFT JOIN优化多个子查询（一） 274

14.28 用LEFT JOIN优化多个子查询（二） 278

14.29 用LEFT JOIN优化多个子查询（三） 280

14.30 去掉由EXISTS引起的FILTER 283

14.31 巧改驱动表提升效率 284

14.32 用分析函数更改反连接 286

14.33 集合判断 288

14.34 相等集合判断 289

14.35 用分析函数改写最值过滤条件 291

14.36 用树形查询找指定级别的数据 292

14.37 行转列与列转行 293

14.38 UPDATE、ROW_NUMBER与MERGE 295

14.39 一个UPDATE语句的优化 298

14.40 自定义函数对速度的影响 302

14.41 纠结的MERGE语句 305

14.42 用CASE WHEN去掉UNION ALL 308

14.43 不恰当的WITH及标量子查询 320

14.44 用分析函数加“行转列”来优化标量子查询 323

14.45 用分析函数处理问题 326

14.46 用列转行改写A表多列关联B表同列 329

14.47 用分析函数改写最值语句 332

14.48 多列关联的半连接与索引 334

14.49 巧用分析函数优化自关联 335

14.50 纠结的UPDATE语句 340

14.51 巧用JOIN条件合并UNION ALL语句 342

14.52 用分析函数去掉NOT IN 345

14.53 读懂查询中的需求之裁剪语句 349

14.54 去掉FILTER里的EXISTS之活学活用 350

