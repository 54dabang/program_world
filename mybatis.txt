第1 章 MyBatis 简介 1
1.1 传统的JDBC 编程 1
1.2 ORM 模型 4
1.3 Hibernate 4
1.4 MyBatis 9
1.5 什么时候用MyBatis 12
第2 章 MyBaits 入门 13
2.1 开发环境准备.13
2.1.1 下载MyBatis 13
2.1.2 搭建开发环境 14
2.2 MyBatis 的基本构成 15
2.2.1 构建SqlSessionFactory 15
2.2.2 创建SqlSession19
2.2.3 映射器 21
2.3 生命周期.26
2.3.1 SqlSessionFactoryBuilder 27
2.3.2 SqlSessionFactory 27
2.3.3 SqlSession 27
2.3.4 Mapper 28
2.4 实例 28
第3 章 配置 37
3.1 properties 元素 38
3.1.1 property 子元素.38
3.1.2 properties 配置文件 39
3.1.3 程序参数传递 39
3.1.4 优先级 40
3.2 设置 41
3.3 别名 44
3.3.1 系统定义别名 44
3.3.2 自定义别名 47
3.4 typeHandler 类型处理器.48
3.4.1 系统定义的typeHandler 49
3.4.2 自定义typeHandler 51
3.4.3 枚举类型typeHandler55
3.5 ObjectFactory 62
3.6 插件 65
3.7 environments 配置环境 65
3.7.1 概述65
3.7.2 数据库事务 66
3.7.3 数据源 67
3.8 databaseIdProvider 数据库厂商标识 68
3.8.1 使用系统默认规则 68
3.8.2 不使用系统默认规则69
3.9 引入映射器的方法 71
第4 章 映射器 73
4.1 映射器的主要元素 73
4.2 select 元素 74
4.2.1 概述74
4.2.2 简易数据类型的例子75
4.2.3 自动映射.76
4.2.4 传递多个参数 78
4.2.5 使用resultMap 映射结果集 81
4.3 insert 元素 82
4.3.1 概述82
4.3.2 主键回填和自定义 83
4.4 update 元素和delete 元素 85
4.5 参数 85
4.5.1 参数配置.86
4.5.2 存储过程支持 86
4.5.3 特殊字符串替换和处理（#和$） 87
4.6 sql 元素 88
4.7 resultMap 结果映射集 89
4.7.1 resultMap 元素的构成 89
4.7.2 使用map 存储结果集91
4.7.3 使用POJO 存储结果集 91
4.7.4 级联92
4.8 缓存cache 113
4.8.1 系统缓存（一级缓存和二级缓存） 113
4.8.2 自定义缓存 117
第5 章 动态SQL 119
5.1 概述119
5.2 if 元素 120
5.3 choose、when、otherwise 元素 120
5.4 trim、where、set 元素 121
5.5 foreach 元素 123
5.6 test 的属性 124
5.7 bind 元素125
第6 章 MyBatis 的解析和运行原理 127
6.1 涉及的技术难点简介 128
6.1.1 反射技术129
6.1.2 JDK 动态代理.130
6.1.3 CGLIB 动态代理 133
6.2 构建SqlSessionFactory 过程134
6.2.1 构建Configuration 135
6.2.2 映射器的内部组成 136
6.2.3 构建SqlSessionFactory 138
6.3 SqlSession 运行过程 138
6.3.1 映射器的动态代理 138
6.3.2 SqlSession 下的四大对象.142
6.3.3 SqlSession 运行总结150
第7 章 插件.152
7.1 插件接口152
7.2 插件的初始化153
7.3 插件的代理和反射设计154
7.4 常用的工具类——MetaObject 157
7.5 插件开发过程和实例 159
7.5.1 确定需要拦截的签名 159
7.5.2 实现拦截方法.161
7.5.3 配置和运行 162
7.5.4 插件实例163
7.6 总结166
第8 章 MyBatis-Spring 168
8.1 Spring 的基础知识.168
8.1.1 Spring IOC 基础 169
8.1.2 Spring AOP 基础 171
8.1.3 Spring 事务管理 173
8.1.4 Spring MVC 基础 179
8.2 MyBatis-Spring 应用 181
8.2.1 概述 181
8.2.2 配置SqlSessionFactory 182
8.2.3 配置SqlSessionTemplate 184
8.2.4 配置Mapper 188
8.2.5 配置事务190
8.3 实例191
8.3.1 环境准备191
8.3.2 文件目录193
8.3.3 Spring 配置文件 194
8.3.4 MyBatis 框架相关配置 198
8.3.5 配置服务层 205
8.3.6 编写控制器 209
8.3.7 测试 210
8.4 总结210
第9 章 实用的场景 212
9.1 数据库BLOB 字段读写 212
9.2 批量更新215
9.3 调用存储过程217
9.3.1 存储过程in 和out 参数的使用217
9.3.2 存储过程游标.220
9.4 分表225
9.5 分页227
9.5.1 RowBounds 分页 227
9.5.2 插件分页229
9.6 上传文件到服务器239
9.7 在映射中使用枚举247
9.8 多对多级联 249
9.9 总结253
附录A 数据库模型描述与级联学生关系建表语句.254



第1章　MyBatis快速入门
1．1　ORM简介
1．2　常见持久化框架
1．3　MyBatis示例
1．4　MyBatis整体架构
1．4．1　基础支持层
1．4．2　核心处理层
1．4．3　接口层
1．5　本章小结
第2章　基础支持层
2．1　解析器模块
2．1．1　XPath简介
2．1．2　XPathParser
2．2　反射工具箱
2．2．1　Reflector＆ReflectorFactory
2．2．2　TypeParameterResolver
2．2．3　ObjectFactory
2．2．4　Property工具集
2．2．5　MetaClass
2．2．6　ObjectWrapper
2．2．7　MetaObject
2．3　类型转换
2．3．1　TypeHandler
2．3．2　TypeHandlerRegistry
2．3．3　TypeAliasRegistry
2．4　日志模块
2．4．1　适配器模式
2．4．2　日志适配器
2．4．3　代理模式与JDK动态代理
2．4．4　JDBC调试
2．5　资源加载
2．5．1　类加载器简介
2．5．2　ClassLoaderWrapper
2．5．3　ResolverUtil
2．5．4　单例模式
2．5．5　VFS
2．6　DataSource
2．6．1　工厂方法模式
2．6．2　DataSourceFactory
2．6．3　UnpooledDataSource
2．6．4　PooledDataSource
2．7　Transaction
2．8　binding模块
2．8．1　MapperRegistry＆MapperProxyFactory
2．8．2　MapperProxy
2．8．3　MapperMethod
2．9　缓存模块
2．9．1　装饰器模式
2．9．2　Cache接口及其实现
2．9．3　CacheKey
2．10　本章小结
第3章　核心处理层
3．1　MyBatis初始化
3．1．1　建造者模式
3．1．2　BaseBuilder
3．1．3　XMLConfigBuilder
3．1．4　XMLMapperBuilder
3．1．5　XMLStatementBuilder
3．1．6　绑定Mapper接口
3．1．7　处理incomplete*集合
3．2　SqlNode＆SqlSource
3．2．1　组合模式
3．2．2　OGNL表达式简介
3．2．3　DynamicContext
3．2．4　SqlNode
3．2．5　SqlSourceBuilder
3．2．6　DynamicSqlSource
3．2．7　RawSqlSource
3．3　ResultSetHandler
3．3．1　handleResultSets()方法
3．3．2　ResultSetWrapper
3．3．3　简单映射
3．3．4　嵌套映射
3．3．5　嵌套查询＆延迟加载
3．3．6　多结果集处理
3．3．7　游标
3．3．8　输出类型的参数
3．4　KeyGenerator
3．4．1　Jdbc3KeyGenerator
3．4．2　SelectkeyGenerator
3．5　StatementHandler
3．5．1　RoutingStatementHandler
3．5．2　BaseStatementHandler
3．5．3　ParameterHandler
3．5．4　SimpleStatementHandler
3．5．5　PreparedStatementHandler
3．6　Executor
3．6．1　模板方法模式
3．6．2　BaseExecutor
3．6．3　SimpleExecutor
3．6．4　ReuseExecutor
3．6．5　BatchExecutor
3．6．6　CachingExecutor
3．7　接口层
3．7．1　策略模式
3．7．2　SqlSession
3．7．3　DefaultSqlSessionFactory
3．7．4　SqlSessionManager
3．8　本章小结
第4章　高级主题
4．1　插件模块
4．1．1　责任链模式
4．1．2　Interceptor
4．1．3　应用场景分析
4．2　MyBatis与Spring集成
4．2．1　Spring基本概念
4．2．2　Spring MVC介绍
4．2．3　集成环境搭建
4．2．4 Mybatis-Spring剖析
4．3　拾遗
4．3．1　应用＜sql＞节点
4．3．2　OgnlUtils工具类
4．3．3　SQL语句生成器
4．3．4　动态SQL脚本插件
4．3．5　MyBatis-Generator逆向工程

第1章　MyBatis快速入门
1．1　ORM简介
1．2　常见持久化框架
1．3　MyBatis示例
1．4　MyBatis整体架构
1．4．1　基础支持层
1．4．2　核心处理层
1．4．3　接口层
1．5　本章小结
第2章　基础支持层
2．1　解析器模块
2．1．1　XPath简介
2．1．2　XPathParser
2．2　反射工具箱
2．2．1　Reflector＆ReflectorFactory
2．2．2　TypeParameterResolver
2．2．3　ObjectFactory
2．2．4　Property工具集
2．2．5　MetaClass
2．2．6　ObjectWrapper
2．2．7　MetaObject
2．3　类型转换
2．3．1　TypeHandler
2．3．2　TypeHandlerRegistry
2．3．3　TypeAliasRegistry
2．4　日志模块
2．4．1　适配器模式
2．4．2　日志适配器
2．4．3　代理模式与JDK动态代理
2．4．4　JDBC调试
2．5　资源加载
2．5．1　类加载器简介
2．5．2　ClassLoaderWrapper
2．5．3　ResolverUtil
2．5．4　单例模式
2．5．5　VFS
2．6　DataSource
2．6．1　工厂方法模式
2．6．2　DataSourceFactory
2．6．3　UnpooledDataSource
2．6．4　PooledDataSource
2．7　Transaction
2．8　binding模块
2．8．1　MapperRegistry＆MapperProxyFactory
2．8．2　MapperProxy
2．8．3　MapperMethod
2．9　缓存模块
2．9．1　装饰器模式
2．9．2　Cache接口及其实现
2．9．3　CacheKey
2．10　本章小结
第3章　核心处理层
3．1　MyBatis初始化
3．1．1　建造者模式
3．1．2　BaseBuilder
3．1．3　XMLConfigBuilder
3．1．4　XMLMapperBuilder
3．1．5　XMLStatementBuilder
3．1．6　绑定Mapper接口
3．1．7　处理incomplete*集合
3．2　SqlNode＆SqlSource
3．2．1　组合模式
3．2．2　OGNL表达式简介
3．2．3　DynamicContext
3．2．4　SqlNode
3．2．5　SqlSourceBuilder
3．2．6　DynamicSqlSource
3．2．7　RawSqlSource
3．3　ResultSetHandler
3．3．1　handleResultSets()方法
3．3．2　ResultSetWrapper
3．3．3　简单映射
3．3．4　嵌套映射
3．3．5　嵌套查询＆延迟加载
3．3．6　多结果集处理
3．3．7　游标
3．3．8　输出类型的参数
3．4　KeyGenerator
3．4．1　Jdbc3KeyGenerator
3．4．2　SelectkeyGenerator
3．5　StatementHandler
3．5．1　RoutingStatementHandler
3．5．2　BaseStatementHandler
3．5．3　ParameterHandler
3．5．4　SimpleStatementHandler
3．5．5　PreparedStatementHandler
3．6　Executor
3．6．1　模板方法模式
3．6．2　BaseExecutor
3．6．3　SimpleExecutor
3．6．4　ReuseExecutor
3．6．5　BatchExecutor
3．6．6　CachingExecutor
3．7　接口层
3．7．1　策略模式
3．7．2　SqlSession
3．7．3　DefaultSqlSessionFactory
3．7．4　SqlSessionManager
3．8　本章小结
第4章　高级主题
4．1　插件模块
4．1．1　责任链模式
4．1．2　Interceptor
4．1．3　应用场景分析
4．2　MyBatis与Spring集成
4．2．1　Spring基本概念
4．2．2　Spring MVC介绍
4．2．3　集成环境搭建
4．2．4 Mybatis-Spring剖析
4．3　拾遗
4．3．1　应用＜sql＞节点
4．3．2　OgnlUtils工具类
4．3．3　SQL语句生成器
4．3．4　动态SQL脚本插件
4．3．5　MyBatis-Generator逆向工程


第2章　了解MyBatis 14
2．1 传统JDBC开发模式的缺陷 14
2．1．1 JDBC连接数据库模式分析 14
2．1．2 JDBC操作SQL语句模式分析 16
2．1．3 待优化的问题 17
2．2 初识MyBatis 18
2．2．1 MyBatis介绍 18
2．2．2 MyBatis整体架构 18
2．2．3 MyBatis运行流程 21

第3章 搭建MyBatis工作环境 23
3．1 入门程序搭建与测试 23
3．1．1 数据库准备 23
3．1．2 搭建工程环境 24
3．1．3 编写日志输出环境配置文件 26
3．1．4 编写数据库连接池配置文件 27
3．1．5 编写SQL映射配置文件 29
3．1．6 编写数据交互类与测试用例 30
3．2 入门程序数据操作 33
3．2．1 模糊查询样例 33
3．2．2 新增样例 34
3．2．3 删除与修改样例 37

第4章 MyBatis配置文件详解 40
4．1 SqlMapConfig配置文件详解 40
4．1．1 properties配置分析 43
4．1．2 setting配置分析 44
4．1．3 typeAliases配置分析 48
4．1．4 typeHandlers配置分析 50
4．1．5 objectFactory配置分析 53
4．1．6 plugins配置分析 56
4．1．7 environments配置分析 58
4．1．8 mappers配置分析 60
4．2 Mapper映射文件 61
4．2．1 映射文件总体介绍 61
4．2．2 Mapper配置输入映射 64
4．2．3 Mapper输入映射样例 65
4．2．4 Mapper配置输出映射 68
4．2．5 Mapper自动映射 75
4．2．6 Mapper配置动态SQL语句 76

第5章 MyBatis高级映射 80
5．1 建立测试数据模型 80
5．1．1 业务模型分析 80
5．1．2 根据业务创建测试表 81
5．2 一对一查询 83
5．2．1 使用resultType实现 83
5．2．2 使用resultMap实现 85
5．3 一对多查询 87
5．3．1 实体类定义与Mapper编写 87
5．3．2 测试查询结果 89
5．4 多对多查询 90
5．4．1 实体类定义与Mapper编写 91
5．4．2 测试查询结果 94
5．5 延迟加载 96
5．5．1 Mapper映射配置编写 96
5．5．2 测试延迟加载效果 97
5．6 Mapper动态代理 99
5．6．1 Mapper代理实例编写 99
5．6．2 测试动态代理效果 100

第6章 MyBatis缓存结构 102
6．1 一级查询缓存 103
6．1．1 一级缓存原理阐述 103
6．1．2 一级缓存测试示例 103
6．2 二级查询缓存 105
6．2．1 二级缓存原理阐述 105
6．2．2 二级缓存测试实例 106
6．2．3 验证二级缓存清空 108

第7章 MyBatis技术拓展 110
7．1 MyBatis与Spring的整合 110
7．1．1 创建测试工程 110
7．1．2 引入依赖jar包 111
7．1．3 编写Spring配置文件 112
7．1．4 编写MyBatis配置文件 114
7．1．5 编写Mapper及其他配置文件 115
7．1．6 编写DAO层 116
7．1．7 编写Service测试类 117
7．1．8 使用Mapper代理 118
7．2 MyBatis逆向工程 121
7．2．1 逆向工程配置 121
7．2．2 逆向数据文件生成类 123
7．2．3 运行测试方法 124
7．2．4 测试生成的数据文件 126

第3篇 Spring MVC技术入门
第8章　Spring MVC 132
8．1 Spring MVC基础 133
8．1．1 Spring体系结构 133
8．1．2 Spring MVC请求流程 134
8．2 Spring MVC与Struts的区别 135
8．3 Spring MVC环境搭建 136
8．3．1　依赖jar包的添加和前端控制器配置 137
8．3．2　编写核心配置文件springmvc．xml 138
8．3．3　编写Handler处理器与视图 140

第9章 处理器映射器和适配器 144
9．1 非注解的处理器映射器和适配器 144
9．1．1　非注解的处理器映射器 144
9．1．2　非注解的处理器适配器 146
9．2 注解的处理器映射器和适配器 151

第10章 前端控制器和视图解析器 154
10．1 前端控制器源码分析 154
10．2 视图解析器 162
10．2．1　AbstractCachingViewResolver 162
10．2．2　UrlBasedViewResolver 162
10．2．3　InternalResourceViewResolver 163
10．2．4　XmlViewResolver 163
10．2．5　BeanNameViewResolver 164
10．2．6　ResourceBundleViewResolver 165
10．2．7　FreeMarkerViewResolver与VelocityViewResolver 167
10．2．8　ViewResolver链 168

第11章 请求映射与参数绑定 169
11．1 Controller与RequestMapping 169
11．2 参数绑定过程 173
11．2．1　简单类型参数绑定 174
11．2．2　包装类型参数绑定 176
11．2．3　集合类型参数绑定 182

第12章 Validation校验 187
12．1 Bean Validation数据校验 188
12．1．1 搭建validation校验框架 188
12．1．2 添加校验注解信息 189
12．1．3 测试validation校验效果 191
12．1．4 validation注解全面介绍 192
12．2 分组校验 193
12．2．1 设置分组校验 193
12．2．2 测试分组校验效果 195
12．3 Spring Validator接口校验 195
12．3．1 Validator接口的使用 195
12．3．2 Validator接口验证测试 199

第13章 异常处理和拦截器 201
13．1 全局异常处理器 201
13．2 拦截器定义与配置 207
13．2．1　HandlerInterceptor接口 207
13．2．2　WebRequestInterceptor接口 209
13．2．3　拦截器链 210
13．2．4　拦截器登录控制 213

第14章　Spring MVC其他操作 217
14．1　利用 Spring MVC上传文件 217
14．2　利用Spring MVC实现JSON交互 223
14．3　利用Spring MVC实现RESTful风格 231
14．3．1　RESTful 231
14．3．2　使用Spring MVC实现RESTful风格 232
14．3．3　静态资源访问问题 235

第4篇　Spring MVC与MyBatis项目实战
第15章 项目分析与建模 238
15．1 项目需求分析 238
15．1．1 系统主要使用者业务关系分析 239
15．1．2 系统主要使用者经济关系分析 239
15．2 项目UML图例 240
15．2．1 UML图的类型 240
15．2．2 绘制系统用例图 241
15．2．3 绘制系统模块图 241
15．3 项目数据库建模 242
15．3．1 系统数据关系分析 243
15．3．2 系统主要表设计 243

第16章 开发框架环境搭建 250
16．1 搭建工程的Maven环境 250
16．1．1 Maven下载配置 250
16．1．2 创建Maven工程 252
16．1．3 为工程添加依赖 254
16．2 开发框架基础配置与测试 259
16．2．1 开发框架环境配置 259
16．2．2　测试环境配置结果 266

第17章　核心代码以及登录模块编写 277
17．1 各层核心基础代码 277
17．1．1 编写DAO层核心代码 277
17．1．2 编写Controller层核心代码 279
17．2 登录注册管理模块 280
17．2．1 编写登录模块 280
17．2．2　编写登录验证服务 283
17．2．3 编写注册模块 288
17．2．4 编写注册服务 290

第18章 零售商及货物管理模块 292
18．1 零售商管理模块 292
18．1．1 添加主导航栏 292
18．1．2 编写基础Controller及实体类 294
18．1．3 创建Mapper映射文件 295
18．1．4 编写DAO层处理逻辑 297
18．1．5 编写Service层处理逻辑 297
18．1．6 完善Controller类 298
18．1．7 编写相关视图页面 300
18．1．8 分页操作逻辑编写 302
18．1．9 测试分页效果 305
18．1．10 编写编辑功能 307
18．1．11 测试编辑功能 310
18．1．12 编写删除功能 311
18．1．13 测试删除功能 312
18．1．14 编写添加功能 312
18．1．15 测试添加功能 314
18．2 货物信息管理模块 315
18．2．1 导航栏与Controller基础准备 315
18．2．2 创建Mapper映射文件 316
18．2．3 编写DAO层处理逻辑 318
18．2．4 编写Service层处理逻辑 319
18．2．5 完善Controller类 320
18．2．6 编写相关视图页面 322
18．3 附属品管理模块 325
18．3．1 导航栏与Controller基础准备 325
18．3．2 创建Mapper映射文件 326
18．3．3 完善Controller类 327
18．3．4 编写相关视图页面 329
18．3．5 验证页面效果 331
18．3．6 批量删除实现 332

第19章 购销合同管理模块 335
19．1 购销合同管理模块 335
19．1．1 购销合同Mapper实现 335
19．1．2 编写DAO层处理逻辑 341
19．1．3 编写Service层处理逻辑 342
19．1．4 编写Controller基础类 344
19．1．5 编写相关视图页面 345
19．2 关联零售商 347
19．2．1 编写添加逻辑 347
19．2．2 实现零售商关联浮出框 349
19．2．3 测试零售商关联 354
19．3 关联水果货物 354
19．3．1 货物关联展示与浮出框编写 354
19．3．2 勾选货物功能编写 358
19．3．3 测试货物关联 360
19．4 完善购销合同 360
19．4．1 合同关联信息合并提交 360
19．4．2 测试合并提交 365
19．4．3 合同打印以及删除实现 369
19．5　总结 372

1．1　Java EE应用概述 2
1．1．1　Java EE应用的分层模型 2
1．1．2　Java EE应用的组件 3
1．1．3　Java EE应用的结构和优势 4
1．2　轻量级Java EE应用相关技术 4
1．2．1　JSP、Servlet和JavaBean及替代技术 4
1．2．2　MyBatis 3及替代技术 5
1．2．3　Spring 5及替代技术 6
1．2．4　使用开源框架的好处 7
1．3　本章小结 7

第2章　Spring MVC简介 8
2．1　MVC思想概述 9
2．1．1　传统Model1和Model2 9
2．1．2　MVC思想及其优势 10
2．2　Struts 2和Spring MVC 11
2．2．1　Spring MVC的优势 11
2．2．2　Spring MVC和Struts 2的区别 11
2．3　开发第一个Spring MVC应用 12
2．3．1　Spring的下载和安装 12
2．3．2　Spring MVC的DispatcherServlet 13
2．3．3　基于Controller接口的控制器 14
示例：第一个Spring MVC应用 14
示例：基于注解的控制器 18
2．4　详解DispatcherServlet 20
2．5　Spring MVC执行的流程 22
2．5．1　Spring MVC应用的开发步骤 22
2．5．2　Spring MVC执行的流程 24
2．6　本章小结 25

第3章　Spring MVC的常用注解 26
3．1　@Controller注解 27
示例：@Controller注解的使用 27
3．2　@RequestMapping注解 29
3．2．1　@RequestMapping注解简介 29
3．2．2　请求处理方法中可出现的参数类型 32
3．2．3　请求处理方法可返回的类型 33
3．2．4　Model和ModelMap 33
示例：Model和ModelMap的使用 34
3．2．5　ModelAndView 35
示例：ModelAndView的使用 35
3．2．6　页面转发 35
3．3　@RequestParam注解 36
示例：@RequestMapping和@RequestParam注解的使用 37
3．4　@PathVariable注解 41
3．5　@MatrixVariable注解 42
3．6　@CrossOrigin注解 42
示例：@PathVariable注解和@MatrixVariable注解的使用 43
示例：@CrossOrigin注解的使用 45
3．7　@RequestHeader注解 46
示例：@RequestHeader注解的使用 47
3．8　@CookieValue注解 48
示例：@CookieValue注解的使用 49
3．9　@RequestAttribute注解 50
3．10　@SessionAttribute注解 50
示例：@RequestAttribute注解和@SessionAttribute注解的使用 51
3．11　@SessionAttributes注解 53
示例：@SessionAttributes注解的使用 53
3．12　@ModelAttribute注解 55
示例：@ModelAttribute注解的使用 55
3．13　@RequestBody注解 62
3．13．1　HttpMessageConverter＜T＞接口 62
3．13．2　转换JSON数据 64
示例：@RequestBody接收JSON格式的数据 65
示例：自定义HttpMessageConverter接收JSON格式的数据 68
3．14　@ResponseBody注解 70
示例：@ResponseBody返回JSON格式的数据 70
示例：自定义HttpMessageConverter返回JSON格式的数据 72
3．15　转换XML数据 72
示例：接收XML格式的数据 72
示例：返回XML格式的数据 75
3．16　@RestController注解 76
示例：@RestController注解的使用 76
3．17　Spring MVC的异常处理 77
3．17．1　Spring MVC异常处理接口以及实现类 77
示例：SimpleMappingExceptionResolver处理异常 78
3．17．2 @ResponseStatus注解 82
示例：@ResponseStatus处理异常 82
3．17．3　@ExceptionHandle注解 84
示例：@ExceptionHandler处理异常 84
3．17．4　@ControllerAdvice注解 87
示例：@ControllerAdvice处理异常 87
3．17．5　@RestControllerAdvice注解 91
示例：@RestControllerAdvice注解的使用 91
3．18　本章小结 92

第4章　Spring MVC的标签库 93
4．1　表单标签库 94
4．1．1　form标签 94
4．1．2　input标签 95
示例：form和input标签的使用 95
4．1．3　password标签 97
4．1．4　hidden标签 98
4．1．5　textarea标签 98
4．1．6　checkbox标签 99
示例：checkbox标签的使用 99
4．1．7　checkboxes标签 101
示例：checkboxes标签的使用 101
4．1．8　radiobutton标签 105
示例：radiobutton标签的使用 105
4．1．9　radiobuttons标签 106
示例：radiobuttons标签的使用 107
4．1．10　select标签 108
4．1．11　option标签 109
4．1．12　options标签 109
示例：select、option和options标签的使用 109
4．1．13 errors标签 113
示例：errors标签的使用 114
4．2　本章小结 116

第5章　Spring MVC的国际化 117
5．1　Spring MVC国际化的相关知识 118
5．1．1　messageSource接口 118
5．1．2　localeResolver接口 118
5．1．3　message标签 119
5．2　Spring MVC的国际化处理 119
5．2．1　AcceptHeaderLocaleResolver 119
示例：基于浏览器请求的国际化实现 119
5．2．2　SessionLocaleResolver 122
示例：基于HttpSession的国际化实现 123
5．2．3　CookieLocaleResolver 125
示例：基于Cookie的国际化实现 125
5．3　本章小结 127

第6章　Spring MVC的数据转换、格式化和数据校验 128
6．1　数据绑定流程 129
6．2　数据转换 129
6．2．1　ConversionService 129
6．2．2　Spring支持的转换器 130
示例：使用ConversionService转换数据 131
示例：使用@InitBinder添加自定义编辑器转换数据 134
示例：使用WebBindingInitializer注册全局自定义编辑器转换数据 135
6．2．3 多种转换器的优先顺序 135
6．3　数据格式化 136
示例：使用Formatter格式化数据 137
示例：使用FormatterRegistrar注册Formatter 138
示例：使用AnnotationFormatterFactory ＜A extends Annotation＞格式化数据 139
6．4　数据校验 142
6．4．1　Spring的Validation校验框架 143
示例：测试Spring的Validation校验 143
6．4．2　JSR 303校验 146
示例：测试JSR 303校验 147
6．5　本章小结 152

第7章　Spring MVC的文件上传下载和拦截器机制 153
7．1　文件上传 154
示例：Spring MVC的文件上传 154
示例：使用对象接收上传文件 157
7．2　文件下载 158
示例：Spring MVC的文件下载 158
7．3　拦截器 160
7．3．1　HandlerInterceptor接口 160
示例：拦截器实现用户权限验证 161
7．4　本章小结 164

第8章　MyBatis简介 165
8．1　ORM和MyBatis 166
8．1．1　对象/关系数据库映射（ORM） 166
8．1．2　基本映射方式 167
8．1．3　流行的ORM框架简介 168
8．1．4　MyBatis概述 168
8．2　MyBatis入门 169
8．2．1　MyBatis下载和安装 169
示例：MyBatis的数据库操作入门 170
8．3　本章小结 175

第9章　MyBatis的基本用法 176
9．1　MyBatis体系结构 177
9．1．1　SqlSessionFactory 177
9．1．2　SqlSession 177
9．2　深入MyBatis的配置文件 179
9．2．1　MyBatis的配置文件结构 180
9．2．2　properties属性 180
9．2．3　settings设置 181
9．2．4　typeAliases类型命名 183
9．2．5　typeHandlers类型处理器 184
9．2．6　objectFactory对象工厂 185
9．2．7　environments配置环境 185
9．2．8　mapper映射器 187
9．3　MyBatis日志信息配置 188
9．3．1　log4j．properties配置日志 188
9．3．2　log4j．xml配置日志 189
9．4　深入Mapper XML映射文件 190
9．4．1　select 191
9．4．2　insert、update和delete 192
9．4．3　sql 194
9．4．4　参数（Parameters） 195
示例：测试select、insert、update和delete操作 195
9．4．5　ResultMaps 200
示例：测试ResultMaps 201
9．5　本章小结 208

第10章　深入使用MyBatis 209
10．1　MyBatis关联映射 210
10．1．1　一对一 210
示例：OneToOneTest 210
10．1．2　一对多 213
示例：OneToManyTest 213
10．1．3　多对多 218
示例：ManyToManyTest 218
10．2　MyBatis动态SQL 225
示例：DynamicSQLTest 225
10．2．1　if 226
10．2．2　choose（when、otherwise） 229
10．2．3　where 230
10．2．4　set 232
10．2．5　foreach 233
10．2．6　bind 234
10．3　MyBatis调用存储过程 234
示例：MyBatis调用存储过程 235
10．3．1　插入数据 235
10．3．2　查询数据返回集合 237
10．3．3　根据id查询数据返回对象 238
10．3．4　修改数据 239
10．3．5　删除数据 241
10．4　MyBatis事务管理 242
10．4．1　事务的概念 242
10．4．2　Transaction接口 243
10．4．3　事务的配置创建和使用 243
10．5　MyBatis缓存机制 247
10．5．1　一级缓存（SqlSession级别） 247
示例：OneLevelCacheTest 247
10．5．2　二级缓存（mapper级别） 251
示例：TwoLevelCacheTest 251
10．6　本章小结 254

第11章　MyBatis的注解配置 255
11．1　常用注解 256
11．2　注解的使用 256
示例：测试select、insert、update和delete操作 257
示例：测试一对一关联 262
示例：测试一对多关联 263
示例：测试多对多关联 265
示例：测试动态SQL 267
示例：测试调用存储过程 274
示例：测试二级缓存 276
11．3　本章小结 278

第12章　Spring 5整合MyBatis 3 279
12．1　开发环境搭建 280
12．2　准备所需的jar包 280
12．3　准备数据库资源 280
12．4　完成配置文件 281
12．5　持久层功能实现 283
12．6　服务层功能实现 284
12．7　控制层功能实现 286
12．8　JSP页面 288
12．9　测试Spring 5整合MyBatis 3 289
12．10　本章小结 290

第13章　实战项目：人事管理系统 291
13．1　项目简介及系统结构 292
13．1．1　系统功能介绍 292
13．1．2　相关技术介绍 293
13．1．3　系统结构 293
13．1．4　系统的功能模块 294
13．2　数据表和持久化类 294
13．2．1　设计数据库表 294
13．2．2　设计持久化实体 296
13．2．3　创建持久化实体类 297
13．3　实现DAO持久层 303
13．3．1　公共常量类 304
13．3．2　定义DAO接口 304
13．3．3　部署DAO层 318
13．4　实现Service持久层 319
13．4．1　业务逻辑组件的设计 319
13．4．2　实现业务逻辑组件 320
13．4．3　事务管理 335
13．4．4　部署业务逻辑组件 335
13．5　实现Web层 335
13．5．1　控制器的处理顺序 335
13．5．2　用户管理 339
13．5．3　部门管理 342
13．5．4　职位管理 345
13．5．5　员工管理 348
13．5．6　公告管理 351
13．5．7　下载中心 355
13．6　本章小结 359

附录A　EL表达式和JSTL标签库 360

第2章 快速搭建第一个SSM项目 10
2.1 SSM简述 10
2.1.1 Spring简述 10
2.1.2 Spring MVC简述 12
2.1.3 MyBatis简述 12
2.2 快速搭建SSM项目 13
2.2.1 快速搭建Web项目 13
2.2.2 集成Spring 16
2.2.3 集成Spring MVC框架 21
2.2.4 集成MyBatis框架 27
2.2.5 集成Log4j日志框架 34
2.2.6 集成JUnit测试框架 38
第3章 Spring快速上手 40
3.1 Spring IOC和DI 40
3.1.1 Spring IOC和DI概述 40
3.1.2 单例模式 42
3.1.3 Spring单例模式源码解析 48
3.1.4 简单工厂模式详解 51
3.1.5 工厂方法模式详解 55
3.1.6 Spring Bean工厂类详解 59
3.2 Spring AOP 61
3.2.1 Spring AOP概述 61
3.2.2 Spring AOP核心概念 61
3.2.3 JDK动态代理实现日志框架 63
3.2.4 Spring AOP实现日志框架 68
3.2.5 静态代理与动态代理模式 70
第4章 MyBatis映射器与动态SQL 74
4.1 MyBatis映射器 74
4.1.1 映射器的主要元素 74
4.1.2 select元素 75
4.1.3 insert元素 77
4.1.4 selectKey元素 77
4.1.5 update元素 78
4.1.6 delete元素 79
4.1.7 sql元素 80
4.1.8 #与$区别 81
4.1.9 resultMap结果映射集 81
4.2 动态SQL 83
4.2.1 动态SQL概述 83
4.2.2 if元素 83
4.2.3 choose、when、otherwise元素 84
4.2.4 trim、where、set元素 86
4.2.5 foreach元素 88
4.2.6 bind元素 89
4.3 MyBatis注解配置 90
4.3.1 MyBatis常用注解 90
4.3.2 @Select注解 91
4.3.3 @Insert、@Update、@Delete注解 91
4.3.4 @Param注解 92
4.4 MyBatis关联映射 94
4.4.1 关联映射概述 94
4.4.2 一对一 94
4.4.3 一对多 97
4.4.4 多对多 101
第5章 MyBatis分页开发 106
5.1 RowBounds分页 106
5.1.1 分页概述 106
5.1.2 RowBounds分页 107
5.1.3 RowBounds分页使用 108
5.1.4 RowBounds分页原理 109
5.2 分页插件PageHelper 111
5.2.1 PageHelper概述 111
5.2.2 PageHelper使用 111
第6章 Spring MVC常用注解 114
6.1 请求映射注解 114
6.1.1 @Controller注解 114
6.1.2 @RequestMapping注解 116
6.1.3 @GetMapping和@PostMapping注解 120
6.1.4 Model和ModelMap 121
6.1.5 ModelAndView 122
6.1.6 请求方法可出现参数和可返回类型 123
6.2 参数绑定注解 125
6.2.1 @RequstParam注解 125
6.2.2 @PathVariable注解 126
6.2.3 @RequestHeader注解 127
6.2.4 @CookieValue注解 128
6.2.5 @ModelAttribute注解 129
6.2.6 @SessionAttribute和@SessionAttributes注解 134
6.2.7 @ResponseBody和@RequestBody注解 136
6.3 信息转换详解 138
6.3.1 HttpMessageConverter 138
6.3.2 RequestMappingHandlerAdapter 140
6.3.3 自定义HttpMessageConverter 141
第7章 Spring数据校验 142
7.1 数据校验概述 142
7.2 Spring的Validation校验框架 143
7.3 JSR 303校验 147
第8章 Spring和MyBatis事务管理 152
8.1 Spring事务管理 152
8.1.1 Spring事务回顾 152
8.1.2 Spring声明式事务 153
8.1.3 Spring注解事务行为 153
8.2 MyBatis事务管理 155
第9章 MyBatis缓存机制 160
9.1 MyBatis的缓存模式 160
9.2 一级查询缓存 161
9.2.1 一级缓存概述 161
9.2.2 一级缓存示例 161
9.2.3 一级缓存生命周期 164
9.3 二级查询缓存 165
9.3.1 二级缓存概述 165
9.3.2 二级缓存示例 166
9.3.3 cache-ref共享缓存 168
9.4 MyBatis缓存原理 170
9.4.1 MyBatis缓存的工作原理 170
9.4.2 装饰器模式 171
9.4.3 Cache接口及其实现 173
第10章 Spring MVC原理剖析 176
10.1 Spring MVC执行流程 176
10.1.1 Spring MVC执行流程 176
10.1.2 前端控制器DispatcherServlet 178
10.2 处理映射器和适配器 182
10.2.1 处理映射器 182
10.2.2 处理适配器 183
10.3 视图解析器 195
10.3.1 概述 195
10.3.2 视图解析流程 195
10.3.3 常用视图解析器 195
10.3.4 ViewResolver链 201
第11章 MyBatis原理剖析 203
11.1 MyBatis整体框架 203
11.1.1 概述 203
11.1.2 接口层 203
11.1.3 核心处理层 206
11.1.4 基础支撑层 207
11.2 MyBatis初始化流程 208
11.3 MyBatis执行流程 211
第12章 高并发点赞项目实践 215
12.1 高并发点赞项目 215
12.1.1 项目概述 215
12.1.2 数据库表和持久化类 216
12.1.3 DAO层和Mapper映射文件 220
12.1.4 Service层和DTO类 223
12.1.5 Controller层和前端页面 227
12.1.6 测试 229
12.2 传统点赞功能实现 229
12.2.1 概述 229
12.2.2 代码实现 231
12.2.3 测试 235
12.3 集成Redis缓存 235
12.3.1 概述 235
12.3.2 Redis安装和使用 236
12.3.3 集成Redis缓存 243
12.3.4 设计Redis数据结构 246
12.3.5 代码实现 247
12.3.6 集成Quartz定时器 251
12.3.7 测试 255
12.4 集成ActiveMQ 255
12.4.1 概述 255
12.4.2 ActiveMQ的安装 256
12.4.3 集成ActiveMQ 258
12.4.4 ActiveMQ异步消费 261
12.4.5 测试 264


15.2 MyBatis子项目 389

15.3 MyBatis的自身定位 389

15.3.1 JPA持久化框架 390

15.3.2 MyBatis的功能 390

15.3.3 MyBatis与JPA的异同 390

15.4 MyBatis的架构 391

15.4.1 模块 391

15.4.2 MyBatis的项目包 392

第16章 构建阶段 394

16.1 关键类 394

16.2 关键时序 395

16.3 构建的入口：SqlSessionFactoryBuilder和SqlSessionFactory 396

16.4 配置（Configuration）和配置构造器（XmlConfigBuilder） 397

16.4.1 XmlConfigBuilder的初始化 397

16.4.2 完整的mybatis-3-config.dtd 399

16.4.3 解析配置文件构建Configuration配置 399

16.5 SQL简介 418

16.6 SQL映射的构建 419

16.6.1 通过XML定义的SQL Mapper 419

16.6.2 Configuration类中与SQL Mapping相关的类 420

16.6.3 XmlMapperBuilder是如何工作的 421

16.6.4 映射注解器定义的SQL Mapper 438

16.6.5 小结 440

第17章 执行阶段 441

17.1 关键类 441

17.2 关键接口及默认实现初始化 442

17.2.1 SqlSession及其关联类的构建过程 442

17.2.2 StatementHandler语句处理器 446

17.3 DQL语句是如何执行的 448

17.3.1 查询接口 448

17.3.2 关键时序 449

17.3.3 程序执行查询的入口：DefaultSqlSession#selectList(statement) 450

17.3.4 生成执行语句：getMappedStatement() 450

17.3.5 执行器查询：Executor#query() 451

17.3.6 JDBC执行语句：SimpleStatementHandler#query() 455

17.3.7 结果集处理：DefaultResultSetHandler#handlerResultSets() 455

17.4 DML语句是如何执行的 460

17.4.1 操作接口 460

17.4.2 关键时序 460

17.4.3 程序执行更新的入口：DefaultSqlSession#update() 461

17.4.4 执行器执行方法：Executor#update() 461

17.4.5 SQL语句执行：SimpleStatementHandler#update() 464

17.4.6 结果集主键逻辑：Jdbc3KeyGenerator#processAfter() 464

17.5 小结 466

第18章 专题特性解析 467

18.1 动态SQL支持 467

18.1.1 XmlScriptBuilder解析配置 467

18.1.2 NodeHandler构建SqlNode树 468

18.1.3 SqlNode处理SQL语句 471

18.2 MyBatis的缓存支持 477

18.2.1 本地缓存 478

18.2.2 二级缓存 482

18.3 结果集支持：Object、List、Map和Cursor 491

18.4 自定义扩展点及接口 496

第19章 作为中间件如何承上启下 498

19.1 MyBatis与底层的JDBC 498

19.1.1 java.sql.DataSource 498

19.1.2 java.sql.Connection 499

19.1.3 java.sql.Statement 500

19.1.4 java.sql.Resultset 502

19.2 MyBatis的主流集成方式 502

19.2.1 mybatis-spring简介 502

19.2.2 Spring对JDBC的支持 502

19.2.3 mybatis-spring与Spring 504


#{}是预编译处理，${}是字符串替换；

Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；

Mybatis在处理${}时，就是把${}替换成变量的值；

使用#{}可以有效的防止SQL注入，提高系统安全性。

126. mybatis 有几种分页方式？
数组分页
sql分页
拦截器分页
RowBounds分页


128. mybatis 逻辑分页和物理分页的区别是什么？

物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。

物理分页总是优于逻辑分页：

没有必要将属于数据库端的压力加诸到应用端来，

就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。


129. mybatis 是否支持延迟加载？延迟加载的原理是什么？

Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。

它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。

当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。

说一下 mybatis 的一级缓存和二级缓存？
一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。

二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；

对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。

131. mybatis 和 hibernate 的区别有哪些？

Mybatis有三种基本的执行器（Executor）：

SimpleExecutor：每执行一次update或select，就开启一个Statement对象，
用完立刻关闭Statement对象。

ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，
不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。
简言之，就是重复使用Statement对象。

BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加
到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement
对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。
与JDBC批处理相同。
133. mybatis 分页插件的实现原理是什么？

分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。

134. mybatis 如何编写一个自定义插件？

Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：

1、Executor：拦截执行器的方法(log记录)
2、StatementHandler ：拦截Sql语法构建的处理
3、ParameterHandler ：拦截参数的处理
4、ResultSetHandler ：拦截结果集的处理
前两种应用较为广泛。

Mybatis自定义插件必须实现Interceptor接口：

public interface Interceptor {
    Object intercept(Invocation invocation) throws Throwable;
    Object plugin(Object target);
    void setProperties(Properties properties);
}
intercept方法：拦截器具体处理逻辑方法
plugin方法：根据签名signatureMap生成动态代理对象
setProperties方法：设置Properties属性

自定义插件demo:

// ExamplePlugin.java
@Intercepts({@Signature(
  type= Executor.class,
  method = "update",
  args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
  public Object intercept(Invocation invocation) throws Throwable {
  Object target = invocation.getTarget(); //被代理对象
  Method method = invocation.getMethod(); //代理方法
  Object[] args = invocation.getArgs(); //方法参数
  // do something ...... 方法拦截前执行代码块
  Object result = invocation.proceed();
  // do something .......方法拦截后执行代码块
  return result;
  }
  public Object plugin(Object target) {
    return Plugin.wrap(target, this);
  }
  public void setProperties(Properties properties) {
  }
}
一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下：
type：表示拦截的类，这里是Executor的实现类
method：表示拦截的方法，这里是拦截Executor的update方法
args：表示方法参数


1.JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？
① 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。
解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。

② Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。
解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。

③ 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。
解决： Mybatis自动将java对象映射至sql语句。

④ 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。
解决：Mybatis自动将sql执行结果映射至java对象。
2.MyBatis编程步骤是什么样的？
① 创建SqlSessionFactory
② 通过SqlSessionFactory创建SqlSession
③ 通过sqlsession执行数据库操作
④ 调用session.commit()提交事务
⑤ 调用session.close()关闭会话
3.MyBatis与Hibernate有哪些不同？
    Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。

    Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。

    Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。
总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。
4.使用MyBatis的mapper接口调用时有哪些要求？
①  Mapper接口方法名和mapper.xml中定义的每个sql的id相同
②  Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同
③  Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同
④  Mapper.xml文件中的namespace即是mapper接口的类路径。
5.SqlMapConfig.xml中配置有哪些内容？
SqlMapConfig.xml中配置的内容和顺序如下：
properties（属性）
settings（配置）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境集合属性对象）
environment（环境子属性对象）
transactionManager（事务管理）
dataSource（数据源）
mappers（映射器）
6.简单的说一下MyBatis的一级缓存和二级缓存？
Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。value为从查询出来映射生成的java对象

Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨SqlSession的。
7.Mapper编写有哪几种方式？
①接口实现类继承SqlSessionDaoSupport
使用此种方法需要编写mapper接口，mapper接口实现类、mapper.xml文件

1、在sqlMapConfig.xml中配置mapper.xml的位置



<mappers>
    <mapper resource="mapper.xml文件的地址" />
    <mapper resource="mapper.xml文件的地址" />
</mappers>


2、定义mapper接口

3、实现类集成SqlSessionDaoSupport

mapper方法中可以this.getSqlSession()进行数据增删改查。

4、spring 配置



<bean id=" " class="mapper接口的实现">
    <property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
</bean>
②使用org.mybatis.spring.mapper.MapperFactoryBean


1、在sqlMapConfig.xml中配置mapper.xml的位置

如果mapper.xml和mappre接口的名称相同且在同一个目录，这里可以不用配置



<mappers>
    <mapper resource="mapper.xml文件的地址" />
    <mapper resource="mapper.xml文件的地址" />
</mappers>


2、定义mapper接口

注意

1、mapper.xml中的namespace为mapper接口的地址

2、mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致

3、 Spring中定义



<bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean">
    <property name="mapperInterface"   value="mapper接口地址" />
    <property name="sqlSessionFactory" ref="sqlSessionFactory" />
</bean>
③使用mapper扫描器


1、mapper.xml文件编写，

注意：

mapper.xml中的namespace为mapper接口的地址

mapper接口中的方法名和mapper.xml中的定义的statement的id保持一致

如果将mapper.xml和mapper接口的名称保持一致则不用在sqlMapConfig.xml中进行配置

2、定义mapper接口

注意mapper.xml的文件名和mapper的接口名称保持一致，且放在同一个目录

3、配置mapper扫描器

<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="mapper接口包地址"></property>
    <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
</bean>
4、使用扫描器后从spring容器中获取mapper的实现对象


扫描器将接口通过代理方法生成实现对象，要spring容器中自动注册，名称为mapper 接口的名称。


超全MyBatis动态SQL详解！( 看完SQL爽多了)
阿进的写字台  java进阶架构师  前天


阅读文本大概需要 18 分钟。

温馨提示：文中代码看不全可左右滑动

MyBatis 令人喜欢的一大特性就是动态 SQL。 在使用 JDBC 的过程中， 根据条件进行 SQL 的拼接是很麻烦且很容易出错的。 MyBatis 动态 SQL 的出现， 解决了这个麻烦。

MyBatis通过 OGNL 来进行动态 SQL 的使用的。目前， 动态 SQL 支持以下几种标签：



1 数据准备
为了后面的演示， 创建了一个 Maven 项目 mybatis-dynamic, 创建了对应的数据库和表

DROP TABLE IF EXISTS `student`;

CREATE TABLE `student` (
  `student_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '编号',
  `name` varchar(20) DEFAULT NULL COMMENT '姓名',
  `phone` varchar(20) DEFAULT NULL COMMENT '电话',
  `email` varchar(50) DEFAULT NULL COMMENT '邮箱',
  `sex` tinyint(4) DEFAULT NULL COMMENT '性别',
  `locked` tinyint(4) DEFAULT NULL COMMENT '状态(0:正常,1:锁定)',
  `gmt_created` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '存入数据库的时间',
  `gmt_modified` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改的时间',
  `delete` int(11) DEFAULT NULL,
  PRIMARY KEY (`student_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='学生表';

对应的项目结构



2 if 标签
if 标签是我们最常使用的。 在查询、删除、更新的时候很可能会使用到。 必须结合 test 属性联合使用。

2.1 在 WHERE 条件中使用 if 标签
这是常见的一种现象， 我们在进行按条件查询的时候， 可能会有多种情况。

2.1.1 查询条件
根据输入的学生信息进行条件检索

当只输入用户名时， 使用用户名进行模糊检索；

当只输入性别时， 使用性别进行完全匹配

当用户名和性别都存在时， 用这两个条件进行查询匹配查询

2.1.2 动态 SQL
接口函数

    /**
     * 根据输入的学生信息进行条件检索
     * 1. 当只输入用户名时， 使用用户名进行模糊检索；
     * 2. 当只输入邮箱时， 使用性别进行完全匹配
     * 3. 当用户名和性别都存在时， 用这两个条件进行查询匹配的用
     * @param student
     * @return
     */
        List<Student> selectByStudentSelective(Student student);

对应的动态 SQL

  <select id="selectByStudentSelective" resultMap="BaseResultMap" parameterType="com.homejim.mybatis.entity.Student">
    select
    <include refid="Base_Column_List" />
    from student
    where 1=1
    <if test="name != null and name !=''">
      and name like concat('%', #{name}, '%')
    </if>
    <if test="sex != null">
      and sex=#{sex}
    </if>
  </select>

在此 SQL 语句中， where 1=1 是多条件拼接时的小技巧， 后面的条件查询就可以都用 and 了。

同时， 我们添加了 if 标签来处理动态 SQL

    <if test="name != null and name !=''">
      and name like concat('%', #{name}, '%')
    </if>
    <if test="sex != null">
      and sex=#{sex}
    </if>

此 if 标签的 test 属性值是一个符合 OGNL 的表达式， 表达式可以是 true 或 false。 如果表达式返回的是数值， 则0为 false, 非 0 为 true;

2.1.3 测试
     @Test
    public void selectByStudent() {
        SqlSession sqlSession = null;
        sqlSession = sqlSessionFactory.openSession();
        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);

        Student search = new Student();
        search.setName("明");

        System.out.println("只有名字时的查询");
        List<Student> studentsByName = studentMapper.selectByStudentSelective(search);
        for (int i = 0; i < studentsByName.size(); i++) {
            System.out.println(ToStringBuilder.reflectionToString(studentsByName.get(i), ToStringStyle.MULTI_LINE_STYLE));
        }

        search.setName(null);
        search.setSex((byte) 1);
        System.out.println("只有性别时的查询");
        List<Student> studentsBySex = studentMapper.selectByStudentSelective(search);
        for (int i = 0; i < studentsBySex.size(); i++) {
            System.out.println(ToStringBuilder.reflectionToString(studentsBySex.get(i), ToStringStyle.MULTI_LINE_STYLE));
        }

        System.out.println("姓名和性别同时存在的查询");
        search.setName("明");
        List<Student> studentsByNameAndSex = studentMapper.selectByStudentSelective(search);
        for (int i = 0; i < studentsByNameAndSex.size(); i++) {
            System.out.println(ToStringBuilder.reflectionToString(studentsByNameAndSex.get(i), ToStringStyle.MULTI_LINE_STYLE));
        }

        sqlSession.commit();
        sqlSession.close();
    }

只有名字时的查询， 发送的语句和结果



查询的条件只发送了

where 1=1 and name like concat('%', ?, '%')

只有性别时的查询， 发送的语句和结果



查询的条件只发送了

where 1=1 and sex=?

姓名和性别同时存在的查询， 发送的语句和结果



查询条件

where 1=1 and name like concat('%', ?, '%') and sex=?

2.2 在 UPDATE 更新列中使用 if 标签
有时候我们不希望更新所有的字段， 只更新有变化的字段。

2.2.1 更新条件
只更新有变化的字段， 空值不更新。

2.2.1 动态 SQL
接口方法

    /**
     * 更新非空属性
     */
    int updateByPrimaryKeySelective(Student record);

对应的 SQL

  <update id="updateByPrimaryKeySelective" parameterType="com.homejim.mybatis.entity.Student">
    update student
    <set>
      <if test="name != null">
        `name` = #{name,jdbcType=VARCHAR},
      </if>
      <if test="phone != null">
        phone = #{phone,jdbcType=VARCHAR},
      </if>
      <if test="email != null">
        email = #{email,jdbcType=VARCHAR},
      </if>
      <if test="sex != null">
        sex = #{sex,jdbcType=TINYINT},
      </if>
      <if test="locked != null">
        locked = #{locked,jdbcType=TINYINT},
      </if>
      <if test="gmtCreated != null">
        gmt_created = #{gmtCreated,jdbcType=TIMESTAMP},
      </if>
      <if test="gmtModified != null">
        gmt_modified = #{gmtModified,jdbcType=TIMESTAMP},
      </if>
    </set>
    where student_id = #{studentId,jdbcType=INTEGER}

2.2.3 测试
    @Test
    public void updateByStudentSelective() {
        SqlSession sqlSession = null;
        sqlSession = sqlSessionFactory.openSession();
        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);

        Student student = new Student();
        student.setStudentId(1);
        student.setName("明明");
        student.setPhone("13838438888");
        System.out.println(studentMapper.updateByPrimaryKeySelective(student));

        sqlSession.commit();
        sqlSession.close();
    }

结果如下



2.3 在 INSERT 动态插入中使用 if 标签
我们插入数据库中的一条记录， 不是每一个字段都有值的， 而是动态变化的。 在这时候使用 if 标签， 可帮我们解决这个问题。

2.3.1 插入条件
只有非空属性才插入。

2.3.2 动态SQL
接口方法

    /**
     * 非空字段才进行插入
     */
    int insertSelective(Student record);

对应的SQL

<insert id="insertSelective" parameterType="com.homejim.mybatis.entity.Student">
    insert into student
    <trim prefix="(" suffix=")" suffixOverrides=",">
      <if test="studentId != null">
        student_id,
      </if>
      <if test="name != null">
        `name`,
      </if>
      <if test="phone != null">
        phone,
      </if>
      <if test="email != null">
        email,
      </if>
      <if test="sex != null">
        sex,
      </if>
      <if test="locked != null">
        locked,
      </if>
      <if test="gmtCreated != null">
        gmt_created,
      </if>
      <if test="gmtModified != null">
        gmt_modified,
      </if>
    </trim>
    <trim prefix="values (" suffix=")" suffixOverrides=",">
      <if test="studentId != null">
        #{studentId,jdbcType=INTEGER},
      </if>
      <if test="name != null">
        #{name,jdbcType=VARCHAR},
      </if>
      <if test="phone != null">
        #{phone,jdbcType=VARCHAR},
      </if>
      <if test="email != null">
        #{email,jdbcType=VARCHAR},
      </if>
      <if test="sex != null">
        #{sex,jdbcType=TINYINT},
      </if>
      <if test="locked != null">
        #{locked,jdbcType=TINYINT},
      </if>
      <if test="gmtCreated != null">
        #{gmtCreated,jdbcType=TIMESTAMP},
      </if>
      <if test="gmtModified != null">
        #{gmtModified,jdbcType=TIMESTAMP},
      </if>
    </trim>
  </insert>

这个 SQL 大家应该很熟悉， 毕竟是自动生成的。

2.3.3 测试
    @Test
    public void insertByStudentSelective() {
        SqlSession sqlSession = null;
        sqlSession = sqlSessionFactory.openSession();
        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);

        Student student = new Student();
        student.setName("小飞机");
        student.setPhone("13838438899");
        student.setEmail("xiaofeiji@qq.com");
        student.setLocked((byte) 0);

        System.out.println(studentMapper.insertSelective(student));

        sqlSession.commit();
        sqlSession.close();
    }

对应的结果



SQL 中， 只有非空的字段才进行了插入。

3 choose 标签
choose when otherwise 标签可以帮我们实现 if else 的逻辑。一个 choose 标签至少有一个 when, 最多一个otherwise。

下面是一个查询的例子。

3.1 查询条件
假设 name 具有唯一性， 查询一个学生

当 studen_id 有值时， 使用 studen_id 进行查询；

当 studen_id 没有值时， 使用 name 进行查询；

否则返回空

3.2 动态SQL
接口方法

    /**
     * - 当 studen_id 有值时， 使用 studen_id 进行查询；
     * - 当 studen_id 没有值时， 使用 name 进行查询；
     * - 否则返回空
     */
    Student selectByIdOrName(Student record);

对应的SQL

  <select id="selectByIdOrName" resultMap="BaseResultMap" parameterType="com.homejim.mybatis.entity.Student">
    select
    <include refid="Base_Column_List" />
    from student
    where 1=1
    <choose>
      <when test="studentId != null">
        and student_id=#{studentId}
      </when>
      <when test="name != null and name != ''">
        and name=#{name}
      </when>
      <otherwise>
        and 1=2
      </otherwise>
    </choose>
  </select>

3.3 测试
 @Test
    public void selectByIdOrName() {
        SqlSession sqlSession = null;
        sqlSession = sqlSessionFactory.openSession();
        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);

        Student student = new Student();
        student.setName("小飞机");
        student.setStudentId(1);

        Student studentById = studentMapper.selectByIdOrName(student);
        System.out.println("有 ID 则根据 ID 获取");
        System.out.println(ToStringBuilder.reflectionToString(studentById, ToStringStyle.MULTI_LINE_STYLE));

        student.setStudentId(null);
        Student studentByName = studentMapper.selectByIdOrName(student);
        System.out.println("没有 ID 则根据 name 获取");
        System.out.println(ToStringBuilder.reflectionToString(studentByName, ToStringStyle.MULTI_LINE_STYLE));

        student.setName(null);
        Student studentNull = studentMapper.selectByIdOrName(student);
        System.out.println("没有 ID 和 name, 返回 null");
        Assert.assertNull(studentNull);

        sqlSession.commit();
        sqlSession.close();
    }

有 ID 则根据 ID 获取， 结果



没有 ID 则根据 name 获取



没有 ID 和 name, 返回 null



4 trim(set、where)
这三个其实解决的是类似的问题。 如我们在写前面的[在 WHERE 条件中使用 if 标签] SQL 的时候， where 1=1 这个条件我们是不希望存在的。

4.1 where
4.1.1 查询条件
根据输入的学生信息进行条件检索。

当只输入用户名时， 使用用户名进行模糊检索；

当只输入性别时， 使用性别进行完全匹配

当用户名和性别都存在时， 用这两个条件进行查询匹配查询

不使用 where 1=1。

4.1.2 动态 SQL
很显然， 我们要解决这几个问题

当条件都不满足时： 此时 SQL 中应该要不能有 where ， 否则导致出错
当 if 有条件满足时： SQL 中需要有 where， 且第一个成立的 if 标签下的 and | or 等要去掉
这时候， 我们可以使用 where 标签。

接口方法

    /**
     * 根据输入的学生信息进行条件检索
     * 1. 当只输入用户名时， 使用用户名进行模糊检索；
     * 2. 当只输入邮箱时， 使用性别进行完全匹配
     * 3. 当用户名和性别都存在时， 用这两个条件进行查询匹配的用
     */
    List<Student> selectByStudentSelectiveWhereTag(Student student);

对应的 SQL

  <select id="selectByStudentSelectiveWhereTag" resultMap="BaseResultMap" parameterType="com.homejim.mybatis.entity.Student">
    select
    <include refid="Base_Column_List" />
    from student
   <where>
    <if test="name != null and name !=''">
      and name like concat('%', #{name}, '%')
    </if>
    <if test="sex != null">
      and sex=#{sex}
    </if>
   </where>
  </select>

4.1.3 测试
    @Test
    public void selectByStudentWhereTag() {
        SqlSession sqlSession = null;
        sqlSession = sqlSessionFactory.openSession();
        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);

        Student search = new Student();
        search.setName("明");

        System.out.println("只有名字时的查询");
        List<Student> studentsByName = studentMapper.selectByStudentSelectiveWhereTag(search);
        for (int i = 0; i < studentsByName.size(); i++) {
            System.out.println(ToStringBuilder.reflectionToString(studentsByName.get(i), ToStringStyle.MULTI_LINE_STYLE));
        }

        search.setSex((byte) 1);
        System.out.println("姓名和性别同时存在的查询");
        List<Student> studentsBySex = studentMapper.selectByStudentSelectiveWhereTag(search);
        for (int i = 0; i < studentsBySex.size(); i++) {
            System.out.println(ToStringBuilder.reflectionToString(studentsBySex.get(i), ToStringStyle.MULTI_LINE_STYLE));
        }

        System.out.println("姓名和性别都不存在时查询");
        search.setName(null);
        search.setSex(null);
        List<Student> studentsByNameAndSex = studentMapper.selectByStudentSelectiveWhereTag(search);
        for (int i = 0; i < studentsByNameAndSex.size(); i++) {
            System.out.println(ToStringBuilder.reflectionToString(studentsByNameAndSex.get(i), ToStringStyle.MULTI_LINE_STYLE));
        }

        sqlSession.commit();
        sqlSession.close();
    }

只有名字时的查询, 有 where



姓名和性别同时存在的查询， 有 where



姓名和性别都不存在时查询, 此时， where 不会再出现了。



4.2 set
set 标签也类似， 在 [2.2 在 UPDATE 更新列中使用 if 标签] 中， 如果我们的方法 updateByPrimaryKeySelective 没有使用

4.3 trim
set 和 where 其实都是 trim 标签的一种类型， 该两种功能都可以使用 trim 标签进行实现。

4.3.1 trim 来表示 where
如以上的 where 标签， 我们也可以写成

<trim prefix="where" prefixOverrides="AND |OR">
</trim>

表示当 trim 中含有内容时， 添加 where， 且第一个为 and 或 or 时， 会将其去掉。 而如果没有内容， 则不添加 where。

4.3.2 trim 来表示 set
相应的， set 标签可以如下表示

<trim prefix="SET" suffixOverrides=",">
</trim>

表示当 trim 中含有内容时， 添加 set， 且最后的内容为 , 时， 会将其去掉。 而没有内容， 不添加 set

4.3.3 trim 的几个属性
prefix: 当 trim 元素包含有内容时， 增加 prefix 所指定的前缀

prefixOverrides: 当 trim 元素包含有内容时， 去除 prefixOverrides 指定的 前缀

suffix: 当 trim 元素包含有内容时， 增加 suffix 所指定的后缀

suffixOverrides： 当 trim 元素包含有内容时， 去除 suffixOverrides 指定的后缀

5 foreach 标签
foreach 标签可以对数组， Map 或实现 Iterable 接口。

foreach 中有以下几个属性：

collection: 必填， 集合/数组/Map的名称.

item: 变量名。 即从迭代的对象中取出的每一个值

index: 索引的属性名。 当迭代的对象为 Map 时， 该值为 Map 中的 Key.

open: 循环开头的字符串

close: 循环结束的字符串

separator: 每次循环的分隔符

其他的比较好理解， collection 中的值应该怎么设定呢？

跟接口方法中的参数相关。

1. 只有一个数组参数或集合参数
默认情况： 集合collection=list， 数组是collection=array

推荐： 使用 @Param 来指定参数的名称， 如我们在参数前@Param("ids")， 则就填写 collection=ids

2. 多参数
多参数请使用 @Param 来指定， 否则SQL中会很不方便

3. 参数是Map
指定为 Map 中的对应的 Key 即可。 其实上面的 @Param 最后也是转化为 Map 的。

4. 参数是对象
使用属性.属性即可。

5.1 在 where 中使用 foreach
在 where条件中使用， 如按id集合查询， 按id集合删除等。

5.1.1 查询条件
我们希望查询用户 id 集合中的所有用户信息。

5.1.2 动态 SQL
函数接口

    /**
     * 获取 id 集合中的用户信息
     * @param ids
     * @return
     */
    List<Student> selectByStudentIdList(List<Integer> ids);

对应 SQL

  <select id="selectByStudentIdList" resultMap="BaseResultMap">
    select
    <include refid="Base_Column_List" />
    from student
    where student_id in
    <foreach collection="list" item="id" open="(" close=")" separator="," index="i">
      #{id}
    </foreach>
  </select>

5.1.3 测试
    @Test
    public void selectByStudentIdList() {
        SqlSession sqlSession = null;
        sqlSession = sqlSessionFactory.openSession();
        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);

        List<Integer> ids = new LinkedList<>();
        ids.add(1);
        ids.add(3);

        List<Student> students = studentMapper.selectByStudentIdList(ids);
        for (int i = 0; i < students.size(); i++) {
            System.out.println(ToStringBuilder.reflectionToString(students.get(i), ToStringStyle.MULTI_LINE_STYLE));
        }

        sqlSession.commit();
        sqlSession.close();
    }

结果



5.2 foreach 实现批量插入
可以通过foreach来实现批量插入。

5.2.1 动态SQL
接口方法

    /**
     * 批量插入学生
     */
    int insertList(List<Student> students);

对应的SQL

  <insert id="insertList">
    insert into student(name, phone, email, sex, locked)
    values
    <foreach collection="list" item="student" separator=",">
      (
      #{student.name}, #{student.phone},#{student.email},
      #{student.sex},#{student.locked}
      )
    </foreach>
  </insert>

5.2.2 测试
    @Test
    public void insertList() {
        SqlSession sqlSession = null;
        sqlSession = sqlSessionFactory.openSession();
        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);

        List<Student> students = new LinkedList<>();
        Student stu1 = new Student();
        stu1.setName("批量01");
        stu1.setPhone("13888888881");
        stu1.setLocked((byte) 0);
        stu1.setEmail("13888888881@138.com");
        stu1.setSex((byte) 1);
        students.add(stu1);

        Student stu2 = new Student();
        stu2.setName("批量02");
        stu2.setPhone("13888888882");
        stu2.setLocked((byte) 0);
        stu2.setEmail("13888888882@138.com");
        stu2.setSex((byte) 0);
        students.add(stu2);

        System.out.println(studentMapper.insertList(students));
        sqlSession.commit();
        sqlSession.close();
    }

结果



6 bind 标签
bind 标签是通过 OGNL 表达式去定义一个上下文的变量， 这样方便我们使用。

如在 selectByStudentSelective 方法中， 有如下

<if test="name != null and name !=''">
      and name like concat('%', #{name}, '%')
    </if>

在 MySQL 中， 该函数支持多参数， 但在 Oracle 中只支持两个参数。 那么我们可以使用 bind 来让该 SQL 达到支持两个数据库的作用

<if test="name != null and name !=''">
     <bind name="nameLike" value="'%'+name+'%'"/>
     and name like #{nameLike}
</if>

更改后的查询结果如下


https://github.com/homejim/mybatis-examples


cnblogs.com/homejim/p/9909657.html


