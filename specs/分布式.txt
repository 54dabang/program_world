分布式缓存

第 1部分 基本功能
第　1章 基于HTTP的内存缓存服务　3
1．1　缓存服务的接口　3
1．1．1　REST接口　3
1．1．2　缓存Set流程　5
1．1．3　缓存Get流程　6
1．1．4　缓存Del流程　7
1．2　Go语言实现　8
1．2．1　main包的实现　8
1．2．2　cache包的实现　9
1．2．3　HTTP包的实现　14
1．3　功能演示　19
1．4　与Redis比较　21
1．4．1　Redis介绍　21
1．4．2　redis-benchmark介绍　23
1．4．3　cache-benchmark介绍　24
1．4．4　性能对比　26
1．5　小结　30
第　2章 基于TCP的内存缓存服务　32
2．1　基于TCP的缓存协议规范　33
2．1．1　协议范式　33
2．1．2　缓存Set流程　35
2．1．3　缓存Get流程　36
2．1．4　缓存Del流程　36
2．2　Go语言实现　37
2．2．1　main函数的变化　37
2．2．2　TCP包的实现　38
2．2．3　客户端的实现　44
2．3　功能演示　45
2．4　性能测试　47
2．5　小结　48
第3章　数据持久化　50
3．1　RocksDB简介　50
3．2　RocksDB性能测试　51
3．2．1　基本读写性能　52
3．2．2　大容量测试　52
3．3　用cgo调用C++库函数　55
3．4　Go语言实现　58
3．4．1　main函数的实现　58
3．4．2　cache包的实现　59
3．5　功能演示　65
3．6　性能测试　67
3．7　小结　69
第　2部分 性能相关
第4章　用pipelining加速性能　73
4．1　pipelining原理　73
4．2　redis pipelining性能对比　75
4．3　Go语言实现　77
4．3．1　main包的实现　77
4．3．2　cacheClient包的实现　86
4．4　性能测试　97
4．5　小结　99
第5章　批量写入　101
5．1　批量写入能够提升写入性能的原理　101
5．2　RocksDB批量写入性能测试　102
5．3　Go语言实现　103
5．4　性能测试　108
5．5　小结　112
第6章　异步操作　113
6．1　异步操作能够提升读取性能的原理　114
6．2　Go语言实现　117
6．3　性能测试　122
6．4　小结　127
第3部分　服务集群
第7章　分布式缓存　131
7．1　为什么我们需要集群服务　131
7．2　负载均衡和一致性散列　133
7．3　获取节点列表的接口　140
7．4　Go语言实现　140
7．4．1　main函数的实现　140
7．4．2　cluster包的实现　141
7．4．3　HTTP包的实现　145
7．4．4　TCP包的实现　147
7．5　功能演示　149
7．6　小结　152
第8章　节点再平衡　154
8．1　节点再平衡的技术细节　154
8．2　节点再平衡的接口　155
8．3　Go语言实现　155
8．3．1　HTTP包的实现　155
8．3．2　cache包的实现　157
8．4　功能演示　162
8．5　小结　164

第9章　缓存生存时间　166
9．1　缓存生存时间的作用　166
9．2　Go语言实现　167
9．2．1　main函数的实现　167
9．2．2　cache包的实现　168
9．3　功能演示　172

-------------------------
第1章　缓存为王1

1.1　什么是缓存？1

1.2　为什么使用缓存？2

1.2.1　从用户体验说起3

1.2.2　关于系统的性能3

1.3　从网站的架构发展看缓存4

1.4　客户端缓存5

1.4.1　页面缓存6

1.4.2　浏览器缓存7

1.4.3　APP上的缓存8

1.5　网络中的缓存11

1.5.1　Web代理缓存11

1.5.2　边缘缓存12

1.6　服务端缓存14

1.6.1　数据库缓存14

1.6.2　平台级缓存16

1.6.3　应用级缓存18

第2章　分布式系统理论24

2.1　分布式系统概论24

2.2　分布式系统概念26

2.2.1　进程与线程26

2.2.2　并发26

2.2.3　锁26

2.2.4　并行27

2.2.5　集群27

2.2.6　状态特性28

2.2.7　系统重发与幂等性28

2.2.8　硬件异常30

2.3　分布式系统理论31

2.3.1　CAP理论32

2.3.2　CAP理论澄清34

2.3.3　Paxos35

2.3.4　2PC38

2.3.5　3PC39

2.3.6　Raft40

2.3.7　Lease机制41

2.3.8　解决“脑裂”问题43

2.3.9　Quorum NWR44

2.3.10　MVCC45

2.3.11　Gossip46

2.4　分布式系统设计策略49

2.4.1　心跳检测50

2.4.2　高可用设计50

2.4.3　容错性52

2.4.4　负载均衡53

2.5　分布式系统设计实践54

2.5.1　全局ID生成54

2.5.2　哈希取模56

2.5.3　一致性哈希57

2.5.4　路由表58

2.5.5　数据拆分58

第3章　动手写缓存60

3.1　缓存定义的规范60

3.1.1　新规范的主要内容及特性60

3.1.2　新规范的API介绍61

3.2　缓存框架的实现62

3.2.1　前期准备63

3.2.2　缓存的架构介绍63

3.2.3　设计思路以及知识点详解64

3.3　缓存框架的使用示例74

第4章 　Ehcache与Guava Cache76

4.1　Ehcache的主要特性76

4.2　Ehcache使用介绍77

4.2.1　Ehcache架构图77

4.2.2　缓存数据过期策略78

4.2.3　Ehcache缓存的基本用法81

4.2.4　在Spring中使用Ehcache83

4.3　Ehcache集群介绍85

4.3.1　集群的方式86

4.3.2　如何配置集群88

4.4　 Ehcache的适用场景89

4.5　Guava Cache的使用92

4.5.1　Guava Cache的适用场景92

4.5.2　Guava Cache的创建方式93

4.5.3　缓存数据删除95

4.5.4　并发场景下的使用95

4.6　本章小结96

第5章　从Memcached开始了解集中式缓存97

5.1　Memcached基本知识98

5.1.1　Memcached的操作命令98

5.1.2　Memcached使用场景100

5.1.3　Memcached特征100

5.1.4　Memcached的一些问题101

5.2　Memcached内存存储102

5.2.1　Slab Allocation机制102

5.2.2　使用 Growth Factor进行调优104

5.2.3　Item105

5.3　典型问题解析106

5.3.1　过期机制106

5.3.2　哈希算法107

5.3.3　热点问题108

5.3.4　缓存与数据库的更新问题108

5.3.5　别把缓存当存储109

5.3.6　命名空间110

5.3.7　CAS110

5.4　Memcached客户端分析110

5.4.1　Memcached的Client111

5.4.2　Spymemcached设计思想解析111

5.5　Memcached周边工具发展117

第6章　Memcached 周边技术119

6.1　Twemcache119

6.1.1　Twemcache 的设计原理120

6.1.2　Twemcache的安装及命令行详解122

6.1.3　基于Java的Twemcache用法125

6.2　Twemproxy126

6.2.1　Twemproxy的常用部署模式127

6.2.2　Twemproxy的可扩展性129

6.2.3　Twemproxy源代码简析131

6.3　Mcrouter137

6.3.1　Mcrouter路由算法138

6.3.2　典型的使用场景139

6.3.3　Mcrouter的可扩展性142

6.3.4　源码简要解析144

第7章　Redis探秘148

7.1　数据结构148

7.1.1　value对象的通用结构149

7.1.2　String149

7.1.3　List152

7.1.4　Map155

7.1.5　Set157

7.1.6　Sorted-Set159

7.2　客户端与服务器的交互160

7.2.1　客户端/服务器协议161

7.2.2　请求/响应模式163

7.2.3　事务模式164

7.2.4　脚本模式168

7.2.5　发布/订阅模式169

7.3　单机处理逻辑171

7.3.1　多路复用171

7.3.2　定时任务处理173

7.4　持久化174

7.4.1　基于全量模式的持久化174

7.4.2　基于增量模式的持久化176

7.4.3　基于增量模式持久化的优化178

第8章　分布式Redis180

8.1　水平拆分（sharding）181

8.1.1　数据分布181

8.1.2　请求路由182

8.2　主备复制（replication）182

8.2.1　主备复制流程183

8.2.2　断点续传183

8.3　故障转移（failover）184

8.3.1　sentinel间的相互感知185

8.3.2　master的故障发现186

8.3.3　failover决策186

8.4　Redis Cluster187

8.4.1　拓扑结构187

8.4.2　配置的一致性188

8.4.3　sharding190

8.4.4　failover193

8.4.5　可用性和性能196

第9章　Tair探秘198

9.1　Tair总体架构198

9.2　Config Server简介199

9.3　Data Server简介201

9.4　Tair高可用和负载均衡204

9.4.1　对照表204

9.4.2　数据迁移219

9.5　存储引擎220

9.6　Tair的API222

9.6.1　key/value相关API223

9.6.2　prefix相关的API226

第10章　EVCache探秘229

10.1　EVCache项目介绍230

10.1.1　EVCache的由来231

10.1.2　EVCache的发展232

10.1.3　EVCache的演进234

10.2　EVCache 的使用场景238

10.2.1　典型用例238

10.2.2　典型部署239

10.3　EVCache的性能240

10.3.1　EVCache集群的性能240

10.3.2　全局化复制时的性能问题242

10.3.3　Moneta项目中的组件性能243

10.4　EVCache 的高可用性244

10.4.1　AWS的多可用区244

10.4.2　EVCache对AWS高可用性的增强245

10.5　源码与示例245

10.5.1　源码浅析245

10.5.2　EVCache 示例253

第11章　Aerospike原理及广告业务应用259

11.1　Aerospike架构259

11.2　Aerospike具体实现261

11.2.1　Aerospike集群管理261

11.2.2　数据分布263

11.3　Aerospike集群配置和部署265

11.3.1　搭建集群的方式与配置266

11.3.2　部署集群267

11.4　Aerospike与Redis的对比271

11.5　Aeropsike在广告行业的具体应用272

11.5.1　Aerospike在个性化推荐广告中的应用273

11.5.2　Aerospike在实时竞价广告中的应用274

第12章　社交场景架构进化：从数据库到缓存283

12.1　社交业务示例283

12.1.1　业务模型283

12.1.2　业务场景284

12.1.3　业务特点285

12.2　关系（relation）的存储286

12.2.1　基于DB的最简方案286

12.2.2　DB的sharding方案288

12.2.3　引入缓存290

12.2.4　缓存的优化方案292

12.3　帖子（post）的存储293

12.3.1　基于DB的方案294

12.3.2　引入服务端缓存296

12.3.3　本地缓存297

12.4　时间线（timeline）的存储297

12.4.1　基于DB的方案—push模式298

12.4.2　基于DB的方案—pull模式300

12.4.3　增量查询引入服务端缓存302

第13章　缓存在社交网络Feed系统中的架构实践304

13.1　Feed系统架构304

13.2　Feed缓存模型307

13.3　Feed缓存架构的设计309

13.3.1　简单数据类型的缓存设计310

13.3.2　集合类数据的缓存设计312

13.3.3　其他类型数据的缓存设计314

13.4　Feed缓存的扩展 315

13.4.1　Redis的扩展315

13.4.2　计数器的扩展316

13.4.3　存在性判断的扩展318

13.5　Feed缓存的服务化319

第14章　典型电商应用与缓存324

14.1　电商类应用的挑战及特点324

14.2　应用数据静态化架构高性能单页Web应用325

14.2.1　整体架构326

14.2.2　CMS系统326

14.2.3　前端展示系统328

14.2.4　控制系统328

14.3　应用多级缓存模式支撑海量读服务329

14.3.1　多级缓存介绍329

14.3.2　如何缓存数据331

14.3.3　分布式缓存与应用负载均衡332

14.3.4　热点数据与更新缓存334

14.3.5　更新缓存与原子性336

14.3.6　缓存崩溃与快速修复336

14.4　构建需求响应式亿级商品详情页337

14.4.1　商品详情页前端结构338

14.4.2　单品页技术架构发展338

14.4.3　详情页架构设计原则343

14.4.4　遇到的一些问题349

第15章　同程凤凰缓存系统基于Redis的设计与实践357

15.1　同程凤凰缓存系统要解决什么问题357

15.1.1　Redis用法的凌乱358

15.1.2　从实际案例再看Redis的使用360

15.1.3　如何改变Redis用不好的误区362

15.1.4　凤凰缓存系统对Redis系统化改造364

15.2　用好Redis先运维好它366

15.2.1　传统的Redis运维方式366

15.2.2　Redis的Docker化部署368

15.2.3　凤凰缓存系统对Redis的监控369

15.2.4　凤凰缓存系统对Redis的集群分片优化370

15.2.5　客户端在运维中的作用371

15.2.6　凤凰缓存系统在Redis运维上的工具372

15.3　凤凰缓存系统的使用效果373

第16章　新的旅程374

16.1　更好的引入缓存技术374

16.1.1　缓存引入前的考量374

16.1.2　缓存组件的选择375

16.1.3　缓存架构的设计376

16.1.4　缓存系统的监控及演进377

16.2　缓存分类总结377

16.3　缓存知识结构更多Tips378

16.3.1　缓存使用模式379

16.3.2　缓存协议379

16.3.3　缓存连接池380

16.3.4　几个关注点383

16.3.5　管理缓存387

16.3.6　缓存可用性390

16.3.7　数据一致性392

16.3.8　热点数据处理393

16.3.9　注意事项Tips396

========================

第1章　分布式系统的特征
1.1　简介
1.2　分布式系统的例子
1.2.1　Web搜索
1.2.2　大型多人在线游戏
1.2.3　金融交易
1.3　分布式系统的趋势
1.3.1　泛在联网和现代互联网
1.3.2　移动和无处不在计算
1.3.3　分布式多媒体系统
1.3.4　把分布式计算作为一个公共设施
1.4　关注资源共享
1.5　挑战
1.5.1　异构性
1.5.2　开放性
1.5.3　安全性
1.5.4　可伸缩性
1.5.5　故障处理
1.5.6　并发性
1.5.7　透明性
1.5.8　服务质量
1.6　实例研究：万维网
1.7　小结
练习
第2章　系统模型
2.1　简介
2.2　物理模型
2.3　体系结构模型
2.3.1　体系结构元素
2.3.2　体系结构模式
2.3.3　相关的中间件解决方案
2.4　基础模型
2.4.1　交互模型
2.4.2　故障模型
2.4.3　安全模型
2.5　小结
练习
第3章　网络和网际互连
3.1　简介
3.2　网络类型
3.3　网络原理
3.3.1　数据包的传输
3.3.2　数据流
3.3.3　交换模式
3.3.4　协议
3.3.5　路由
3.3.6　拥塞控制
3.3.7　网际互连
3.4　互联网协议
3.4.1　IP寻址
3.4.2　IP协议
3.4.3　IP路由
3.4.4　IPv
3.4.5　移动IP
3.4.6　TCP和UDP
3.4.7　域名
3.4.8　防火墙
3.5　实例研究：以太网、WiFi、蓝牙
3.5.1　以太网
3.5.2　IEEE 802.11无线LAN
3.5.3　IEEE 802.15.1蓝牙无线PAN
3.6　小结
练习
第4章　进程间通信
4.1　简介
4.2　互联网协议的API
4.2.1　进程间通信的特征
4.2.2　套接字
4.2.3　UDP数据报通信
4.2.4　TCP流通信
4.3　外部数据表示和编码
4.3.1　CORBA的公共数据表示
4.3.2　Java对象序列化
4.3.3　可扩展标记语言
4.3.4　远程对象引用
4.4　组播通信
4.4.1　IP组播--组播通信的实现
4.4.2　组播的可靠性和排序
4.5　网络虚拟化：覆盖网络
4.5.1　覆盖网络
4.5.2　Skype：一个覆盖网络的例子
4.6　实例研究：MPI
4.7　小结
练习
第5章　远程调用
5.1　简介
5.2　请求-应答协议
5.3　远程过程调用
5.3.1　RPC的设计问题
5.3.2　RPC的实现
5.3.3　实例研究：Sun RPC
5.4　远程方法调用
5.4.1　RMI的设计问题
5.4.2　RMI的实现
5.4.3　分布式无用单元收集
5.5　实例研究：Java RMI
5.5.1　创建客户和服务器程序
5.5.2　Java RMI的设计和实现
5.6　小结
练习
第6章　间接通信
6.1　简介
6.2　组通信
6.2.1　编程模型
6.2.2　实现问题
6.2.3　实例研究：JGroups工具箱
6.3　发布-订阅系统
6.3.1　编程模型
6.3.2　实现问题
6.3.3　发布-订阅系统的例子
6.4　消息队列
6.4.1　编程模型
6.4.2　实现问题
6.4.3　实例研究：Java消息服务
6.5　共享内存的方式
6.5.1　分布式共享内存
6.5.2　元组空间通信
6.6　小结
练习
第7章　操作系统支持
7.1　简介
7.2　操作系统层
7.3　保护
7.4　进程和线程
7.4.1　地址空间
7.4.2　新进程的生成
7.4.3　线程
7.5　通信和调用
7.5.1　调用性能
7.5.2　异步操作
7.6　操作系统的体系结构
7.7　操作系统层的虚拟化
7.7.1　系统虚拟化
7.7.2　实例研究：系统虚拟化的Xen方法
7.8　小结
练习
第8章　分布式对象和组件
8.1　简介
8.2　分布式对象
8.3　实例研究：CORBA
8.3.1　CORBA RMI
8.3.2　CORBA的体系结构
8.3.3　CORBA远程对象引用
8.3.4　CORBA服务
8.3.5　CORBA客户和服务器实例
8.4　从对象到组件
8.5　实例研究：企业JavaBeans和Fractal
8.5.1　企业JavaBeans
8.5.2　Fractal
8.6　小结
练习
第9章　Web服务
9.1　简介
9.2　Web服务
9.2.1　SOAP
9.2.2　Web服务与分布式对象模型的比较
9.2.3　在Java中使用SOAP
9.2.4　Web服务和CORBA的比较
9.3　Web服务的服务描述和接口定义语言
9.4　Web服务使用的目录服务
9.5　XML安全性
9.6　Web服务的协作
9.7　Web服务的应用
9.7.1　面向服务的体系结构
9.7.2　网格
9.7.3　云计算
9.8　小结
练习
第10章　对等系统
10.1　简介
10.2　Napster及其遗留系统
10.3　对等中间件
10.4　路由覆盖
10.5　路由覆盖实例研究：Pastry和Tapestry
10.5.1　Pastry
10.5.2　Tapestry
10.5.3　从结构化对等方法到非结构化对等方法
10.6　应用实例研究：Squirrel、OceanStore和Ivy
10.6.1　Squirrel Web缓存
10.6.2　OceanStore文件存储
10.6.3　Ivy文件系统
10.7　小结
练习
第11章　安全性
11.1　简介
11.1.1　威胁和攻击
11.1.2　保护电子事务
11.1.3　设计安全系统
11.2　安全技术概述
11.2.1　密码学
11.2.2　密码学的应用
11.2.3　证书
11.2.4　访问控制
11.2.5　凭证
11.2.6　防火墙
11.3　密码算法
11.3.1　密钥（对称）算法
11.3.2　公钥（不对称）算法
11.3.3　混合密码协议
11.4　数字签名
11.4.1　公钥数字签名
11.4.2　密钥数字签名--MAC
11.4.3　安全摘要函数
11.4.4　证书标准和证书权威机构
11.5　密码实用学
11.5.1　密码算法的性能
11.5.2　密码学的应用和政治障碍
11.6　实例研究：Needham-Schroeder、Kerberos、TLS和802.11 WiFi
11.6.1　Needham-Schroeder认证协议
11.6.2　Kerberos
11.6.3　使用安全套接字确保电子交易安全
11.6.4　IEEE 802.11 WiFi安全设计中最初的缺陷
11.7　小结
练习
第12章　分布式文件系统
12.1　简介
12.1.1　文件系统的特点
12.1.2　分布式文件系统的需求
12.1.3　实例研究
12.2　文件服务体系结构
12.3　实例研究：SUN网络文件系统
12.4　实例研究：Andrew文件系统
12.4.1　实现
12.4.2　缓存的一致性
12.4.3　其他方面
12.5　最新进展
12.6　小结
练习
第13章　名字服务
13.1　简介
13.2　名字服务和域名系统
13.2.1　名字空间
13.2.2　名字解析
13.2.3　域名系统
13.3　目录服务
13.4　实例研究：全局名字服务
13.5　实例研究：X.500目录服务
13.6　小结
练习
第14章　时间和全局状态
14.1　简介
14.2　时钟、事件和进程状态
14.3　同步物理时钟
14.3.1　同步系统中的同步
14.3.2　同步时钟的Cristian方法
14.3.3　Berkeley算法
14.3.4　网络时间协议
14.4　逻辑时间和逻辑时钟
14.5　全局状态
14.5.1　全局状态和一致割集
14.5.2　全局状态谓词、稳定性、安全性和活性
14.5.3　Chandy和Lamport的“快照”算法
14.6　分布式调试
14.6.1　收集状态
14.6.2　观察一致的全局状态
14.6.3　判定可能的
14.6.4　判定明确的
14.6.5　在同步系统中判定可能的和明确的
14.7　小结
练习
第15章　协调和协定
15.1　简介
15.2　分布式互斥
15.3　选举
15.4　组通信中的协调与协定
15.4.1　基本组播
15.4.2　可靠组播
15.4.3　有序组播
15.5　共识和相关问题
15.5.1　系统模型和问题定义
15.5.2　同步系统中的共识问题
15.5.3　同步系统中的拜占庭将军问题
15.5.4　异步系统的不可能性
15.6　小结
练习
第16章　事务和并发控制
16.1　简介
16.1.1　简单的同步机制（无事务）
16.1.2　事务的故障模型
16.2　事务
16.2.1　并发控制
16.2.2　事务放弃时的恢复
16.3　嵌套事务
16.4　锁
16.4.1　死锁
16.4.2　在加锁机制中增加并发度
16.5　乐观并发控制
16.6　时间戳排序
16.7　并发控制方法的比较
16.8　小结
练习
第17章　分布式事务
17.1　简介
17.2　平面分布式事务和嵌套分布式事务
17.3　原子提交协议
17.3.1　两阶段提交协议
17.3.2　嵌套事务的两阶段提交协议
17.4　分布式事务的并发控制
17.4.1　加锁
17.4.2　时间戳并发控制
17.4.3　乐观并发控制
17.5　分布式死锁
17.6　事务恢复
17.6.1　日志
17.6.2　影子版本
17.6.3　为何恢复文件需要事务状态和意图列表
17.6.4　两阶段提交协议的恢复
17.7　小结
练习
第18章　复制
18.1　简介
18.2　系统模型和组通信的作用
18.2.1　系统模型
18.2.2　组通信的作用
18.3　容错服务
18.3.1　被动（主备份）复制
18.3.2　主动复制
18.4　高可用服务的实例研究：闲聊体系结构、Bayou和Coda
18.4.1　闲聊体系结构
18.4.2　Bayou系统和操作变换方法
18.4.3　Coda文件系统
18.5　复制数据上的事务
18.5.1　复制事务的体系结构
18.5.2　可用拷贝复制
18.5.3　网络分区
18.5.4　带验证的可用拷贝
18.5.5　法定数共识方法
18.5.6　虚拟分区算法
18.6　小结
练习
第19章　移动和无处不在计算
19.1　简介
19.2　关联
19.2.1　发现服务
19.2.2　物理关联
19.2.3　小结和前景
19.3　互操作
19.3.1　易变系统的面向数据编程
19.3.2　间接关联和软状态
19.3.3　小结和前景
19.4　感知和上下文敏感
19.4.1　传感器
19.4.2　感知体系结构
19.4.3　位置感知
19.4.4　小结和前景
19.5　安全性和私密性
19.5.1　背景
19.5.2　一些解决办法
19.5.3　小结和前景
19.6　自适应
19.6.1　内容的上下文敏感自适应
19.6.2　适应变化的系统资源
19.6.3　小结和前景
19.7　实例研究：Cooltown
19.7.1　Web存在
19.7.2　物理超链接
19.7.3　互操作和eSquirt协议
19.7.4　小结和前景
19.8　小结
练习
第20章　分布式多媒体系统
20.1　简介
20.2　多媒体数据的特征
20.3　服务质量管理
20.3.1　服务质量协商
20.3.2　许可控制
20.4　资源管理
20.5　流自适应
20.5.1　调整
20.5.2　过滤
20.6　实例研究：Tiger视频文件服务器、BitTorrent和端系统多播
20.6.1　Tiger视频文件服务器
20.6.2　BitTorrent
20.6.3　端系统多播
20.7　小结
练习
第21章　分布式系统设计：Google实例研究
21.1　简介
21.2　实例研究简介：Google
21.3　总体结构和设计理念
21.3.1　物理模型
21.3.2　总的系统体系结构
21.4　底层通信范型
21.4.1　远程调用
21.4.2　发布-订阅
21.4.3　通信的关键设计选择总结
21.5　数据存储和协调服务
21.5.1　Google文件系统
21.5.2　Chubby
21.5.3　Bigtable
21.5.4　关键设计选择总结
21.6　分布式计算服务
21.6.1　MapReduce
21.6.2　Sawzall
21.6.3　关键设计选择总结

============================
1.1.1 什么是分布式系统
1.1.2 集中式系统与分布式系统
1.1.3 如何设计分布式系统
1.1.4 分布式系统所面临的挑战

1.2 线程
1.2.1 什么是线程
1.2.2 进程和线程
1.2.3 线程和纤程
1.2.4 编程语言中的线程对象
1.2.5 SimpleThreads示例

1.3 通信
1.3.1 网络I/O模型的演进
1.3.2 远程过程调用（RPC）
1.3.3 面向消息的通信
1.4 一致性
1.4.1 以数据为中心的一致性模型
1.4.2 以客户为中心的一致性
1.5 容错性
1.5.1 基本概念
1.5.2 故障分类
1.5.3 使用冗余来掩盖故障
1.5.4 分布式提交
1.6 CAP理论
1.6.1 什么是CAP理论
1.6.2 为什么CAP只能三选二
1.6.3 CAP常见模型
1.6.4 CAP的意义
1.6.5 CAP最新发展
1.7 安全性
1.7.1 基本概念
1.7.2 加密算法
1.7.3 安全通道
1.7.4 访问控制
1.8 并发
1.8.1 线程与并发
1.8.2 并发与并行
1.8.3 并发带来的风险
1.8.4 同步（Synchronization）
1.8.5 原子访问（Atomic Access）
1.8.6 无锁化设计提升并发能力
1.8.7 缓存提升并发能力
1.8.8 更细颗粒度的并发单元
第2章 分布式系统架构体系
2.1 基于对象的体系结构
2.1.1 分布式对象
2.1.2 Java RMI
2.2 面向服务的架构（SOA）
2.2.1 SOA的基本概念
2.2.2 基于Web Services的SOA
2.2.3 SOA的演变
2.3 REST风格的架构
2.3.1 什么是REST
2.3.2 REST有哪些特征
2.3.3 Java实现REST的例子
2.3.4 REST API最佳实践
2.4 微服务架构（MSA）
2.4.1 什么是MSA
2.4.2 MSA与SOA
2.4.3 何时采用MSA
2.4.4 如何构建微服务
2.5 容器技术
2.5.1 虚拟化技术
2.5.2 容器与虚拟机
2.5.3 基于容器的持续部署
2.6 Serverless架构
2.6.1 什么是Serverless架构
2.6.2 Serverless典型的应用场景
2.6.3 Serverless架构原则
2.6.4 例子：使用Serverless实现游戏全球同服
第3章 分布式消息服务
3.1 分布式消息概述
3.1.1 基本概念
3.1.2 使用场景
3.1.3 常用技术
3.2 Apache ActiveMQ
3.2.1 例子：producer-consumer
3.2.2 例子：使用JMX来监控ActiveMQ
3.2.3 例子：使用Java实现producer-consumer
3.3 RabbitMQ
3.3.1 例子：Work Queues
3.3.2 例子：Publish/Subscribe
3.3.3 例子：Routing
3.3.4 例子：Topics
3.3.5 例子：RPC
3.4 Apache RocketMQ
3.4.1 例子：使用Java实现producer-consumer
3.4.2 RocketMQ最佳实践
3.5 Apache Kafka
3.5.1 Apache Kafka的核心概念
3.5.2 Apache Kafka的使用场景
3.6 实战：基于JMS的消息发送和接收
3.6.1 项目概述
3.6.2 项目配置
3.6.3 编码实现
3.6.4 运行
第4章 分布式计算
4.1 分布式计算概述
4.1.1 使用场景
4.1.2 常用技术
4.2 MapReduce
4.2.1 MapReduce简介
4.2.2 MapReduce的编程模型
4.2.3 MapReduce接口实现
4.2.4 MapReduce的使用技巧
4.3 Apache Hadoop
4.3.1 Apache Hadoop的核心组件
4.3.2 例子：词频统计WordCount程序
4.4 Spark
4.4.1 Spark简介
4.4.2 Spark与Hadoop的关系
4.4.3 Spark 2.0的新特性
4.4.4 Spark集群模式
4.5 Mesos
4.5.1 Mesos简介
4.5.2 设计高可用的Mesos framework
4.6 实战：基于Spark的词频统计
4.6.1 项目概述
4.6.2 项目配置
4.6.3 编码实现
4.6.4 运行
第5章 分布式存储
5.1 分布式存储概述
5.1.1 使用场景
5.1.2 常用技术
5.2 Bigtable
5.2.1 Bigtable的数据模型
5.2.2 Bigtable的实现
5.2.3 Bigtable的性能优化
5.3 Apache HBase
5.3.1 Apache HBase的基本概念
5.3.2 Apache HBase的架构
5.4 Apache Cassandra
5.4.1 Apache Cassandra简介
5.4.2 Apache Cassandra的应用场景
5.4.3 Apache Cassandra的架构和数据模型
5.4.4 用于配置Apache Cassandra的核心组件
5.5 Memcached
5.5.1 Memcached简介
5.5.2 Memcached的架构
5.5.3 Memcached客户端
5.6 Redis
5.6.1 Redis简介
5.6.2 Redis的下载与简单使用
5.6.3 Redis的数据类型及抽象
5.7 MongoDB
5.7.1 MongoDB简介
5.7.2 MongoDB核心概念
5.7.3 MongoDB的数据模型
5.7.4 示例：Java连接MongoDB
5.8 实战：基于Redis的分布式锁
5.8.1 项目概述
5.8.2 项目配置
5.8.3 编码实现
5.8.4 运行
第6章 分布式监控
6.1 分布式监控概述
6.1.1 使用场景
6.1.2 常用技术
6.2 Nagios
6.2.1 Nagios监控
6.2.2 Nagios插件
6.3 Zabbix
6.3.1 Zabbix对容器的支持
6.3.2 Zabbix的基本概念
6.4 Consul
6.4.1 Consul架构
6.4.2 Consul agent
6.5 ZooKeeper
6.5.1 ZooKeeper简介
6.5.2 ZooKeeper内部工作原理
6.5.3 例子：ZooKeeper实现barrier和producer-consumer queue
6.6 实战：基于ZooKeeper的服务注册和发现
6.6.1 项目概述
6.6.2 项目配置
6.6.3 编码实现
6.6.4 运行
第7章 分布式版本控制系统
7.1 分布式版本控制系统概述
7.1.1 集中式与分布式
7.1.2 分布式版本控制系统的核心概念
7.2 Bazaar
7.2.1 Bazaar的核心概念
7.2.2 Bazaar的使用
7.3 Mercurial
7.3.1 Mercurial的核心概念
7.3.2 Mercurial的使用
7.4 Git
7.4.1 Git的基础概念
7.4.2 Git的使用
7.5 Git Flow——团队协作最佳实践
7.5.1 分支定义
7.5.2 新功能开发工作流
7.5.3 Bug修复工作流
7.5.4 版本发布工作流
第8章 RESTful API、微服务及容器技术
8.1 Jersey
8.1.1 Jersey简介
8.1.2 Jersey的模块和依赖
8.1.3 JAX-RS核心概念
8.1.4 例子：用SSE构建实时Web应用
8.2 Spring Boot
8.2.1 Spring Boot简介
8.2.2 Spring Boot的安装
8.2.3 Spring Boot的使用
8.2.4 Spring Boot的属性与配置
8.3 Docker
8.3.1 Docker简介
8.3.2 Docker的核心组成、架构及工作原理
8.3.3 Docker的使用
8.4 实战：基于Docker构建、运行、发布微服务
8.4.1 编写微服务
8.4.2 微服务容器化
8.4.3 构建Docker image
8.4.4 运行image
8.4.5 访问应用
8.4.6 发布微服务

==========================
第1章 网关之道

1.1 认识API网关

1.1.1 API网关是什么

1.1.2 API网关涵盖的基本功能

1.1.3 API网关架构示例

1.2 一个API的生命周期

1.2.1 什么是API

1.2.2 生命周期

1.2.3 生命周期的过程

1.3 API网关的基石—泛化调用

1.4 如何发布API到网关系统

1.5 管道技术

1.5.1 管道实现

1.5.2 如何获取管道

1.5.3 管道信息传递

1.5.4 管道的优点

1.5.5 责任链模式

1.6 一个传统网关系统有几种“死”法

1.6.1 关注CPU

1.6.2 关注磁盘

1.6.3 关注网络

1.7 Servlet 3异步原理与实践

1.7.1 什么是Servlet

1.7.2 什么是Servlet规范

1.7.3 同步、异步、阻塞、非阻塞

1.7.4 Servlet 3的异步流程

1.7.5 Servlet 3的异步使用步骤

1.7.6 Servlet 3的异步使用示例

1.7.7 Tomcat NIO Connector、Servlet 3.0 Async和Spring MVC Async的关系

1.7.8 Servlet 3非阻塞I/O

1.8 全异步网关

1.9 脱库与多级缓存

1.9.1 脱库

1.9.2 多级缓存

1.10 热更新

1.11 网关系统的七种武器

1.12 本章小结

第2章 开放之道

2.1 认识OAuth 2.0

2.1.1 什么是OAuth 2.0

2.1.2 角色

2.1.3 OAuth 2.0协议流程

2.1.4 采用OAuth 2.0协议的开放平台

2.1.5 京东宙斯开放（授权码方式场景）

2.2 开放平台

2.2.1 一名开发者的基本需求

2.2.2 完整性

2.2.3 稳定性

2.2.4 安全性

2.2.5 整体技术架构

2.2.6 意义

2.3 如何设计一套SPI应用架构

2.3.1 API和SPI区别

2.3.2 术语约定

2.3.3 业务场景

2.3.4 架构实现

2.3.5 测试

2.3.6 SPI是一种思想

2.4 讲一讲越权

2.4.1 什么是越权访问

2.4.2 越权访问的种类

2.4.3 发生越权访问的根本原因

2.4.4 如何避免与解决

2.4.5 开放平台环境下的越权访问

2.5 从Facebook数据泄漏谈开放安全

2.5.1 OAuth 2.0授权

2.5.2 数据加/解密

2.5.3 IP地址白名单

2.5.4 平台内环境

2.6 API治理

2.6.1 性能

2.6.2 可用率

2.6.3 文档可读性

2.7 API经济

2.7.1 API盈利模式

2.7.2 API市场

2.7.3 API经济价值链

2.8 沙箱环境

2.8.1 协同

2.8.2 维护

2.9 本章小结

第3章 分布式之道

3.1 认识分布式

3.2 分布式事务

3.2.1 什么是分布式事务

3.2.2 CAP和BASE理论

3.3 分布式锁

3.3.1 为什么需要分布式锁

3.3.2 分布式锁的实现方式

3.4 分布式限流

3.4.1 计数器

3.4.2 限速器

3.4.3 限流的维度

3.4.4 流量包

3.4.5 再来谈令牌桶

3.5 衡量性能的指标QPS、TPS等

3.5.1 什么是QPS

3.5.2 什么是TPS

3.5.3 什么是RT

3.5.4 什么是并发数

3.6 本章小结

第4章 MQ之道

4.1 认识JMS

4.1.1 JMS的组成

4.1.2 JMS编程模型

4.1.3 JMS消息结构

4.1.4 JMS消息模型

4.2 带着思考理解MQ下的基本概念

4.2.1 生产者—消费者（Producer-Consumer）

4.2.2 空间解耦

4.2.3 时间解耦

4.2.4 观察者模式与发布/订阅

4.3 消费幂等

4.3.1 什么是幂等操作

4.3.2 是什么引起我们关注消费幂等

4.3.3 如何处理消费幂等

4.4 详述MQ各种功能场景

4.4.1 解耦

4.4.2 削峰填谷

4.4.3 最终一致性

4.4.4 广播消费

4.4.5 使用集群消费模拟广播

4.4.6 重试之坑

4.5 数据异构的武器—MQ+canal

4.5.1 定义

4.5.2 常见应用场景

4.5.3 数据异构方向

4.5.4 数据异构的常用方法

4.5.5 binlog和MQ方式

4.6 关于MQ再问自己几个问题

4.6.1 我想自己控制开始消费如何做

4.6.2 为什么需要消息过滤

4.6.3 过期消息是怎么处理的

4.6.4 消息重试的注意点

4.6.5 为什么需要事务消息

4.6.6 消息为什么没有了顺序

4.7 本章小结

第5章 消息推送之道

5.1 认识消息推送

5.2 构建长连接推送系统之HTTP实践

5.2.1 Web网络结构及配置

5.2.2 基本配置

5.2.3 Transfer-Encoding: chunked

5.2.4 HTTP长连接系统组成结构

5.2.5 Session管理

5.2.6 心跳

5.2.7 消息接收的概念

5.2.8 消息推送的概念

5.2.9 消息追踪

5.2.10 HTTP长连接系统时序调用

5.2.11 创建会话（连接）

5.2.12 心跳逻辑

5.2.13 消息接收实例

5.2.14 消息推送实例

5.2.15 半推半拉

5.2.16 系统优化

5.2.17 测试

5.3 构建消息推送系统之Netty实践

5.3.1 启动

5.3.2 创建会话

5.3.3 心跳

5.3.4 发送消息

5.3.5 注销会话

5.3.6 黏包

5.4 一台服务器可以“跑”多少个连接

5.5 一台服务器可以“跑”多少个线程

5.6 弱网络环境

5.7 发送APNs

5.7.1 认识APNs

5.7.2 HTTP/2

5.7.3 Pushy的使用

5.8 本章小结

第6章 RPC之道

6.1 认识RPC

6.2 RPC是如何实现通信的

6.2.1 动态代理

6.2.2 反射

6.2.3 序列化

6.2.4 网络编程

6.3 一次RPC调用时间都去哪儿了

6.4 异步RPC

6.4.1 异步调用

6.4.2 异步监听

6.4.3 callback调用

6.5 本章小结

第7章 I/O之道

7.1 认识I/O

7.2 解读I/O多路复用技术

7.2.1 I/O多路复用概述

7.2.2 用户进程和内核

7.2.3 select和recvfrom

7.2.4 阻塞、非阻塞

7.2.5 适用场景

7.3 解读Tomcat中的NIO模型

7.3.1 Tomcat对I/O模型的支持

7.3.2 Tomcat中NIO的配置与使用

7.3.3 NioEndpoint组件关系图解读

7.3.4 NioEndpoint执行序列图

7.3.5 关于性能

7.4 本章小结

第8章 微服务之道

8.1 认识微服务

8.2 微服务后如何做一次系统梳理

8.2.1 系统分类与演进

8.2.2 梳理目的要搞清楚

8.2.3 如何做

8.2.4 核心功能的核心流程梳理

8.3 朝着微服务的方向去做一次数据库拆分

8.3.1 现状

8.3.2 方法

8.3.3 拆库的步骤（MySQL）

8.4 本章小结

第9章 容错之道

9.1 认识容错

9.2 降级与限流

9.3 线程池隔离

9.3.1 为什么要做线程池隔离

9.3.2 实现一个线程池隔离

9.3.3 线程池隔离的优点

9.3.4 线程池隔离的缺点

9.4 快速失败

9.5 熔断

9.5.1 熔断器介绍

9.5.2 熔断使用注意

9.6 Hystrix的使用

9.6.1 认识Hystrix

9.6.2 线程池隔离

9.6.3 信号量隔离

9.6.4 熔断

9.6.5 回退降级

9.7 大促备战都“备”什么

9.7.1 分离技术

9.7.2 缓存技术

9.7.3 SQL优化

9.7.4 快速失败

9.7.5 降级限流

9.7.6 性能压测

9.8 本章小结

第10章 程序之外

10.1 程序与健身

10.2 程序员的硬件装备

10.3 程序员应该看的四本技术书籍

10.4 程序员应该熟悉的常用定律法则

10.5 知识、数据、工具

===============
分布式对象存储

1.1　分布式存储概念
1.2　分布式存储分类

第一篇　基础篇

第2章　单机存储系统
2.1　硬件基础
2.1.1　CPU架构
2.1.2　IO总线
2.1.3　网络拓扑
2.1.4　性能参数
2.1.5　存储层次架构
2.2　单机存储引擎
2.2.1　哈希存储引擎
2.2.2　B树存储引擎
2.2.3　LSM树存储引擎
2.3　数据模型
2.3.1　文件模型
2.3.2　关系模型
2.3.3　键值模型
2.3.4　SQL与NoSQL
2.4　事务与并发控制
2.4.1　事务
2.4.2　并发控制
2.5　故障恢复
2.5.1　操作日志
2.5.2　重做日志
2.5.3　优化手段
2.6　数据压缩
2.6.1　压缩算法
2.6.2　列式存储

第3章　分布式系统
3.1　基本概念
3.1.1　异常
3.1.2　一致性
3.1.3　衡量指标
3.2　性能分析
3.3　数据分布
3.3.1　哈希分布
3.3.2　顺序分布
3.3.3　负载均衡
3.4　复制
3.4.1　复制的概述
3.4.2　一致性与可用性
3.5　容错
3.5.1　常见故障
3.5.2　故障检测
3.5.3　故障恢复
3.6　可扩展性
3.6.1　总控节点
3.6.2　数据库扩容
3.6.3　异构系统
3.7　分布式协议
3.7.1　两阶段提交协议
3.7.2　Paxos协议
3.7.3　Paxos与2PC
3.8　跨机房部署

第二篇　范型篇

第4章　分布式文件系统
4.1　Google文件系统
4.1.1　系统架构
4.1.2　关键问题
4.1.3　Master设计
4.1.4　ChunkServer设计
4.1.5　讨论
4.2　Taobao File System
4.2.1　系统架构
4.2.2　讨论
4.3　Facebook Haystack
4.3.1　系统架构
4.3.2　讨论
4.4　内容分发网络
4.4.1　CDN架构
4.4.2　讨论

第5章　分布式键值系统
5.1　Amazon Dynamo
5.1.1　数据分布
5.1.2　一致性与复制
5.1.3　容错
5.1.4　负载均衡
5.1.5　读写流程
5.1.6　单机实现
5.1.7　讨论
5.2　淘宝Tair
5.2.1　系统架构
5.2.2　关键问题
5.2.3　讨论

第6章　分布式表格系统
6.1　Google Bigtable
6.1.1　架构
6.1.2　数据分布
6.1.3　复制与一致性
6.1.4　容错
6.1.5　负载均衡
6.1.6　分裂与合并
6.1.7　单机存储
6.1.8　垃圾回收
6.1.9　讨论
6.2　Google Megastore
6.2.1　系统架构
6.2.2　实体组
6.2.3　并发控制
6.2.4　复制
6.2.5　索引
6.2.6　协调者
6.2.7　读取流程
6.2.8　写入流程
6.2.9　讨论
6.3　Windows Azure Storage
6.3.1　整体架构
6.3.2　文件流层
6.3.3　分区层
6.3.4　讨论

第7章　分布式数据库
7.1　数据库中间层
7.1.1　架构
7.1.2　扩容
7.1.3　讨论
7.2　Microsoft SQL Azure
7.2.1　数据模型
7.2.2　架构
7.2.3　复制与一致性
7.2.4　容错
7.2.5　负载均衡
7.2.6　多租户
7.2.7　讨论
7.3　Google Spanner
7.3.1　数据模型
7.3.2　架构
7.3.3　复制与一致性
7.3.4　TrueTime
7.3.5　并发控制
7.3.6　数据迁移
7.3.7　讨论

第三篇　实践篇

第8章　OceanBase架构初探
8.1　背景简介
8.2　设计思路
8.3　系统架构
8.3.1　整体架构图
8.3.2　客户端
8.3.3　RootServer
8.3.4　MergeServer
8.3.5　ChunkServer
8.3.6　UpdateServer
8.3.7　定期合并&数据分发
8.4　架构剖析
8.4.1　一致性选择
8.4.2　数据结构
8.4.3　可靠性与可用性
8.4.4　读写事务
8.4.5　单点性能
8.4.6　SSD支持
8.4.7　数据正确性
8.4.8　分层结构

第9章　分布式存储引擎
9.1　公共模块
9.1.1　内存管理
9.1.2　基础数据结构
9.1.3　锁
9.1.4　任务队列
9.1.5　网络框架
9.1.6　压缩与解压缩
9.2　RootServer实现机制
9.2.1　数据结构
9.2.2　子表复制与负载均衡
9.2.3　子表分裂与合并
9.2.4　UpdateServer选主
9.2.5　RootServer主备
9.3　UpdateServer实现机制
9.3.1　存储引擎
9.3.2　任务模型
9.3.3　主备同步
9.4　ChunkServer实现机制
9.4.1　子表管理
9.4.2　SSTable
9.4.3　缓存实现
9.4.4　IO实现
9.4.5　定期合并&数据分发
9.4.6　定期合并限速
9.5　消除更新瓶颈
9.5.1　读写优化回顾
9.5.2　数据旁路导入
9.5.3　数据分区

第10章　数据库功能
10.1　整体结构
10.2　只读事务
10.2.1　物理操作符接口
10.2.2　单表操作
10.2.3　多表操作
10.2.4　SQL执行本地化
10.3　写事务
10.3.1　写事务执行流程
10.3.2　多版本并发控制
10.4　OLAP业务支持
10.4.1　并发查询
10.4.2　列式存储
10.5　特色功能
10.5.1　大表左连接
10.5.2　数据过期与批量删除

第11章　质量保证、运维及实践
11.1　质量保证
11.1.1　RD开发
11.1.2　QA测试
11.1.3　试运行
11.2　使用与运维
11.2.1　使用
11.2.2　运维
11.3　应用
11.3.1　收藏夹
11.3.2　天猫评价
11.3.3　直通车报表
11.4　最佳实践
11.4.1　系统发展路径
11.4.2　人员成长
11.4.3　系统设计
11.4.4　系统实现
11.4.5　使用与运维
11.4.6　工程现象
11.4.7　经验法则

第四篇　专题篇

第12章　云存储
12.1　云存储的概念
12.2　云存储的产品形态
12.3　云存储技术
12.4　云存储的核心优势
12.5　云平台整体架构
12.5.1　Amazon云平台
12.5.2　Google云平台
12.5.3　Microsoft云平台
12.5.4　云平台架构
12.6　云存储技术体系
12.7　云存储安全

第13章　大数据
13.1　大数据的概念
13.2　MapReduce
13.3　MapReduce扩展
13.3.1　Google Tenzing
13.3.2　Microsoft Dryad
13.3.3　Google Pregel
13.4　流式计算
13.4.1　原理
13.4.2　Yahoo S4
13.4.3　Twitter Storm
13.5　实时分析
13.5.1　MPP架构
13.5.2　EMC Greenplum
13.5.3　HP Vertica
13.5.4　Google Dremel



第　1章 对象存储简介　1

1.1　和传统网络存储的区别　1

1.1.1　数据的管理方式　2

1.1.2　访问数据的方式　2

1.1.3　对象存储的优势　3

1.2　单机版对象存储的架构　4

1.2.1　REST接口　4

1.2.2　对象PUT流程　5

1.2.3　对象GET流程　5

1.3　Go语言实现　6

1.4　功能测试　10

1.5　小结　12

第　2章 可扩展的分布式系统　15

2.1　什么是分布式系统　15

2.2　接口和数据存储分离的架构　16

2.2.1　REST接口　17

2.2.2　RabbitMQ消息设计　18

2.2.3　对象PUT流程　19

2.2.4　对象GET流程　20

2.3　Go语言实现　21

2.3.1　数据服务　21

2.3.2　接口服务　23

2.3.3　rabbitmq包　34

2.4　功能测试　38

2.5　小结　41

第3章　元数据服务　45

3.1　什么是元数据　45

3.1.1　系统定义的元数据　45

3.1.2　用户自定义的元数据　45

3.1.3　散列值和散列函数　46

3.2　加入元数据服务的架构　47

3.2.1　REST接口　48

3.2.2　ES接口　51

3.2.3　对象PUT流程　54

3.2.4　对象GET流程　55

3.3　Go语言实现　55

3.3.1　接口服务　55

3.3.2　es包　63

3.4　功能测试　68

3.5　小结　74

第4章　数据校验和去重　77

4.1　何为去重　77

4.1.1　需要数据校验的原因　78

4.1.2　实现数据校验的方法　79

4.2　给数据服务加入缓存功能　79

4.2.1　数据服务的REST

接口　80

4.2.2　对象PUT流程　80

4.3　Go语言实现　82

4.3.1　接口服务　82

4.3.2　数据服务　87

4.4　功能测试　98

4.5　去重导致的性能问题　101

4.6　小结　102

第5章　数据冗余和即时修复　105

5.1　数据冗余的概念　105

5.1.1　数据丢失和数据

不可用　105

5.1.2　数据冗余　106

5.1.3　对象存储系统的数据

冗余策略　107

5.2　数据冗余的实现　108

5.2.1　REST接口　108

5.2.2　对象PUT流程　108

5.2.3　对象GET流程　109

5.3　Go语言实现　111

5.3.1　接口服务　111

5.3.2　数据服务　126

5.4　功能测试　131

5.5　小结　135

第6章　断点续传　139

6.1　为什么对象存储需要支持

断点续传　139

6.1.1　断点下载流程　139

6.1.2　断点上传流程　140

6.1.3　接口服务的REST

接口　142

6.1.4　数据服务的REST

接口　144

6.2　Go语言实现　145

6.2.1　接口服务　145

6.2.2　数据服务　158

6.3　功能测试　160

6.4　小结　165

第7章　数据压缩　169

7.1　用gzip实现对象存储和下载时的数据压缩　170

7.1.1　存储时的数据压缩　170

7.1.2　下载时的数据压缩　171

7.1.3　接口服务的REST

接口　172

7.2　Go语言实现　172

7.2.1　接口服务　172

7.2.2　数据服务　174

7.3　功能测试　176

7.4　小结　180

第8章　数据维护　183

8.1　对象存储系统的数据维护

工作　183

8.1.1　对象版本留存　183

8.1.2　数据定期检查和

修复　184

8.1.3　数据服务的REST

接口　185

8.2　Go语言实现　185

8.2.1　删除过期元数据　185

8.2.2　删除没有元数据引用的

对象数据　188

8.2.3　对象数据的检查和

修复　191

8.3　功能测试　193

====================

分布式数据库

1.1 分布式数据处理
1.2 什么是分布式数据库系统
1.3 数据发送的不同选择
1.4 DDBS的承诺
1.4.1 分布及复制数据的透明管理
1.4.2 分布式事务提供的可靠性
1.4.3 改进的性能
1.4.4 更为容易的系统扩展
1.5 分布所带来的复杂性
1.6 设计问题
1.6.1 分布式数据库设计
1.6.2 分布式目录管理
1.6.3 分布式查询处理
1.6.4 分布式并发控制
1.6.5 分布式死锁管理
1.6.6 分布式数据库的可靠性
1.6.7 复制
1.6.8 问题之间的相互关系
1.6.9 其他方面的问题
1.7 分布式DBMS体系架构
1.7.1 ANSL/SPARC体系架构
1.7.2 集中式DBMS的通用体系架构
1.7.3 分布式DBMS体系架构的模型
1.7.4 自治性
1.7.5 分布
1.7.6 异构性
1.7.7 体系架构的不同选择
1.7.8 客户／服务器系统
1.7.9 P2P系统
1.7.10 多数据库体系架构
1.8 参考文献说明

第2章 背景知识
2.1 关系DBMS概述
2.1.1 关系数据库概念
2.1.2 规范化
2.1.3 关系语言
2.2 计算机网络概述
2.2.1 不同类型的网络
2.2.2 通信方式
2.2.3 数据通信的基本概念
2.2.4 通信协议
2.3 参考文献说明

第3章 分布式数据库设计
3.1 自顶向下的设计过程
3.2 分布设计的研究问题
3.2.1 为什么要分片
3.2.2 不同的分片方法
3.2.3 划分程度
3.2.4 分片的正确性规则
3.2.5 不同的分配方法
3.2.6 信息需求
3.3 分片
3.3.1 水平分片
3.3.2 垂直分片
3.3.3 混合分片
3.4 分配
3.4.1 分配问题的定义
3.4.2 信息需求
3.4.3 分配模型
3.4.4 解决办法
3.5 数据目录
3.6 本章小结
3.7 参考文献说明
练习

第4章 数据库集成
4.1 自底向上的设计方法
4.2 模式匹配
4.2.1 模式异构性
4.2.2 语言匹配方法
4.2.3 基于限制的匹配方法
……
第5章 数据与访问控制
第6章 查询处理概述
第7章 查询分解与数据本地化
第8章 分布式查询的优化
第9章 多数据库查询处理
第10章 事务管理介绍
第11章 分布式并发控制
第12章 分布式DBMS的可靠性
第13章 数据复制
第14章 并行数据库系统
第15章 分布式对象数据库管理
第16章 P2P数据管理
第17章 万维网数据管理
第18章 前沿研究：流数据和云计算

==================

分布式计算

　第1章分布式计算概述1

　　1.1分布式概念1

　　1.2分布式计算及其原理2

　　1.3分布式系统特性3

　　1.3.1容错性3

　　1.3.2高可扩展性4

　　1.3.3开放性5

　　1.3.4并发处理能力5

　　1.3.5透明性6

　　1.4通用分布式计算系统6

　　1.4.1ApacheHadoop6

　　1.4.2ApacheSpark8

　　1.4.3ApacheStorm9

　　1.5分布式存储系统10

　　1.5.1分布式存储概念10

　　1.5.2分布式存储系统特点12

　　1.5.3分布式存储系统分类12

　　1.5.4常见分布式存储系统13

　　1.6本章小结14

　　第2章分布式系统通信基础15

　　2.1时代的浪潮15

　　2.1.1集中式通信网16

　　2.1.2去中心化16

　　2.2可靠的数据链路17

　　2.2.1数据分组17

　　2.2.2帧同步18

　　2.2.3差错控制18

　　2.2.4链路管理18

　　2.2.5问题与解决方案19

　　2.3分层架构19

　　2.4网络层22

　　2.4.1寻找路径22

　　2.4.2网络分层23

　　2.4.3TCP/IP概述23

　　2.4.4IP协议24

　　2.5传输层30

　　2.5.1数据自动分包30

　　2.5.2端到端的传输30

　　2.5.3数据的可靠传输30

　　2.6应用层35

　　2.6.1ping35

　　2.6.2telnet36

　　2.6.3OSPF36

　　2.6.4DNS36

　　2.6.5HTTP协议37

　　2.7基于消息协议的公告牌38

　　2.7.1需求描述38

　　2.7.2制定协议38

　　2.8分布式通信举例——MapReduce39

　　2.9本章小结41

　　第3章通信系统高层抽象42

　　3.1RPC介绍42

　　3.2RESTful44

　　3.2.1资源和表现层45

　　3.2.2状态转移45

　　3.2.3RESTful总结46

　　3.3消息队列46

　　3.4序列化49

　　3.5使用Thrift实现公告牌服务50

　　3.5.1ApacheThrift介绍51

　　3.5.2安装ApacheThrift51

　　3.5.3编写Thrift文件52

　　3.5.4实现服务器53

　　3.5.5实现客户端54

　　3.6本章小结56

　　第4章走进C++高性能编程57

　　4.1基于C++的留言板系统58

　　4.1.1基于Socket的通信58

　　4.1.2C++中的内存与资源管理64

　　4.2来自服务器的天书69

　　4.2.1编码69

　　4.2.2C++98的编码缺陷72

　　4.2.3C++11编码支持73

　　4.3繁忙的服务器75

　　4.3.1分身乏术75

　　4.3.2fork——分身术76

　　4.3.3进程间通信79

　　4.3.4轻量级分身——线程85

　　4.3.5C++11线程86

　　4.3.6竞争问题与解决方案88

　　4.3.7多线程优化95

　　4.3.8异步I/O99

　　4.4消失不见的内存105

　　4.4.1内存分配与内存碎片106

　　4.4.2tcmalloc108

　　4.4.3内存池110

　　4.5本章小结112

　　第5章分布式实时处理系统113

　　5.1Hadoop与MapReduce113

　　5.1.1HDFS114

　　5.1.2MapReduce模型115

　　5.2Storm实时处理系统129

　　5.2.1历史129

　　5.2.2计算模型130

　　5.2.3总体架构133

　　5.2.4Storm元数据133

　　5.2.5Storm与Hadoop比较138

　　5.3有保证的消息处理139

　　5.3.1完全处理与元组树139

　　5.3.2元组的唯一标识139

　　5.3.3确认和失败141

　　5.3.4高效实现143

　　5.4本章小结144

　　第6章实时处理系统编程接口设计145

　　6.1总体架构设计145

　　6.1.1Hurricane与Storm比较145

　　6.1.2总体架构146

　　6.1.3任务接口148

　　6.2消息源接口设计149

　　6.3消息处理器接口设计150

　　6.4数据收集器设计151

　　6.5元组接口设计154

　　6.6序列化接口设计160

　　6.7本章小结161

　　第7章服务组件设计与实现162

　　7.1Executor设计与实现162

　　7.1.1事件驱动的消息队列162

　　7.1.2动态装载技术167

　　7.1.3Executor实现169

　　7.2Task设计与实现171

　　7.3本章小结172

　　第8章管理服务设计与实现173

　　8.1President功能与设计173

　　8.2President实现174

　　8.2.1简单的网络通信实现175

　　8.2.2Topology装载实现182

　　8.2.3Manager管理调度实现184

　　8.2.4序列化实现193

　　8.3本章小结198

　　第9章实时处理系统编程接口实现199

　　9.1消息源接口实现200

　　9.1.1消息源执行器200

　　9.1.2WordCount实现实例205

　　9.2消息处理单元接口实现207

　　9.2.1消息处理单元执行器207

　　9.2.2事件处理212

　　9.2.3WordCount实现实例215

　　9.3数据收集器实现218

　　9.3.1分发策略218

　　9.3.2传输层实现224

　　9.4本章小结226

　　第10章可靠消息处理227

　　10.1基本概念227

　　10.1.1完全处理227

　　10.1.2失败与重发229

　　10.2接口设计229

　　10.3具体实现233

　　10.3.1简单实现233

　　10.3.2高效实现235

　　10.4本章小结237

　　第11章通信系统设计与实现238

　　11.1I/O多路复用方案解析239

　　11.1.1基本网络编程接口239

　　11.1.2非阻塞的服务器程序241

　　11.1.3使用select()接口的基于事件驱动的服务器模型242

　　11.1.4使用epoll实现异步事件通知模型245

　　11.2基础工具249

　　11.2.1线程工具250

　　11.2.2日志工具254

　　11.3传输层实现263

　　11.3.1Reactor模式263

　　11.3.2定义抽象TP传输层264

　　11.3.3实现基于epoll的TP传输层269

　　11.3.4实现基于IOCP的TP传输层290

　　11.4应用层HTTP实现307

　　11.4.1HttpContext307

　　11.4.2HttpRequest311

　　11.4.3HttpResponse313

　　11.4.4HttpConnection315

　　11.4.5HttpServer317

　　11.4.6总结319

　　11.5跨平台分割编译320

　　11.5.1Makefile320

　　11.5.2Kake323

　　11.6与实时处理系统集成325

　　11.6.1修改NetListener325

　　11.6.2修改NetConnector327

　　11.7本章小结330

　　第12章事务性Topology实现331

　　12.1Exact-once语义解决方案331

　　12.2设计细节333

　　12.2.1构造事务性Topology333

　　12.2.2消息处理单元334

　　12.3事务性TopologyAPI337

　　12.3.1消息处理单元337

　　12.3.2事务性消息源339

　　12.4本章小结339

　　第13章多语言接口340

　　13.1C语言通用接口340

　　13.1.1元组接口342

　　13.1.2消息源接口346

　　13.1.3消息处理单元接口349

　　13.1.4计算拓扑接口352

　　13.2Python接口354

　　13.2.1ctypes354

　　13.2.2元组接口356

　　13.2.3消息源接口359

　　13.2.4消息处理单元接口360

　　13.2.5计算拓扑接口361

　　13.2.6应用示例364

　　13.3JavaScript接口365

　　13.3.1V8引擎366

　　13.3.2Node.js366

　　13.3.3V8的互操作接口367

　　13.3.4任务接口368

　　13.3.5消息源接口369

　　13.3.6消息处理单元接口370

　　13.3.7计算拓扑接口371

　　13.3.8应用示例373

　　13.4Java接口375

　　13.4.1任务接口375

　　13.4.2消息源接口376

　　13.4.3消息处理单元接口377

　　13.4.4计算拓扑接口377

　　13.4.5本地代码380

　　13.4.6应用示例382

　　13.5Swift接口384

　　13.5.1应用范围385

　　13.5.2任务接口385

　　13.5.3消息源接口386

　　13.5.4消息处理单元接口387

　　13.5.5计算拓扑接口388

　　13.6本章小结390

　　第14章Squared设计与实现——实现高级抽象元语391

　　14.1StormTrident介绍391

　　14.1.1Squared示例391

　　14.1.2DRPC示例394

　　14.2Squared实现396

　　14.2.1SquaredTopology和Spout396

　　14.2.2SquaredBolt401

　　14.2.3Stream405

　　14.2.4状态存储410

　　14.2.5DRPC实现412

　　14.2.6操作与处理节点416

　　14.2.7流操作419

　　14.3本章小结423

　　第15章实战：日志流处理425

　　15.1日志流处理设计方案425

　　15.2实现Topology427

　　15.2.1编写消息源427

　　15.2.2编写索引消息处理单元428

　　15.2.3编写统计消息处理单元429

　　15.3本章小结431

　　第16章实战：频繁组合查找432

　　16.1背景介绍432

　　16.1.1数据挖掘概念432

　　16.1.2关联规则和频繁项集433

　　16.1.3啤酒与尿布435

　　16.2频繁二项集挖掘方法435

　　16.2.1频繁二项集435

　　16.2.2算法设计思路438

　　16.2.3Hurricane实现思路439

　　16.3编写Spout439

　　16.4编写Bolt441

　　16.4.1SplitBolt441

　　16.4.2PairCountBolt442

　　16.4.3PairTotalCountBolt443

　　16.4.4ConfidenceComputeBolt444

　　16.4.5SupportComputeBolt445

　　16.4.6FilterBolt447

　　16.5编写Topology448

　　16.6本章小结449

　　第17章实战：在AWS和阿里云上部署Hurricane实时处理系统450

　　17.1AWS部署450

　　17.1.1搭建虚拟私有云452

　　17.1.2配置安全组455

　　17.1.3加载EC2实例456

　　17.1.4弹性IP地址管理461

　　17.2阿里云部署464

　　17.2.1创建虚拟私有云464

　　17.2.2管理安全组467

　　17.2.3创建ECS468

　　17.2.4SSH登录471

　　17.3Hurricane分布式部署与管理471

　　17.3.1分布式部署原理472

　　17.3.2分布式安装配置472

　　17.3.3分布式启动476

　　17.4部署分布式实时处理系统477

　　17.5未来之路478

　　17.6本章小结479

============

分布式机器学习

第1章 绪论/ 1

1.1 人工智能及其飞速发展/ 2

1.2 大规模、分布式机器学习/ 4

1.3 本书的安排/ 6

参考文献/ 7

第2章 机器学习基础/ 9

2.1 机器学习的基本概念/ 10

2.2 机器学习的基本流程/ 13

2.3 常用的损失函数/ 16

2.3.1 Hinge损失函数/ 16

2.3.2 指数损失函数/ 16

2.3.3 交叉熵损失函数/ 17

2.4 常用的机器学习模型/ 18

2.4.1 线性模型/ 18

2.4.2 核方法与支持向量机/ 18

2.4.3 决策树与Boosting/ 21

2.4.4 神经网络/ 23

2.5 常用的优化方法/ 32

2.6 机器学习理论/ 33

2.6.1 机器学习算法的泛化误差/ 34

2.6.2 泛化误差的分解/ 34

2.6.3 基于容度的估计误差的上界/ 35

2.7 总结/ 36

参考文献/ 36

第3章 分布式机器学习框架/ 41

3.1 大数据与大模型的挑战/ 42

3.2 分布式机器学习的基本流程/ 44

3.3 数据与模型划分模块/ 46

3.4 单机优化模块/ 48

3.5 通信模块/ 48

3.5.1 通信的内容/ 48

3.5.2 通信的拓扑结构/ 49

3.5.3 通信的步调/ 51

3.5.4 通信的频率/ 52

3.6 数据与模型聚合模块/ 53

3.7 分布式机器学习理论/ 54

3.8 分布式机器学习系统/ 55

3.9 总结/ 56

参考文献/ 57

第4章 单机优化之确定性算法/ 61

4.1 基本概述/ 62

4.1.1 机器学习的优化框架/ 62

4.1.2 优化算法的分类和发展历史/ 65

4.2 一阶确定性算法/ 67

4.2.1 梯度下降法/ 67

4.2.2 投影次梯度下降法/ 69

4.2.3 近端梯度下降法/ 70

4.2.4 Frank-Wolfe算法/ 71

4.2.5 Nesterov加速法/ 72

4.2.6 坐标下降法/ 75

4.3 二阶确定性算法/ 75

4.3.1 牛顿法/ 76

4.3.2 拟牛顿法/ 77

4.4 对偶方法/ 78

4.5 总结/ 81

参考文献/ 8

第5章 单机优化之随机算法/ 85

5.1 基本随机优化算法/ 86

5.1.1 随机梯度下降法/ 86

5.1.2 随机坐标下降法/ 88

5.1.3 随机拟牛顿法/ 91

5.1.4 随机对偶坐标上升法/ 93

5.1.5 小结/ 95

5.2 随机优化算法的改进/ 96

5.2.1 方差缩减方法/ 96

5.2.2 算法组合方法/ 100

5.3 非凸随机优化算法/ 101

5.3.1 Ada系列算法/ 102

5.3.2 非凸理论分析/ 104

5.3.3 逃离鞍点问题/ 106

5.3.4 等级优化算法/ 107

5.4 总结/ 109

参考文献/ 109

第6章 数据与模型并行/ 113

6.1 基本概述/ 114

6.2 计算并行模式/ 117

6.3 数据并行模式/ 119

6.3.1 数据样本划分/ 120

6.3.2 数据维度划分/ 123

6.4 模型并行模式/ 123

6.4.1 线性模型/ 123

6.4.2 神经网络/ 127

6.5 总结/ 133

参考文献/ 133

第7章 通信机制/ 135

7.1 基本概述/ 136

7.2 通信的内容/ 137

7.2.1 参数或参数的更新/ 137

7.2.2 计算的中间结果/ 137

7.2.3 讨论/ 138

7.3 通信的拓扑结构/ 139

7.3.1 基于迭代式MapReduce/AllReduce的通信拓扑/ 140

7.3.2 基于参数服务器的通信拓扑/ 142

7.3.3 基于数据流的通信拓扑/ 143

7.3.4 讨论/ 145

7.4 通信的步调/ 145

7.4.1 同步通信/ 146

7.4.2 异步通信/ 147

7.4.3 同步和异步的平衡/ 148

7.4.4 讨论/ 150

7.5 通信的频率/ 150

7.5.1 时域滤波/ 150

7.5.2 空域滤波/ 153

7.5.3 讨论/ 155

7.6 总结/ 156

参考文献/ 156

第8章 数据与模型聚合/ 159

8.1 基本概述/ 160

8.2 基于模型加和的聚合方法/ 160

8.2.1 基于全部模型加和的聚合/ 160

8.2.2 基于部分模型加和的聚合/ 162

8.3 基于模型集成的聚合方法/ 167

8.3.1 基于输出加和的聚合/ 168

8.3.2 基于投票的聚合/ 171

8.4 总结/ 174

参考文献/ 174

第9章 分布式机器学习算法/ 177

9.1 基本概述/ 178

9.2 同步算法/ 179

9.2.1 同步SGD方法/ 179

9.2.2 模型平均方法及其改进/ 182

9.2.3 ADMM算法/ 183

9.2.4 弹性平均SGD算法/ 185

9.2.5 讨论/ 186

9.3 异步算法/ 187

9.3.1 异步SGD/ 187

9.3.2 Hogwild!算法/ 189

9.3.3 Cyclades算法/ 190

9.3.4 带延迟处理的异步算法/ 192

9.3.5 异步方法的进一步加速/ 199

9.3.6 讨论/ 199

9.4 同步和异步的对比与融合/ 199

9.4.1 同步和异步算法的实验对比/ 199

9.4.2 同步和异步的融合/ 201

9.5 模型并行算法/ 203

9.5.1 DistBelief/ 203

9.5.2 AlexNet/ 204

9.6 总结/ 205

参考文献/ 205

第10章 分布式机器学习理论/ 209

10.1 基本概述/ 210

10.2 收敛性分析/ 210

10.2.1 优化目标和算法/ 211

10.2.2 数据和模型并行/ 213

10.2.3 同步和异步/ 215

10.3 加速比分析/ 217

10.3.1 从收敛速率到加速比/ 218

10.3.2 通信量的下界/ 219

10.4 泛化分析/ 221

10.4.1 优化的局限性/ 222

10.4.2 具有更好泛化能力的非凸优化算法/ 224

10.5 总结/ 226

参考文献/ 226

第11章 分布式机器学习系统/ 229

11.1 基本概述/ 230

11.2 基于IMR的分布式机器学习系统/ 231

11.2.1 IMR和Spark/ 231

11.2.2 Spark MLlib/ 234

11.3 基于参数服务器的分布式机器学习系统/ 236

11.3.1 参数服务器/ 236

11.3.2 Multiverso参数服务器/ 237

11.4 基于数据流的分布式机器学习系统/ 241

11.4.1 数据流/ 241

11.4.2 TensorFlow数据流系统/ 243

11.5 实战比较/ 248

11.6 总结/ 252

参考文献/ 252

第12章 结语/ 255

12.1 全书总结/ 256

12.2 未来展望/ 257