第1章二次排序：简介	19
二次排序问遨解决方案	21
MapReduce/Hadoop的二次排序解决方案	25
Spark的二次排序解决方案	29
第2章二次排序：详细示例	42
二次排序技术	43
二次排序的宪整示例	46
运行示例——老版本Hadoop API	50
运行示例	新版本Hadoop API	52
第3章Top 10列表	54
Top N设计揆式的形式化描述	55
MapReduce/Hadoop实现：卷一键	56
Spark实现：唯一键	62
Spark实现：非准一键	73
使用takeOrdered()的Spark Top 10解决方案	84
MapReduce/Hadoop Top 10解决方案：非准一键	91
第4章左外连接	96
左外连接示例	96
MapReduce左外连接实现	99
Spark左外连接实现	105
使用 leftOuterJoin()的 Spark实现	117
第5章反转排序	127
反转排序模式示例	128
反转排序模式的MapReduce/Hadoop实现	129
运行示例	134
第6章移动平均	137
示例1:时间序列数据（股栗价格）	137
示例2:时间序列数据（URL访问数）	138
形式定义	139
POJO移动平均解决方案	140
MapReduce/Hadoop移动平均解决方案	143
第7章购物篮分析	155
MBAg#	155
MBA的应用领域	157
使用MapReduce的购物篮分析	157
Spark解决方案	166
运行Spark实现的YARN脚本	179
第8章共同好友	182
	183
POJO共同好友解决方案	183
MapReduce 算法	184
解决方案1:使用文本的Hadoop实现	187
解决方案2:使用ArrayListOfLongsWritable的Hadoop实现	189
Spark解决方案	191
第9章使用MapReduce实现推荐引擎	201
购买过该商S的顾客还购买了拓些商品	202
经常一起购买的商品	206
推荐连接	210
第10章基于内容的电影推荐	225
 226
MapReduce 隨 1	226
MapReduce阶段2和阶段3	227
Spark电影推荐实现	234
第11章使用马尔可夫模型的智能邮件营销	253
马尔可夫链基本原理	254
使用MapReduce的马尔可夫模型	256
Spark解决方案	269
第12章K-均值聚类	282
什么是K-均馆聚类?	285
聚类的应同领域	285
K-均佰聚类方法非形式化描述：分区方法	286
K-均佰距离函数	286
K-均佰聚类形式化描述	287
K-均佰聚类的MapReduce解决方案	288
K-均佰算法Spark实现	292
第13章k-近邻	296
	297
距离涵数	297
kNN^^J	298
kNN算法非形式化描述	299
kNN算法形式化描述	299
kNN的类Java非MapReduce解决方案	299
Spark的kNN算法实现	301
第14章朴素贝叶斯	315
训练和学习示例	316
条件概率	319
深入分析朴素贝叶斯分类器	319
朴素贝叶斯分类器：符号数据的MapReduce-决方案	322
朴素贝叶斯分类器Spark实现	332
仗周 Spark 和 Mahout	347
第15章情感分析	349
悄感示例	350
悄感分数：正面或负面	350
一个简单的MapReduceffi感分析示例	351
真实世界的悄感分析	353
第16章查找、统计和列出大图中的所有三角形	354
基本的图概念	355
三角形计数的重要性	356
MapReduce/Hadoop解决方案	357
Spark解决方案	364
第17章K-mer计数	375
K-mer计数的输入数据	376
K-mer计数应民	376
K-mer 计数 MapReduce/Hadoop 解决方案	377
K-mei■计数Spark解决方案	378
第18章DNA测序	390
DNA测序的输入数据	392
输入数据验证	393
DNA序列比对	393
DNA 测试的 MapReduce 算法	394
第19章Cox回归	413
Cox模玺剖析	414
使用R的Cox回归	415
Cox 回!]3 应用	416
Cox回!3P0J0解决方案	417
MapReduce 输入	418
使用 MapReduce 的 Cox 回归	419
第20章 Cochran-Armitage趋势检验	426
Cochran-Armitage 算法	427
Cochran-Armitage 应用	432
MapReduce解决方案	435
第21章等位基因频率	443
	444
形式化问逝描述	448
等位基因频率分析的MapReduce解决方案	449
MapReduce解决方案，阶段1	449
MapReduce解决方案，阶段2	459
MapReduce解决方案，阶段3	463
染色体X和Y的特殊处理	466
第22章T检验	468
对bioset完成T检验	469
MapReduce 问雄描述	472
	472
期望铮出	473
MapReduce解决方案	473
Spark 实现	476
第23章皮尔逊相关系数	488
皮尔逊相关系数公式	489
皮尔逊相关系数示例	491
皮尔逊相关系数数据集	492
皮尔逊相关系数POJO解决方案	492
皮尔逊相关系数MapReduce解决方案	493
皮尔逊相关系数的Spark解决方案	496
运行Spark程序的YARN脚本	516
使同Spark计算斯皮尔受相关系数	517
第24章DNA碱基计数	520
FASTA^^	521
FASTQ^^；	522
MapReduce解决方案：FASTA格式	522
运行示例	524
MapReduce解决方案：FASTQ格式	528
Spark解决方案：FASTA格式	533
Spark解决方案：FASTQ格式	537
第25章RNA测序	543
数据大小和格式	543
MapReduce 工作流	544
RNA测序分析桉述	544
RNA 测序 MapReduce 算法	548
第26章基因聚合	553
	554
舶	554
MapReduce解决方案（按单个值过滤和按平均值过滤）	555
基因聚合的Spark解决方案	567
Spark解决方案：按单个值过滤	567
Spark解决方案：按平均佰过滤	576
第27章线性回归	586
基本定义	587
简单示例	587
问翅描述	588
输入数据	589
期望铮出	590
使用 SimpleRegression的 MapReduce解决方案	590
Hadoop 实现类	593
使用R线性模型的MapReduce解决方案	593
第28章MapReduce和么半群	600
贿	600
幺半群的定义	602
幺半群和非么半群示例	603
MapReduce示例：非幺半群	606
MapReduce示例：幺半群	608
使用么半群的Spark示例	612
使用么半群的结论	618
函子和么半群	619
第29章小文件问题	622
解决方案1:在客户端合并小文件	623
解决方案2:周CombineFUehaputFormat解决小文件问趣	629
其他解决方案	634
第30章MapReduce的大容呈缓存	635
实现方案	636
缓存问翅形式化描述	637
一个捎巧.可伸缩的解决方案	637
实现LRUMap缓存	640
使用LRUMap的MapReduce解决方案	646
第31章Bloom过滤器	651
Bloom过滤器性璜	651
—个简单的Bloom过滤器示例	653
Guava库中的Bloom过游器	654
MapReduce中使用Bloom过游器	655
附录A Bioset	657
附录B Spark RDD	659
参考书目	677



第1章　算法在计算中的作用
1.1　算法
1.2　作为一种技术的算法
思考题
本章注记
第2章　算法基础
2.1　插入排序
2.2　分析算法
2.3　设计算法
2.3.1　分治法
2.3.2　分析分治算法
思考题
本章注记
第3章　函数的增长
3.1　渐近记号
3.2　标准记号与常用函数
思考题
本章注记
第4章　分治策略
4.1　最大子数组问题
4.2　矩阵乘法的Strassen算法
4.3　用代入法求解递归式
4.4　用递归树方法求解递归式
4.5　用主方法求解递归式
4.6　证明主定理
4.6.1　对b的幂证明主定理
4.6.2　向下取整和向上取整
思考题
本章注记
第5章　概率分析和随机算法
5.1　雇用问题
5.2　指示器随机变量
5.3　随机算法
5.4　概率分析和指示器随机变量的进一步使用
5.4.1　生日悖论
5.4.2　球与箱子
5.4.3　特征序列
5.4.4　在线雇用问题
思考题
本章注记


第二部分　排序和顺序统计量
第6章　堆排序
6.1　堆
6.2　维护堆的性质
6.3　建堆
6.4　堆排序算法
6.5　优先队列
思考题
本章注记
第7章　快速排序
7.1　快速排序的描述
7.2　快速排序的性能
7.3　快速排序的随机化版本
7.4　快速排序分析
7.4.1　最坏情况分析
7.4.2　期望运行时间
思考题
本章注记
第8章　线性时间排序
8.1　排序算法的下界
8.2　计数排序
8.3　基数排序
8.4　桶排序
思考题
本章注记
第9章　中位数和顺序统计量
9.1　最小值和最大值
9.2　期望为线性时间的选择算法
9.3　最坏情况为线性时间的选择算法
思考题
本章注记


第三部分　数据结构
第10章　基本数据结构
10.1　栈和队列
10.2　链表
10.3　指针和对象的实现
10.4　有根树的表示
思考题
本章注记
第11章　散列表
11.1　直接寻址表
11.2　散列表
11.3　散列函数
11.3.1　除法散列法
11.3.2　乘法散列法
11.3.3　全域散列法
11.4　开放寻址法
11.5　完全散列
思考题
本章注记
第12章　二叉搜索树
12.1　什么是二叉搜索树
12.2　查询二叉搜索树
12.3　插入和删除
12.4　随机构建二叉搜索树
思考题
本章注记
第13章　红黑树
13.1　红黑树的性质
13.2　旋转
13.3　插入
13.4　删除
思考题
本章注记
第14章　数据结构的扩张
14.1　动态顺序统计
14.2　如何扩张数据结构
14.3　区间树
思考题
本章注记


第四部分　高级设计和分析技术
第15章　动态规划
15.1　钢条切割
15.2　矩阵链乘法
15.3　动态规划原理
15.4　最长公共子序列
15.5　最优二叉搜索树
思考题
本章注记
第16章　贪心算法
16.1　活动选择问题
16.2　贪心算法原理
16.3　赫夫曼编码
16.4　拟阵和贪心算法
16.5　用拟阵求解任务调度问题
思考题
本章注记
第17章　摊还分析
17.1　聚合分析
17.2　核算法
17.3　势能法
17.4　动态表
17.4.1　表扩张
17.4.2　表扩张和收缩
思考题
本章注记


第五部分　高级数据结构
第18章　B树
18.1　B树的定义
18.2　B树上的基本操作
18.3　从B树中删除关键字
思考题
本章注记
第19章　斐波那契堆
19.1　斐波那契堆结构
19.2　可合并堆操作
19.3　关键字减值和删除一个结点
19.4　最大度数的界
思考题
本章注记
第20章　van Emde Boas树
20.1　基本方法
20.2　递归结构
20.2.1　原型van Emde Boas结构
20.2.2　原型van Emde Boas结构上的操作
20.3　van Emde Boas树及其操作
20.3.1　van Emde Boas树
20.3.2　van Emde Boas树的操作
思考题
本章注记
第21章　用于不相交集合的数据结构
21.1　不相交集合的操作
21.2　不相交集合的链表表示
21.3　不相交集合森林
*21.4　带路径压缩的按秩合并的分析
思考题
本章注记


第六部分　图算法
第22章　基本的图算法
22.1　图的表示
22.2　广度优先搜索
22.3　深度优先搜索
22.4　拓扑排序
22.5　强连通分量
思考题
本章注记
第23章　最小生成树
23.1　最小生成树的形成
23.2　Kruskal算法和Prim算法
思考题
本章注记
第24章　单源最短路径
24.1　Bellman-Ford算法
24.2　有向无环图中的单源最短路径问题
24.3　Dijkstra算法
24.4　差分约束和最短路径
24.5　最短路径性质的证明
思考题
本章注记
第25章　所有结点对的最短路径问题
25.1　最短路径和矩阵乘法
25.2　FloydWarshall算法
25.3　用于稀疏图的Johnson算法
思考题
本章注记
第26章　最大流
26.1　流网络
26.2　Ford\Fulkerson方法
26.3　最大二分匹配
26.4　推送重贴标签算法
26.5　前置重贴标签算法
思考题
本章注记


第七部分　算法问题选编
第27章　多线程算法
27.1　动态多线程基础
27.2　多线程矩阵乘法
27.3　多线程归并排序
思考题
本章注记
第28章　矩阵运算
28.1　求解线性方程组
28.2　矩阵求逆
28.3　对称正定矩阵和最小二乘逼近
思考题
本章注记
第29章　线性规划
29.1　标准型和松弛型
29.2　将问题表达为线性规划
29.3　单纯形算法
29.4　对偶性
29.5　初始基本可行解
思考题
本章注记
第30章　多项式与快速傅里叶变换
30.1　多项式的表示
30.2　DFT与FFT
30.3　高效FFT实现
思考题
本章注记
第31章　数论算法
31.1　基础数论概念
31.2　最大公约数
31.3　模运算
31.4　求解模线性方程
31.5　中国余数定理
31.6　元素的幂
31.7　RSA公钥加密系统
31.8　素数的测试
31.9　整数的因子分解
思考题
本章注记
第32章　字符串匹配
32.1　朴素字符串匹配算法
32.2　Rabin\Karp算法
32.3　利用有限自动机进行字符串匹配
32.4　Knuth-Morris-Pratt算法
思考题
本章注记
第33章　计算几何学
33.1　线段的性质
33.2　确定任意一对线段是否相交
33.3　寻找凸包
33.4　寻找最近点对
思考题
本章注记
第34章　NP完全性
34.1　多项式时间
34.2　多项式时间的验证
34.3　NP完全性与可归约性
34.4　NP完全性的证明
34.5　NP完全问题
34.5.1　团问题
34.5.2　顶点覆盖问题
34.5.3　哈密顿回路问题
34.5.4　旅行商问题
34.5.5　子集和问题
思考题
本章注记
第35章　近似算法
35.1　顶点覆盖问题
35.2　旅行商问题
35.2.1　满足三角不等式的旅行商问题
35.2.2　一般旅行商问题
35.3　集合覆盖问题
35.4　随机化和线性规划
35.5　子集和问题
思考题
本章注记
第八部分　附录：数学基础知识
附录A　求和
A.1　求和公式及其性质
A.2　确定求和时间的界
思考题
附录注记
附录B　集合等离散数学内容
B.1　集合
B.2　关系
B.3　函数
B.4　图
B.5　树
B.5.1　自由树
B.5.2　有根树和有序树
B.5.3　二叉树和位置树
思考题
附录注记
附录C　计数与概率
C.1　计数
C.2　概率
C.3　离散随机变量
C.4　几何分布与二项分布
*C.5　二项分布的尾部
思考题
附录注记
附录D　矩阵
D.1　矩阵与矩阵运算
D.2　矩阵基本性质


第1章　 基础
1.1　基础编程模型
1.1.1　Java程序的基本结构
1.1.2　原始数据类型与表达式
1.1.3　 语句
1.1.4　 简便记法
1.1.5　 数组
1.1.6　 静态方法
1.1.7　 API
1.1.8　 字符串
1.1.9　 输入输出
1.1.10　 二分查找
1.1.11　 展望
1.2　 数据抽象
1.2.1　 使用抽象数据类型
1.2.2　 抽象数据类型举例
1.2.3　 抽象数据类型的实现
1.2.4　 更多抽象数据类型的实现
1.2.5　 数据类型的设计
1.3　 背包、队列和栈
1.3.1　 API
1.3.2　 集合类数据类型的实现
1.3.3　 链表
1.3.4　 综述
1.4　 算法分析
1.4.1　 科学方法
1.4.2　 观察
1.4.3　 数学模型
1.4.4　 增长数量级的分类
1.4.5　 设计更快的算法
1.4.6　 倍率实验
1.4.7　 注意事项
1.4.8　 处理对于输入的依赖
1.4.9　 内存
1.4.10　 展望
1.5　 案例研究：union-find算法
1.5.1　 动态连通性
1.5.2　 实现
1.5.3　 展望


第2章　 排序
2.1　 初级排序算法
2.1.1　 游戏规则
2.1.2　 选择排序
2.1.3　 插入排序
2.1.4　 排序算法的可视化
2.1.5　 比较两种排序算法
2.1.6　 希尔排序
2.2　 归并排序
2.2.1　 原地归并的抽象方法
2.2.2　 自顶向下的归并排序
2.2.3　 自底向上的归并排序
2.2.4　 排序算法的复杂度
2.3　 快速排序
2.3.1　 基本算法
2.3.2　 性能特点
2.3.3　 算法改进
2.4　 优先队列
2.4.1　 API
2.4.2　 初级实现
2.4.3　 堆的定义
2.4.4　 堆的算法
2.4.5　 堆排序
2.5　 应用
2.5.1　 将各种数据排序
2.5.2　 我应该使用哪种排序算法
2.5.3　 问题的归约
2.5.4　 排序应用一览


第3章　查找
3.1　符号表
3.1.1　API
3.1.2　有序符号表
3.1.3　用例举例
3.1.4　无序链表中的顺序查找
3.1.5　有序数组中的二分查找
3.1.6　对二分查找的分析
3.1.7　预览
3.2　二叉查找树
3.2.1　基本实现
3.2.2　分析
3.2.3　有序性相关的方法与删除操作
3.3　平衡查找树
3.3.1　2-3查找树
3.3.2　红黑二叉查找树
3.3.3　实现
3.3.4　删除操作
3.3.5　红黑树的性质
3.4　散列表
3.4.1　散列函数
3.4.2　基于拉链法的散列表
3.4.3　基于线性探测法的散列表
3.4.4　调整数组大小
3.4.5　内存使用
3.5　应用
3.5.1　我应该使用符号表的哪种实现
3.5.2　集合的API
3.5.3　字典类用例
3.5.4　索引类用例
3.5.5　稀疏向量


第4章　 图
4.1　 无向图
4.1.1　 术语表
4.1.2　 表示无向图的数据类型
4.1.3　 深度优先搜索
4.1.4　 寻找路径
4.1.5　 广度优先搜索
4.1.6　 连通分量
4.1.7　 符号图
4.1.8　 总结
4.2　 有向图
4.2.1　 术语
4.2.2　 有向图的数据类型
4.2.3　 有向图中的可达性
4.2.4　 环和有向无环图
4.2.5　 有向图中的强连通性
4.2.6　 总结
4.3　 最小生成树
4.3.1　 原理
4.3.2　 加权无向图的数据类型
4.3.3　 最小生成树的API和测试用例
4.3.4　 Prim算法
4.3.5　 Prim算法的即时实现
4.3.6　 Kruskal算法
4.3.7　 展望
4.4　 最短路径
4.4.1　 最短路径的性质
4.4.2　 加权有向图的数据结构
4.4.3　 最短路径算法的理论基础
4.4.4　 Dijkstra算法
4.4.5　 无环加权有向图中的最短路径算法
4.4.6　 一般加权有向图中的最短路径问题
4.4.7　 展望


第5章　 字符串
5.1　 字符串排序
5.1.1　 键索引计数法
5.1.2　 低位优先的字符串排序
5.1.3　 高位优先的字符串排序
5.1.4　 三向字符串快速排序
5.1.5　 字符串排序算法的选择
5.2　 单词查找树
5.2.1　 单词查找树
5.2.2　 单词查找树的性质
5.2.3　 三向单词查找树
5.2.4　 三向单词查找树的性质
5.2.5　 应该使用字符串符号表的哪种实现
5.3　 子字符串查找
5.3.1　 历史简介
5.3.2　 暴力子字符串查找算法
5.3.3　 Knuth-Morris-Pratt子字符串查找算法
5.3.4　 Boyer-Moore字符串查找算法
5.3.5　 Rabin-Karp指纹字符串查找算法
5.3.6　 总结
5.4　 正则表达式
5.4.1　 使用正则表达式描述模式
5.4.2　 缩略写法
5.4.3　 正则表达式的实际应用
5.4.4　 非确定有限状态自动机
5.4.5　 模拟NFA的运行
5.4.6　 构造与正则表达式对应的
5.5　 数据压缩
5.5.1　 游戏规则
5.5.2　 读写二进制数据
5.5.3　 局限
5.5.4　 热身运动：基因组
5.5.5　 游程编码
5.5.6　 霍夫曼压缩

1．1　引言　1
1．1．1　性能方面　1
1．1．2　问题解决技巧　2
1．2　二分查找　2
1．2．1　更佳的查找方式　4
1．2．2　运行时间　8
1．3　大O 表示法　8
1．3．1　算法的运行时间以不同的速度增加　9
1．3．2　理解不同的大O运行时间　10
1．3．3　大O 表示法指出了最糟情况下的运行时间　12
1．3．4　一些常见的大O运行时间　12
1．3．5　旅行商　13
1．4　小结　15
第2　章 选择排序　16
2．1　内存的工作原理　16
2．2　数组和链表　18
2．2．1　链表　19
2．2．2　数组　20
2．2．3　术语　21
2．2．4　在中间插入　22
2．2．5　删除　23
2．3　选择排序　25
2．4　小结　28
第3　章 递归　29
3．1　递归　29
-----------------
程序调用自身的编程技巧称为递归（ recursion）。递归作为一种算法在程序设计语言中广泛应用。一个方法或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
  例如求和问题：若要求解S100 = 1 + 2 + 3 + 4 + …. + 100的值，通过循环的方式代码如下：

int sum = 0;
for (int i = 1; i <= 100; i++) {
    sum = sum + i;
}
  通过递归方式是如何求解呢？由 **1 + 2 + 3 + 4 + …. + 100 **可以分解为 ( 1 + 2 + 3 + 4 + …. + 99) + 100，可以看出
  S100 = S99 + 100，可以得出 Sn = Sn-1 + n。通过递归的方式代码如下：

public int sum(int n) {
    if (n == 1) {
        return 1;
    } else {
         return sum(n - 1) + n;
    }
}
  通过递归代码可以看出，sum() 方法中又调用了其自身，只是将传入的参数发生改变。这种程序调用自身的方式就是递归。

2 应用场景
  什么样的问题才可以使用递归的方式求解呢？构成递归需要具备两个条件：
  （1）子问题与原始问题为同样的事情，二者的求解方法是相同的，且子问题比原始问题更易求解。
  （2）递归不能无限制地调用本身，必须有个递归出口。递归出口对应的情形相对简单，可以化简为非递归状况处理。

3 实例
3.1 斐波那契数列
  斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：
  1、1、2、3、5、8、13、21、34、……
  在数学上，斐波纳契数列以如下被以递推的方法定义：
  F(1)=1，F(2)=1,，F(n) = F(n-1) + F(n-2)（n>=3，n∈N*）。

问题分析：
  斐波那契数列的对于原问题F(n)的求解可以转为对F(n-1)、F(n-2)两个子问题的求解，故符合条件（1）。由F(1)=1，F(2)=1,可以得出斐波那契数列问题是有递归出口的，递归出口对应F(1) = 1，F(2) = 1。求解斐波那契数列的代码如下：

public class FibonacciSequence {
    public static void main(String[] args){
        System.out.println(Fribonacci(9));
    }
    public static int Fribonacci(int n){
        if(n <= 2)
            return 1;
        else
            return Fribonacci(n-1)+Fribonacci(n-2);
    }
}
3.2 阶乘问题
  阶乘问题的数学表达式为：n! = n * (n-1) * (n-2) * …* 1 (n>0)。通过分析可以得出n! = (n-1)! * n。令F(n) = n!，则F(n) = F(n-1) * n。则阶乘问题符合条件（1）。由0! = 1，可以得出F(0) = 1。则阶乘问题符合条件（2），递归出口为F(0) = 1。利用递归求解阶乘问题代码如下：

int factorial(int n)
{
    int sum = 0;
    if (0 == n)
        return 1;
    else
        sum = n * factorial(n-1);
    return sum;
}
3.3 树的遍历
  对于树遍历问题在之前树的专题中已经详细介绍，这里不再赘述。二叉树的遍历代码如下：

/*前序遍历算法*/
void PreOderTraverse(BiTree T)
{
    if(T == NULL)
        return;
    printf("%c",T->data);  //显示结点数据，可以更改为其他对结点操作
    PreOderTraverse(T->lchild);   //先遍历左子树
    PreOderTraverse(T->rchild);    //最后遍历右子树
}
 /*中序遍历递归算法*/
void InOderTraverse(BiTree T)
{
    if(T == NULL)
        return ;
    InOderTraverse(T->lchild);   //中序遍历左子树
    printf("%c",T->data);   //显示结点数据，可以更改为其他对结点的操作
    InOderTraverse(T->rchild);  //最后中序遍历右子树
}
 /*后序遍历递归算法*/
void PostOderTraverse(T)
{
    if(T==NULL)
        return;
    PostOderTraverse(T->lchild);   //先遍历左子树
    PostsOderTraverse(T->rchild);  //再遍历右子树
    printf("%c",T->data);    //显示结点数可以更改为其他对结点数据
}
  通过代码可以看出，二叉树的遍历过程使用递归方式实现既有助于理解，又简化了代码量。

4 结语
  使用递归求解问题就好比，你手中有一把钥匙想要打开一扇门。当你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开它。若干次之后，你打开面前的门后，发现只有一间屋子，没有门了。然后，你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这你把钥匙打开了几扇门。
---------------------------
3．2　基线条件和递归条件　32
3．3　栈　33
3．3．1　调用栈　34
3．3．2　递归调用栈　36
第4　章 快速排序　41
4．1　分而治之　41
4．2　快速排序　47
4．3　再谈大O表示法　52
4．3．1　比较合并排序和快速排序　53
4．3．2　平均情况和最糟情况　54
4．4　小结　57
第5　章 散列表　58
5．1　散列函数　60
5．2　应用案例　63
5．2．1　将散列表用于查找　63
5．2．2　防止重复　64
5．2．3　将散列表用作缓存　66
5．2．4　小结　68
5．3　冲突　69
5．4　性能　71
5．4．1　填装因子　72
5．4．2　良好的散列函数　74
5．5　小结　75
第6　章 广度优先搜索　76
6．1　图简介　77
6．2　图是什么　79
6．3　广度优先搜索　79
6．3．1　查找最短路径　82
6．3．2　队列　83
6．4　实现图　84
6．5　实现算法　86
6．6　小结　93
第7　章 狄克斯特拉算法　94
7．1　使用狄克斯特拉算法　95
7．2　术语　98
7．3　换钢琴　100
7．4　负权边　105
7．5　实现　108
7．6　小结　116
第8　章 贪婪算法　117
8．1　教室调度问题　117
8．2　背包问题　119
8．3　集合覆盖问题　121
8．4　NP 完全问题　127
8．4．1　旅行商问题详解　127
8．4．2　如何识别NP 完全问题　131
8．5　小结　133
第9　章 动态规划　134
9．1　背包问题　134
9．1．1　简单算法　135
9．1．2　动态规划　136
9．2　背包问题FAQ　143
9．2．1　再增加一件商品将如何呢　143
9．2．2　行的排列顺序发生变化时结果将如何　145
9．2．3　可以逐列而不是逐行填充网格吗　146
9．2．4　增加一件更小的商品将如何呢　146
9．2．5　可以偷商品的一部分吗　146
9．2．6　旅游行程最优化　147
9．2．7　处理相互依赖的情况　148
9．2．8　计算最终的解时会涉及两个以上的子背包吗　148
9．2．9　最优解可能导致背包没装满吗　149
9．3　最长公共子串　149
9．3．1　绘制网格　150
9．3．2　填充网格　151
9．3．3　揭晓答案　152
9．3．4　最长公共子序列　153
9．3．5　最长公共子序列之解决方案　154
9．4　小结　155
第10　章 K 最近邻算法　156
10．1　橙子还是柚子　156
10．2　创建推荐系统　158
10．2．1　特征抽取　159
10．2．2　回归　162
10．2．3　挑选合适的特征　164
10．3　机器学习简介　165
10．3．1　OCR　165
10．3．2　创建垃圾邮件过滤器　166
10．3．3　预测股票市场　167
10．4　小结　167
第11　章 接下来如何做　168
11．1　树　168
11．2　反向索引　171
11．3　傅里叶变换　171
11．4　并行算法　172
11．5　MapReduce　173
11．5．1　分布式算法为何很有用　173
11．5．2　映射函数　173
11．5．3　归并函数　174
11．6　布隆过滤器和HyperLogLog　174
11．6．1　布隆过滤器　175
11．6．2　HyperLogLog　176
11．7　SHA 算法　176
11．7．1　比较文件　177
11．7．2　检查密码　178
11．8　局部敏感的散列算法　178
11．9　Diffie-Hellman 密钥交换　179
11．10　线性规划　180

第1章算法分析
1.1分析算法
1.1.1伪代码
1.1.2随机存取机模型
1.1.3基本操作数目的计算
1.1.4递归算法的分析
1.1.5渐近表示法
1.1.6渐近表示法的重要性
1.2相关数学知识复习
1.2.1求和
1.2.2对数和幂
1.2.3简单的证明技术
1.2.4概率基础
1.3算法分析案例
1.3.1最大子数组问题的第一个解
1.3.2一种改进的求最大子数组算法
1.3.3线性时间的最大子数组算法
1.4平摊分析
1.4.1平摊技术
1.4.2对一个可扩展数组实现的分析
1.5练习
本章注记
第一部分数据结构
第2章基本数据结构
2.1栈和队列
2.1.1栈
2.1.2队列
2.2列表
2.2.1基于索引的列表
2.2.2链表
2.3树
2.3.1树的定义
2.3.2树的遍历
2.3.3二叉树
2.3.4表示树的数据结构
2.4练习
本章注记
第3章二叉搜索树
3.1搜索和更新
3.1.1二叉搜索树的定义
3.1.2二叉搜索树中的搜索
3.1.3二叉搜索树中的插入
3.1.4二叉搜索树中的删除
3.1.5二叉搜索树的性能
3.2范围查询
3.3基于索引的搜索
3.4随机构造二叉搜索树
3.5练习
本章注记
第4章平衡二叉搜索树
4.1秩和旋转
4.2AVL树
4.3红黑树
4.4弱AVL树
4.5伸展树
4.6练习
本章注记
第5章优先队列和堆
5.1优先队列
5.2PQ排序、选择排序和插入排序
5.2.1选择排序
5.2.2插入排序
5.3堆
5.3.1基于数组结构的二叉树
5.3.2堆中的插入
5.3.3堆中的删除
5.4堆排序
5.5扩展优先队列
5.6练习
本章注记
第6章散列表
6.1映射
6.1.1映射的定义
6.1.2查找表
6.2散列函数
6.2.1分量求和
6.2.2多项式求值函数
6.2.3基于表格的散列
6.2.4取模
6.2.5随机线性和多项式函数
6.3碰撞处理与再散列
6.3.1拉链法
6.3.2开放寻址法
6.3.3线性探测
6.3.4平方探测
6.3.5双重散列
6.3.6再散列
6.4布谷鸟散列
6.5通用散列
6.6练习
本章注记
第7章并查集结构
7.1并查集及其应用
7.1.1连通分支
7.1.2迷宫建筑和渗透理论
7.2基于列表的实现
7.3基于树的实现
7.4练习
本章注记
第二部分排序和选择
第8章归并排序和快速排序
8.1归并排序
8.1.1分而治之
8.1.2归并排序和递推方程
8.2快速排序
8.2.1随机快速排序
8.2.2原地快速排序
8.3基于比较的排序的下界
8.4练习
本章注记
第9章快速排序和选择
9.1桶排序和基数排序
9.1.1桶排序
9.1.2基数排序
9.2选择
9.2.1随机快速选择
9.2.2确定性选择
9.3加权中位数
9.4练习
本章注记
第三部分基本技术
第10章贪心法
10.1分份背包问题
10.2任务调度
10.3文本压缩和哈夫曼编码
10.4练习
本章注记
第11章分治法
11.1递推与主定理
11.2整数乘法
11.3矩阵乘法
11.4极大点集问题
11.5练习
本章注记
第12章动态规划
12.1矩阵连乘
12.2通用技术
12.3望远镜调度
12.4博弈策略
12.4.1硬币行
12.4.2概率博弈策略与逆向归纳法
12.5最长公共子序列问题
12.5.1问题定义
12.5.2应用动态规划解LCS问题
12.60-1背包问题
12.7练习
本章注记
第13章图及遍历
13.1图的术语和表示方法
13.1.1图的一些术语
13.1.2图的操作
13.1.3表示图的数据结构
13.2深度优先搜索
13.3广度优先搜索
13.4有向图
13.4.1遍历有向图
13.4.2传递闭包
13.4.3有向DFS和垃圾回收
13.4.4有向无环图
13.5双连通分量
第四部分图算法
第14章最短路径
14.1单源最短路径
14.2Dijkstra算法
14.3BellmanFord 算法
14.4有向无环图中的最短路径
14.5所有顶点对之间的最短路径
14.5.1动态规划最短路径算法
14.5.2通过矩阵乘法计算最短路径
14.6练习
本章注记
第15章最小生成树
15.1最小生成树的性质
15.2Kruskal算法
15.3PrimJarník算法
15.4Baruvka算法
15.5练习
本章注记
第16章网络流和匹配
16.1流与割
16.1.1割
16.1.2剩余容量和增流路径
16.2最大流算法
16.2.1FordFulkerson算法
16.2.2EdmondsKarp算法
16.3最大二分图匹配
16.4棒球赛的淘汰
16.5最低成本流
16.6练习
本章注记
第五部分计算困难问题
第17章NP完全性
17.1P和NP
17.1.1定义复杂类P和NP
17.1.2一些有趣的NP问题
17.2NP完全性
17.2.1多项式时间归约和NP难度
17.2.2CookLevin 定理
17.2.3如何证明一个问题是NP完全问题
17.3合取范式可满足问题和3可满足问题
17.4顶点覆盖、团和集合覆盖
17.5子集和与背包问题
17.6哈密顿回路和TSP
17.7练习
本章注记
第18章近似算法
18.1几何旅行商问题
18.1.1MetricTSP的一个2近似算法
18.1.2Christofides近似算法
18.2覆盖问题的近似
18.2.1顶点覆盖的2近似算法
18.2.2集合覆盖的对数近似
18.3多项式时间近似方法
18.4回溯和分支定界
18.4.1回溯法
18.4.2分支定界法
第19章随机算法
19.1随机排列的生成
19.2稳定婚姻和优惠券收集
19.2.1优惠券收集问题分析
19.2.2稳定婚姻问题
19.3最小割
19.3.1收缩边
19.3.2计算最小割
19.3.3更快的算法
19.4寻找素数
19.5切尔诺夫界
19.5.1马尔可夫不等式
19.5.2示性随机变量之和

