锋—6大设计原则全新解读
第1章 单一职责原则 2
1.1 我是“牛”类，我可以担任多职吗 2
1.2 绝杀技，打破你的传统思维 3
1.3 我单纯，所以我快乐 6
1.4 最佳实践 7
第2章 里氏替换原则 8
2.1 爱恨纠葛的父子关系 8
2.2 纠纷不断，规则压制 9
2.3 最佳实践 18
第3章 依赖倒置原则 19
3.1 依赖倒置原则的定义 19
3.2 言而无信，你太需要契约 20
3.3 依赖的三种写法 25
3.4 最佳实践 26
第4章 接口隔离原则 28
4.1 接口隔离原则的定义 28
4.2 美女何其多，观点各不同 29
4.3 保证接口的纯洁性 33
4.4 最佳实践 35
第5章 迪米特法则 36
5.1 迪米特法则的定义 36
5.2 我的知识你知道得越少越好 36
5.3 最佳实践 43
第6章 开闭原则 44
6.1 开闭原则的定义 44
6.2 开闭原则的庐山真面目 44
6.3 为什么要采用开闭原则 49
6.4 如何使用开闭原则 51
6.5 最佳实践 55
第二部分 真刀实枪—23种设计模式完美演绎
第7章 单例模式 58
7.1 我是皇帝我独苗 58
7.2 单例模式的定义 59
7.3 单例模式的应用 60
7.3.1 单例模式的优点 60
7.3.2 单例模式的缺点 60
7.3.3 单例模式的使用场景 61
7.3.4 单例模式的注意事项 61
7.4 单例模式的扩展 62
7.5 最佳实践 64
第8章 工厂方法模式 65
8.1 女娲造人的故事 65
8.2 工厂方法模式的定义 69
8.3 工厂方法模式的应用 70
8.3.1 工厂方法模式的优点 70
8.3.2 工厂方法模式的使用场景 71
8.4 工厂方法模式的扩展 71
8.5 最佳实践 77
第9章 抽象工厂模式 78
9.1 女娲的失误 78
9.2 抽象工厂模式的定义 83
9.3 抽象工厂模式的应用 86
9.3.1 抽象工厂模式的优点 86
9.3.2 抽象工厂模式的缺点 86
9.3.3 抽象工厂模式的使用场景 86
9.3.4 抽象工厂模式的注意事项 86
9.4 最佳实践 87
第10章 模板方法模式 88
10.1 辉煌工程—制造悍马 88
10.2 模板方法模式的定义 93
10.3 模板方法模式的应用 94
10.3.1 模板方法模式的优点 94
10.3.2 模板方法模式的缺点 95
10.3.3 模板方法模式的使用场景 95
10.4 模板方法模式的扩展 95
10.5 最佳实践 99
第11章 建造者模式 100
11.1 变化是永恒的 100
11.2 建造者模式的定义 109
11.3 建造者模式的应用 111
11.3.1 建造者模式的优点 111
11.3.2 建造者模式的使用场景 111
11.3.3 建造者模式的注意事项 111
11.4 建造者模式的扩展 111
11.5 最佳实践 112
第12章 代理模式 113
12.1 我是游戏至尊 113
12.2 代理模式的定义 116
12.3 代理模式的应用 118
12.3.1 代理模式的优点 118
12.3.2 代理模式的使用场景 119
12.4 代理模式的扩展 119
12.4.1 普通代理 119
12.4.2 强制代理 121
12.4.3 代理是有个性的 126
12.4.4 动态代理 128
12.5 最佳实践 134
第13章 原型模式 135
13.1 个性化电子账单 135
13.2 原型模式的定义 141
13.3 原型模式的应用 142
13.3.1 原型模式的优点 142
13.3.2 原型模式的使用场景 142
13.4 原型模式的注意事项 143
13.4.1 构造函数不会被执行 143
13.4.2 浅拷贝和深拷贝 144
13.4.3 clone与final两个冤家 146
13.5 最佳实践 146
第14章 中介者模式 147
14.1 进销存管理是这个样子的吗 147
14.2 中介者模式的定义 156
14.3 中介者模式的应用 159
14.3.1 中介者模式的优点 159
14.3.2 中介者模式的缺点 159
14.3.3 中介者模式的使用场景 159
14.4 中介者模式的实际应用 160
14.5 最佳实践 161
第15章 命令模式 162
15.1 项目经理也难当 162
15.2 命令模式的定义 170
15.3 命令模式的应用 173
15.3.1 命令模式的优点 173
15.3.2 命令模式的缺点 173
15.3.3 命令模式的使用场景 173
15.4 命令模式的扩展 173
15.4.1 未讲完的故事 173
15.4.2 反悔问题 174
15.5 最佳实践 175
第16章 责任链模式 178
16.1 古代妇女的枷锁—“三从四德” 178
16.2 责任链模式的定义 186
16.3 责任链模式的应用 189
16.3.1 责任链模式的优点 189
16.3.2 责任链模式的缺点 190
16.3.3 责任链模式的注意事项 190
16.4 最佳实践 190
第17章 装饰模式 192
17.1 罪恶的成绩单 192
17.2 装饰模式的定义 198
17.3 装饰模式应用 201
17.3.1 装饰模式的优点 201
17.3.2 装饰模式的缺点 201
17.3.3 装饰模式的使用场景 201
17.4 最佳实践 201
第18章 策略模式 203
18.1 刘备江东娶妻，赵云他容易吗 203
18.2 策略模式的定义 206
18.3 策略模式的应用 208
18.3.1 策略模式的优点 208
18.3.2 策略模式的缺点 208
18.3.3 策略模式的使用场景 209
18.3.4 策略模式的注意事项 209
18.4 策略模式的扩展 209
18.5 最佳实践 214
第19章 适配器模式 215
19.1 业务发展—上帝才能控制 215
19.2 适配器模式的定义 221
19.3 适配器模式的应用 223
19.3.1 适配器模式的优点 223
19.3.2 适配器模式的使用场景 224
19.3.3 适配器模式的注意事项 224
19.4 适配器模式的扩展 224
19.5 最佳实践 229
第20章 迭代器模式 230
20.1 整理项目信息—苦差事 230
20.2 迭代器模式的定义 236
20.3 迭代器模式的应用 239
20.4 最佳实践 239
第21章 组合模式 240
21.1 公司的人事架构是这样的吗 240
21.2 组合模式的定义 253
21.3 组合模式的应用 255
21.3.1 组合模式的优点 255
21.3.2 组合模式的缺点 256
21.3.3 组合模式的使用场景 256
21.3.4 组合模式的注意事项 256
21.4 组合模式的扩展 256
21.4.1 真实的组合模式 256
21.4.2 透明的组合模式 257
21.4.3 组合模式的遍历 259
21.5 最佳实践 260
第22章 观察者模式 262
22.1 韩非子身边的卧底是谁派来的 262
22.2 观察者模式的定义 271
22.3 观察者模式的应用 273
22.3.1 观察者模式的优点 273
22.3.2 观察者模式的缺点 274
22.3.3 观察者模式的使用场景 274
22.3.4 观察者模式的注意事项 274
22.4 观察者模式的扩展 275
22.4.1 Java世界中的观察者模式 275
22.4.2 项目中真实的观察者模式 276
22.4.3 订阅发布模型 277
22.5 最佳实践 277
第23章 门面模式 278
23.1 我要投递信件 278
23.2 门面模式的定义 283
23.3 门面模式的应用 284
23.3.1 门面模式的优点 284
23.3.2 门面模式的缺点 285
23.3.3 门面模式的使用场景 285
23.4 门面模式的注意事项 285
23.4.1 一个子系统可以有多个门面 285
23.4.2 门面不参与子系统内的业务逻辑 286
23.5 最佳实践 288
第24章 备忘录模式 289
24.1 如此追女孩子，你还不乐 289
24.2 备忘录模式的定义 294
24.3 备忘录模式的应用 297
24.3.1 备忘录模式的使用场景 297
24.3.2 备忘录模式的注意事项 297
24.4 备忘录模式的扩展 297
24.4.1 clone方式的备忘录 297
24.4.2 多状态的备忘录模式 300
24.4.3 多备份的备忘录 304
24.4.4 封装得更好一点 305
24.5 最佳实践 307
第25章 访问者模式 308
25.1 员工的隐私何在 308
25.2 访问者模式的定义 316
25.3 访问者模式的应用 320
25.3.1 访问者模式的优点 320
25.3.2 访问者模式的缺点 320
25.3.3 访问者模式的使用场景 320
25.4 访问者模式的扩展 321
25.4.1 统计功能 321
25.4.2 多个访问者 323
25.4.3 双分派 326
25.5 最佳实践 328
第26章 状态模式 329
26.1 城市的纵向发展功臣—电梯 329
26.2 状态模式的定义 341
26.3 状态模式的应用 343
26.3.1 状态模式的优点 343
26.3.2 状态模式的缺点 344
26.3.3 状态模式的使用场景 344
26.3.4 状态模式的注意事项 344
26.4 最佳实践 344
第27章 解释器模式 346
27.1 四则运算你会吗 346
27.2 解释器模式的定义 352
27.3 解释器模式的应用 354
27.3.1 解释器模式的优点 354
27.3.2 解释器模式的缺点 354
27.3.3 解释器模式使用的场景 355
27.3.4 解释器模式的注意事项 355
27.4 最佳实践 355
第28章 享元模式 356
28.1 内存溢出，司空见惯 356
28.2 享元模式的定义 361
28.3 享元模式的应用 364
28.3.1 享元模式的优点和缺点 364
28.3.2 享元模式的使用场景 364
28.4 享元模式的扩展 365
28.4.1 线程安全的问题 365
28.4.2 性能平衡 366
28.5 最佳实践 369
第29章 桥梁模式 371
29.1 我有一个梦想 371
29.2 桥梁模式的定义 379
29.3 桥梁模式的应用 381
29.3.1 桥梁模式的优点 381
29.3.2 桥梁模式的使用场景 382
29.3.3 桥梁模式的注意事项 382
29.4 最佳实践 382
第三部分 谁的地盘谁做主—设计模式PK
第30章 创建类模式大PK 384
30.1 工厂方法模式VS建造者模式 384
30.1.1 按工厂方法建造超人 384
30.1.2 按建造者模式建造超人 386
30.1.3 最佳实践 389
30.2 抽象工厂模式VS建造者模式 390
30.2.1 按抽象工厂模式生产车辆 390
30.2.2 按建造者模式生产车辆 394
30.2.3 最佳实践 399
第31章 结构类模式大PK 400
31.1 代理模式VS装饰模式 400
31.1.1 代理模式 400
31.1.2 装饰模式 402
31.1.3 最佳实践 403
31.2 装饰模式VS适配器模式 404
31.2.1 用装饰模式描述丑小鸭 404
31.2.2 用适配器模式实现丑小鸭 407
31.2.3 最佳实践 410
第32章 行为类模式大PK 411
32.1 命令模式VS策略模式 411
32.1.1 策略模式实现压缩算法 411
32.1.2 命令模式实现压缩算法 414
32.1.3 小结 419
32.2 策略模式VS状态模式 420
32.2.1 策略模式实现人生 420
32.2.2 状态模式实现人生 423
32.2.3 小结 425
32.3 观察者模式VS责任链模式 426
32.3.1 责任链模式实现DNS
解析过程 427
32.3.2 触发链模式实现DNS
解析过程 432
32.3.3 小结 437
第33章 跨战区PK 438
33.1 策略模式VS桥梁模式 438
33.1.1 策略模式实现邮件发送 439
33.1.2 桥梁模式实现邮件发送 442
33.1.3 最佳实践 445
33.2 门面模式VS中介者模式 446
33.2.1 中介者模式实现工资计算 446
33.2.2 门面模式实现工资计算 451
33.2.3 最佳实践 454
33.3 包装模式群PK 455
33.3.1 代理模式 455
33.3.2 装饰模式 457
33.3.3 适配器模式 459
33.3.4 桥梁模式 461
33.3.5 最佳实践 464
第四部分 完美世界—设计模式混编
第34章 命令模式+责任链模式 466
34.1 搬移UNIX的命令 466
34.2 混编小结 481
第35章 工厂方法模式+策略模式 483
35.1 迷你版的交易系统 483
35.2 混编小结 493
第36章 观察者模式+中介者模式 495
36.1 事件触发器的开发 495
36.2 混编小结 508
第五部分 扩展篇
第37章 MVC框架 510
37.1 MVC框架的实现 510
37.1.1 MVC的系统架构 512
37.1.2 模型管理器 518
37.1.3 值栈 522
37.1.4 视图管理器 522
37.1.5 工具类 526
37.2 最佳实践 528
第38章 新模式 530
38.1 规格模式 530
38.1.1 规格模式的实现 530
38.1.2 最佳实践 543
38.2 对象池模式 546
38.2.1 正确的池化 546
38.2.2 对象池模式的意图 547
38.2.3 最佳实践 549
38.3 雇工模式 549
38.3.1 雇工合作 549
38.3.2 雇工模式的意图 551
38.3.3 最佳实践 552
38.4 黑板模式 552
38.4.1 黑板模式的意图 552
38.4.2 黑板模式的实现方法 553
38.5 空对象模式 554
38.5.1 空对象模式的例子 554
38.5.2 最佳实践 555
附录　23种设计模式彩图


1．1　软件工程简介　1
1．1．1　软件生命周期　2
1．1．2　软件开发方法　3
1．2　理解面向对象　5
1．2．1　面向对象的特征　5
1．2．2　使用面向对象　7
1．3　UML的使用　8
1．3．1　UML的概念　8
1．3．2　使用用例图　9
1．3．3　使用时序图　10
1．3．4　使用类图　12
1．4　总结　14
1．5　习题　15
第2章　面向对象程序设计原则　16
2．1　单一职责原则　16
2．2　开放/闭合原则　18
2．3　接口隔离原则　20
2．4　依赖倒置原则　22
2．5　Liskov替换原则　25
2．6　总结　28
2．7　习题　28
第3章　设计模式入门　30
3．1　设计模式的概念　30
3．1．1　设计模式的定义　30
3．1．2　使用设计模式　31
3．2　GRASP设计模式　37
3．2．1　创建者模式　37
3．2．2　信息专家模式　39
3．2．3　控制器模式　40
3．3　简单工厂模式　43
3．4　总结　45
3．5　习题　45
第4章　GoF创建型模式　47
4．1　单例模式　47
4．1．1　模式定义　47
4．1．2　使用单例　48
4．1．3　行业案例　49
4．2　原型模式　50
4．2．1　模式定义　50
4．2．2　使用原型　51
4．2．3　行业案例　55
4．3　构造器模式　56
4．3．1　模式定义　56
4．3．2　使用构造器　58
4．3．3　行业案例　61
4．4　抽象工厂模式　63
4．4．1　模式定义　63
4．4．2　使用抽象工厂　64
4．4．3　行业案例　67
4．5　工厂方法模式　69
4．5．1　模式定义　69
4．5．2　使用工厂方法　70
4．5．3　行业案例　73
4．6　总结　75
4．7　习题　76
第5章　GoF结构型模式　78
5．1　适配器模式　78
5．1．1　模式定义　78
5．1．2　使用适配器　80
5．1．3　行业案例　83
5．2　桥模式　87
5．2．1　模式定义　87
5．2．2　使用桥　89
5．2．3　行业案例　92
5．3　组合模式　95
5．3．1　模式定义　95
5．3．2　使用组合　96
5．3．3　行业案例　98
5．4　装饰器模式　102
5．4．1　模式定义　102
5．4．2　使用装饰器　103
5．4．3　行业案例　107
5．5　门面模式　111
5．5．1　模式定义　111
5．5．2　使用门面　113
5．5．3　行业案例　115
5．6　享元模式　118
5．6．1　模式定义　118
5．6．2　使用享元　120
5．6．3　行业案例　123
5．7　代理模式　128
5．7．1　模式定义　128
5．7．2　使用代理　130
5．7．3　行业案例　132
5．8　总结　135
5．9　习题　136
第6章　GoF行为型模式　138
6．1　责任链模式　138
6．1．1　模式定义　138
6．1．2　使用责任链　140
6．1．3　行业案例　143
6．2　命令模式　146
6．2．1　模式定义　146
6．2．2　使用命令　148
6．2．3　行业案例　152
6．3　解释器模式　155
6．3．1　模式定义　155
6．3．2　使用解释器　157
6．3．3　行业案例　160
6．4　迭代器模式　166
6．4．1　模式定义　166
6．4．2　使用迭代器　168
6．4．3　行业案例　172
6．5　仲裁者模式　175
6．5．1　模式定义　175
6．5．2　使用仲裁者　178
6．5．3　行业案例　180
6．6　备忘录模式　184
6．6．1　模式定义　184
6．6．2　使用备忘录　185
6．6．3　行业案例　188
6．7　观察者模式　195
6．7．1　模式定义　195
6．7．2　使用观察者　196
6．7．3　行业案例　199
6．8　状态模式　204
6．8．1　模式定义　204
6．8．2　使用状态　206
6．8．3　行业案例　208
6．9　策略模式　215
6．9．1　模式定义　215
6．9．2　使用策略　216
6．9．3　行业案例　219
6．10　模板方法模式　225
6．10．1　模式定义　225
6．10．2　使用模板方法　227
6．10．3　行业案例　229
6．11　访问者模式　234
6．11．1　模式定义　234
6．11．2　使用访问者　236
6．11．3　行业案例　240
6．12　总结　244
6．13　习题　246
附　录 COS需求　248
1　引言　248
1．1　系统背景　248
1．2　用户　248
1．3　假设和相关性　248
2　COS功能需求　249
2．1　点餐　249
2．2　套餐预订　250
2．3　注册支付信息　251
2．4　请求配送　251
2．5　创建、查看、修改、删除食堂菜单和菜品　252
3　数据需求　253
4　接口需求　253
4．1　用户接口　253
4．2　硬件接口　253
4．3　软件接口　253
4．4　通信接口　254
5　非功能性需求　254
5．1　性能需求　254
5．2　安全需求　254
5．3　软件质量属性　254
5．4　国际化　254


1.1 什么是设计模式
1.2 Smalltalk MVC中的设计模式
1.3 描述设计模式
1.4 设计模式的编目
1.5 组织编目
1.6 设计模式怎样解决设计问题
1.6.1 寻找合适的对象
1.6.2 决定对象的粒度
1.6.3 指定对象接口
1.6.4 描述对象的实现
1.6.5 运用复用机制
1.6.6 关联运行时刻和编译时刻的结构
1.6.7 设计应支持变化
1.7 怎样选择设计模式
1.8 怎样使用设计模式
第2章 实例研究：设计一个文档编辑器
2.1 设计问题
2.2 文档结构
2.2.1 递归组合
2.2.2 图元
2.2.3 组合模式
2.3 格式化
2.3.1 封装格式化算法
2.3.2 Compositor和Composition
2.3.3 策略模式
2.4 修饰用户界面
2.4.1 透明围栏
2.4.2 MonoGlyph
2.4.3 Decorator模式
2.5支持多种视感标准
2.5.1 对象创建的抽象
2.5.2 工厂类和产品类
2.5.3 Abstract Factory模式
2.6 支持多种窗口系统
2.6.1 我们是否可以使用Abstract Factory模式
2.6.2 封装实现依赖关系
2.6.3 Window和Windowlmp
2.6.4 Bridge模式
2.7 用户操作
2.7.1 封装一个请求
2.7.2 Command类及其子类
2.7.3 撤消和重做
2.7.4 命令历史记录
2.7.5 Command模式
2.8 拼写检查和断字处理
2.8.1 访问分散的信息
2.8.2 封装访问和遍历
2.8.3 Iterator类及其子类
2.8.4 Iterator模式
2.8.5 遍历和遍历过程中的动作
2.8.6 封装分析
2.8.7 Visitor类及其子类
2.8.8 Visitor模式
2.9小结
第3章 创建型模式
……
第4章 结构型模式
……
第5章 行为模式
……
第6章 结论

