第1章 分布式微服务架构设计原理 1

1.1 从传统单体架构到服务化架构 2

1.1.1 JEE架构 2

1.1.2 SSH架构 5

1.1.3 服务化架构 8

1.2 从服务化到微服务 11

1.2.1 微服务架构的产生 12

1.2.2 微服务架构与传统单体架构的对比 13

1.2.3 微服务架构与SOA服务化的对比 15

1.3 微服务架构的核心要点和实现原理 16

1.3.1 微服务架构中职能团队的划分 16

1.3.2 微服务的去中心化治理 18

1.3.3 微服务的交互模式 18

1.3.4 微服务的分解和组合模式 22

1.3.5 微服务的容错模式 35

1.3.6 微服务的粒度 41

1.4 Java平台微服务架构的项目组织形式 42

1.4.1 微服务项目的依赖关系 42

1.4.2 微服务项目的层级结构 43

1.4.3 微服务项目的持续发布 45

1.5 服务化管理和治理框架的技术选型 45

1.5.1 RPC 46

1.5.2 服务化 47

1.5.3 微服务 49

1.6 本章小结 52

第2章 彻底解决分布式系统一致性的问题 54

2.1 什么是一致性 55

2.2 一致性问题 56

2.3 解决一致性问题的模式和思路 57

2.3.1 酸碱平衡理论 58

2.3.2 分布式一致性协议 61

2.3.3 保证最终一致性的模式 67

2.4 超时处理模式 75

2.4.1 微服务的交互模式 76

2.4.2 同步与异步的抉择 77

2.4.3 交互模式下超时问题的解决方案 78

2.4.4 超时补偿的原则 85

2.5 迁移开关的设计 87

2.6 本章小结 88

第3章 服务化系统容量评估和性能保障 89

3.1 架构设计与非功能质量 90

3.2 全面的非功能质量需求 91

3.2.1 非功能质量需求的概述 91

3.2.2 非功能质量需求的具体指标 92

3.3 典型的技术评审提纲 97

3.3.1 现状 97

3.3.2 需求 98

3.3.3 方案描述 98

3.3.4 方案对比 99

3.3.5 风险评估 100

3.3.6 工作量评估 100

3.4 性能和容量评估经典案例 100

3.4.1 背景 100

3.4.2 目标数据量级 101

3.4.3 量级评估标准 101

3.4.4 方案 102

3.4.5 小结 107

3.5 性能评估参考标准 108

3.5.1 常用的应用层性能指标参考标准 108

3.5.2 常用的系统层性能指标参考标准 109

3.6 性能测试方案的设计和最佳实践 112

3.6.1 明确压测目标 112

3.6.2 压测场景设计和压测方案制定 114

3.6.3 准备压测环境 121

3.6.4 压测的执行 122

3.6.5 问题修复和系统优化 123

3.7 有用的压测工具 123

3.7.1 ab 123

3.7.2 jmeter 125

3.7.3 mysqlslap 125

3.7.4 sysbench 129

3.7.5 dd 134

3.7.6 LoadRunner 135

3.7.7 hprof 136

3.8 本章小结 138

第4章 大数据日志系统的构建 140

4.1 开源日志框架的原理分析与应用实践 142

4.1.1 JDK Logger 142

4.1.2 Apache Commons Logging 143

4.1.3 Apache Log4j 147

4.1.4 Slf4j 156

4.1.5 Logback 160

4.1.6 Apache Log4j 2 164

4.2 日志系统的优化和最佳实践 168

4.2.1 开发人员的日志意识 168

4.2.2 日志级别的设置 168

4.2.3 日志的数量和大小 169

4.2.4 切割方式 170

4.2.5 日志格式的配置 170

4.2.6 一行日志导致的线上事故 177

4.3 大数据日志系统的原理与设计 178

4.3.1 通用架构和设计 179

4.3.2 日志采集器 180

4.3.3 日志缓冲队列 186

4.3.4 日志解析器 187

4.3.5 日志存储和搜索 187

4.3.6 日志展示系统 188

4.3.7 监控和报警 188

4.3.8 日志系统的容量和性能评估 188

4.4 ELK系统的构建与使用 190

4.4.1 Elasticsearch 191

4.4.2 Logstash 193

4.4.3 Kibana 196

4.5 本章小结 198

第5章 基于调用链的服务治理系统的设计与实现 199

5.1 APM系统简介 200

5.1.1 优秀的开源APM系统 200

5.1.2 国内商业APM产品的介绍 202

5.2 调用链跟踪的原理 203

5.2.1 分布式系统的远程调用过程 204

5.2.2 TraceID 207

5.2.3 SpanID 208

5.2.4 业务链 210

5.3 调用链跟踪系统的设计与实现 211

5.3.1 整体架构 211

5.3.2 TraceID和SpanID在服务间的传递 213

5.3.3 采集器的设计与实现 217

5.3.4 处理器的设计与实现 222

5.3.5 调用链系统的展示 225

5.4 本章小结 226

第6章 Java服务的线上应急和技术攻关 227

6.1 海恩法则和墨菲定律 227

6.2 线上应急的目标、原则和方法 229

6.2.1 应急目标 229

6.2.2 应急原则 229

6.2.3 线上应急的方法和流程 230

6.3 技术攻关的方法论 233

6.4 环境搭建和示例服务启动 236

6.5 高效的服务化治理脚本 240

6.5.1 show-busiest-java-threads 240

6.5.2 find-in-jar 243

6.5.3 grep-in-jar 244

6.5.4 jar-conflict-detect 245

6.5.5 http-spy 247

6.5.6 show-mysql-qps 248

6.5.7 小结 249

6.6 JVM提供的监控命令 249

6.6.1 jad 249

6.6.2 btrace 250

6.6.3 jmap 252

6.6.4 jstat 255

6.6.5 jstack 256

6.6.6 jinfo 258

6.6.7 其他命令 258

6.6.8 小结 259

6.7 重要的Linux基础命令 260

6.7.1 必不可少的基础命令和工具 260

6.7.2 查看活动进程的命令 268

6.7.3 窥探内存的命令 270

6.7.4 针对CPU使用情况的监控命令 272

6.7.5 监控磁盘I/O的命令 273

6.7.6 查看网络信息和网络监控命令 275

6.7.7 Linux系统的高级工具 287

6.7.8 /proc文件系统 288

6.7.9 摘要命令 288

6.7.10 小结 290

6.8 现实中的应急和攻关案例 291

6.8.1 一次OOM事故的分析和定位 291

6.8.2 一次CPU 100%的线上事故排查 301

6.9 本章小结 304

第7章 服务的容器化过程 306

7.1 容器vs虚拟机 306

7.1.1 什么是虚拟机 306

7.1.2 什么是容器 306

7.1.3 容器和虚拟机的区别 307

7.1.4 容器主要解决的问题 307

7.1.5 Docker的优势 310

7.2 Docker实战 311

7.2.1 Docker的架构 311

7.2.2 Docker的安装 315

7.2.3 Docker初体验 319

7.2.4 Docker后台服务的管理 322

7.2.5 Docker的客户端命令 328

7.2.6 Docker Compose编排工具的使用 372

7.3 容器化项目 379

7.3.1 传统的应用部署 380

7.3.2 将应用程序部署在虚拟机上 380

7.3.3 容器化部署应用 381

7.3.4 Docker实现的应用容器化示例 382

7.4 本章小结 384

第8章 敏捷开发2.0的自动化工具 385

8.1 什么是敏捷开发2.0 385

8.1.1 常用的4种开发模式 385

8.1.2 什么是DevOps 390

8.1.3 敏捷开发2.0解决的问题 392

8.2 敏捷开发的自动化流程 393

8.2.1 持续集成 393

8.2.2 持续交付和持续部署 397

8.3 敏捷开发的常用自动化工具 400

8.3.1 分布式版本控制工具Git 400

8.3.2 持续集成和持续交付工具Jenkins 410

8.3.3 基础平台管理工具SaltStack 418

8.3.4 Docker容器化工具 421


------------

第1章 网关之道

1.1 认识API网关

1.1.1 API网关是什么

1.1.2 API网关涵盖的基本功能

1.1.3 API网关架构示例

1.2 一个API的生命周期

1.2.1 什么是API

1.2.2 生命周期

1.2.3 生命周期的过程

1.3 API网关的基石—泛化调用

1.4 如何发布API到网关系统

1.5 管道技术

1.5.1 管道实现

1.5.2 如何获取管道

1.5.3 管道信息传递

1.5.4 管道的优点

1.5.5 责任链模式

1.6 一个传统网关系统有几种“死”法

1.6.1 关注CPU

1.6.2 关注磁盘

1.6.3 关注网络

1.7 Servlet 3异步原理与实践

1.7.1 什么是Servlet

1.7.2 什么是Servlet规范

1.7.3 同步、异步、阻塞、非阻塞

1.7.4 Servlet 3的异步流程

1.7.5 Servlet 3的异步使用步骤

1.7.6 Servlet 3的异步使用示例

1.7.7 Tomcat NIO Connector、Servlet 3.0 Async和Spring MVC Async的关系

1.7.8 Servlet 3非阻塞I/O

1.8 全异步网关

1.9 脱库与多级缓存

1.9.1 脱库

1.9.2 多级缓存

1.10 热更新

1.11 网关系统的七种武器

1.12 本章小结

第2章 开放之道

2.1 认识OAuth 2.0

2.1.1 什么是OAuth 2.0

2.1.2 角色

2.1.3 OAuth 2.0协议流程

2.1.4 采用OAuth 2.0协议的开放平台

2.1.5 京东宙斯开放（授权码方式场景）

2.2 开放平台

2.2.1 一名开发者的基本需求

2.2.2 完整性

2.2.3 稳定性

2.2.4 安全性

2.2.5 整体技术架构

2.2.6 意义

2.3 如何设计一套SPI应用架构

2.3.1 API和SPI区别

2.3.2 术语约定

2.3.3 业务场景

2.3.4 架构实现

2.3.5 测试

2.3.6 SPI是一种思想

2.4 讲一讲越权

2.4.1 什么是越权访问

2.4.2 越权访问的种类

2.4.3 发生越权访问的根本原因

2.4.4 如何避免与解决

2.4.5 开放平台环境下的越权访问

2.5 从Facebook数据泄漏谈开放安全

2.5.1 OAuth 2.0授权

2.5.2 数据加/解密

2.5.3 IP地址白名单

2.5.4 平台内环境

2.6 API治理

2.6.1 性能

2.6.2 可用率

2.6.3 文档可读性

2.7 API经济

2.7.1 API盈利模式

2.7.2 API市场

2.7.3 API经济价值链

2.8 沙箱环境

2.8.1 协同

2.8.2 维护

2.9 本章小结

第3章 分布式之道

3.1 认识分布式

3.2 分布式事务

3.2.1 什么是分布式事务

3.2.2 CAP和BASE理论

3.3 分布式锁

3.3.1 为什么需要分布式锁

3.3.2 分布式锁的实现方式

3.4 分布式限流

3.4.1 计数器

3.4.2 限速器

3.4.3 限流的维度

3.4.4 流量包

3.4.5 再来谈令牌桶

3.5 衡量性能的指标QPS、TPS等

3.5.1 什么是QPS

3.5.2 什么是TPS

3.5.3 什么是RT

3.5.4 什么是并发数

3.6 本章小结

第4章 MQ之道

4.1 认识JMS

4.1.1 JMS的组成

4.1.2 JMS编程模型

4.1.3 JMS消息结构

4.1.4 JMS消息模型

4.2 带着思考理解MQ下的基本概念

4.2.1 生产者—消费者（Producer-Consumer）

4.2.2 空间解耦

4.2.3 时间解耦

4.2.4 观察者模式与发布/订阅

4.3 消费幂等

4.3.1 什么是幂等操作

4.3.2 是什么引起我们关注消费幂等

4.3.3 如何处理消费幂等

4.4 详述MQ各种功能场景

4.4.1 解耦

4.4.2 削峰填谷

4.4.3 最终一致性

4.4.4 广播消费

4.4.5 使用集群消费模拟广播

4.4.6 重试之坑

4.5 数据异构的武器—MQ+canal

4.5.1 定义

4.5.2 常见应用场景

4.5.3 数据异构方向

4.5.4 数据异构的常用方法

4.5.5 binlog和MQ方式

4.6 关于MQ再问自己几个问题

4.6.1 我想自己控制开始消费如何做

4.6.2 为什么需要消息过滤

4.6.3 过期消息是怎么处理的

4.6.4 消息重试的注意点

4.6.5 为什么需要事务消息

4.6.6 消息为什么没有了顺序

4.7 本章小结

第5章 消息推送之道

5.1 认识消息推送

5.2 构建长连接推送系统之HTTP实践

5.2.1 Web网络结构及配置

5.2.2 基本配置

5.2.3 Transfer-Encoding: chunked

5.2.4 HTTP长连接系统组成结构

5.2.5 Session管理

5.2.6 心跳

5.2.7 消息接收的概念

5.2.8 消息推送的概念

5.2.9 消息追踪

5.2.10 HTTP长连接系统时序调用

5.2.11 创建会话（连接）

5.2.12 心跳逻辑

5.2.13 消息接收实例

5.2.14 消息推送实例

5.2.15 半推半拉

5.2.16 系统优化

5.2.17 测试

5.3 构建消息推送系统之Netty实践

5.3.1 启动

5.3.2 创建会话

5.3.3 心跳

5.3.4 发送消息

5.3.5 注销会话

5.3.6 黏包

5.4 一台服务器可以“跑”多少个连接

5.5 一台服务器可以“跑”多少个线程

5.6 弱网络环境

5.7 发送APNs

5.7.1 认识APNs

5.7.2 HTTP/2

5.7.3 Pushy的使用

5.8 本章小结

第6章 RPC之道

6.1 认识RPC

6.2 RPC是如何实现通信的

6.2.1 动态代理

6.2.2 反射

6.2.3 序列化

6.2.4 网络编程

6.3 一次RPC调用时间都去哪儿了

6.4 异步RPC

6.4.1 异步调用

6.4.2 异步监听

6.4.3 callback调用

6.5 本章小结

第7章 I/O之道

7.1 认识I/O

7.2 解读I/O多路复用技术

7.2.1 I/O多路复用概述

7.2.2 用户进程和内核

7.2.3 select和recvfrom

7.2.4 阻塞、非阻塞

7.2.5 适用场景

7.3 解读Tomcat中的NIO模型

7.3.1 Tomcat对I/O模型的支持

7.3.2 Tomcat中NIO的配置与使用

7.3.3 NioEndpoint组件关系图解读

7.3.4 NioEndpoint执行序列图

7.3.5 关于性能

7.4 本章小结

第8章 微服务之道

8.1 认识微服务

8.2 微服务后如何做一次系统梳理

8.2.1 系统分类与演进

8.2.2 梳理目的要搞清楚

8.2.3 如何做

8.2.4 核心功能的核心流程梳理

8.3 朝着微服务的方向去做一次数据库拆分

8.3.1 现状

8.3.2 方法

8.3.3 拆库的步骤（MySQL）

8.4 本章小结

第9章 容错之道

9.1 认识容错

9.2 降级与限流

9.3 线程池隔离

9.3.1 为什么要做线程池隔离

9.3.2 实现一个线程池隔离

9.3.3 线程池隔离的优点

9.3.4 线程池隔离的缺点

9.4 快速失败

9.5 熔断

9.5.1 熔断器介绍

9.5.2 熔断使用注意

9.6 Hystrix的使用

9.6.1 认识Hystrix

9.6.2 线程池隔离

9.6.3 信号量隔离

9.6.4 熔断

9.6.5 回退降级

9.7 大促备战都“备”什么

9.7.1 分离技术

9.7.2 缓存技术

9.7.3 SQL优化

9.7.4 快速失败

9.7.5 降级限流

9.7.6 性能压测

9.8 本章小结

第10章 程序之外

10.1 程序与健身

10.2 程序员的硬件装备

10.3 程序员应该看的四本技术书籍

10.4 程序员应该熟悉的常用定律法则

10.5 知识、数据、工具

参考文献

