第1章 分布式微服务架构设计原理 1

1.1 从传统单体架构到服务化架构 2

1.1.1 JEE架构 2

1.1.2 SSH架构 5

1.1.3 服务化架构 8

1.2 从服务化到微服务 11

1.2.1 微服务架构的产生 12

1.2.2 微服务架构与传统单体架构的对比 13

1.2.3 微服务架构与SOA服务化的对比 15

1.3 微服务架构的核心要点和实现原理 16

1.3.1 微服务架构中职能团队的划分 16

1.3.2 微服务的去中心化治理 18

1.3.3 微服务的交互模式 18

1.3.4 微服务的分解和组合模式 22

1.3.5 微服务的容错模式 35

1.3.6 微服务的粒度 41

1.4 Java平台微服务架构的项目组织形式 42

1.4.1 微服务项目的依赖关系 42

1.4.2 微服务项目的层级结构 43

1.4.3 微服务项目的持续发布 45

1.5 服务化管理和治理框架的技术选型 45

1.5.1 RPC 46

1.5.2 服务化 47

1.5.3 微服务 49

1.6 本章小结 52

第2章 彻底解决分布式系统一致性的问题 54

2.1 什么是一致性 55

2.2 一致性问题 56

2.3 解决一致性问题的模式和思路 57

2.3.1 酸碱平衡理论 58

2.3.2 分布式一致性协议 61

2.3.3 保证最终一致性的模式 67

2.4 超时处理模式 75

2.4.1 微服务的交互模式 76

2.4.2 同步与异步的抉择 77

2.4.3 交互模式下超时问题的解决方案 78

2.4.4 超时补偿的原则 85

2.5 迁移开关的设计 87

2.6 本章小结 88

第3章 服务化系统容量评估和性能保障 89

3.1 架构设计与非功能质量 90

3.2 全面的非功能质量需求 91

3.2.1 非功能质量需求的概述 91

3.2.2 非功能质量需求的具体指标 92

3.3 典型的技术评审提纲 97

3.3.1 现状 97

3.3.2 需求 98

3.3.3 方案描述 98

3.3.4 方案对比 99

3.3.5 风险评估 100

3.3.6 工作量评估 100

3.4 性能和容量评估经典案例 100

3.4.1 背景 100

3.4.2 目标数据量级 101

3.4.3 量级评估标准 101

3.4.4 方案 102

3.4.5 小结 107

3.5 性能评估参考标准 108

3.5.1 常用的应用层性能指标参考标准 108

3.5.2 常用的系统层性能指标参考标准 109

3.6 性能测试方案的设计和最佳实践 112

3.6.1 明确压测目标 112

3.6.2 压测场景设计和压测方案制定 114

3.6.3 准备压测环境 121

3.6.4 压测的执行 122

3.6.5 问题修复和系统优化 123

3.7 有用的压测工具 123

3.7.1 ab 123

3.7.2 jmeter 125

3.7.3 mysqlslap 125

3.7.4 sysbench 129

3.7.5 dd 134

3.7.6 LoadRunner 135

3.7.7 hprof 136

3.8 本章小结 138

第4章 大数据日志系统的构建 140

4.1 开源日志框架的原理分析与应用实践 142

4.1.1 JDK Logger 142

4.1.2 Apache Commons Logging 143

4.1.3 Apache Log4j 147

4.1.4 Slf4j 156

4.1.5 Logback 160

4.1.6 Apache Log4j 2 164

4.2 日志系统的优化和最佳实践 168

4.2.1 开发人员的日志意识 168

4.2.2 日志级别的设置 168

4.2.3 日志的数量和大小 169

4.2.4 切割方式 170

4.2.5 日志格式的配置 170

4.2.6 一行日志导致的线上事故 177

4.3 大数据日志系统的原理与设计 178

4.3.1 通用架构和设计 179

4.3.2 日志采集器 180

4.3.3 日志缓冲队列 186

4.3.4 日志解析器 187

4.3.5 日志存储和搜索 187

4.3.6 日志展示系统 188

4.3.7 监控和报警 188

4.3.8 日志系统的容量和性能评估 188

4.4 ELK系统的构建与使用 190

4.4.1 Elasticsearch 191

4.4.2 Logstash 193

4.4.3 Kibana 196

4.5 本章小结 198

第5章 基于调用链的服务治理系统的设计与实现 199

5.1 APM系统简介 200

5.1.1 优秀的开源APM系统 200

5.1.2 国内商业APM产品的介绍 202

5.2 调用链跟踪的原理 203

5.2.1 分布式系统的远程调用过程 204

5.2.2 TraceID 207

5.2.3 SpanID 208

5.2.4 业务链 210

5.3 调用链跟踪系统的设计与实现 211

5.3.1 整体架构 211

5.3.2 TraceID和SpanID在服务间的传递 213

5.3.3 采集器的设计与实现 217

5.3.4 处理器的设计与实现 222

5.3.5 调用链系统的展示 225

5.4 本章小结 226

第6章 Java服务的线上应急和技术攻关 227

6.1 海恩法则和墨菲定律 227

6.2 线上应急的目标、原则和方法 229

6.2.1 应急目标 229

6.2.2 应急原则 229

6.2.3 线上应急的方法和流程 230

6.3 技术攻关的方法论 233

6.4 环境搭建和示例服务启动 236

6.5 高效的服务化治理脚本 240

6.5.1 show-busiest-java-threads 240

6.5.2 find-in-jar 243

6.5.3 grep-in-jar 244

6.5.4 jar-conflict-detect 245

6.5.5 http-spy 247

6.5.6 show-mysql-qps 248

6.5.7 小结 249

6.6 JVM提供的监控命令 249

6.6.1 jad 249

6.6.2 btrace 250

6.6.3 jmap 252

6.6.4 jstat 255

6.6.5 jstack 256

6.6.6 jinfo 258

6.6.7 其他命令 258

6.6.8 小结 259

6.7 重要的Linux基础命令 260

6.7.1 必不可少的基础命令和工具 260

6.7.2 查看活动进程的命令 268

6.7.3 窥探内存的命令 270

6.7.4 针对CPU使用情况的监控命令 272

6.7.5 监控磁盘I/O的命令 273

6.7.6 查看网络信息和网络监控命令 275

6.7.7 Linux系统的高级工具 287

6.7.8 /proc文件系统 288

6.7.9 摘要命令 288

6.7.10 小结 290

6.8 现实中的应急和攻关案例 291

6.8.1 一次OOM事故的分析和定位 291

6.8.2 一次CPU 100%的线上事故排查 301

6.9 本章小结 304

第7章 服务的容器化过程 306

7.1 容器vs虚拟机 306

7.1.1 什么是虚拟机 306

7.1.2 什么是容器 306

7.1.3 容器和虚拟机的区别 307

7.1.4 容器主要解决的问题 307

7.1.5 Docker的优势 310

7.2 Docker实战 311

7.2.1 Docker的架构 311

7.2.2 Docker的安装 315

7.2.3 Docker初体验 319

7.2.4 Docker后台服务的管理 322

7.2.5 Docker的客户端命令 328

7.2.6 Docker Compose编排工具的使用 372

7.3 容器化项目 379

7.3.1 传统的应用部署 380

7.3.2 将应用程序部署在虚拟机上 380

7.3.3 容器化部署应用 381

7.3.4 Docker实现的应用容器化示例 382

7.4 本章小结 384

第8章 敏捷开发2.0的自动化工具 385

8.1 什么是敏捷开发2.0 385

8.1.1 常用的4种开发模式 385

8.1.2 什么是DevOps 390

8.1.3 敏捷开发2.0解决的问题 392

8.2 敏捷开发的自动化流程 393

8.2.1 持续集成 393

8.2.2 持续交付和持续部署 397

8.3 敏捷开发的常用自动化工具 400

8.3.1 分布式版本控制工具Git 400

8.3.2 持续集成和持续交付工具Jenkins 410

8.3.3 基础平台管理工具SaltStack 418

8.3.4 Docker容器化工具 421


------------

第1章 网关之道

1.1 认识API网关

1.1.1 API网关是什么

1.1.2 API网关涵盖的基本功能

1.1.3 API网关架构示例

1.2 一个API的生命周期

1.2.1 什么是API

1.2.2 生命周期

1.2.3 生命周期的过程

1.3 API网关的基石—泛化调用

1.4 如何发布API到网关系统

1.5 管道技术

1.5.1 管道实现

1.5.2 如何获取管道

1.5.3 管道信息传递

1.5.4 管道的优点

1.5.5 责任链模式

1.6 一个传统网关系统有几种“死”法

1.6.1 关注CPU

1.6.2 关注磁盘

1.6.3 关注网络

1.7 Servlet 3异步原理与实践

1.7.1 什么是Servlet

1.7.2 什么是Servlet规范

1.7.3 同步、异步、阻塞、非阻塞

1.7.4 Servlet 3的异步流程

1.7.5 Servlet 3的异步使用步骤

1.7.6 Servlet 3的异步使用示例

1.7.7 Tomcat NIO Connector、Servlet 3.0 Async和Spring MVC Async的关系

1.7.8 Servlet 3非阻塞I/O

1.8 全异步网关

1.9 脱库与多级缓存

1.9.1 脱库

1.9.2 多级缓存

1.10 热更新

1.11 网关系统的七种武器

1.12 本章小结

第2章 开放之道

2.1 认识OAuth 2.0

2.1.1 什么是OAuth 2.0

2.1.2 角色

2.1.3 OAuth 2.0协议流程

2.1.4 采用OAuth 2.0协议的开放平台

2.1.5 京东宙斯开放（授权码方式场景）

2.2 开放平台

2.2.1 一名开发者的基本需求

2.2.2 完整性

2.2.3 稳定性

2.2.4 安全性

2.2.5 整体技术架构

2.2.6 意义

2.3 如何设计一套SPI应用架构

2.3.1 API和SPI区别

2.3.2 术语约定

2.3.3 业务场景

2.3.4 架构实现

2.3.5 测试

2.3.6 SPI是一种思想

2.4 讲一讲越权

2.4.1 什么是越权访问

2.4.2 越权访问的种类

2.4.3 发生越权访问的根本原因

2.4.4 如何避免与解决

2.4.5 开放平台环境下的越权访问

2.5 从Facebook数据泄漏谈开放安全

2.5.1 OAuth 2.0授权

2.5.2 数据加/解密

2.5.3 IP地址白名单

2.5.4 平台内环境

2.6 API治理

2.6.1 性能

2.6.2 可用率

2.6.3 文档可读性

2.7 API经济

2.7.1 API盈利模式

2.7.2 API市场

2.7.3 API经济价值链

2.8 沙箱环境

2.8.1 协同

2.8.2 维护

2.9 本章小结

第3章 分布式之道

3.1 认识分布式

3.2 分布式事务

3.2.1 什么是分布式事务

3.2.2 CAP和BASE理论

3.3 分布式锁

3.3.1 为什么需要分布式锁

3.3.2 分布式锁的实现方式

3.4 分布式限流

3.4.1 计数器

3.4.2 限速器

3.4.3 限流的维度

3.4.4 流量包

3.4.5 再来谈令牌桶

3.5 衡量性能的指标QPS、TPS等

3.5.1 什么是QPS

3.5.2 什么是TPS

3.5.3 什么是RT

3.5.4 什么是并发数

3.6 本章小结

第4章 MQ之道

4.1 认识JMS

4.1.1 JMS的组成

4.1.2 JMS编程模型

4.1.3 JMS消息结构

4.1.4 JMS消息模型

4.2 带着思考理解MQ下的基本概念

4.2.1 生产者—消费者（Producer-Consumer）

4.2.2 空间解耦

4.2.3 时间解耦

4.2.4 观察者模式与发布/订阅

4.3 消费幂等

4.3.1 什么是幂等操作

4.3.2 是什么引起我们关注消费幂等

4.3.3 如何处理消费幂等

4.4 详述MQ各种功能场景

4.4.1 解耦

4.4.2 削峰填谷

4.4.3 最终一致性

4.4.4 广播消费

4.4.5 使用集群消费模拟广播

4.4.6 重试之坑

4.5 数据异构的武器—MQ+canal

4.5.1 定义

4.5.2 常见应用场景

4.5.3 数据异构方向

4.5.4 数据异构的常用方法

4.5.5 binlog和MQ方式

4.6 关于MQ再问自己几个问题

4.6.1 我想自己控制开始消费如何做

4.6.2 为什么需要消息过滤

4.6.3 过期消息是怎么处理的

4.6.4 消息重试的注意点

4.6.5 为什么需要事务消息

4.6.6 消息为什么没有了顺序

4.7 本章小结

第5章 消息推送之道

5.1 认识消息推送

5.2 构建长连接推送系统之HTTP实践

5.2.1 Web网络结构及配置

5.2.2 基本配置

5.2.3 Transfer-Encoding: chunked

5.2.4 HTTP长连接系统组成结构

5.2.5 Session管理

5.2.6 心跳

5.2.7 消息接收的概念

5.2.8 消息推送的概念

5.2.9 消息追踪

5.2.10 HTTP长连接系统时序调用

5.2.11 创建会话（连接）

5.2.12 心跳逻辑

5.2.13 消息接收实例

5.2.14 消息推送实例

5.2.15 半推半拉

5.2.16 系统优化

5.2.17 测试

5.3 构建消息推送系统之Netty实践

5.3.1 启动

5.3.2 创建会话

5.3.3 心跳

5.3.4 发送消息

5.3.5 注销会话

5.3.6 黏包

5.4 一台服务器可以“跑”多少个连接

5.5 一台服务器可以“跑”多少个线程

5.6 弱网络环境

5.7 发送APNs

5.7.1 认识APNs

5.7.2 HTTP/2

5.7.3 Pushy的使用

5.8 本章小结

第6章 RPC之道

6.1 认识RPC

6.2 RPC是如何实现通信的

6.2.1 动态代理

6.2.2 反射

6.2.3 序列化

6.2.4 网络编程

6.3 一次RPC调用时间都去哪儿了

6.4 异步RPC

6.4.1 异步调用

6.4.2 异步监听

6.4.3 callback调用

6.5 本章小结

第7章 I/O之道

7.1 认识I/O

7.2 解读I/O多路复用技术

7.2.1 I/O多路复用概述

7.2.2 用户进程和内核

7.2.3 select和recvfrom

7.2.4 阻塞、非阻塞

7.2.5 适用场景

7.3 解读Tomcat中的NIO模型

7.3.1 Tomcat对I/O模型的支持

7.3.2 Tomcat中NIO的配置与使用

7.3.3 NioEndpoint组件关系图解读

7.3.4 NioEndpoint执行序列图

7.3.5 关于性能

7.4 本章小结

第8章 微服务之道

8.1 认识微服务

8.2 微服务后如何做一次系统梳理

8.2.1 系统分类与演进

8.2.2 梳理目的要搞清楚

8.2.3 如何做

8.2.4 核心功能的核心流程梳理

8.3 朝着微服务的方向去做一次数据库拆分

8.3.1 现状

8.3.2 方法

8.3.3 拆库的步骤（MySQL）

8.4 本章小结

第9章 容错之道

9.1 认识容错

9.2 降级与限流

9.3 线程池隔离

9.3.1 为什么要做线程池隔离

9.3.2 实现一个线程池隔离

9.3.3 线程池隔离的优点

9.3.4 线程池隔离的缺点

9.4 快速失败

9.5 熔断

9.5.1 熔断器介绍

9.5.2 熔断使用注意

9.6 Hystrix的使用

9.6.1 认识Hystrix

9.6.2 线程池隔离

9.6.3 信号量隔离

9.6.4 熔断

9.6.5 回退降级

9.7 大促备战都“备”什么

9.7.1 分离技术

9.7.2 缓存技术

9.7.3 SQL优化

9.7.4 快速失败

9.7.5 降级限流

9.7.6 性能压测

9.8 本章小结

第10章 程序之外

10.1 程序与健身

10.2 程序员的硬件装备

10.3 程序员应该看的四本技术书籍

10.4 程序员应该熟悉的常用定律法则

10.5 知识、数据、工具

参考文献

第1章逃离单体地狱/1

1.1迈向单体地狱的漫长旅程/2

1.1.1FTGO应用程序的架构/3

1.1.2单体架构的好处/4

1.1.3什么是单体地狱/4

1.2为什么本书与你有关/7

1.3你会在本书中学到什么/8

1.4拯救之道：微服务架构/8

1.4.1扩展立方体和服务/9

1.4.2微服务架构作为模块化的一种形式/11

1.4.3每个服务都拥有自己的数据库/12

1.4.4FTGO的微服务架构/12

1.4.5微服务架构与SOA的异同/14

1.5微服务架构的好处和弊端/15

1.5.1微服务架构的好处/15

1.5.2微服务架构的弊端/17

1.6微服务架构的模式语言/19

1.6.1微服务架构并不是“银弹”/20

1.6.2模式和模式语言/21

1.6.3微服务架构的模式语言概述/24

1.7微服务之上：流程和组织/29

1.7.1进行软件开发和交付的组织/30

1.7.2进行软件开发和交付的流程/31

1.7.3采用微服务架构时的人为因素/32

第2章服务的拆分策略/34

2.1微服务架构到底是什么/35

2.1.1软件架构是什么，为什么它如此重要/35

2.1.2什么是架构的风格/37

2.1.3微服务架构是一种架构风格/40

2.2为应用程序定义微服务架构/43

2.2.1识别系统操作/45

2.2.2根据业务能力进行服务拆分/50

2.2.3根据子域进行服务拆分/53

2.2.4拆分的指导原则/54

2.2.5拆分单体应用为服务的难点/56

2.2.6定义服务API/59

第3章微服务架构中的进程间通信/63

3.1微服务架构中的进程间通信概述/64

3.1.1交互方式/64

3.1.2在微服务架构中定义API/66

3.1.3API的演化/67

3.1.4消息的格式/69

3.2基于同步远程过程调用模式的通信/70

3.2.1使用REST/71

3.2.2使用gRPC/74

3.2.3使用断路器模式处理局部故障/75

3.2.4使用服务发现/78

3.3基于异步消息模式的通信/82

3.3.1什么是消息传递/83

3.3.2使用消息机制实现交互方式/84

3.3.3为基于消息机制的服务API创建API规范/86

3.3.4使用消息代理/87

3.3.5处理并发和消息顺序/91

3.3.6处理重复消息/92

3.3.7事务性消息/93

3.3.8消息相关的类库和框架/97

3.4使用异步消息提高可用性/99

3.4.1同步消息会降低可用性/99

3.4.2消除同步交互/101

第4章使用Saga管理事务/106

4.1微服务架构下的事务管理/107

4.1.1微服务架构对分布式事务的需求/108

4.1.2分布式事务的挑战/109

4.1.3使用Saga模式维护数据一致性/109

4.2Saga的协调模式/113

4.2.1协同式Saga/113

4.2.2编排式Saga/117

4.3解决隔离问题/121

4.3.1缺乏隔离导致的问题/122

4.3.2Saga模式下实现隔离的对策/123

4.4OrderService和CreateOrderSaga的设计/127

4.4.1OrderService类/128

4.4.2CreateOrderSaga的实现/129

4.4.3OrderCommandHandlers类/136

4.4.4OrderServiceConfiguration类/138

第5章微服务架构中的业务逻辑设计/141

5.1业务逻辑组织模式/142

5.1.1使用事务脚本模式设计业务逻辑/143

5.1.2使用领域模型模式设计业务逻辑/144

5.1.3关于领域驱动设计/146

5.2使用聚合模式设计领域模型/146

5.2.1模糊边界所带来的问题/147

5.2.2聚合拥有明确的边界/149

5.2.3聚合的规则/150

5.2.4聚合的颗粒度/152

5.2.5使用聚合设计业务逻辑/153

5.3发布领域事件/154

5.3.1为什么需要发布变更事件/154

5.3.2什么是领域事件/155

5.3.3事件增强/155

5.3.4识别领域事件/156

5.3.5生成和发布领域事件/157

5.3.6消费领域事件/161

5.4KitchenService的业务逻辑/162

5.5OrderService的业务逻辑/167

5.5.1Order聚合/169

5.5.2OrderService类/173

第6章使用事件溯源开发业务逻辑/176

6.1使用事件溯源开发业务逻辑概述/177

6.1.1传统持久化技术的问题/177

6.1.2什么是事件溯源/179

6.1.3使用乐观锁处理并发更新/186

6.1.4事件溯源和发布事件/186

6.1.5使用快照提升性能/188

6.1.6幂等方式的消息处理/189

6.1.7领域事件的演化/190

6.1.8事件溯源的好处/192

6.1.9事件溯源的弊端/193

6.2实现事件存储库/194

6.2.1EventuateLocal事件存储库的工作原理/195

6.2.2Eventuate的Java客户端框架/198

6.3同时使用Saga和事件溯源/201

6.3.1使用事件溯源实现协同式Saga/203

6.3.2创建编排式Saga/203

6.3.3实现基于事件溯源的Saga参与方/205

6.3.4实现基于事件溯源的Saga编排器/208

第7章在微服务架构中实现查询/212

7.1使用API组合模式进行查询/213

7.1.1findOrder()查询操作/213

7.1.2什么是API组合模式/214

7.1.3使用API组合模式实现findOrder()查询操作/215

7.1.4API组合模式的设计缺陷/216

7.1.5API组合模式的好处和弊端/219

7.2使用CQRS模式/220

7.2.1为什么要使用CQRS/220

7.2.2什么是CQRS/223

7.2.3CQRS的好处/226

7.2.4CQRS的弊端/227

7.3设计CQRS视图/228

7.3.1选择视图存储库/229

7.3.2设计数据访问模块/230

7.3.3添加和更新CQRS视图/232

7.4实现基于AWSDynamoDB的CQRS视图/233

7.4.1OrderHistoryEventHandlers模块/234

7.4.2DynamoDB中的数据建模和查询设计/235

7.4.3OrderHistoryDaoDynamoDb类/239

第8章外部API模式/244

8.1外部API的设计难题/245

8.1.1FTGO移动客户端API的设计难题/246

8.1.2其他类型客户端API的设计难题/248

8.2APIGateway模式/250

8.2.1什么是APIGateway模式/250

8.2.2APIGateway模式的好处和弊端/256

8.2.3以Netflix为例的APIGateway/257

8.2.4APIGateway的设计难题/258

8.3实现一个APIGateway/260

8.3.1使用现成的APIGateway产品或服务/261

8.3.2开发自己的APIGateway/262

8.3.3使用GraphQL实现APIGateway/269

第9章微服务架构中的测试策略（上）/282

9.1微服务架构中的测试策略概述/284

9.1.1什么是测试/284

9.1.2微服务架构中的测试挑战/289

9.1.3部署流水线/295

9.2为服务编写单元测试/296

9.2.1为实体编写单元测试/298

9.2.2为值对象编写单元测试/299

9.2.3为Saga编写单元测试/300

9.2.4为领域服务编写单元测试/302

9.2.5为控制器编写单元测试/303

9.2.6为事件和消息处理程序编写单元测试/305

第10章微服务架构中的测试策略（下）/308

10.1编写集成测试/308

10.1.1针对持久化层的集成测试/311

10.1.2针对基于REST的请求/响应式交互的集成测试/312

10.1.3针对发布/订阅式交互的集成测试/316

10.1.4针对异步请求/响应式交互的集成契约测试/320

10.2编写组件测试/324

10.2.1定义验收测试/325

10.2.2使用Gherkin编写验收测试/326

10.2.3设计组件测试/328

10.2.4为FTGO的OrderService编写组件测试/330

10.3端到端测试/334

10.3.1设计端到端测试/335

10.3.2编写端到端测试/335

10.3.3运行端到端测试/336

第11章开发面向生产环境的微服务应用/338

11.1开发安全的服务/339

11.1.1传统单体应用程序的安全性/340

11.1.2在微服务架构中实现安全性/343

11.2设计可配置的服务/349

11.2.1使用基于推送的外部化配置/350

11.2.2使用基于拉取的外部化配置/352

11.3设计可观测的服务/353

11.3.1使用健康检查API模式/355

11.3.2使用日志聚合模式/357

11.3.3使用分布式追踪模式/358

11.3.4使用应用程序指标模式/361

11.3.5使用异常追踪模式/364

11.3.6使用审计日志模式/365

11.4使用微服务基底模式开发服务/367

11.4.1使用微服务基底/368

11.4.2从微服务基底到服务网格/368

第12章部署微服务应用/371

12.1部署模式：编程语言特定的发布包格式/374

12.1.1使用编程语言特定的发布包格式进行部署的好处/376

12.1.2使用编程语言特定的发布包格式进行部署的弊端/377

12.2部署模式：将服务部署为虚拟机/378

12.2.1将服务部署为虚拟机的好处/380

12.2.2将服务部署为虚拟机的弊端/380

12.3部署模式：将服务部署为容器/381

12.3.1使用Docker部署服务/383

12.3.2将服务部署为容器的好处/385

12.3.3将服务部署为容器的弊端/386

12.4使用Kubernetes部署FTGO应用程序/386

12.4.1什么是Kubernetes/386

12.4.2在Kubernetes上部署RestaurantService/389

12.4.3部署APIGateway/392

12.4.4零停机部署/393

12.4.5使用服务网格分隔部署与发布流程/394

12.5部署模式：Serverless部署/402

12.5.1使用AWSLambda进行Serverless部署/403

12.5.2开发Lambda函数/404

12.5.3调用Lambda函数/404

12.5.4使用Lambda函数的好处/405

12.5.5使用Lambda函数的弊端/406

12.6使用AWSLambda和AWSGateway部署RESTful服务/406

12.6.1AWSLambda版本的RestaurantService/407

12.6.2把服务打包为ZIP文件/411

12.6.3使用Serverless框架部署Lambda函数/412

第13章微服务架构的重构策略/415

13.1重构到微服务需要考虑的问题/416

13.1.1为什么要重构单体应用/416

13.1.2绞杀单体应用/417

13.2将单体应用重构为微服务架构的若干策略/420

13.2.1将新功能实现为服务/420

13.2.2隔离表现层与后端/422

13.2.3提取业务能力到服务中/423

13.3设计服务与单体的协作方式/429

13.3.1设计集成胶水/430

13.3.2在服务和单体之间维持数据一致性/434

13.3.3处理身份验证和访问授权/438

13.4将新功能实现为服务：处理错误配送订单/440

13.4.1DelayedDeliveryService的设计/441

13.4.2为DelayedDeliveryService设计集成胶水/442

13.5从单体中提取送餐管理功能/444

13.5.1现有的送餐管理功能/444

13.5.2DeliveryService概览/446

13.5.3设计DeliveryService的领域模型/447

13.5.4DeliveryService集成胶水的设计/450

13.5.5修改FTGO单体使其能够与DeliveryService交互/451

第1章 微服务概念 1

1.1 理解应用程序 2

1.1.1 领域驱动设计 2

1.1.2 单一职责原则 4

1.1.3 显式发布的接口 5

1.2 独立部署、更新、扩展以及替换 7

1.2.1 独立部署 7

1.2.2 更新 7

1.2.3 可扩展性 8

1.3 轻量级通信 12

1.3.1 同步 13

1.3.2 异步 13

1.4 异质/多语言 14

1.5 通信的文档化 14

1.6 Web应用程序端点 15

1.7 移动应用程序端点 15

1.8 缓存客户端 16

1.9 调节客户端 17

1.10 确定贫血域 17

1.11 确定fat域 18

1.12 针对业务确定微服务域 18

1.13 从域到实体 19

1.14 本章小结 20

第2章 微服务工具 21

2.1 编程语言 21

2.1.1 熟练程度 22

2.1.2 性能 22

2.1.3 实践开发 23

2.1.4 生态圈 23

2.1.5 扩展性的开销 24

2.1.6 选取编程语言 24

2.2 微服务框架 27

2.2.1 Python语言 27

2.2.2 Go语言 29

2.3 二进制通信—服务间的直接通信 31

2.3.1 理解通信方式 31

2.3.2 直接通信间的警示信息 35

2.4 消息代理—服务间的异步通信 37

2.4.1 ActiveMQ 38

2.4.2 RabbitMQ 39

2.4.3 Kafka 40

2.5 缓存工具 40

2.5.1 Memcached 42

2.5.2 Redis 42

2.6 故障警示工具 44

2.6.1 性能 44

2.6.2 构建 45

2.6.3 组件 46

2.6.4 实现鸿沟 47

2.7 数据库 47

2.8 本地性能度量 48

2.8.1 Apache Benchmark 49

2.8.2 WRK 50

2.8.3 Locust 51

2.9 本章小结 53

第3章 内部模式 55

3.1 开发结构 55

3.1.1 数据库 55

3.1.2 编程语言和工具 56

3.1.3 项目结构 56

3.2 缓存策略 71

3.2.1 缓存机制的应用 72

3.2.2 缓存优先 78

3.2.3 队列任务 79

3.2.4 异步机制和worker 81

3.3 CQRS—查询策略 87

3.3.1 CQRS的概念 87

3.3.2 理解CQRS 88

3.3.3 CQRS的优点和缺陷 90

3.4 事件源—数据完整性 91

3.5 本章小结 92

第4章 微服务生态环境 93

4.1 容器中的分离机制 93

4.1.1 分层服务架构 95

4.1.2 分离UsersService 96

4.2 存储分布 103

4.2.1 折旧数据 103

4.2.2 区域化数据 103

4.3 隔离—使用生态系统防止故障的出现 104

4.3.1 冗余设计 104

4.3.2 临界分区 109

4.3.3 隔离设计 110

4.3.4 快速故障 111

4.4 断路器 112

4.5 本章小结 113

第5章 共享数据微服务设计模式 115

5.1 理解模式 115

5.2 将单体应用程序划分为微服务 116

5.2.1 定义优先级 117

5.2.2 设置期限 117

5.2.3 定义应用程序域 117

5.2.4 试验操作 117

5.2.5 制定标准 118

5.2.6 构建原型 118

5.2.7 发送产品 118

5.2.8 开发新的微服务 118

5.3 数据编排 130

5.4 响应整合 132

5.5 微服务通信 132

5.6 存储共享反模式 133

5.7 最佳实践 133

5.8 测试机制 133

5.9 共享数据模式的利弊 135

5.10 本章小结 136

第6章 聚合器微服务设计模式 137

6.1 理解聚合器设计模式 137

6.2 使用CQRS和事件源 139

6.2.1 分离数据库 139

6.2.2 重构微服务 140

6.3 微服务通信 153

6.3.1 创建编排器 154

6.3.2 使用消息代理 159

6.4 模式扩展 163

6.5 瓶颈反模式 164

6.6 最佳实践 166

6.7 测试 167

6.7.1 功能测试 167

6.7.2 集成测试 168

6.8 聚合器设计模式的优缺点 170

6.8.1 聚合器设计模式的优点 170

6.8.2 聚合器设计模式的缺点 170

6.9 本章小结 170

第7章 代理微服务设计模式 171

7.1 代理方案 171

7.1.1 哑代理 172

7.1.2 智能代理 172

7.1.3 理解当前代理 173

7.2 编排器的代理策略 175

7.3 微服务通信 176

7.4 模式扩展性 176

7.5 最佳实践 177

7.5.1 纯粹的模式 177

7.5.2 瓶颈问题 178

7.5.3 代理制的缓存机制 178

7.5.4 简单的响应 178

7.6 代理设计模式的优缺点 179

7.7 本章小结 179

第8章 链式微服务设计模式 181

8.1 理解模式 181

8.2 数据编排和响应整合 184

8.3 微服务通信 185

8.4 模式扩展性 185

8.5 “大泥球”反模式 186

8.6 最佳实践方案 188

8.6.1 纯微服务 188

8.6.2 请求一致性数据 188

8.6.3 深入理解链式设计模式 189

8.6.4 关注通信层 189

8.7 链式设计模式的优缺点 189

8.8 本章小结 190

第9章 分支微服务设计模式 191

9.1 理解模式 191

9.2 数据编排和响应整合 194

9.3 微服务通信 195

9.4 模式扩展 197

9.5 最佳实践方案 198

9.5.1 域定义 198

9.5.2 遵守规则 198

9.5.3 关注物理组件 198

9.5.4 简化行为 199

9.6 分支设计模式的优缺点 199

9.7 本章小结 199

第10章 异步消息微服务 201

10.1 理解当前模式 201

10.2 域定义—RecommendationService 203

10.3 域定义—RecommendationService 204

10.4 微服务编码 204

10.5 微服务通信 211

10.5.1 使用消息代理和队列 211

10.5.2 准备pub/sub结构 212

10.6 模式的可扩展性 214

10.7 进程序列反模式 214

10.8 最佳实践方案 215

10.8.1 应用程序定义 215

10.8.2 不要尝试创建响应 216

10.8.3 保持简单性 216

10.9 异步消息传递设计模式的优缺点 216

10.10 本章小结 217

第11章 微服务间的协同工作 219

11.1 理解当前应用程序状态 219

11.1.1 公共饰面层 220

11.1.2 内部层 222

11.1.3 理解通用工具 223

11.2 通信层和服务间的委托 224

11.2.1 理解服务间的数据合约 225

11.2.2 使用二进制通信 228

11.3 模式分布 235

11.4 故障策略 236

11.5 API集成 237

11.6 本章小结 239

第12章 微服务测试 241

12.1 单元测试 241

12.2 针对集成测试配置容器 249

12.3 集成测试 251

12.4 端到端测试 253

12.5 发布管线 259

12.6 签名测试 259

12.7 Monkey测试 260

12.8 Chaos Monkey 260

12.9 本章小结 262

第13章 安全监测和部署方案 263

13.1 监测微服务 263

13.1.1 监测单一服务 264

13.1.2 监测多项服务 266

13.1.3 查看日志 267

13.1.4 应用程序中的错误 268

13.1.5 度量方法 271

13.2 安全问题 272

13.2.1 理解JWT 272

13.2.2 单点登录 275

13.2.3 数据安全 276

13.2.4 预防恶意攻击—识别攻击行为 277

13.2.5 拦截器 277

13.2.6 容器 278

13.2.7 API网关 279

13.3 部署 279

13.3.1 持续集成和持续交付/持续部署 280

13.3.2 蓝/绿部署模式和Canary发布 281

13.3.3 每台主机包含多个服务实例 282

13.3.4 每台主机的服务实例 283

13.4 本章小结 285

