第1章　计算机系统漫游1
1.1　信息就是位+上下文1
1.2　程序被其他程序翻译成不同的格式3
1.3　了解编译系统如何工作是大有益处的4
1.4　处理器读并解释储存在内存中的指令5
1.4.1　系统的硬件组成5
1.4.2　运行hello程序7
1.5　高速缓存至关重要9
1.6　存储设备形成层次结构9
1.7　操作系统管理硬件10
1.7.1　进程11
1.7.2　线程12
1.7.3　虚拟内存12
1.7.4　文件14
1.8　系统之间利用网络通信14
1.9　重要主题16
1.9.1　Amdahl定律16
1.9.2　并发和并行17
1.9.3　计算机系统中抽象的重要性19
1.10　小结20
参考文献说明20
练习题答案20
第一部分
程序结构和执行
第2章　信息的表示和处理22
2.1　信息存储24
2.1.1　十六进制表示法25
2.1.2　字数据大小27
2.1.3　寻址和字节顺序29
2.1.4　表示字符串34
2.1.5　表示代码34
2.1.6　布尔代数简介35
2.1.7　C语言中的位级运算37
2.1.8　C语言中的逻辑运算39
2.1.9　C语言中的移位运算40
2.2　整数表示41
2.2.1　整型数据类型42
2.2.2　无符号数的编码43
2.2.3　补码编码44
2.2.4　有符号数和无符号数之间的转换49
2.2.5　C语言中的有符号数与无符号数52
2.2.6　扩展一个数字的位表示54
2.2.7　截断数字56
2.2.8　关于有符号数与无符号数的建议58
2.3　整数运算60
2.3.1　无符号加法60
2.3.2　补码加法62
2.3.3　补码的非66
2.3.4　无符号乘法67
2.3.5　补码乘法67
2.3.6　乘以常数70
2.3.7　除以2的幂71
2.3.8　关于整数运算的最后思考74
2.4　浮点数75
2.4.1　二进制小数76
2.4.2　IEEE浮点表示78
2.4.3　数字示例79
2.4.4　舍入83
2.4.5　浮点运算85
2.4.6　C语言中的浮点数86
2.5　小结87
参考文献说明88
家庭作业88
练习题答案97
第3章　程序的机器级表示109
3.1　历史观点110
3.2　程序编码113
3.2.1　机器级代码113
3.2.2　代码示例114
3.2.3　关于格式的注解117
3.3　数据格式119
3.4　访问信息119
3.4.1　操作数指示符121
3.4.2　数据传送指令122
3.4.3　数据传送示例125
3.4.4　压入和弹出栈数据127
3.5　算术和逻辑操作128
3.5.1　加载有效地址129
3.5.2　一元和二元操作130
3.5.3　移位操作131
3.5.4　讨论131
3.5.5　特殊的算术操作133
3.6　控制135
3.6.1　条件码135
3.6.2　访问条件码136
3.6.3　跳转指令138
3.6.4　跳转指令的编码139
3.6.5　用条件控制来实现条件分支…141
3.6.6　用条件传送来实现条件分支…145
3.6.7　循环149
3.6.8　switch语句159
3.7　过程164
3.7.1　运行时栈164
3.7.2　转移控制165
3.7.3　数据传送168
3.7.4　栈上的局部存储170
3.7.5　寄存器中的局部存储空间172
3.7.6　递归过程174
3.8　数组分配和访问176
3.8.1　基本原则176
3.8.2　指针运算177
3.8.3　嵌套的数组178
3.8.4　定长数组179
3.8.5　变长数组181
3.9　异质的数据结构183
3.9.1　结构183
3.9.2　联合186
3.9.3　数据对齐189
3.10　在机器级程序中将控制与数据结合起来192
3.10.1　理解指针192
3.10.2　应用：使用GDB调试器193
3.10.3　内存越界引用和缓冲区溢出194
3.10.4　对抗缓冲区溢出攻击198
3.10.5　支持变长栈帧201
3.11　浮点代码204
3.11.1　浮点传送和转换操作205
3.11.2　过程中的浮点代码209
3.11.3　浮点运算操作210
3.11.4　定义和使用浮点常数212
3.11.5　在浮点代码中使用位级操作212
3.11.6　浮点比较操作213
3.11.7　对浮点代码的观察结论215
3.12　小结216
参考文献说明216
家庭作业216
练习题答案226
第4章　处理器体系结构243
4.1　Y86-64指令集体系结构245
4.1.1　程序员可见的状态245
4.1.2　Y86-64指令245
4.1.3　指令编码246
4.1.4　Y86-64异常250
4.1.5　Y86-64程序251
4.1.6　一些Y86-64指令的详情255
4.2　逻辑设计和硬件控制语言HCL256
4.2.1　逻辑门257
4.2.2　组合电路和HCL布尔表达式257
4.2.3　字级的组合电路和HCL整数表达式258
4.2.4　集合关系261
4.2.5　存储器和时钟262
4.3　Y86-64的顺序实现264
4.3.1　将处理组织成阶段264
4.3.2　SEQ硬件结构272
4.3.3　SEQ的时序274
4.3.4　SEQ阶段的实现277
4.4　流水线的通用原理282
4.4.1　计算流水线282
4.4.2　流水线操作的详细说明284
4.4.3　流水线的局限性284
4.4.4　带反馈的流水线系统287
4.5　Y86-64的流水线实现288
4.5.1　SEQ+：重新安排计算阶段288
4.5.2　插入流水线寄存器289
4.5.3　对信号进行重新排列和标号292
4.5.4　预测下一个PC293
4.5.5　流水线冒险295
4.5.6　异常处理306
4.5.7　PIPE各阶段的实现308
4.5.8　流水线控制逻辑314
4.5.9　性能分析322
4.5.10　未完成的工作323
4.6　小结325
参考文献说明326
家庭作业327
练习题答案331
第5章　优化程序性能341
5.1　优化编译器的能力和局限性342
5.2　表示程序性能345
5.3　程序示例347
5.4　消除循环的低效率350
5.5　减少过程调用353
5.6　消除不必要的内存引用354
5.7　理解现代处理器357
5.7.1　整体操作357
5.7.2　功能单元的性能361
5.7.3　处理器操作的抽象模型362
5.8　循环展开366
5.9　提高并行性369
5.9.1　多个累积变量370
5.9.2　重新结合变换373
5.10　优化合并代码的结果小结377
5.11　一些限制因素378
5.11.1　寄存器溢出378
5.11.2　分支预测和预测错误处罚379
5.12　理解内存性能382
5.12.1　加载的性能382
5.12.2　存储的性能383
5.13　应用：性能提高技术387
5.14　确认和消除性能瓶颈388
5.14.1　程序剖析388
5.14.2　使用剖析程序来指导优化390
5.15　小结392
参考文献说明393
家庭作业393
练习题答案395
第6章　存储器层次结构399
6.1　存储技术399
6.1.1　随机访问存储器400
6.1.2　磁盘存储406
6.1.3　固态硬盘414
6.1.4　存储技术趋势415
6.2　局部性418
6.2.1　对程序数据引用的局部性418
6.2.2　取指令的局部性419
6.2.3　局部性小结420
6.3　存储器层次结构421
6.3.1　存储器层次结构中的缓存422
6.3.2　存储器层次结构概念小结424
6.4　高速缓存存储器425
6.4.1　通用的高速缓存存储器组织结构425
6.4.2　直接映射高速缓存427
6.4.3　组相联高速缓存433
6.4.4　全相联高速缓存434
6.4.5　有关写的问题437
6.4.6　一个真实的高速缓存层次结构的解剖438
6.4.7　高速缓存参数的性能影响439
6.5　编写高速缓存友好的代码440
6.6　综合：高速缓存对程序性能的影响444
6.6.1　存储器山444
6.6.2　重新排列循环以提高空间局部性447
6.6.3　在程序中利用局部性450
6.7　小结450
参考文献说明451
家庭作业451
练习题答案459
第二部分
在系统上运行程序
第7章　链接464
7.1　编译器驱动程序465
7.2　静态链接466
7.3　目标文件466
7.4　可重定位目标文件467
7.5　符号和符号表468
7.6　符号解析470
7.6.1　链接器如何解析多重定义的全局符号471
7.6.2　与静态库链接475
7.6.3　链接器如何使用静态库来解析引用477
7.7　重定位478
7.7.1　重定位条目479
7.7.2　重定位符号引用479
7.8　可执行目标文件483
7.9　加载可执行目标文件484
7.10　动态链接共享库485
7.11　从应用程序中加载和链接共享库487
7.12　位置无关代码489
7.13　库打桩机制492
7.13.1　编译时打桩492
7.13.2　链接时打桩492
7.13.3　运行时打桩494
7.14　处理目标文件的工具496
7.15　小结496
参考文献说明497
家庭作业497
练习题答案499
第8章　异常控制流501
8.1　异常502
8.1.1　异常处理503
8.1.2　异常的类别504
8.1.3　Linux/x86-64系统中的异常505
8.2　进程508
8.2.1　逻辑控制流508
8.2.2　并发流509
8.2.3　私有地址空间509
8.2.4　用户模式和内核模式510
8.2.5　上下文切换511
8.3　系统调用错误处理512
8.4　进程控制513
8.4.1　获取进程ID513
8.4.2　创建和终止进程513
8.4.3　回收子进程516
8.4.4　让进程休眠521
8.4.5　加载并运行程序521
8.4.6　利用fork和execve运行程序524
8.5　信号526
8.5.1　信号术语527
8.5.2　发送信号528
8.5.3　接收信号531
8.5.4　阻塞和解除阻塞信号532
8.5.5　编写信号处理程序533
8.5.6　同步流以避免讨厌的并发错误540
8.5.7　显式地等待信号543
8.6　非本地跳转546
8.7　操作进程的工具550
8.8　小结550
参考文献说明550
家庭作业550
练习题答案556
第9章　虚拟内存559
9.1　物理和虚拟寻址560
9.2　地址空间560
9.3　虚拟内存作为缓存的工具561
9.3.1　DRAM缓存的组织结构562
9.3.2　页表562
9.3.3　页命中563
9.3.4　缺页564
9.3.5　分配页面565
9.3.6　又是局部性救了我们565
9.4　虚拟内存作为内存管理的工具565
9.5　虚拟内存作为内存保护的工具567
9.6　地址翻译567
9.6.1　结合高速缓存和虚拟内存570
9.6.2　利用TLB加速地址翻译570
9.6.3　多级页表571
9.6.4　综合：端到端的地址翻译573
9.7　案例研究：Intel Core i7/Linux内存系统576
9.7.1　Core i7地址翻译576
9.7.2　Linux虚拟内存系统580
9.8　内存映射582
9.8.1　再看共享对象583
9.8.2　再看fork函数584
9.8.3　再看execve函数584
9.8.4　使用mmap函数的用户级内存映射585
9.9　动态内存分配587
9.9.1　malloc和free函数587
9.9.2　为什么要使用动态内存分配589
9.9.3　分配器的要求和目标590
9.9.4　碎片591
9.9.5　实现问题592
9.9.6　隐式空闲链表592
9.9.7　放置已分配的块593
9.9.8　分割空闲块594
9.9.9　获取额外的堆内存594
9.9.10　合并空闲块594
9.9.11　带边界标记的合并595
9.9.12　综合：实现一个简单的分配器597
9.9.13　显式空闲链表603
9.9.14　分离的空闲链表604
9.10　垃圾收集605
9.10.1　垃圾收集器的基本知识606
9.10.2　Mark&Sweep垃圾收集器607
9.10.3　C程序的保守Mark&Sweep608
9.11　C程序中常见的与内存有关的错误609
9.11.1　间接引用坏指针609
9.11.2　读未初始化的内存609
9.11.3　允许栈缓冲区溢出610
9.11.4　假设指针和它们指向的对象是相同大小的610
9.11.5　造成错位错误611
9.11.6　引用指针，而不是它所指向的对象611
9.11.7　误解指针运算611
9.11.8　引用不存在的变量612
9.11.9　引用空闲堆块中的数据612
9.11.10　引起内存泄漏613
9.12　小结613
参考文献说明613
家庭作业614
练习题答案617
第三部分
程序间的交互和通信
第10章　系统级I/O622　10.1　Unix I/O622
10.2　文件623
10.3　打开和关闭文件624
10.4　读和写文件625
10.5　用RIO包健壮地读写626
10.5.1　RIO的无缓冲的输入输出函数627
10.5.2　RIO的带缓冲的输入函数627
10.6　读取文件元数据632
10.7　读取目录内容633
10.8　共享文件634
10.9　I/O重定向637
10.10　标准I/O638
10.11　综合：我该使用哪些I/O函数？638
10.12　小结640
参考文献说明640
家庭作业640
练习题答案641
第11章　网络编程642
11.1　客户端服务器编程模型642
11.2　网络643
11.3　全球IP因特网646
11.3.1　IP地址647
11.3.2　因特网域名649
11.3.3　因特网连接651
11.4　套接字接口652
11.4.1　套接字地址结构653
11.4.2　socket函数654
11.4.3　connect函数654
11.4.4　bind函数654
11.4.5　listen函数655
11.4.6　accept函数655
11.4.7　主机和服务的转换656
11.4.8　套接字接口的辅助函数660
11.4.9　echo客户端和服务器的示例662
11.5　Web服务器665
11.5.1　Web基础665
11.5.2　Web内容666
11.5.3　HTTP事务667
11.5.4　服务动态内容669
11.6　综合：TINY Web服务器671
11.7　小结678
参考文献说明678
家庭作业678
练习题答案679
第12章　并发编程681
12.1　基于进程的并发编程682
12.2　基于I/O多路复用的并发编程684
12.3　基于线程的并发编程691
12.4　多线程程序中的共享变量696
12.5　用信号量同步线程698
12.6　使用线程提高并行性710
12.7　其他并发问题716
12.8　小结722
参考文献说明723
家庭作业723
练习题答案726
附录A　错误处理729
参考文献733
《算法导论（原书第3版）》
出版者的话
译者序
前言
第一部分　基础知识
第1章　算法在计算中的作用
第2章　算法基础
第3章　函数的增长
第4章　分治策略
第5章　概率分析和随机算法
第二部分　排序和顺序统计量
第6章　堆排序
第7章　快速排序
第8章　线性时间排序
第9章　中位数和顺序统计量
第三部分　数据结构
第10章　基本数据结构
第11章　散列表
第12章　二叉搜索树
第13章　红黑树
第14章　数据结构的扩张
第四部分　高级设计和分析技术
第15章　动态规划
第16章　贪心算法
第17章　摊还分析
第五部分　高级数据结构
第18章　B树
第19章　斐波那契堆
第20章　van Emde Boas树
第21章　用于不相交集合的数据结构
第六部分　图算法
第22章　基本的图算法
第23章　最小生成树
第24章　单源最短路径
第25章　所有结点对的最短路径问题
第26章　最大流
第七部分　算法问题选编
第27章　多线程算法
第28章　矩阵运算
第29章　线性规划
第30章　多项式与快速傅里叶变换
第31章　数论算法
第32章　字符串匹配
第33章　计算几何学
第34章　NP完全性
第35章　近似算法


第1章　引论1
1.1　什么是操作系统2
1.1.1　作为扩展机器的操作系统2
1.1.2　作为资源管理者的操作系统3
1.2　操作系统的历史4
1.2.1　第一代（1945～1955）：真空管和穿孔卡片4
1.2.2　第二代（1955～1965）：晶体管和批处理系统4
1.2.3　第三代（1965～1980）：集成电路和多道程序设计6
1.2.4　第四代（1980年至今）：个人计算机8
1.2.5　第五代（1990年至今）：移动计算机10
1.3　计算机硬件简介11
1.3.1　处理器12
1.3.2　存储器14
1.3.3　磁盘15
1.3.4　I/O设备16
1.3.5　总线18
1.3.6　启动计算机19
1.4　操作系统大观园20
1.4.1　大型机操作系统20
1.4.2　服务器操作系统20
1.4.3　多处理器操作系统20
1.4.4　个人计算机操作系统20
1.4.5　掌上计算机操作系统21
1.4.6　嵌入式操作系统21
1.4.7　传感器节点操作系统21
1.4.8　实时操作系统21
1.4.9　智能卡操作系统21
1.5　操作系统概念22
1.5.1　进程22
1.5.2　地址空间23
1.5.3　文件23
1.5.4　输入/输出25
1.5.5　保护25
1.5.6　shell25
1.5.7　个体重复系统发育26
1.6　系统调用28
1.6.1　用于进程管理的系统调用31
1.6.2　用于文件管理的系统调用32
1.6.3　用于目录管理的系统调用32
1.6.4　各种系统调用34
1.6.5　Windows Win32 API34
1.7　操作系统结构35
1.7.1　单体系统36
1.7.2　层次式系统36
1.7.3　微内核37
1.7.4　客户端–服务器模式38
1.7.5　虚拟机39
1.7.6　外核41
1.8　依靠C的世界41
1.8.1　C语言41
1.8.2　头文件41
1.8.3　大型编程项目43
1.8.4　运行模型43
1.9　有关操作系统的研究44
1.10　本书其他部分概要45
1.11　公制单位45
1.12　小结46
习题46
第2章　进程与线程48
2.1　进程48
2.1.1　进程模型48
2.1.2　进程的创建49
2.1.3　进程的终止51
2.1.4　进程的层次结构51
2.1.5　进程的状态51
2.1.6　进程的实现53
2.1.7　多道程序设计模型54
2.2　线程54
2.2.1　线程的使用54
2.2.2　经典的线程模型57
2.2.3　POSIX线程60
2.2.4　在用户空间中实现线程60
2.2.5　在内核中实现线程63
2.2.6　混合实现63
2.2.7　调度程序激活机制64
2.2.8　弹出式线程64
2.2.9　使单线程代码多线程化65
2.3　进程间通信67
2.3.1　竞争条件67
2.3.2　临界区68
2.3.3　忙等待的互斥68
2.3.4　睡眠与唤醒71
2.3.5　信号量73
2.3.6　互斥量74
2.3.7　管程78
2.3.8　消息传递81
2.3.9　屏障82
2.3.10　避免锁：读–复制–更新83
2.4　调度84
2.4.1　调度简介84
2.4.2　批处理系统中的调度88
2.4.3　交互式系统中的调度89
2.4.4　实时系统中的调度92
2.4.5　策略和机制93
2.4.6　线程调度93
2.5　经典的IPC问题94
2.5.1　哲学家就餐问题94
2.5.2　读者–写者问题96
2.6　有关进程与线程的研究97
2.7　小结97
习题98
第3章　内存管理102
3.1　无存储器抽象102
3.2　一种存储器抽象：地址空间104
3.2.1　地址空间的概念104
3.2.2　交换技术106
3.2.3　空闲内存管理107
3.3　虚拟内存109
3.3.1　分页110
3.3.2　页表112
3.3.3　加速分页过程112
3.3.4　针对大内存的页表114
3.4　页面置换算法117
3.4.1　最优页面置换算法117
3.4.2　最近未使用页面置换算法118
3.4.3　先进先出页面置换算法118
3.4.4　第二次机会页面置换算法118
3.4.5　时钟页面置换算法119
3.4.6　最近最少使用页面置换算法119
3.4.7　用软件模拟LRU120
3.4.8　工作集页面置换算法121
3.4.9　工作集时钟页面置换算法123
3.4.10　页面置换算法小结124
3.5　分页系统中的设计问题124
3.5.1　局部分配策略与全局分配策略124
3.5.2　负载控制126
3.5.3　页面大小126
3.5.4　分离的指令空间和数据空间127
3.5.5　共享页面128
3.5.6　共享库128
3.5.7　内存映射文件130
3.5.8　清除策略130
3.5.9　虚拟内存接口130
3.6　有关实现的问题131
3.6.1　与分页有关的工作131
3.6.2　缺页中断处理131
3.6.3　指令备份132
3.6.4　锁定内存中的页面132
3.6.5　后备存储133
3.6.6　策略和机制的分离134
3.7　分段134
3.7.1　纯分段的实现136
3.7.2　分段和分页结合：MULTICS136
3.7.3　分段和分页结合：Intel x86138
3.8　有关内存管理的研究141
3.9　小结141
习题142
第4章　文件系统147
4.1　文件148
4.1.1　文件命名148
4.1.2　文件结构149
4.1.3　文件类型149
4.1.4　文件访问151
4.1.5　文件属性151
4.1.6　文件操作152
4.1.7　使用文件系统调用的一个示例程序152
4.2　目录154
4.2.1　一级目录系统154
4.2.2　层次目录系统154
4.2.3　路径名154
4.2.4　目录操作156
4.3　文件系统的实现157
4.3.1　文件系统布局157
4.3.2　文件的实现157
4.3.3　目录的实现160
4.3.4　共享文件162
4.3.5　日志结构文件系统163
4.3.6　日志文件系统164
4.3.7　虚拟文件系统165
4.4　文件系统管理和优化167
4.4.1　磁盘空间管理167
4.4.2　文件系统备份171
4.4.3　文件系统的一致性174

1.1操作系统的功能 2



1.1.1用户视角 2



1.1.2系统视角 3



1.1.3操作系统的定义 4



1.2计算机系统的组成 4



1.2.1计算机系统的运行 5



1.2.2存储结构 6



1.2.3I/O结构 8



1.3计算机系统的体系结构 9



1.3.1单处理器系统 9



1.3.2多处理器系统 10



1.3.3集群系统 12



1.4操作系统的结构 13



1.5操作系统的执行 14



1.5.1双重模式与多重模式的执行 15



1.5.2定时器 16



1.6进程管理 17



1.7内存管理 18



1.8存储管理 18



1.8.1文件系统管理 18



1.8.2大容量存储器管理 19



1.8.3高速缓存 19



1.8.4I/O系统 21



1.9保护与安全 21



1.10内核数据结构 22



1.10.1列表、堆栈及队列 22



1.10.2树 23



1.10.3哈希函数与哈希表 23



1.10.4位图 24



1.11计算环境 24



1.11.1传统计算 24



1.11.2移动计算 25



1.11.3分布计算 26



1.11.4客户机-服务器计算 26



1.11.5对等计算 27



1.11.6虚拟化 28



1.11.7云计算 29



1.11.8实时嵌入式系统 30



1.12开源操作系统 31



1.12.1历史 31



1.12.2Linux 31



1.12.3BSD UNIX 32



1.12.4Solaris 32



1.12.5用作学习的开源操作系统 33



1.13小结 33



习题 35



推荐读物 36



参考文献 36



第2章操作系统结构 38



2.1操作系统的服务 38



2.2用户与操作系统的界面 40



2.2.1命令解释程序 40



2.2.2图形用户界面 41



2.2.3界面的选择 42



2.3系统调用 43



2.4系统调用的类型 46



2.4.1进程控制 46



2.4.2文件管理 49



2.4.3设备管理 50



2.4.4信息维护 50



2.4.5通信 50



2.4.6保护 51



2.5系统程序 51



2.6操作系统的设计与实现 52



2.6.1设计目标 52



2.6.2机制与策略 53



2.6.3实现 53



2.7操作系统的结构 54



2.7.1简单结构 54



2.7.2分层方法 55



2.7.3微内核 56



2.7.4模块 57



2.7.5混合系统 58



2.8操作系统的调试 60



2.8.1故障分析 60



2.8.2性能优化 60



2.8.3DTrace 61



2.9操作系统的生成 63



2.10系统引导 64



2.11小结 64



习题 65



编程题 66



编程项目 66



推荐读物 69



参考文献 69



第二部分　进程管理



第3章　进程 72



3.1进程概念 72



3.1.1进程 72



3.1.2进程状态 73



3.1.3进程控制块 73



3.1.4线程 74



3.2进程调度 75



3.2.1调度队列 75



3.2.2调度程序 77



3.2.3上下文切换 78



3.3进程运行 79



3.3.1进程创建 79



3.3.2进程终止 82



3.4进程间通信 83



3.4.1共享内存系统 85



3.4.2消息传递系统 86



3.5IPC系统例子 89



3.5.1例子：POSIX共享内存 89



3.5.2例子：Mach 91



3.5.3例子：Windows 92



3.6客户机/服务器通信 93



3.6.1套接字 93



3.6.2远程过程调用 96



3.6.3管道 98



3.7小结 102



习题 103



编程题 105



编程项目 107



推荐读物 110



参考文献 110



第4章　多线程编程 112



4.1概述 112



4.1.1动机 112



4.1.2优点 113



4.2多核编程 114



4.2.1编程挑战 115



4.2.2并行类型 115



4.3多线程模型 116



4.3.1多对一模型 116



4.3.2一对一模型 116



4.3.3多对多模型 116



4.4线程库 117



4.4.1Pthreads 118



4.4.2Windows线程 119



4.4.3Java线程 121



4.5隐式多线程 122



4.5.1线程池 123



4.5.2OpenMP 124



4.5.3大中央调度 125



4.5.4其他方法 125



4.6多线程问题 125



4.6.1系统调用fork()和exec() 125



4.6.2信号处理 126



4.6.3线程撤销 127



4.6.4线程本地存储 128



4.6.5调度程序激活 128



4.7操作系统例子 129



4.7.1Windows线程 129



4.7.2Linux线程 130



4.8小结 131



习题 131



编程题 133



编程项目 134



推荐读物 136



参考文献 136



第5章　进程调度 138



5.1基本概念 138



5.1.1CPU-I/O执行周期 138



5.1.2CPU调度程序 139



5.1.3抢占调度 139



5.1.4调度程序 140



5.2调度准则 140



5.3调度算法 141



5.3.1先到先服务调度 141



5.3.2最短作业优先调度 142



5.3.3优先级调度 144



5.3.4轮转调度 145



5.3.5多级队列调度 147



5.3.6多级反馈队列调度 148



5.4线程调度 149



5.4.1竞争范围 149



5.4.2Pthreads调度 149



5.5多处理器调度 151



5.5.1多处理器调度的方法 151



5.5.2处理器亲和性 151



5.5.3负载平衡 152



5.5.4多核处理器 152



5.6实时CPU调度 154



5.6.1最小化延迟 154



5.6.2优先权调度 155



5.6.3单调速率调度 156



5.6.4最早截止期限优先调度 157



5.6.5比例分享调度 158



5.6.6POSIX实时调度 158



5.7操作系统例子 160



5.7.1例子：Linux调度 160



5.7.2例子：Windows调度 162



5.7.3例子：Solaris调度 164



5.8算法评估 165



5.8.1确定性模型 166



5.8.2排队模型 167



5.8.3仿真 167



5.8.4实现 168



5.9小结 169



习题 170



推荐读物 172



参考文献 173



第6章　同步 175



6.1背景 175



6.2临界区问题 177



6.3Peterson解决方案 178



6.4硬件同步 179



6.5互斥锁 181



6.6信号量

1.1　信息就是位+上下文1

1.2　程序被其他程序翻译成不同的格式3

1.3　了解编译系统如何工作是大有益处的4

1.4　处理器读并解释储存在内存中的指令5

1.4.1　系统的硬件组成5

1.4.2　运行hello程序7

1.5　高速缓存至关重要9

1.6　存储设备形成层次结构9

1.7　操作系统管理硬件10

1.7.1　进程11

1.7.2　线程12

1.7.3　虚拟内存12

1.7.4　文件14

1.8　系统之间利用网络通信14

1.9　重要主题16

1.9.1　Amdahl定律16

1.9.2　并发和并行17

1.9.3　计算机系统中抽象的重要性19

1.10　小结20

参考文献说明20

练习题答案20

第一部分

程序结构和执行

第2章　信息的表示和处理22

2.1　信息存储24

2.1.1　十六进制表示法25

2.1.2　字数据大小27

2.1.3　寻址和字节顺序29

2.1.4　表示字符串34

2.1.5　表示代码34

2.1.6　布尔代数简介35

2.1.7　C语言中的位级运算37

2.1.8　C语言中的逻辑运算39

2.1.9　C语言中的移位运算40

2.2　整数表示41

2.2.1　整型数据类型42

2.2.2　无符号数的编码43

2.2.3　补码编码44

2.2.4　有符号数和无符号数之间的转换49

2.2.5　C语言中的有符号数与无符号数52

2.2.6　扩展一个数字的位表示54

2.2.7　截断数字56

2.2.8　关于有符号数与无符号数的建议58

2.3　整数运算60

2.3.1　无符号加法60

2.3.2　补码加法62

2.3.3　补码的非66

2.3.4　无符号乘法67

2.3.5　补码乘法67

2.3.6　乘以常数70

2.3.7　除以2的幂71

2.3.8　关于整数运算的最后思考74

2.4　浮点数75

2.4.1　二进制小数76

2.4.2　IEEE浮点表示78

2.4.3　数字示例79

2.4.4　舍入83

2.4.5　浮点运算85

2.4.6　C语言中的浮点数86

2.5　小结87

参考文献说明88

家庭作业88

练习题答案97

第3章　程序的机器级表示109

3.1　历史观点110

3.2　程序编码113

3.2.1　机器级代码113

3.2.2　代码示例114

3.2.3　关于格式的注解117

3.3　数据格式119

3.4　访问信息119

3.4.1　操作数指示符121

3.4.2　数据传送指令122

3.4.3　数据传送示例125

3.4.4　压入和弹出栈数据127

3.5　算术和逻辑操作128

3.5.1　加载有效地址129

3.5.2　一元和二元操作130

3.5.3　移位操作131

3.5.4　讨论131

3.5.5　特殊的算术操作133

3.6　控制135

3.6.1　条件码135

3.6.2　访问条件码136

3.6.3　跳转指令138

3.6.4　跳转指令的编码139

3.6.5　用条件控制来实现条件分支…141

3.6.6　用条件传送来实现条件分支…145

3.6.7　循环149

3.6.8　switch语句159

3.7　过程164

3.7.1　运行时栈164

3.7.2　转移控制165

3.7.3　数据传送168

3.7.4　栈上的局部存储170

3.7.5　寄存器中的局部存储空间172

3.7.6　递归过程174

3.8　数组分配和访问176

3.8.1　基本原则176

3.8.2　指针运算177

3.8.3　嵌套的数组178

3.8.4　定长数组179

3.8.5　变长数组181

3.9　异质的数据结构183

3.9.1　结构183

3.9.2　联合186

3.9.3　数据对齐189

3.10　在机器级程序中将控制与数据结合起来192

3.10.1　理解指针192

3.10.2　应用：使用GDB调试器193

3.10.3　内存越界引用和缓冲区溢出194

3.10.4　对抗缓冲区溢出攻击198

3.10.5　支持变长栈帧201

3.11　浮点代码204

3.11.1　浮点传送和转换操作205

3.11.2　过程中的浮点代码209

3.11.3　浮点运算操作210

3.11.4　定义和使用浮点常数212

3.11.5　在浮点代码中使用位级操作212

3.11.6　浮点比较操作213

3.11.7　对浮点代码的观察结论215

3.12　小结216

参考文献说明216

家庭作业216

练习题答案226

第4章　处理器体系结构243

4.1　Y86-64指令集体系结构245

4.1.1　程序员可见的状态245

4.1.2　Y86-64指令245

4.1.3　指令编码246

4.1.4　Y86-64异常250

4.1.5　Y86-64程序251

4.1.6　一些Y86-64指令的详情255

4.2　逻辑设计和硬件控制语言HCL256

4.2.1　逻辑门257

4.2.2　组合电路和HCL布尔表达式257

4.2.3　字级的组合电路和HCL整数表达式258

4.2.4　集合关系261

4.2.5　存储器和时钟262

4.3　Y86-64的顺序实现264

4.3.1　将处理组织成阶段264

4.3.2　SEQ硬件结构272

4.3.3　SEQ的时序274

4.3.4　SEQ阶段的实现277

4.4　流水线的通用原理282

4.4.1　计算流水线282

4.4.2　流水线操作的详细说明284

4.4.3　流水线的局限性284

4.4.4　带反馈的流水线系统287

4.5　Y86-64的流水线实现288

4.5.1　SEQ+：重新安排计算阶段288

4.5.2　插入流水线寄存器289

4.5.3　对信号进行重新排列和标号292

4.5.4　预测下一个PC293

4.5.5　流水线冒险295

4.5.6　异常处理306

4.5.7　PIPE各阶段的实现308

4.5.8　流水线控制逻辑314

4.5.9　性能分析322

4.5.10　未完成的工作323

4.6　小结325

参考文献说明326

家庭作业327

练习题答案331

第5章　优化程序性能341

5.1　优化编译器的能力和局限性342

5.2　表示程序性能345

5.3　程序示例347

5.4　消除循环的低效率350

5.5　减少过程调用353

5.6　消除不必要的内存引用354

5.7　理解现代处理器357

5.7.1　整体操作357

5.7.2　功能单元的性能361

5.7.3　处理器操作的抽象模型362

5.8　循环展开366

5.9　提高并行性369

5.9.1　多个累积变量370

5.9.2　重新结合变换373

5.10　优化合并代码的结果小结377

5.11　一些限制因素378

5.11.1　寄存器溢出378

5.11.2　分支预测和预测错误处罚379

5.12　理解内存性能382

5.12.1　加载的性能382

5.12.2　存储的性能383

5.13　应用：性能提高技术387

5.14　确认和消除性能瓶颈388

5.14.1　程序剖析388

5.14.2　使用剖析程序来指导优化390

5.15　小结392

参考文献说明393

家庭作业393

练习题答案395

第6章　存储器层次结构399

6.1　存储技术399

6.1.1　随机访问存储器400

6.1.2　磁盘存储406

6.1.3　固态硬盘414

6.1.4　存储技术趋势415

6.2　局部性418

6.2.1　对程序数据引用的局部性418

6.2.2　取指令的局部性419

6.2.3　局部性小结420

6.3　存储器层次结构421

6.3.1　存储器层次结构中的缓存422

6.3.2　存储器层次结构概念小结424

6.4　高速缓存存储器425

6.4.1　通用的高速缓存存储器组织结构425

6.4.2　直接映射高速缓存427

6.4.3　组相联高速缓存433

6.4.4　全相联高速缓存434

6.4.5　有关写的问题437

6.4.6　一个真实的高速缓存层次结构的解剖438

6.4.7　高速缓存参数的性能影响439

6.5　编写高速缓存友好的代码440

6.6　综合：高速缓存对程序性能的影响444

6.6.1　存储器山444

6.6.2　重新排列循环以提高空间局部性447

6.6.3　在程序中利用局部性450

6.7　小结450

参考文献说明451

家庭作业451

练习题答案459

第二部分

在系统上运行程序

第7章　链接464

7.1　编译器驱动程序465

7.2　静态链接466

7.3　目标文件466

7.4　可重定位目标文件467

7.5　符号和符号表468

7.6　符号解析470

7.6.1　链接器如何解析多重定义的全局符号471

7.6.2　与静态库链接475

7.6.3　链接器如何使用静态库来解析引用477

7.7　重定位478

7.7.1　重定位条目479

7.7.2　重定位符号引用479

7.8　可执行目标文件483

7.9　加载可执行目标文件484

7.10　动态链接共享库485

7.11　从应用程序中加载和链接共享库487

7.12　位置无关代码489

7.13　库打桩机制492

7.13.1　编译时打桩492

7.13.2　链接时打桩492

7.13.3　运行时打桩494

7.14　处理目标文件的工具496

7.15　小结496

参考文献说明497

家庭作业497

练习题答案499

第8章　异常控制流501

8.1　异常502

8.1.1　异常处理503

8.1.2　异常的类别504

8.1.3　Linux/x86-64系统中的异常505

8.2　进程508

8.2.1　逻辑控制流508

8.2.2　并发流509

8.2.3　私有地址空间509

8.2.4　用户模式和内核模式510

8.2.5　上下文切换511

8.3　系统调用错误处理512

8.4　进程控制513

8.4.1　获取进程ID513

8.4.2　创建和终止进程513

8.4.3　回收子进程516

8.4.4　让进程休眠521

8.4.5　加载并运行程序521

8.4.6　利用fork和execve运行程序524

8.5　信号526

8.5.1　信号术语527

8.5.2　发送信号528

8.5.3　接收信号531

8.5.4　阻塞和解除阻塞信号532

8.5.5　编写信号处理程序533

8.5.6　同步流以避免讨厌的并发错误540

8.5.7　显式地等待信号543

8.6　非本地跳转546

8.7　操作进程的工具550

8.8　小结550

参考文献说明550

家庭作业550

练习题答案556

第9章　虚拟内存559

9.1　物理和虚拟寻址560

9.2　地址空间560

9.3　虚拟内存作为缓存的工具561

9.3.1　DRAM缓存的组织结构562

9.3.2　页表562

9.3.3　页命中563

9.3.4　缺页564

9.3.5　分配页面565

9.3.6　又是局部性救了我们565

9.4　虚拟内存作为内存管理的工具565

9.5　虚拟内存作为内存保护的工具567

9.6　地址翻译567

9.6.1　结合高速缓存和虚拟内存570

9.6.2　利用TLB加速地址翻译570

9.6.3　多级页表571

9.6.4　综合：端到端的地址翻译573

9.7　案例研究：Intel Core i7/Linux内存系统576

9.7.1　Core i7地址翻译576

9.7.2　Linux虚拟内存系统580

9.8　内存映射582

9.8.1　再看共享对象583

9.8.2　再看fork函数584

9.8.3　再看execve函数584

9.8.4　使用mmap函数的用户级内存映射585

9.9　动态内存分配587

9.9.1　malloc和free函数587

9.9.2　为什么要使用动态内存分配589

9.9.3　分配器的要求和目标590

9.9.4　碎片591

9.9.5　实现问题592

9.9.6　隐式空闲链表592

9.9.7　放置已分配的块593

9.9.8　分割空闲块594

9.9.9　获取额外的堆内存594

9.9.10　合并空闲块594

9.9.11　带边界标记的合并595

9.9.12　综合：实现一个简单的分配器597

9.9.13　显式空闲链表603

9.9.14　分离的空闲链表604

9.10　垃圾收集605

9.10.1　垃圾收集器的基本知识606

9.10.2　Mark&Sweep垃圾收集器607

9.10.3　C程序的保守Mark&Sweep608

9.11　C程序中常见的与内存有关的错误609

9.11.1　间接引用坏指针609

9.11.2　读未初始化的内存609

9.11.3　允许栈缓冲区溢出610

9.11.4　假设指针和它们指向的对象是相同大小的610

9.11.5　造成错位错误611

9.11.6　引用指针，而不是它所指向的对象611

9.11.7　误解指针运算611

9.11.8　引用不存在的变量612

9.11.9　引用空闲堆块中的数据612

9.11.10　引起内存泄漏613

9.12　小结613

参考文献说明613

家庭作业614

练习题答案617

第三部分

程序间的交互和通信

第10章　系统级I/O622　10.1　Unix I/O622

10.2　文件623

10.3　打开和关闭文件624

10.4　读和写文件625

10.5　用RIO包健壮地读写626

10.5.1　RIO的无缓冲的输入输出函数627

10.5.2　RIO的带缓冲的输入函数627

10.6　读取文件元数据632

10.7　读取目录内容633

10.8　共享文件634

10.9　I/O重定向637

10.10　标准I/O638

10.11　综合：我该使用哪些I/O函数？638

10.12　小结640

参考文献说明640

家庭作业640

练习题答案641

第11章　网络编程642

11.1　客户端服务器编程模型642

11.2　网络643

11.3　全球IP因特网646

11.3.1　IP地址647

11.3.2　因特网域名649

11.3.3　因特网连接651

11.4　套接字接口652

11.4.1　套接字地址结构653

11.4.2　socket函数654

11.4.3　connect函数654

11.4.4　bind函数654

11.4.5　listen函数655

11.4.6　accept函数655

11.4.7　主机和服务的转换656

11.4.8　套接字接口的辅助函数660

11.4.9　echo客户端和服务器的示例662

11.5　Web服务器665

11.5.1　Web基础665

11.5.2　Web内容666

11.5.3　HTTP事务667

11.5.4　服务动态内容669

11.6　综合：TINY Web服务器671

11.7　小结678

参考文献说明678

家庭作业678

练习题答案679

第12章　并发编程681

12.1　基于进程的并发编程682

12.2　基于I/O多路复用的并发编程684

12.3　基于线程的并发编程691

12.4　多线程程序中的共享变量696

12.5　用信号量同步线程698

12.6　使用线程提高并行性710

12.7　其他并发问题716

12.8　小结722

参考文献说明723

家庭作业723

练习题答案726

附录A　错误处理729

参考文献733