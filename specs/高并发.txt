第1章　并发编程的挑战 1
1.1　上下文切换 1
1.1.1　多线程一定快吗 1
1.1.2　测试上下文切换次数和时长 3
1.1.3　如何减少上下文切换 3
1.1.4　减少上下文切换实战 4
1.2　死锁 5
1.3　资源限制的挑战 6
1.4　本章小结 7
第2章　Java并发机制的底层实现原理 8
2.1　volatile的应用 8
2.2　synchronized的实现原理与应用 11
2.2.1　Java对象头 12
2.2.2　锁的升级与对比 13
2.3　原子操作的实现原理 16
2.4　本章小结 20
第3章　Java内存模型 21
3.1　Java内存模型的基础 21
3.1.1　并发编程模型的两个关键问题 21
3.1.2　Java内存模型的抽象结构 22
3.1.3　从源代码到指令序列的重排序 23
3.1.4　并发编程模型的分类 24
3.1.5　happens-before简介 26
3.2　重排序 27
3.2.1　数据依赖性 28
3.2.2　as-if-serial语义 28
3.2.3　程序顺序规则 29
3.2.4　重排序对多线程的影响 29
3.3　顺序一致性 31
3.3.1　数据竞争与顺序一致性 31
3.3.2　顺序一致性内存模型 32
3.3.3　同步程序的顺序一致性效果 34
3.3.4　未同步程序的执行特性 35
3.4　volatile的内存语义 38
3.4.1　volatile的特性 38
3.4.2　volatile写-读建立的happens-before关系 39
3.4.3　volatile写-读的内存语义 40
3.4.4　volatile内存语义的实现 42
3.4.5　JSR-133为什么要增强volatile的内存语义 46
3.5　锁的内存语义 47
3.5.1　锁的释放-获取建立的
　　　happens-before关系 47
3.5.2　锁的释放和获取的内存语义 48
3.5.3　锁内存语义的实现 50
3.5.4　concurrent包的实现 54
3.6　final域的内存语义 55
3.6.1　final域的重排序规则 55
3.6.2　写final域的重排序规则 56
3.6.3　读final域的重排序规则 57
3.6.4　final域为引用类型 58
3.6.5　为什么final引用不能从构造函数内“溢出” 59
3.6.6　final语义在处理器中的实现 61
3.6.7　JSR-133为什么要增强f?inal的语义 62
3.7　happens-before 62
3.7.1　JMM的设计 62
3.7.2　happens-before的定义 64
3.7.3　happens-before规则 65
3.8　双重检查锁定与延迟初始化 67
3.8.1　双重检查锁定的由来 67
3.8.2　问题的根源 69
3.8.3　基于volatile的解决方案 71
3.8.4　基于类初始化的解决方案 72
3.9　Java内存模型综述 78
3.9.1　处理器的内存模型 78
3.9.2　各种内存模型之间的关系 80
3.9.3　JMM的内存可见性保证 80
3.9.4　JSR-133对旧内存模型的修补 81
3.10　本章小结 82
第4章　Java并发编程基础 83
4.1　线程简介 83
4.1.1　什么是线程 83
4.1.2　为什么要使用多线程 84
4.1.3　线程优先级 85
4.1.4　线程的状态 87
4.1.5　Daemon线程 90
4.2　启动和终止线程 91
4.2.1　构造线程 91
4.2.2　启动线程 92
4.2.3　理解中断 92
4.2.4　过期的suspend()、resume()和stop() 93
4.2.5　安全地终止线程 95
4.3　线程间通信 96
4.3.1　volatile和synchronized关键字 96
4.3.2　等待/通知机制 98
4.3.3　等待/通知的经典范式 101
4.3.4　管道输入/输出流 102
4.3.5　Thread.join()的使用 103
4.3.6　ThreadLocal的使用 105
4.4　线程应用实例 106
4.4.1　等待超时模式 106
4.4.2　一个简单的数据库连接池示例 106
4.4.3　线程池技术及其示例 110
4.4.4　一个基于线程池技术的简单Web服务器 114
4.5　本章小结 118
第5章　Java中的锁 119
5.1　Lock接口 119
5.2　队列同步器 121
5.2.1　队列同步器的接口与示例 121
5.2.2　队列同步器的实现分析 124
5.3　重入锁 136
5.4　读写锁 140
5.4.1　读写锁的接口与示例 141
5.4.2　读写锁的实现分析 142
5.5　LockSupport工具 146
5.6　Condition接口 147
5.6.1　Condition接口与示例 148
5.6.2　Condition的实现分析 150
5.7　本章小结 154
第6章　Java并发容器和框架 155
6.1　ConcurrentHashMap的实现原理与使用 155
6.1.1　为什么要使用ConcurrentHashMap 155
6.1.2　ConcurrentHashMap的结构 156
6.1.3　ConcurrentHashMap的初始化 157
6.1.4　定位Segment 159
6.1.5　ConcurrentHashMap的操作 160
6.2　ConcurrentLinkedQueue 161
6.2.1　ConcurrentLinkedQueue的结构 162
6.2.2　入队列 162
6.2.3　出队列 165
6.3　Java中的阻塞队列 167
6.3.1　什么是阻塞队列 167
6.3.2　Java里的阻塞队列 168
6.3.3　阻塞队列的实现原理 172
6.4　Fork/Join框架 175
6.4.1　什么是Fork/Join框架 175
6.4.2　工作窃取算法 176
6.4.3　Fork/Join框架的设计 177
6.4.4　使用Fork/Join框架 177
6.4.5　Fork/Join框架的异常处理 179
6.4.6　Fork/Join框架的实现原理 179
6.5　本章小结 181
第7章　Java中的13个原子操作类 182
7.1　原子更新基本类型类 182
7.2　原子更新数组 184
7.3　原子更新引用类型 185
7.4　原子更新字段类 187
7.5　本章小结 188
第8章　Java中的并发工具类 189
8.1　等待多线程完成的CountDownLatch 189
8.2　同步屏障CyclicBarrier 191
8.2.1　CyclicBarrier简介 191
8.2.2　CyclicBarrier的应用场景 193
8.2.3　CyclicBarrier和CountDownLatch的区别 195
8.3　控制并发线程数的Semaphore 196
8.4　线程间交换数据的Exchanger 198
8.5　本章小结 199
第9章　Java中的线程池 200
9.1　线程池的实现原理 200
9.2　线程池的使用 203
9.2.1　线程池的创建 203
9.2.2　向线程池提交任务 205
9.2.3　关闭线程池 205
9.2.4　合理地配置线程池 206
9.2.5　线程池的监控 206
9.3　本章小结 207
第10章　Executor框架 208
10.1　Executor框架简介 208
10.1.1　Executor框架的两级调度模型 208
10.1.2　Executor框架的结构与成员 208
10.2　ThreadPoolExecutor详解 213
10.2.1　FixedThreadPool详解 213
10.2.2　SingleThreadExecutor详解 214
10.2.3　CachedThreadPool详解 215
10.3　ScheduledThreadPoolExecutor详解 217
10.3.1　ScheduledThreadPoolExecutor的运行机制 217
10.3.2　ScheduledThreadPoolExecutor的实现 218
10.4　FutureTask详解 221
10.4.1　FutureTask简介 222
10.4.2　FutureTask的使用 222
10.4.3　FutureTask的实现 224
10.5　本章小结 227
第11章　Java并发编程实践 228
11.1　生产者和消费者模式 228
11.1.1　生产者消费者模式实战 229
11.1.2　多生产者和多消费者场景 231
11.1.3　线程池与生产消费者模式 234
11.2　线上问题定位 234
11.3　性能测试 236
11.4　异步任务池 238
11.5　本章小结 240

1.1　并发简史
1.2　线程的优势
1.2.1　发挥多处理器的强大能力
1.2.2　建模的简单性
1.2.3　异步事件的简化处理
1.2.4　响应更灵敏的用户界面
1.3　线程带来的风险
1.3.1　安全性问题
1.3.2　活跃性问题
1.3.3　性能问题
1.4　线程无处不在
第一部分　基础知识
第2章　线程安全性
2.1　什么是线程安全性
2.2　原子性
2.2.1　竞态条件
2.2.2　示例：延迟初始化中的竞态条件
2.2.3　复合操作
2.3　加锁机制
2.3.1　内置锁
2.3.2　重入
2.4　用锁来保护状态
2.5　活跃性与性能
第3章　对象的共享
3.1　可见性
3.1.1　失效数据
3.1.2　非原子的64位操作
3.1.3　加锁与可见性
3.1.4　Volatile变量
3.2　发布与逸出
3.3　线程封闭
3.3.1　Ad-hoc线程封闭
3.3.2　栈封闭
3.3.3　ThreadLocal类
3.4　不变性
3.4.1　Final域
3.4.2　示例：使用Volatile类型来发布不可变对象
3.5　安全发布
3.5.1　不正确的发布：正确的对象被破坏
3.5.2 　不可变对象与初始化安全性
3.5.3　安全发布的常用模式
3.5.4　事实不可变对象
3.5.5　可变对象
3.5.6　安全地共享对象
第4章　对象的组合
4.1　设计线程安全的类
4.1.1　收集同步需求
4.1.2　依赖状态的操作
4.1.3　状态的所有权
4.2　实例封闭
4.2.1　Java监视器模式
4.2.2　示例：车辆追踪
4.3　线程安全性的委托
4.3.1　示例：基于委托的车辆追踪器
4.3.2　独立的状态变量
4.3.3　当委托失效时
4.3.4　发布底层的状态变量
4.3.5　示例：发布状态的车辆追踪器
4.4　在现有的线程安全类中添加功能
4.4.1　客户端加锁机制
4.4.2　组合
4.5　将同步策略文档化
第5章　基础构建模块
5.1　同步容器类
5.1.1　同步容器类的问题
5.1.2　迭代器与Concurrent-ModificationException
5.1.3　隐藏迭代器
5.2　并发容器
5.2.1　ConcurrentHashMap
5.2.2　额外的原子Map操作
5.2.3　CopyOnWriteArrayList
5.3　阻塞队列和生产者-消费者模式
5.3.1　示例：桌面搜索
5.3.2　串行线程封闭
5.3.3　双端队列与工作密取
5.4　阻塞方法与中断方法
5.5　同步工具类
5.5.1　闭锁
5.5.2　FutureTask
5.5.3　信号量
5.5.4　栅栏
5.6　构建高效且可伸缩的结果缓存
第二部分　结构化并发应用程序
第6章　任务执行
6.1　在线程中执行任务
6.1.1　串行地执行任务
6.1.2　显式地为任务创建线程
6.1.3　无限制创建线程的不足
6.2　Executor框架
6.2.1　示例：基于Executor的Web服务器
6.2.2　执行策略
6.2.3　线程池
6.2.4　Executor的生命周期
6.2.5　延迟任务与周期任务
6.3　找出可利用的并行性
6.3.1　示例：串行的页面渲染器
6.3.2　携带结果的任务Callable与Future
6.3.3　示例：使用Future实现页面渲染器
6.3.4　在异构任务并行化中存在的局限
6.3.5　CompletionService:Executor与BlockingQueue
6.3.6　示例：使用CompletionService实现页面渲染器
6.3.7　为任务设置时限
6.3.8　示例：旅行预定门户网站
第7章　取消与关闭
第8章　线程池的使用
第9章　图形用户界面应用程序
第三部分　活跃性、性能与测试
第10章　避免活跃性危险
第11章　性能与可伸缩性
第12章　并发程序的测试
第四部分　高级主题
第13章　显式锁
第14章　构建自定义的同步工具
第15章　原子变量与非阻塞同步机制
第16章　Java内存模型
附录A　并发性标注

第1章：快速认识线程 22
1.1 线程的介绍 22
1.2 快速创建并启动一个线程 22
1.2.1 尝试并行运行 23
1.2.2 并发运行交替输出 24
1.2.3 使用Jconsole观察线程 25
1.3 线程的生命周期详解 26
1.3.1 线程的NEW状态 27
1.3.2 线程的RUNNABLE状态 28
1.3.3 线程的 RUNNING状态 28
1.3.4 线程的BLOCKED状态 29
1.3.5 线程的TERMINATED状态 29
1.4 线程的start方法剖析--模板设计模式在Thread中的应用 30
1.4.1 Thread start方法源码分析以及注意事项 30
1.4.2 模板设计模式在Thread中的应用 33
1.4.3 Thread模拟营业大厅叫号机程序 34
1.5 Runnable接口的引入以及策略模式在Thread中的使用 39
1.5.1 Runnable的职责 39
1.5.2 策略模式在Thread中的应用 40
1.5.3 模拟营业大厅叫号机程序 42
1.6 本章总结 43
第2章：深入理解Thread构造函数 45
2.1 线程的命名 45
2.1.1 线程的默认命名 45
2.1.2 命名线程 46
2.1.3 修改线程的名字 47
2.2 线程的父子关系 48
2.3 Thread与ThreadGroup 48
2.4 Thread与Runnable 50
2.5 Thread与JVM虚拟机栈 50
2.5.1 Thread与Stacksize 51
2.5.2 JVM内存结构 53
2.5.3 Thread与虚拟机栈 58
2.6 守护线程 62
2.6.1 什么是守护线程 62
2.6.2 守护线程的作用 64
2.7 本章总结 64
第3章：Thread API的详细介绍 66
3.1 线程sleep 66
3.1.1 sleep方法介绍 66
3.1.2 使用TimeUnit替代Thread.sleep 67
3.2 线程yield 68
3.2.1 yield方法介绍 68
3.2.2 yield vs sleep 69
3.3 设置线程的优先级 69
3.3.1 线程优先级介绍 70
3.3.2 线程优先级源码分析 71
3.3.3 关于优先级的一些总结 72
3.4 获取线程ID 73
3.5 获取当前线程 73
3.6 设置线程上下文类加载器 74
3.7 线程interrupt 75
3.7.1 interrupt 75
3.7.2 isInterrupted 77
3.7.3 interrupted 79
3.7.4 interrupt注意事项 81
3.8 线程join 82
3.8.1 线程join方法详解 83
3.8.2 join方法结合实战 85
3.9 如何关闭一个线程 90
3.9.1 正常关闭 90
3.9.2 异常退出 94
3.9.3 进程假死 94
3.10 本章总结 95
第4章：线程安全与数据同步 97
4.1 数据同步 97
4.1.1 数据不一致问题的引入 97
4.1.2 数据不一致问题原因分析 99
4.2 初识 synchronized关键字 101
4.2.1 什么是synchronized 102
4.2.2 synchronized关键字的用法 103
4.3 深入synchronized关键字 105
4.3.1 线程堆栈分析 105
4.3.2 JVM指令分析 108
4.3.3 使用synchronized需要注意的问题 112
4.4 This Monitor和Class Monitor的详细介绍 114
4.4.1 this monitor 114
4.4.2 class monitor 117
4.5 程序死锁的原因以及如何诊断 120
4.5.1 程序死锁 120
4.5.2 程序死锁举例 121
4.5.3 死锁诊断 124
4.6 本章总结 126
第5章：线程间通信 127
5.1 同步阻塞与异步非阻塞 127
5.1.1 同步阻塞消息处理 127
5.1.2 异步非阻塞消息处理 128
5.2 单线程间通信 129
5.2.1 初识wait和notify 129
5.2.2 wait和notify方法详解 133
5.2.3 wait和notify注意事项 135
5.2.4 wait vs sleep 137
5.3 多线程间通信 137
5.3.1 生产者消费者 137
5.3.2 线程休息室wait set 140
5.4 自定义显式锁BooleanLock 141
5.4.1 synchronized关键字的缺陷 142
5.4.2 显式锁BooleanLock 143
5.5 本章总结 153
第6章：ThreadGroup详细讲解 155
6.1 ThreadGroup与Thread 155
6.2 创建Thread Group 155
6.3 拷贝Thread数组和ThreadGroup数组 157
6.3.1 拷贝Thread数组 157
6.3.2 拷贝ThreadGroup数组 159
6.4 ThreadGroup操作 160
6.4.1 ThreadGroup的基本操作 161
6.4.2 ThreadGroup的interrupt 164
6.4.3 ThreadGroup的destroy 166
6.4.4 守护ThreadGroup 168
6.5 本章总结 169
第7章：Hook线程以及捕获线程执行异常 170
7.1 获取线程运行时异常 170
7.1.1 UncaughtExceptionHandler介绍 170
7.1.2 UncaughtExceptionHandler实例 171
7.1.3 UncaughtExceptionHandler源码分析 173
7.2 注入钩子线程（Hook） 175
7.2.1 Hook线程介绍 175
7.2.2 Hook线程实战 177
7.2.3 Hook线程应用场景以及注意事项 179
7.3 本章总结 179
第8章：线程池原理以及自定义线程池 180
8.1 线程池原理 180
8.2 线程池实现 181
8.2.1 线程池接口定义 182
8.2.2 线程池详细实现 188
8.3 线程池应用 198
8.4 本章总结 202
第二部分：Java ClassLoader 204
第9章 类的加载过程 205
9.1 类的加载过程介绍 205
9.2 类的主动使用和被动使用 206
9.3 类加载过程详解 209
9.3.1 类的加载阶段 210
9.3.2 类的连接阶段 212
9.3.3 类的初始化阶段 219
9.4 本章总结 221
第10章 JVM类加载器 224
10.1 JVM内置三大类加载器 224
10.1.1 根类加载器介绍 225
10.1.2 扩展类加载器介绍 226
10.1.3 系统类加载器介绍 227
10.2 自定义类加载器 227
10.2.1 自定义类加载器，问候世界 228
10.2.2 双亲委托机制详细介绍 233
10.2.3 破坏双亲委托机制 236
10.2.4 类加载器命名空间，运行时包，类的卸载等 239
10.3 本章总结 246
第11章 线程上下文类加载器 249
11.1 为什么需要线程上下文类加载器 249
11.2 数据库驱动的初始化源码分析 250
第三部分 深入理解volatile关键字 254
第12章 volatile关键字的介绍 255
12.1 初识volatile关键字 255
12.2 机器硬件CPU 257
12.3 Java 内存模型 262
第13章 深入volatile关键字 265
13.1 并发编程的三个重要特性 265
13.1.1 原子性 265
13.1.2 可见性 266
13.1.3 有序性 266
13.2 JMM如何保证三大特性 268
13.2.1 JMM与原子性 269
13.2.2 JMM与可见性 271
13.2.3 JMM与有序性 272
13.3 volatile关键字深入解析 273
13.3.1 volatile关键字的语义 274
13.3.2 volatile的原理和实现机制 277
13.3.3 volatile的使用场景 278

第1 章 并发编程线程基础 2

1.1 什么是线程 2

1.2 线程创建与运行 3

1.3 线程通知与等待 6

1.4 等待线程执行终止的join 方法 16

1.5 让线程睡眠的sleep 方法 19

1.6 让出CPU 执行权的yield 方法 23

1.7 线程中断 24

1.8 理解线程上下文切换 30

1.9 线程死锁 30

1.9.1 什么是线程死锁 30

1.9.2 如何避免线程死锁 33

1.10 守护线程与用户线程 35

1.11 ThreadLocal 39

1.11.1 ThreadLocal 使用示例 40

1.11.2 ThreadLocal 的实现原理 42

1.11.3 ThreadLocal 不支持继承性 45

1.11.4 InheritableThreadLocal 类 46

第2 章 并发编程的其他基础知识 50

2.1 什么是多线程并发编程 50

2.2 为什么要进行多线程并发编程 51

2.3 Java 中的线程安全问题 51

?2.4 Java 中共享变量的内存可见性问题 52

2.5 Java 中的synchronized 关键字 54

2.5.1 synchronized 关键字介绍 54

2.5.2 synchronized 的内存语义 55

2.6 Java 中的volatile 关键字 55

2.7 Java 中的原子性操作 57

2.8 Java 中的CAS 操作 59

2.9 Unsafe 类 59

2.9.1 Unsafe 类中的重要方法 59

2.9.2 如何使用Unsafe 类 61

2.10 Java 指令重排序 65

2.11 伪共享 67

2.11.1 什么是伪共享 67

2.11.2 为何会出现伪共享 68

2.11.3 如何避免伪共享 70

2.11.4 小结 72

2.12 锁的概述 72

2.12.1 乐观锁与悲观锁 72

2.12.2 公平锁与非公平锁 75

2.12.3 独占锁与共享锁 75

2.12.4 什么是可重入锁 76

2.12.5 自旋锁 77

2.13 总结 77

第二部分 Java 并发编程高级篇

第3 章 Java 并发包中ThreadLocalRandom 类原理剖析 80

3.1 Random 类及其局限性 80

3.2 ThreadLocalRandom 82

3.3 源码分析 84

3.4 总结 87

第4 章 Java 并发包中原子操作类原理剖析 88

4.1 原子变量操作类 88

4.2 JDK 8 新增的原子操作类LongAdder 93

4.2.1 LongAdder 简单介绍 93

4.2.2 LongAdder 代码分析 95

4.2.3 小结 101

4.3 LongAccumulator 类原理探究 102

4.4 总结 104

第5 章 Java 并发包中并发List 源码剖析 105

5.1 介绍 105

5.2 主要方法源码解析 106

5.2.1 初始化 106

5.2.2 添加元素 106

5.2.3 获取指定位置元素 108

5.2.4 修改指定元素 109

5.2.5 删除元素 110

5.2.6 弱一致性的迭代器 111

5.3 总结 114

第6 章 Java 并发包中锁原理剖析 115

6.1 LockSupport 工具类 115

6.2 抽象同步队列AQS 概述 122

6.2.1 AQS——锁的底层支持 122

6.2.2 AQS——条件变量的支持 128

6.2.3 基于AQS 实现自定义同步器 131

6.3 独占锁ReentrantLock 的原理 136

6.3.1 类图结构 136

6.3.2 获取锁 137

6.3.3 释放锁 142

6.3.4 案例介绍 143

6.3.5 小结 145

?6.4 读写锁ReentrantReadWriteLock 的原理 145

6.4.1 类图结构 145

6.4.2 写锁的获取与释放 147

6.4.3 读锁的获取与释放 151

6.4.4 案例介绍 156

6.4.5 小结 158

6.5 JDK 8 中新增的StampedLock 锁探究 158

6.5.1 概述 158

6.5.2 案例介绍 160

6.5.3 小结 164

第7 章 Java 并发包中并发队列原理剖析 165

7.1 ConcurrentLinkedQueue 原理探究 165

7.1.1 类图结构 165

7.1.2 ConcurrentLinkedQueue 原理介绍 166

7.1.3 小结 181

7.2 LinkedBlockingQueue 原理探究 182

7.2.1 类图结构 182

7.2.2 LinkedBlockingQueue 原理介绍 185

7.2.3 小结 194

7.3 ArrayBlockingQueue 原理探究 195

7.3.1 类图结构 195

7.3.2 ArrayBlockingQueue 原理介绍 197

7.3.3 小结 202

7.4 PriorityBlockingQueue 原理探究 203

7.4.1 介绍 203

7.4.2 PriorityBlockingQueue 类图结构 203

7.4.3 原理介绍 205

7.4.4 案例介绍 214

7.4.5 小结 216

7.5 DelayQueue 原理探究 217

7.5.1 DelayQueue 类图结构 217

7.5.2 主要函数原理讲解 219

7.5.3 案例介绍 222

7.5.4 小结 224

第8 章 Java 并发包中线程池ThreadPoolExecutor 原理探究 225

8.1 介绍 225

8.2 类图介绍 225

8.3 源码分析 230

8.3.1 public void execute(Runnable command) 230

8.3.2 工作线程Worker 的执行 235

8.3.3 shutdown 操作 238

8.3.4 shutdownNow 操作 240

8.3.5 awaitTermination 操作 241

8.4 总结 242

第9 章 Java 并发包中ScheduledThreadPoolExecutor 原理探究 243

9.1 介绍 243

9.2 类图介绍 243

9.3 原理剖析 245

9.3.1 schedule(Runnable command, long delay,TimeUnit unit) 方法 246

9.3.2 scheduleWithFixedDelay(Runnable command,long initialDelay, long delay,TimeUnit unit) 方法 252

9.3.3 scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit) 方法 254

9.4 总结 255

第10 章 Java 并发包中线程同步器原理剖析 256

10.1 CountDownLatch 原理剖析 256

10.1.1 案例介绍 256

10.1.2 实现原理探究 259

10.1.3 小结 263

10.2 回环屏障CyclicBarrier 原理探究 264

10.2.1 案例介绍 264

10.2.2 实现原理探究 268

10.2.3 小结 272

?10.3 信号量Semaphore 原理探究 272

10.3.1 案例介绍 272

10.3.2 实现原理探究 276

10.3.3 小结 281

10.4 总结 281

第三部分 Java 并发编程实践篇

第11 章 并发编程实践 284

11.1 ArrayBlockingQueue 的使用 284

11.1.1 异步日志打印模型概述 284

11.1.2 异步日志与具体实现 285

11.1.3 小结 293

11.2 Tomcat 的NioEndPoint 中ConcurrentLinkedQueue 的使用 293

11.2.1 生产者——Acceptor 线程 294

11.2.2 消费者——Poller 线程 298

11.2.3 小结 300

11.3 并发组件ConcurrentHashMap 使用注意事项 300

11.4 SimpleDateFormat 是线程不安全的 304

11.4.1 问题复现 304

11.4.2 问题分析 305

11.4.3 小结 309

11.5 使用Timer 时需要注意的事情 309

11.5.1 问题的产生 309

11.5.2 Timer 实现原理分析 310

11.5.3 小结 313

11.6 对需要复用但是会被下游修改的参数要进行深复制 314

11.6.1 问题的产生 314

11.6.2 问题分析 316

11.6.3 小结 318

11.7 创建线程和线程池时要指定与业务相关的名称 319

11.7.1 创建线程需要有线程名 319

11.7.2 创建线程池时也需要指定线程池的名称 321

11.7.3 小结 325

11.8 使用线程池的情况下当程序结束时记得调用shutdown 关闭线程池 325

11.8.1 问题复现 325

11.8.2 问题分析 327

11.8.3 小结 329

11.9 线程池使用FutureTask 时需要注意的事情 329

11.9.1 问题复现 329

11.9.2 问题分析 332

11.9.3 小结 335

11.10 使用ThreadLocal 不当可能会导致内存泄漏 336

11.10.1 为何会出现内存泄漏 336

11.10.2 在线程池中使用ThreadLocal 导致的内存泄漏 339

11.10.3 在Tomcat 的Servlet 中使用ThreadLocal 导致内存泄漏 341

