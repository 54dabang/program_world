1.1 数据库系统的应用
1.2 数据库系统的目标
1.3 数据视图
1.3.1 数据抽象
1.3.2 实例和模式
1.3.3 数据模型
1.4 数据库语言
1.4.1 数据操纵语言
1.4.2 数据定义语言
1.5 关系数据库
1.5.1 表
1.5.2 数据操纵语言
1.5.3 数据定义语言
1.5.4 来自应用程序的数据库访问
1.6 数据库设计
1.6.1 设计过程
1.6.2 大学机构的数据库设计
1.6.3 实体-联系模型
1.6.4 规范化
1.7 数据存储和查询
1.7.1 存储管理器
1.7.2 查询处理器
1.8 事务管理
1.9 数据库体系结构
1.10 数据挖掘与信息检索
1.11 特种数据库
1.11.1 基于对象的数据模型
1.11.2 半结构化数据模型
1.12 数据库用户和管理员
1.12.1 数据库用户和用户界面
1.12.2 数据库管理员
1.13 数据库系统的历史
1.14 总结
术语回顾
实践习题
习题
工具
文献注解
第一部分 关系数据库
第2章 关系模型介绍
2.1 关系数据库的结构
2.2 数据库模式
2.3 码
2.4 模式图
2.5 关系查询语言
2.6 关系运算
2.7 总结
术语回顾
实践习题
习题
文献注解
第3章 SQL
3.1 SQL查询语言概览
3.2 SQL数据定义
3.2.1 基本类型
3.2.2 基本模式定义
3.3 SQL查询的基本结构
3.3.1 单关系查询
3.3.2 多关系查询
3.3.3 自然连接
3.4 附加的基本运算
3.4.1 更名运算
3.4.2 字符串运算
3.4.3 select子句中的属性说明
3.4.4 排列元组的显示次序
3.4.5 where子句谓词
3.5 集合运算
3.5.1 并运算
3.5.2 交运算
3.5.3 差运算
3.6 空值
3.7 聚集函数
3.7.1 基本聚集
3.7.2 分组聚集
3.7.3 having子句
3.7.4 对空值和布尔值的聚集
3.8 嵌套子查询
3.8.1 集合成员资格
3.8.2 集合的比较
3.8.3 空关系测试
3.8.4 重复元组存在性测试
3.8.5 from子句中的子查询
3.8.6 with子句
3.8.7 标量子查询
3.9 数据库的修改
3.9.1 删除
3.9.2 插入
3.9.3 更新
3.10 总结
术语回顾
实践习题
习题
工具
文献注解
第4章 中级SQL
第5章 高级SQL
第6章 形式化关系查询语言
第二部分 数据库设计
第7章 数据库设计和E-R模型
第8章 关系数据库设计
第9章 应用设计和开发
第三部分 数据存储和查询
第10章 存储和文件结构
第11章 索引与散列
第12章 查询处理
第13章 查询优化
第四部分 事务管理
第14章 事务
第15章 并发控制
第16章 恢复系统
第五部分 系统体系结构
第17章 数据库系统体系结构
第18章 并行数据库
第19章 分布式数据库
第六部分 数据仓库、数据挖掘与信息检索
第20章 数据仓库与数据挖掘
第21章 信息检索
第七部分 特种数据库
第22章 基于对象的数据库
第23章 XML
第八部分 高级主题
第24章 高级应用开发
第25章 时空数据和移动性
第九部分 实例研究
第27章 PostgreSQL
第28章 Oracle
第29章 IBM DB2 Universal Database
第30章 Microsoft SQL Server
第十部分 附录
附录A 详细的大学模式


第1章　数据库简介2

1.1　引言3

1.2　传统的基于文件的系统4

1.2.1　基于文件的方法5

1.2.2　基于文件方法的局限性8

1.3　数据库方法10

1.3.1　数据库10

1.3.2　数据库管理系统（DBMS）11

1.3.3　（数据库）应用程序12

1.3.4　DBMS环境的组成部分13

1.3.5　数据库设计：范型改变15

1.4　数据库环境中的各种角色16

1.4.1　数据管理员和数据库管理员16

1.4.2　数据库设计人员16

1.4.3　应用开发人员17

1.4.4　终端用户17

1.5　数据库管理系统的历史17

1.6　DBMS的优点和缺点20

本章小结23

思考题23

习题24

扩展阅读25

第2章　数据库环境26

2.1　ANSI-SPARC三层体系结构27

2.1.1　外部层28

2.1.2　概念层28

2.1.3　内部层28

2.1.4　模式、映射和实例29

2.1.5　数据独立性30

2.2　数据库语言30

2.2.1　数据定义语言（DDL）31

2.2.2　数据操作语言（DML）31

2.2.3　第四代语言32

2.3　数据模型和概念建模33

2.3.1　基于对象的数据模型34

2.3.2　基于记录的数据模型34

2.3.3　物理数据模型36

2.3.4　概念建模36

2.4　DBMS的功能36

本章小结39

思考题40

习题40

扩展阅读41

第3章　数据库的结构与Web42

3.1　多用户DBMS结构42

3.1.1　远程处理43

3.1.2　文件服务器结构43

3.1.3　传统的两层客户-服务器结构44

3.1.4　三层客户-服务器结构45

3.1.5　N层客户-服务器结构47

3.1.6　中间件47

3.1.7　事务处理监视器49

3.2　Web 服务与面向服务的结构50

3.2.1　Web 服务50

3.2.2　面向服务的结构（SOA）51

3.3　分布式DBMS53

3.4　数据仓库54

3.5　云计算56

3.5.1　云计算的好处与风险58

3.5.2　基于云的数据库方案60

3.6　DBMS的组件63

3.7　Oracle的体系结构65

3.7.1　Oracle的逻辑数据库结构65

3.7.2　Oracle的物理数据库结构67

本章小结71

思考题71

习题72

扩展阅读72

第二部分　关系模型与语言

第4章　关系模型74

4.1　关系模型简史74

4.2　基本术语76

4.2.1　关系数据结构76

4.2.2　数学中的关系78

4.2.3　数据库中的关系79

4.2.4　关系的性质79

4.2.5　关系关键字80

4.2.6　关系数据库模式的表示81

4.3　完整性约束83

4.3.1　空83

4.3.2实体完整性83

4.3.3引用完整性84

4.3.4一般性约束84

4.4视图84

4.4.1术语85

4.4.2视图的用途85

4.4.3视图的更新86

本章小结86

思考题86

习题87

扩展阅读87

第5章　关系代数与关系演算88

5.1关系代数88

5.1.1一元运算90

5.1.2集合运算91

5.1.3连接运算93

5.1.4除法运算96

5.1.5聚集运算和分组运算96

5.1.6　关系代数运算小结97

5.2　关系演算98

5.2.1　元组关系演算99

5.2.2　域关系演算101

5.3　其他语言103

本章小结103

思考题104

习题104

扩展阅读106

第6章　SQL：数据操作107

6.1　SQL简介108

6.1.1　SQL的目标108

6.1.2　SQL的历史109

6.1.3　SQL的重要性110

6.1.4　术语110

6.2　书写SQL命令110

6.3　数据操作111

6.3.1　简单查询112

6.3.2　查询结果排序（ORDER BY子句）118

6.3.3　使用SQL聚集函数119

6.3.4　查询结果分组（GROUP BY子句） 121

6.3.5　子查询123

6.3.6　ANY和ALL125

6.3.7　多表查询126

6.3.8　EXISTS和NOT EXISTS131

6.3.9　合并结果表（UNION、INTERSECT和EXCEPT）132

6.3.10　数据库更新 133

本章小结136

思考题137

习题137

第7章　SQL：数据定义140

7.1　ISO SQL数据类型141

7.1.1　SQL标识符141

7.1.2　SQL标量数据类型 141

7.2　完整性增强特性145

7.2.1　必须有值的数据145

7.2.2　域约束145

7.2.3　实体完整性146

7.2.4　引用完整性147

7.2.5　一般性约束148

7.3　数据定义148

7.3.1　创建数据库149

7.3.2　创建表（CREATE TABLE）149

7.3.3　修改表定义（ALTER TABLE） 152

7.3.4　删除表（DROP TABLE）153

7.3.5　创建索引（CREATE INDEX） 153

7.3.6　删除索引（DROP INDEX）154

7.4　视图154

7.4.1　创建视图（CREATE VIEW）154

7.4.2　删除视图（DROP VIEW）156

7.4.3　视图分解157

7.4.4　视图的局限性157

7.4.5　视图的可更新性158

7.4.6　WITH CHECK OPTION159

7.4.7　视图的优缺点160

7.4.8　视图物化161

7.5　事务162

7.6　自主访问控制163

7.6.1　授予其他用户权限（GRANT）164

7.6.2　撤销用户权限（REVOKE）166

本章小结167

思考题168

习题168

第8章　高级SQL171

8.1　SQL编程语言171

8.1.1　声明172

8.1.2　赋值173

8.1.3　控制语句173

8.1.4　PL/SQL的异常175

8.1.5　PL/SQL的游标176

8.2　子程序、存储过程、函数和包178

8.3　触发器179

8.4　递归184

第9章　对象关系DBMS187

9.1　高级数据库应用188

9.2　RDBMS的缺点191

9.3　在关系数据库中存储对象195

9.3.1　将类映射为关系196

9.3.2　访问关系数据库中的对象197

9.4　对象关系数据库系统简介198

9.5　SQL:2011200

9.5.1　行类型201

9.5.2　用户自定义类型201

9.5.3　子类型和超类型204

9.5.4　用户自定义例程206

9.5.5　多态性207

9.5.6　引用类型和对象标识208

9.5.7　创建表208

9.5.8　数据查询210

9.5.9　集类型211

9.5.10　类型视图214

9.5.11　持久化存储模块215

9.5.12　触发器215

9.5.13　大对象217

9.5.14　递归219

9.6　Oracle中面向对象的扩展219

9.6.1　用户自定义数据类型219

9.6.2　操作对象表223

9.6.3　对象视图224

9.6.4　权限225

本章小结226

思考题226

习题226

扩展阅读227

第三部分　数据库分析与设计

第10章　数据库系统开发生命周期230

10.1　信息系统生命周期231

10.2　数据库系统开发生命周期231

10.3　数据库规划233

10.4　系统定义233

10.5　需求收集与分析234

10.5.1　集中式方法235

10.5.2　视图集成方法235

10.6　数据库设计237

10.6.1　数据库设计方法237

10.6.2　数据建模238

10.6.3　数据库设计的阶段划分238

10.7　DBMS选型240

10.8　应用程序设计243

10.8.1　事务设计243

10.8.2　用户界面设计指南244

10.9　建立原型系统246

10.10　实现246

10.11　数据转换与加载246

10.12　测试247

10.13　运行维护247

10.14　CASE工具248

本章小结249

思考题250

习题250

扩展阅读251

第11章　数据库分析与DreamHome案例研究252

11.1　使用实况发现技术的时机253

11.2　收集实况的类型253

11.3　实况发现技术 254

11.3.1　分析文档资料254

11.3.2　面谈254

11.3.3　观察企业的运作255

11.3.4　研究256

11.3.5　问卷调查256

11.4　使用实况发现技术的实例256

11.4.1　DreamHome案例研究—概述257

11.4.2　DreamHome案例研究—数据库规划260

11.4.3　DreamHome案例研究—系统定义264

11.4.4　DreamHome案例研究—需求收集与分析266

11.4.5　DreamHome案例研究—数据库设计271


第12章　实体-联系建模273

12.1　实体类型 274

12.2　联系类型275

12.2.1　联系类型的度276

12.2.2　递归联系278

12.3　属性 279

12.3.1　简单属性和组合属性279

12.3.2　单值属性和多值属性279

12.3.3　导出属性 280

12.3.4　关键字 280

12.4　强实体类型与弱实体类型282

12.5　联系的属性282

12.6　结构化约束283

12.6.1　一对一（1:1）联系283

12.6.2　一对多（1:*）联系284

12.6.3　多对多（*:*）联系285

12.6.4　复杂联系的多重性287

12.6.5　基数约束和参与性约束288

12.7　ER模型的问题289

12.7.1　扇形陷阱289

12.7.2　断层陷阱291

第13章　增强的实体-联系建模295

13.1　特殊化/泛化295

13.1.1　超类和子类296

13.1.2　超类/子类联系296

13.1.3　属性的继承297

13.1.4　特殊化过程297

13.1.5　泛化过程298

13.1.6　特殊化/泛化的约束300

13.1.7　基于DreamHome案例研究的Branch视图特殊化/泛化建模示例301

13.2　聚合304

13.3　组合305

《数据库系统概念》（原书第五版)》

数据存储

物理存储介质


磁盘 磁性物质
60 90

读写头
盘片platter 1-5个盘片
磁道 track 50000-10万个磁道
    扇区 sector 磁盘读写最小单位 扇区一般512byte 500-1000

反转磁性物质磁化  读写头将信息磁化存储到扇区上

盘片每一面有读写头
盘片上移动 访问不同的磁道
所有磁道的读写头安装在一个磁盘手臂 单独装置
一起移动

所有盘片上的读写头一起移动
所有盘片上的第一个磁道 合称为 第i个柱面 cylinder

盘片直径为3.5英寸的磁盘
比大直径成本低 寻道距离短 更大的存储容量
用于便携设备

为了增大记录密度
读写头尽可能靠近磁盘盘片表面
上浮于盘片表面上几微米
磁盘旋转产生微风
读写头距离盘片表面非常近
盘片必须非常平

现在的磁盘 使用 磁金属薄膜

------------------
磁盘驱动单元内部
计算机系统->磁盘控制器->磁盘
disk controller
接受高层次的读写扇区命令

为每个扇区附加checksum
从写到扇区中的数据计算得到

和存储的checksum比较

不一致 重读几次

读操作失败 数据被破坏

坏扇区的重映射 remapping of bad sectors

检测到坏扇区 在逻辑上映射到另一个物理位置
（从为此目的而留出的额外扇区中分配）

重映射记录在磁盘或者非容易失的存储器中
写操作在新的位置上执行

磁盘接口
1.AT附件 AT　attachment ATA 比integrated drive electronics IDE接口更快
2.SATA serial ATA
3.small-computer-system interconnect SCSI
高容量的SCSI接口和光纤通道接口

通常磁盘 采用冗余独立磁盘阵列
redundent arrays of independent disks RAID　
本地化组织　给服务器一个逻辑视图　　

网络附加存储　
network attached storage NAS
通过使用网络文件系统协议 入NFS 或CIFS提供文件系统接口
----------------------

磁盘性能的度量

access time 发出读写请求到数据开始传输之间的时间

寻道时间 seek time
磁盘手臂 重定位的时间
随着手臂移动距离增大而增大
通常在2-30ms
依赖于目的磁道距离磁盘手臂初始位置有多远

平均寻道时间 average seek time
寻道时间平均值
在均匀随机分布请求的序列上计算得到

所有磁道包含相同的扇区数
忽略读写头开始移动和结束移动花费的时间
最坏情况下寻道时间的1/3

最大寻道时间的1/2

平均寻道时间在4-10ms

旋转等待时间
rotational latency time

一旦读写头到达了所需的磁道,等待访问的扇区出现在读写头下
所花费的时间
现在一般的磁盘转速在5400转/min 每秒90转
到每分钟 15000转 每秒250转 之间或者等价地
在每转4ms到每转11.1ms

平均情况下
磁盘需要旋转半周才能使要访问的扇区的开始处处于读写头下方
磁盘的平均旋转等待时间 average latency time
是磁盘旋转一周时间的1/2

----------------------------

访问时间=寻道时间+旋转等待时间
8-20ms

一旦访问数据的第一个扇区来到读写头下方 数据传输开始

data-transfer rate
从磁盘获得和存储数据的速率
最大
25-100M/s

内侧磁道 传输率明显低于最大传输率

平均故障时间 mean time to failure MTTF　

无故障连续运行　
500000~1200000 hour 57-136年

大多数生命周期 可以工作5年左右

PATA 133M/s
SATA 150M/s
320M/s ULtra320 SCSI
256M/s 光纤通道FC 2Gb接口

----------------------------------

磁盘块访问的优化

虚拟内存管理器

每个请求指定访问的磁盘地址

以块号 形式提供

块：
包含固定数目的连续扇区
512-几k之间

缓存块

调度：


--------------------

桶溢出处理 bucket overflow

一直假设插入一条记录  映射到的桶有存储记录的空间

如果没有足够空间


调度 scheduling 把柱面上几个块 传输到内存
块经过读写头的顺序发出访问块请求 节省访问时间
所需块在不同的柱面上 按照使磁盘手臂移动最短距离的顺序发出访问块的请求

磁盘臂调度算法 disk-arm-scheduling

电梯算法 elevator alg

文件组织 file organization
为了减少块访问时间  按照预期数据访问方式 最接近的方式 组织磁盘块

一个连续文件变得碎片化 fragmented
为了减少碎片 备份磁盘数据 恢复整个磁盘 将文件块连续写回
对性能提高 非常显著

非易失性写缓冲区 nonvolatile write buffers
nonvolatile random-access memory NV-RAM
加速写磁盘
使用有后备电池的RAM

写请求时 disk controller 写到Nv-RAM缓冲区

当NV-RAM缓冲区满了 将数据写道磁盘上相应的目标地址

NV-RAM中所有缓冲未完成的写操作写回到磁盘

更多地用于 RAID控制器

日志磁盘  log disk
专门用于写顺序日志的磁盘
对日志磁盘访问时顺序性的  消除了寻道空间
可以一次写几个连续的块

为了最少化磁盘手臂移动 可以重组写操作的顺序

如果实际磁盘位置的写操作完成前崩溃
系统恢复后，系统可以读取日志磁盘
找到没有完成的写操作完成

日志文件系统 journalling file system
甚至将数据和日志存储在同一个磁盘上
可以节省开支 但会降低系统性能

允许快速重启

--------------------------------------------------

磁盘并行访问
冗余独立磁盘阵列 redundant arrays of independent disks
多种磁盘组织技术

更高的可靠性 和更高的执行效率
容易管理和操作

可靠性

重建丢失的信息

一个磁盘发生故障 数据也不会丢失
镜像 复制

先写一个副本 再写另外一个

--------------------------------------

并行提高性能

在多个磁盘上进行数据拆分 striping data 提高传输速度
将每个字节按比特分开 存储到多个磁盘上
比特级拆分 bit-level striping

推广到磁盘总数为8的倍数或者8的因子


块级拆分 block-level striping 将块拆分到多个磁盘

给块逻辑编号 从0开始
n个磁盘阵列
第i个逻辑块
第i mod n +1 个磁盘
第i/n 个磁盘物理块

0
1
0

11
4
1

大的读操作的高数据传输率

将扇区按字节拆分 按扇区拆分


并行
1.负载均衡多个小的访问操作 块访问 提高这种访问操作的吞吐量
2.并行执行大的访问操作 减少访问操作的反应时间

RAID级别
奇偶校验位
较低的代价提供数据冗余


RAID levels
纠错位
副本
存储故障恢复使用的冗余信息

raio 0 无冗余拆分


存储访问
每个文件分成定长的存储单元 块

块
 数据项
  确切的数据项集合由使用的物理数据组织决定
  假定没有数据项跨越两个或两个以上的块

  减少磁盘和存储器之间传输的块数

  减少磁盘访问次数方法一 在主存储器中保留尽可能多的块

  缓冲区：

   存储磁盘块的内存部分
  缓冲区管理器
  负责缓冲区空间分配的子系统

  请求缓冲区管理器
   缓冲区已有 直接返回地址
   不在 在缓冲区分配空间 甚至移除其他块 腾空间 移除的块 仅仅在最近一次写回磁盘后修改过才写回磁盘 块读入缓冲区 地址返回

  类似虚拟存储管理器
   数据库大小比机器硬件地址空间大
   主存储器地址不足对所有磁盘块寻址
   必须采用更复杂的技术
   缓冲区替换策略
    buffer replacement strategy
     LRU least recently used 最近访问最少的块写回磁盘 从缓冲区移走
   被钉住的块 pinned blocks
    限制一个块写回磁盘的时间，支持数据库恢复 如一个块在更新时 不允许将该块写回磁盘
缓冲区替换策略
 减少对磁盘访问
 替换最近最少使用LRU块替换策略 得到短期内的将来信息

 立即丢弃 toss-immediate
 一旦borrower中的元组处理过 就不再需要
 一旦处理完borrow 元组构成的块 就不需要存储在主存储器
 一旦borrower块中最后一个元组处理完，应该
 命令缓冲区管理器释放占用的空间

 最近最常食用MRU
 必须从缓冲区移除customer 块 最近最常使用的块

 有关请求将访问某个特定关系的概率的统计信息
 数据字典 尽量不把数据字典从主存移除
 不把索引块从主存储器移除

 块替换策略
 系统并发处理多个用户请求 并非控制子系统会延迟 保证数据的一致性
 活动的 非延迟请求因此在缓冲区保留

 崩溃恢复子系统

文件组织
 文件有逻辑组织成为记录的序列
 文件 逻辑数据模型不同方式
 块 具有固定的大小 记录大小可不同
 使用多个文件 任意一个文件中只存储一个固定长度的记录
 或者
 构造自己的文件 能容纳多种长度的记录
 首先考虑定长记录文件




---------------------------------------------

索引与散列
直接定位记录

账号->索引->磁盘块->account记录

ordered index 基于值的顺序排序
hash index 基于将值平均分布到若干散列桶中 散列函数

评价因素：
access type 有效支持的访问类型
特定属性值的所有记录 及找到属性值落在某个特定范围内的所有记录
access time
找到一个特定数据项或数据项集所需时间
insertion time
插入一个新数据项所需的时间
1.找到插入这个新数据项的正确位置所需时间
2.更新索引结构所需时间

deletion time 删除一个数据项所需时间
找到待删除项所需时间
更新索引结构所需时间

sparce overhead 空间开销
索引结构所占额外存储空间
牺牲一定的空间代价换取性能的提高


search key
用于在文件中查找记录的属性或属性集

一个文件有多个索引 就有多个搜索码
--------------------------------------------------
顺序索引
索引结构与特定搜索码相关

按顺序存储搜索码的值 将搜索吗与包含搜索码的记录关联

索引文件中的记录自身可以按某种排序顺序存储

一个文件可以有多个索引 分别对应不同的搜索码

clustering index 聚集索引 primary index
包含记录的文件 按某个搜索码指定的顺序排序

可以建立在任何搜索码上的 并非总是建立在主码上的

索引顺序文件
顺序处理文件 又需要随机访问单独记录的应用

非聚集索引 nonclustering index 或者 secondary
搜索码指定的顺序与文件记录的物理顺序不同的索引


index record/index entry
（搜索码值，指向具有该搜索码值得一个或多个记录的指针构成（磁盘块的标识，块内偏移量 标识磁盘块内记录））

顺序索引两类
 dense index
  文件中的每个搜索吗值有一个索引记录
  索引记录包括（搜索码值，指向具有该搜索吗值的第一个数据记录的指针）
  具有相同搜索吗值得其余记录顺序存储在第一个记录之后
  聚集索引 根据相同的搜索吗排序
  速度快

 sparse index
  只为搜索码的某些值建立索引记录。
  索引记录包括（搜索码值，指向具有该搜索吗值的第一个数据记录的指针）
  最大搜索吗值<=所找记录的搜索吗值的索引项
  然后从该索引项指向的记录开始 沿着文件中的指针查找 直到找到所需记录为止
  占用空间小 插入和删除的维护开销较小

  为每个块建立索引项的sparse index
  数据库请求开销由把块磁盘读入主存时间决定
  扫描整个块时间忽略
  使块访问次数最小 保持索引尽可能小 减少空间开销


 多级索引
  在搜索吗上建立和使用索引 （支行名，账户额度）
  不止一个属性的搜索吗 复合搜索吗 composite search key
  搜索吗是一个属性列表
  词典顺序 和单词的字母顺序类似

  使用顺序的（B+树）索引高效回答具有如下形式的查询：
  select loan_number from account where branch_name ='Perridge' and balance = 1000

  指定范围也能 对应于搜索属性上的一个范围查询
  select loan_number from account where branch_name = 'Perridge' and balance <1000

  使用搜索吗（branch_name,balance)顺序索引高校回答
  select loan_number from account where branch_name = 'Perridge'

  建立在一个复合搜索吗上的顺序索引有缺点
  select loan_number from account where branch_name < 'Perridge' and balance = 1000

  由于文件记录的顺序 每条记录可能位于不同的磁盘块 导致大量的IO操作

  第一个属性比较条件 不能对应于搜索吗上的一个范围查询

  这种情况使用位图索引 R树（B+树扩展 用于处理多维上的索引 地理数据类型）

  ----------------

  不唯一的搜索吗
  实现B+树 创建记录指针的桶处理不唯一的搜索吗（有不止一个匹配记录的搜索吗—）

  如果指针桶存储在独立的页中 提取记录时需要附加的IO操作

  为搜索吗增加一个附加的独立属性使搜索吗唯一
  可以是一个记录id 或者唯一数字

  ---------
  覆盖索引
  covering indices
  (附加的属性值（不是搜索吗属性），指向记录的指针)

  一个覆盖索引能使内部结点得到更大的扇出
  潜在降低索引高度 减少搜索吗大小

  -----------
  辅助索引和记录重定位
  一些文件组织如B+树文件组织 可改变记录位置
  当B+树文件组织中的一个叶磁盘页被分裂 一些记录会移动到新的磁盘页
  存储了指向重定位的记录的指针的辅助索引必须更新 即使记录中的值没改变

  每个叶磁盘页可能包含相当多的记录 每个记录分配到每个辅助索引上的不同位置
        一个叶磁盘页分裂可能需要几十个甚至几百次IO操作 更新所有影响到的辅助索引

辅助索引中 存储主索引搜索吗属性的值
account_number 主索引
branch_name 辅助索引 account_number值构成列表
辅助索引定位记录需要两步：辅助索引->主索引搜索吗的值->主索引->对应的记录

降低文件重组导致的索引更新代价

---------------------------------------
静态散列

顺序文件组织缺点
访问索引结构定位 必须使用二分搜索 导致过多的Io操作

基于hashing文件组织和索引

bucket:存储记录的一个存储单位 通常就是一个磁盘块 也可能小于或大于一个磁盘块

K：搜索吗值得集合
B：所有桶地址集合

hash function ：K->B 的函数
必须检查桶中每条记录的搜索吗值 确定该记录是否我们要查找的记录

删除也一样

hash file organization
计算所需记录搜索吗值的函数 直接获得包含该记录的磁盘块地址

hash index organization
把搜索吗以及相关联的指针组织成一个散列文件结构

--------------------------------------------------------------

散列函数

最坏的可能 是散列函数把所有搜索吗值映射到同一个桶中
理想的是均匀分布到所有的桶


特性
分布均匀 每个桶分配同样数量的搜索吗值

分布是随机的
 每个桶应分配到的搜索吗值数目几乎相同
 例如按字母的顺序或者搜索吗长度的顺序

branch_name 搜索吗->散列函数 account文件散列函数

散列函数
搜索吗字符内部二进制机器表示 总和  总和 % 桶数目的模

函数高效实现
最初把散列值设为0  然后从字符串的第一个字符开始迭代
直到最后一个字符为止  每一步迭代都把散列函数值*31 + 下一个字符的值（看作整数）
函数的结果再取桶数目的模得到的值 用作索引

------------------------------------------
桶溢出处理



##############################################

查询处理

查询->语法分析翻译->关系代数表达式（带注释的语法分析树）->优化器->执行计划->执行引擎->查询结果

检查用户查询语法
验证关系名

编译器 语法分析



多个关系表达式 不同的算法

注释：说明如何执行每个操作 声明某个具体操作算法 或将要使用的一个或多个特定的索引
执行原语 evaluation primitive 如何执行的关系代数运算
query-exectution plan query-evaluation plan ->执行一个查询原语操作序列

选择运算指定了一个具体的索引

qyuery-execution engine 接受一个查询执行计划 把结果返回

查询优化
构造具有最小查询执行代价的查询执行计划

每个操作的代价 粗略估计


pipeline 流水线

每个操作同时在输入元组上开始执行

查询执行计划中如何协调多个操作的执行 将操作组织成流水线 避免中间结果立即写入磁盘


查询代价的度量

磁盘存取
传输一块的数据平均消耗 0.1ms 磁盘平均访问时间 4ms
传送磁盘块数 搜索磁盘次数

    读磁盘块

    写磁盘块 是读的两倍
        磁盘系统在写完扇区后还会重新读取该扇区 验证写操作已经成功

    内存缓冲区 所有数据读入缓冲区或者只能容纳数目不多的数据块 每个关系一块

    很有可能访问的磁盘块已经在内存缓冲区了

cpu时间

通信开销（并行\分布式数据库）



选择运算
        文件扫描 file scan 存取数据最低级的操作
        定位 检索 满足条件的记录
        扫描算法
            A1 线性搜素
                扫描每个文件块 测试所有记录 看它们是否满足选择条件
                开始做一次磁盘搜索访问文件第一个块 如果不是连续存放的  需要更多的磁盘搜索

                磁盘操作的次数衡量 线性搜索的代价 是一次磁盘搜索+磁盘块数*磁盘块传输

                作用在吗属性上的选择操作来说，找到所需记录立即停止 而无需搜索表中其他记录
                码属性选择平均传输代价为br/2 最坏情况下的代价仍然是一次磁盘搜索+磁盘块数*磁盘块传输

                可用于任何文件


            A2 二分搜索
                文件按某一属性排序 选择条件是属性的等值比较
                二分搜索定位 针对文件的磁盘块进行



            ....

排序
    对已排序的运算能高效实现

    排序吗 建立索引->索引->按序读取关系

    顺序读取元组可能导致每读一条记录就要访问一次磁盘

    有时需要在物理上对记录排序

    标准排序
        快速排序
    外排序 external sorting
    外部排序归并 external sort-merge
    M:内存中用于缓冲的页面数 内存的缓冲区能容纳的磁盘块数
    建立多个排好序的归并段
    ->归并段总数N小于M 为每个归并段文件分配一个内存页
     此外剩下的空间还能容纳存放结果的一页

     工作流程：
     为N个归并段文件R 各分配一页内存缓冲页 并分别读入一数据块
     repeat
        在所有缓冲页中按序挑选第一个元祖；
        把该元组作为输出写出，将其从缓冲页删除
        if 任何一个归并段文件Ri的缓冲页为空 并且没有到达Ri末尾
            then 读入Ri的下一块到相应的缓冲页

     until 所有的缓冲页均空
二路归并算法
对N个归并段归并 故称为N路归并 N-way merge

如果数据量很大 归并操作需要分多趟进行
由于内存足以容纳M-1个缓冲页 每趟归并可以用M-1个归并段作为输入

最初那趟归并-

磁盘搜索次数+磁盘块传输次数

#############################################

连接运算

嵌套循环连接

equi-join 等值连接

nested-loop join

嵌套for循环

自然链接 去掉重复属性的投影运算
去重


代价大 逐个检查两个关系中每一对元祖

索引

嵌套循环

-----------

块嵌套循环连接
以每个块方式处理

（内层块（元祖...)，外层块（元祖...)）->

元祖对
全体元祖

500次块传输和2次磁盘搜索

-------------------


---------------------------
查询优化

从多种策略找出最有效的查询执行计划

处理查询 选择详细的策略 如选择使用特定索引


找出在Brooklyn任何支行中开设了账户的所有客户的姓名


查询优化器 产生查询执行计划 能获得与原关系表达式相同的结果 执行代价最小

查询执行计划产生有三步：

1.产生逻辑上 与给定表达式等价的表达式
等价规则 逻辑上等价

基于代价的优化 cost based optimization
物化视图 能帮助加速某些查询处理


-----------------
关系表达式转换

1.等价规则 equivalence rule 两种不同形式的表达式是等价的

谓词

属性列表

关系代数表达式

合取选择运算 可分解为单个选择运算的序列

选择运算满足交换律 commutative

一系列投影运算最后一个运算是必需的

选择操作可与笛卡尔积 @连接结合

左端和右端属性顺序不同

可以对等价规则一端加入一个投影操作以适当重排属性

自然连接 @连接的特例  满足交换律
    满足结合律 associative

    任意一个条件都可为空
    笛卡尔积运算也满足结合律

    连接运算满足结合律 交换律在查询优化中重排连接顺序很重要

    选择运算在下面两个条件下对@连接运算具有分配律
    a.当选择条件所有属性只涉及参与连接运算表达式之一
    b.当选择条件@只涉及E1的属性 条件@2只涉及E2属性

投影运算在下面条件对@链接运算有分配律
a.
b.

集合的并与交满足交换律 结合律

选择运算对并 交 差 具有分配律

投影运算对并运算具有分配律

转换的例子


最小的等价规则集
若一组等价规则中任一条规则不能由其他规则联合导出

查询优化其使用等价规则的最小集


2.连接的次序

好的连接运算次序有利于减少临时结果大小


需要保存的临时关系

利用自然链接满足结合律和交换律性质
重写关系代数表达式

2.等价表达式的枚举

给定一个表达式 ->其中任何子表达式 与等价规则某一边相匹配 则优化器产生一个新的表达式
子表达式转换成与它相匹配的规则的另一边 不断进行下去 直到不再有新表达式产生

对空间需求可按如下方式减小

采用一些表达式表示技术 使得两个表达式指向共享的子表达式

-------------------------------
->



2.估计每个执行计划的代价
第二步估计是在后台收集关系的统计信息如关系大小和索引深度


表达式结果集统计大小的估计




选择执行计划
从选择运算到归并连接运算边上标记了流水线

选择运算产生按连接属性排序输出 可以使用流水线

当branch与account基于branch_name索引具有相等branch_name属性值记录排序保存时
选择运算就产生按连接属性排序的输出

查询执行技术
为每个运算选择代价最小的算法
保证表达式树层次较低运算比层次较高运算先执行

归并连接

散列连接

有序输出

使得以后运算 消除重复 集合交 归并连接代价小

索引嵌套循环连接提供把结果按流水线方式传给下一个运算机会


选择总体上最佳的算法

根据可用索引情况 一些选择操作仅用索引就可以i执行

搜索所有计划 基于代价选择最佳计划；
启发式方法 选择

----------------------------------

基于代价的优化器 cost_based_optimizer
使用等价规则从给定的查询语句中产生一系列查询执行计划 选择代价最小的一个

舍弃其他代价较大的连接顺序

动态规划算法寻找最佳连接顺序 存储计算结果并重用 大大较少执行时间
动态规划算法递归程序 连接顺序优化的动态规划算法

减少在大量计划中搜索的代价

sql sqlserver查询优化器 基于等价规则的
易于扩展

缺点 优化本身代价 一个查询不同执行计划数仍然很大


---------------------
启发式优化

尽早执行选择运算

直接使用
先用索引计算连接 去除不满足选择条件的元祖 代价更小

尽早执行投影运算
通常选择运算好 可以利用索引存取元祖

许多查询优化器
System R 只对特殊类型的连接次序搜索
左深连接顺序left-deep join order 用于流水线计算

找到最佳连接顺序
把这一代价同找出总体最佳的连接顺序所需时间比较



->

3.对产生的表达式以不同方式注释 产生不同的查询计划

先产生一些表达式加以注释 再进一步产生一些表达式加以注释


---------------------

嵌套子查询的优化

select cutomer_name
from borrower
wherer exists(select * from depositor where depositor.customer_name = borrower.customer_name)

外层笛卡儿积->每个元组用where子句的谓词进行测试

尽可能将嵌套子查询转换成连接形式

单独优化

select customer_name from borrower,depositor
where depositor.customer_name = borrower.customer.name

select from L1 where p1 and exists(select * from L2 where P2)

create table t1 as select distinct V from L2 where P2

select ... from L1,t1 where p1 and p2

初始的查询可以转换成


create table t1 as select distinct customer_name from depositor
select customer_name from borrower,t1
where t1.customer_name = borrower.customer_name

去除相关
用一个具有连接的擦好像 可能使用临时关系 替代嵌套查询的过程

许多优化器仅作少量的去除

最好避免复杂嵌套子查询


----------------------------
物化视图





-----------
insert overwrite directory '/apps-data/hduser1508/sx_core_safe/lar_dcs_result_ind_test' row format delimited fields terminated by ','
select * from sx_hx_safe.bas_pala_lar_dcs_result_ind;

















