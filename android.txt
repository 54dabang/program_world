


1.1.1　Android系统架构　　2

1.1.2　Android已发布的版本　　3

1.1.3　Android应用开发特色　　4

1.2　手把手带你搭建开发环境　　5


1.3　创建你的第一个Android项目　　9

1.3.1　创建HelloWorld项目　　9

1.3.2　启动模拟器　　12

1.3.3　运行HelloWorld　　15

1.3.4　分析你的第一个Android程序　　16

1.3.5　详解项目中的资源　　22

1.3.6　详解build.gradle文件　　23

1.4　前行必备——掌握日志工具的使用　　26

1.4.1　使用Android的日志工具Log　　26

1.4.2　为什么使用Log而不使用System.out　　27

1.5　小结与点评　　29

2.1　活动是什么　　30

2.2　活动的基本用法　　30

2.2.1　手动创建活动　　31

2.2.2　创建和加载布局　　32

2.2.3　在AndroidManifest文件中注册　　35

2.2.4　在活动中使用Toast　　37

2.2.5　在活动中使用Menu　　38

2.2.6　销毁一个活动　　40

2.3　使用Intent在活动之间穿梭　　41

2.3.1　使用显式Intent　　41

2.3.2　使用隐式Intent　　44

2.3.3　更多隐式Intent的用法　　46

2.3.4　向下一个活动传递数据　　50

2.3.5　返回数据给上一个活动　　51

2.4　活动的生命周期　　53

2.4.1　返回栈　　53

2.4.2　活动状态　　54

2.4.3　活动的生存期　　55

2.4.4　体验活动的生命周期　　56

2.4.5　活动被回收了怎么办　　62

2.5　活动的启动模式　　63

2.5.1　standard　　64

2.5.2　singleTop　　65

2.5.3　singleTask　　67

2.5.4　singleInstance　　68

2.6　活动的最佳实践　　71

2.6.1　知晓当前是在哪一个活动　　71

2.6.2　随时随地退出程序　　72

2.6.3　启动活动的最佳写法　　74

2.7　小结与点评　　75

第3章　软件也要拼脸蛋——UI开发的点点滴滴　　76

3.1　如何编写程序界面　　76

3.2　常用控件的使用方法　　77

3.2.1　TextView　　77

3.2.2　Button　　80

3.2.3　EditText　　82

3.2.4　ImageView　　86

3.2.5　ProgressBar　　88

3.2.6　AlertDialog　　91

3.2.7　ProgressDialog　　93

3.3　详解4种基本布局　　94

3.3.1　线性布局　　94

3.3.2　相对布局　　100

3.3.3　帧布局　　103

3.3.4　百分比布局　　105

3.4　系统控件不够用？创建自定义控件　　108

3.4.1　引入布局　　109

3.4.2　创建自定义控件　　111

3.5　最常用和最难用的控件——ListView　　113

3.5.1　ListView的简单用法　　114

3.5.2　定制ListView的界面　　115

3.5.3　提升ListView的运行效率　　119

3.5.4　ListView的点击事件　　120

3.6　更强大的滚动控件——RecyclerView　　122

3.6.1　RecyclerView的基本用法　　122

3.6.2　实现横向滚动和瀑布流布局　　125

3.6.3　RecyclerView的点击事件　　130

3.7　编写界面的最佳实践　　132

3.7.1　制作Nine-Patch图片　　132

3.7.2　编写精美的聊天界面　　135

3.8　小结与点评　　141


4.1　碎片是什么　　142

4.2　碎片的使用方式　　144

4.2.1　碎片的简单用法　　144

4.2.2　动态添加碎片　　147

4.2.3　在碎片中模拟返回栈　　150

4.2.4　碎片和活动之间进行通信　　151

4.3　碎片的生命周期　　151

4.3.1　碎片的状态和回调　　151

4.3.2　体验碎片的生命周期　　153

4.4　动态加载布局的技巧　　156

4.4.1　使用限定符　　156

4.4.2　使用最小宽度限定符　　159

4.5　碎片的最佳实践——一个简易版的新闻应用　　160

4.6　小结与点评　　169

第5章　全局大喇叭——详解广播机制　　170

5.1　广播机制简介　　170

5.2　接收系统广播　　171

5.2.1　动态注册监听网络变化　　171

5.2.2　静态注册实现开机启动　　174

5.3　发送自定义广播　　177

5.3.1　发送标准广播　　177

5.3.2　发送有序广播　　179

5.4　使用本地广播　　183

5.5　广播的最佳实践——实现强制下线功能　　185

5.6　Git时间——初识版本控制工具　　192

5.6.1　安装Git　　192

5.6.2　创建代码仓库　　193

5.6.3　提交本地代码　　195

5.7　小结与点评　　195

第6章　数据存储全方案——详解持久化技术　　196

6.1　持久化技术简介　　196

6.2　文件存储　　197

6.2.1　将数据存储到文件中　　197

6.2.2　从文件中读取数据　　201

6.3　SharedPreferences存储　　203

6.3.1　将数据存储到SharedPreferences中　　203

6.3.2　从SharedPreferences中读取数据　　206

6.3.3　实现记住密码功能　　208

6.4　SQLite数据库存储　　211

6.4.1　创建数据库　　211

6.4.2　升级数据库　　216

6.4.3　添加数据　　219

6.4.4　更新数据　　222

6.4.5　删除数据　　224

6.4.6　查询数据　　225

6.4.7　使用SQL操作数据库　　228

6.5　使用LitePal操作数据库　　229

6.5.1　LitePal简介　　229

6.5.2　配置LitePal　　230

6.5.3　创建和升级数据库　　231

6.5.4　使用LitePal添加数据　　236

6.5.5　使用LitePal更新数据　　237

6.5.6　使用LitePal删除数据　　240

6.5.7　使用LitePal查询数据　　241

6.6　小结与点评　　243

第7章　跨程序共享数据——探究内容提供器　　244

7.1　内容提供器简介　　244

7.2　运行时权限　　245

7.2.1　Android权限机制详解　　245

7.2.2　在程序运行时申请权限　　249

7.3　访问其他程序中的数据　　254

7.3.1　ContentResolver的基本用法　　254

7.3.2　读取系统联系人　　256

7.4　创建自己的内容提供器　　260

7.4.1　创建内容提供器的步骤　　261

7.4.2　实现跨程序数据共享　　265

7.5　Git时间——版本控制工具进阶　　275

7.5.1　忽略文件　　275

7.5.2　查看修改内容　　276

7.5.3　撤销未提交的修改　　278

7.5.4　查看提交记录　　279

7.6　小结与点评　　280

第8章　丰富你的程序——运用手机多媒体　　281

8.1　将程序运行到手机上　　281

8.2　使用通知　　283

8.2.1　通知的基本用法　　283

8.2.2　通知的进阶技巧　　289

8.2.3　通知的高级功能　　291

8.3　调用摄像头和相册　　293

8.3.1　调用摄像头拍照　　294

8.3.2　从相册中选择照片　　298

8.4　播放多媒体文件　　303

8.4.1　播放音频　　303

8.4.2　播放视频　　307

第9章　看看精彩的世界——使用网络技术　　312

9.1　WebView的用法　　312

9.2　使用HTTP协议访问网络　　314

9.2.1　使用HttpURLConnection　　315

9.2.2　使用OkHttp　　319

9.3　解析XML格式数据　　321

9.3.1　Pull解析方式　　324

9.3.2　SAX解析方式　　326

9.4　解析JSON格式数据　　329

9.4.1　使用JSONObject　　330

9.4.2　使用GSON　　331

9.5　网络编程的最佳实践　　334

9.6　小结与点评　　338

第10章　后台默默的劳动者——探究服务　　339

10.1　服务是什么　　339

10.2　Android多线程编程　　340

10.2.1　线程的基本用法　　340

10.2.2　在子线程中更新UI　　341

10.2.3　解析异步消息处理机制　　345

10.2.4　使用AsyncTask　　347

10.3　服务的基本用法　　349

10.3.1　定义一个服务　　349

10.3.2　启动和停止服务　　352

10.3.3　活动和服务进行通信　　355

10.4　服务的生命周期　　359

10.5　服务的更多技巧　　359

10.5.1　使用前台服务　　359

10.5.2　使用IntentService　　361

10.6　服务的最佳实践——完整版的下载示例　　365

10.7　小结与点评　　378

第11章　Android特色开发——基于位置的服务　　379

11.1　基于位置的服务简介　　379

11.2　申请API Key　　380

11.3　使用百度定位　　384

11.3.1　准备LBS SDK　　384

11.3.2　确定自己位置的经纬度　　386

11.3.3　选择定位模式　　391

11.3.4　看得懂的位置信息　　393

11.4　使用百度地图　　395

11.4.1　让地图显示出来　　395

11.4.2　移动到我的位置　　397

11.4.3　让“我”显示在地图上　　400

11.5　Git时间——版本控制工具的高级用法　　402

11.5.1　分支的用法　　403

11.5.2　与远程版本库协作　　404

11.6　小结与点评　　406

第12章　最佳的UI体验——MaterialDesign实战　　407

12.1　什么是Material Design　　407

12.2　Toolbar　　408

12.3　滑动菜单　　415

12.3.1　DrawerLayout　　415

12.3.2　NavigationView　　418

12.4　悬浮按钮和可交互提示　　423

12.4.1　FloatingActionButton　　424

12.4.2　Snackbar　　427

12.4.3　CoordinatorLayout　　428

12.5　卡片式布局　　430

12.5.1　CardView　　431

12.5.2　AppBarLayout　　437

12.6　下拉刷新　　440

12.7　可折叠式标题栏　　443

12.7.1　CollapsingToolbarLayout　　443

12.7.2　充分利用系统状态栏空间　　453

12.8　小结与点评　　456

第13章　继续进阶——你还应该掌握的高级技巧　　457

13.1　全局获取Context的技巧　　457

13.2　使用Intent传递对象　　461

13.2.1　Serializable方式　　461

13.2.2　Parcelable方式　　463

13.3　定制自己的日志工具　　464

13.4　调试Android程序　　466

13.5　创建定时任务　　469

13.5.1　Alarm机制　　469

13.5.2　Doze模式　　471

13.6　多窗口模式编程　　472

13.6.1　进入多窗口模式　　473

13.6.2　多窗口模式下的生命周期　　475

13.6.3　禁用多窗口模式　　479

13.7　Lambda表达式　　481

13.8　总结　　485

第14章　进入实战——开发酷欧天气　　486

14.1　功能需求及技术可行性分析　　486

14.2　Git时间——将代码托管到GitHub上　　489

14.3　创建数据库和表　　494

14.4　遍历全国省市县数据　　499

14.5　显示天气信息　　509

14.5.1　定义GSON实体类　　509

14.5.2　编写天气界面　　514

14.5.3　将天气显示到界面上　　520

14.5.4　获取必应每日一图　　526

14.6　手动更新天气和切换城市　　532

14.6.1　手动更新天气　　532

14.6.2　切换城市　　535

14.7　后台自动更新天气　　540

14.8　修改图标和名称　　542

14.9　你还可以做的事情　　543

第15章　最后一步——将应用发布到360应用商店　　545

15.1　生成正式签名的APK文件　　545

15.1.1　使用Android Studio生成　　546

15.1.2　使用Gradle生成　　548

15.1.3　生成多渠道APK文件　　551

15.2　申请360开发者账号　　554

15.3　发布应用程序　　556

15.4　嵌入广告进行盈利　　560

15.4.1　注册腾讯广告联盟账号　　560

15.4.2　新建媒体和广告位　　562

15.4.3　接入广告SDK　　564

15.4.4　重新发布应用程序　　569

15.5　结束语　　570

1.1 Android简介

1.1.1 Android起源

1.1.2 Android的优点

1.1.3 Android的系统架构

1.2 Android开发环境配置

1.3 第一个Android应用程序

第2章 Android应用程序

2.1 基本组件介绍

2.2 Activity生命周期

2.3 Android程序调试

第3章 Android常用基本控件

3.1 界面布局

3.1.1 线性布局

3.1.2 表格布局

3.1.3 相对布局

3.1.4 帧布局

3.1.5 绝对布局

3.2 界面控件

3.2.1 文本控件

3.2.2 按钮控件

3.2.3 图片控件

3.2.4 时钟控件

3.2.5 日期与时间选择控件

3.3 菜单

3.3.1 选项菜单和子菜单

3.3.2 上下文菜单

3.4 对话框

3.4.1 对话框简介

3.4.2 普通对话框

3.4.3 列表对话框

3.4.4 单选按钮和复选框对话框

3.4.5 日期及时间选择对话框

3.4.6 进度对话框

3.5 界面事件

3.5.1 onKeyDown方法简介

3.5.2 onKeyUp方法简介

3.5.3 onTouchEvent方法简介

3.5.4 onTrackBallEvent方法和onFocusChanged方法简介

3.5.5 OnClickListener接口简介

3.5.6 OnFocusChangeListener接口简介

3.5.7 OnKeyListener接口简介

3.5.8 OnTouchListener接口简介

3.5.9 OnCreateContextMenuListener接口简介

3.6 动画播放技术

3.6.1 帧动画

3.6.2 补间动画

第4章 Android常用高级控件

4.1 自动完成文本框

4.2 滚动视图和列表视图

4.2.1 滚动视图

4.2.2 列表视图

4.3 滑块与进度条

4.4 画廊控件与消息提示

4.4.1 画廊控件

4.4.2 Toast的使用

4.4.3 Notification的使用

4.5 下拉列表控件与选项卡

4.5.1 下拉列表控件

4.5.2 选项卡

5.1 自定义View的使用

5.2 SurfaceView的使用
5.3 游戏碰撞与检测技术
5.3.1 碰撞检测技术基础
5.3.2 游戏中实体对象之间的碰撞检测
5.3.3 游戏实体对象与环境之间的碰撞检测
5.4 扫雷游戏实例
第6章 Android消息与广播
6.1 Intent
6.1.1 启动Activity
6.1.2 获取Activity返回值
6.2 Intent过滤器
6.3 BroadcastReceive组件应用
第7章 Service后台服务
7.1 Service组件应用
7.2 进程内服务
7.2.1 服务管理
7.2.2 使用线程
7.2.3 服务绑定
7.3 Handler消息传递机制
7.4 单机版音乐盒实例
第8章 Android数据存储与访问
8.1 简单存储
8.2 文件存储
8.2.1 内部存储
8.2.2 外部存储
8.2.3 资源文件
8.3 SQLite数据库存储
8.3.1 SQLite数据库
8.3.2 手动建库
8.3.3 代码建库
8.3.4 数据操作
8.4 内容提供器——Content Providers
8.5 实训
第9章 Android位置服务与地图应用
9.1 位置服务
9.2 Google地图应用
9.2.1 申请地图密钥
9.2.2 使用Google地图
9.2.3 Google地图上贴上标记
9.3 利用Google API完成天气预报
9.3.1 信息来源
9.3.2 UI设计
9.3.3 解析XML
9.3.4 AndroidManifest.xml（限设置）
第10章 综合案例设计与开发
10.1 需求分析
10.2 策划与准备
10.2.1 图片资源的准备
10.2.2 数据库设计
10.3 程序设计
10.3.1 数据库适配器
10.3.2 主界面类PhotographActivity.java的实现
10.3.3 辅助类的设计


1.1 Android介绍
1.2 Android系统构架
1.3 Android应用程序框架
1.4 本章小结
2.1 获取Android源码
2.1.1 在Linux系统中获取Android源码
2.1.2 在Windows平台获取Android源码
2.1.3 编译源码
2.2 Android Studio应用开发
2.2.1 搭建Android Studio应用开发环境
2.2.2 创建第一个Android项目：HelloWorld
2.2.3 启动模拟器
2.2.4 运行到模拟器
2.2.5 下载到真机
2.2.6 详解项目中的资源
2.2.7 详解build.gradle文件
2.2.8 导入外部项目和Eclipse开发的Android项目
2.2.9 添加外部库
2.2.10 应用程序的调试
2.2.11 项目实战：下载Android的各个版本
2.3 本章小结
第3章 Android界面设计
3.1 用户界面基础
3.2 Android的Activity
3.2.1 Activity的介绍
3.2.2 Activity的生命周期
3.2.3 创建一个Activity
3.2.4 创建和加载布局
3.2.5 销毁一个Activity
3.2.6 使用Intent在Activity之间穿梭
3.2.7 Intent调用常见系统组件
3.3 常用控件的使用方法
3.3.1 TextView和EditText
3.3.2 Button、ToggleButton和ImageView
3.3.3 Spinner
3.3.4 ListView
3.3.5 AlertDialog
3.3.6 ProgressBar
3.4 Android布局
3.4.1 线性布局
3.4.2 相对布局
3.4.3 表格布局
3.4.4 百分比布局
3.4.5 嵌套布局实现计算器界面
3.5 样式和主题
3.5.1 定义样式
3.5.2 使用样式
3.5.3 主题
3.6 新控件RecyclerView、CardView和Palette的使用
3.6.1 新控件的使用
3.6.2 实现纵向滚动和横向滚动
3.6.3 RecyclerView的点击事件
3.7 Android新控件
3.8 综合项目实战：WebView实现监控界面
3.9 本章小结
第4章 创建Android应用程序
4.1 概述
4.2 事件处理机制
4.2.1 基于监听器的事件处理
4.2.2 基于回调的事件处理
4.2.3 事件响应的实现
4.2.4 项目实战：获取屏幕触点坐标
4.3 Android多线程
4.3.1 线程的基本用法
4.3.2 在子线程更新UI
4.3.3 Android线程池
4.3.4 Android四种线程池实例
4.4 Android广播组件
4.4.1 动态注册广播
4.4.2 静态注册广播
4.4.3 自定义本地广播
4.5 后台服务（Service）
4.5.1 定义一个服务
4.5.2 启动和停止服务
4.5.3 Service和Activity通信
4.6 Android实现多任务
4.6.1 多任务实现原理
4.6.2 用Handler实现多任务
4.6.3 项目实战：Handler实现模拟下载
4.6.4 AsyncTask实现多任务
4.6.5 项目实战：AsyncTask实现计时
4.7 本章小结
第5章 Android中数据的存储和访问
5.1 简介
5.2 使用共同偏好的存取数据
5.2.1 存取共享偏好
5.2.2 Preference框架
5.3 文件读取和保存
5.3.1 内部存储
5.3.2 扩展存储
5.4 存取结构化数据
5.4.1 SQLite简介
5.4.2 创建SQLite数据库
5.4.3 操作数据库
5.5 使用LitePal操作数据库
5.5.1 LitePal简介
5.5.2 配置LitePal
5.5.3 创建和升级数据库
5.5.4 SQLite命令调试
5.5.5 数据库操作
5.6 网络存储
5.7 本章小结
第6章 ContentProvider
6.1 查询记录
6.2 修改记录
6.3 添加记录
6.4 删除记录
6.5 创建Content Provider
6.6 本章小结
第二部分 物联网应用
第7章 移动智能终端访问网络摄像机
7.1 简介
7.2 网络摄像机
7.3 系统实现
7.3.1 介绍
7.3.2 网络摄像机参数设置
7.3.3 智能手机端视频监控软件
7.4 本章小结
第8章 物联网语音识别开发
8.1 语音识别技术概述
8.2 TTS语音识别技术
8.2.1 TTS基础
8.2.2 TTS开发流程
8.2.3 项目实战：TTS文字识别实例
8.3 Voice Recognition语言识别
8.3.1 Voice Recognition技术基础
8.3.2 项目实战：Voice Recognition语音识别
8.4 本章小结
第9章 在物联网中媒体动画的实现
9.1 Android多媒体系统架构基础
9.2 Graphics类详解
9.2.1 Graphics类基础
9.2.2 Android图形绘制类
9.2.3 绘制基本图形
9.3 二维动画
9.3.1 类Drawable
9.3.2 实现Tween动画效果
9.3.3 Tween动画的四种动画效果
9.3.4 实现Frame动画效果
9.4 项目实战：物联网环境控制动画
9.5 OpenGL ES详解
9.5.1 OpenGL ES基础
9.5.2 Android中的OpenGL ES
9.5.3 Open GL的基本操作
9.5.4 项目实战：利用OpenGL实现旋转的立方体
9.6 音频实现
9.6.1 音频接口类
9.6.2 AudioManager控制铃声
9.6.3 录音详解
9.6.4 项目实战：使用MediaPlay播放音乐
9.7 二维码的识别
9.7.1 二维码介绍
9.7.2 项目实战：Android实现二维码识别
9.8 本章小结
第10章 Android网络开发
10.1 Android Socket网络传输
10.1.1 什么是Socket
10.1.2 Socket的分类
10.1.3 Socket基本实现原理
10.1.4 Android实现Socket简单通信
10.1.5 Android客户端和PC服务器端通信
10.2 Android HTTP网络传输
10.2.1 HttpURLConnection接口
10.2.2 项目实战：HttpURLConnection获取信息
10.2.3 使用OkHttp
10.2.4 项目实战：OkHttp获取信息
10.3 Android应用程序的权限
10.3.1 Android权限机制详解
10.3.2 在程序运行时申请权限
10.4 解析XML格式数据
10.4.1 Pull解析方式
10.4.2 SAX解析方式
10.5 解析JSON格式数据
10.5.1 使用JSONObject
10.5.2 使用GSON
10.6 本章小结
第11章 Android无线通信
11.1 Android蓝牙传输数据
11.1.1 蓝牙介绍
11.1.2 蓝牙体系结构
11.1.3 蓝牙软件的实现
11.1.4 Android的蓝牙接口类
11.1.5 Android蓝牙开发步骤
11.1.6 项目实战：查找蓝牙设备
11.1.7 项目实战：Android手机蓝牙控制智能小车
11.2 Android系统中的NFC
11.2.1 近场通信技术基础
11.2.2 在Android系统中使用NFC
11.2.3 项目实战：在Android中使用NFC读取MifareClassic卡
11.3 本章小结
第12章 Android访问智能电表或智能插座
12.1 简介
12.1.1 RS-485接口智能插座
12.1.2 无线智能插座
12.1.3 智能电表
12.2 使用智能手机访问智能电表或智能插座
12.2.1 使用智能手机访问智能电表或智能插座的方案
12.2.2 使用智能手机访问Wi-Fi型智能插座或智能电表的方案
12.3 使用Android访问智能电表或智能插座
12.3.1 智能手机和Pad之间的数据通信
12.3.2 蓝牙通信实现
12.3.3 访问智能电表或智能插座的命令格式
12.4 本章小结
第三部分 综合实战
第13章 UI新体验——Material Design
13.1 什么是Material Design
13.2 Design Support库的使用
13.3 DrawerLayout和Navigation View
13.4 Material Design开源项目
13.5 本章小结
第14章 综合项目：Cool Weather
14.1 项目分析
14.2 创建数据库和表
14.3 遍历全国省、市、县数据
14.4 设计天气信息界面
14.5 省、市、县数据界面处理
14.6 处理返回的JSON数据
14.7 将天气信息显示到界面上
14.8 后台自动更新天气
第15章 Android应用程序托管和发布
15.1 Git版本控制工具
15.1.1 安装Git
15.1.2 创建代码仓库
15.1.3 提交本地代码
15.2 GitHub
15.2.1 在GitHub注册创建版本库
15.2.2 将代码托管到GitHub
15.3 将应用程序发布到360应用商店
15.3.1 生成正式签名的APK文件
15.3.2 申请360开发账号
15.3.3 发布应用程序
15.3.4 嵌入广告

　8种Android全埋点解决方案包括：
　　AppClick 全埋点方案1：代理 View.OnClickListener、
　　AppClick 全埋点方案2：代理 Window.Callback
　　AppClick 全埋点方案3：代理 View.AccessibilityDelegate
　　AppClick 全埋点方案4：透明层
　　AppClick 全埋点方案5：AspectJ
　　AppClick 全埋点方案6：ASM
　　AppClick 全埋点方案7：Javassist
　　AppClick 全埋点方案8：AST

第1章　全埋点概述1
1.1　Android View 类型3
1.2　View 绑定listener 方式7
第2章　$AppViewScreen全埋点
方案10
2.1　关键技术Application.Activity
LifecycleCallbacks10
2.2原理概述11
2.3　案例12
2.4　完善方案24
2.5　扩展采集能力30
第3章　$AppStart、$AppEnd
全埋点方案33
3.1　原理概述34
3.2　案例35
3.3　缺点46
第4章　$AppClick全埋点方案1：代理
View.OnClickListener47
4.1　关键技术47
4.2　原理概述48
4.3　案例49
4.4　引入DecorView62
4.5　引入ViewTreeObserver.
OnGlobalLayoutListener64
4.6　扩展采集能力67
4.7　缺点91
第5章　$AppClick 全埋点方案2：代理
Window.Callback92
5.1　关键技术92
5.2　原理概述93
5.3　案例93
5.4　扩展采集能力101
5.5　缺点111
第6章　$AppClick 全埋点方案3：代理
View.AccessibilityDelegate112
6.1　关键技术112
6.1.1　Accessibility112
6.1.2　View.AccessibilityDelegate113
6.2　原理概述114
6.3　案例114
6.4　扩展采集能力122
6.5　缺点129
第7章　$AppClick全埋点方案4：
透明层130
7.1　原理概述130
7.1.1　View onTouchEvent130
7.1.2　原理概述130
7.2　案例131
7.3　扩展采集能力139
7.4　缺点145
第8章　$AppClick全埋点方案5:
AspectJ146
8.1　关键技术146
8.1.1　AOP146
8.1.2　AspectJ148
8.1.3　AspectJ 注解148
8.1.4　切点表达式151
8.1.5　JoinPoint153
8.1.6　call与execution区别155
8.1.7　AspectJ 使用方法157
8.1.8　通过Gradle 配置使用 AspectJ157
8.1.9　自定义Gradle Plugin162
8.1.10　发布 Gradle 插件165
8.1.11　使用 Gradle Plugin167
8.1.12　Plugin Project168
8.2　原理概述171
8.3　案例171
8.4　完善方案193
8.5　扩展采集能力196
8.6　缺点202
第9章　$AppClick全埋点方案6：
ASM203
9.1　关键技术203
9.1.1　Gradle Transform203
9.1.2　Gradle Transform 实例207
9.1.3　ASM213
9.2　原理概述220
9.3　案例220
9.4　完善240
9.5　扩展采集能力241
9.6　缺点250
第10章　$AppClick全埋点方案7：
Javassist251
10.1　关键技术251
10.1.1　Javassist251
10.1.2　Javassist基础251
10.2　原理概述255
10.3　案例255
10.4　扩展采集能力272
第11章　$AppClick全埋点方案8：
AST280
11.1　关键技术280
11.1.1　APT280
11.1.2　Element280
11.1.3　APT实例282
11.1.4　javapoet293
11.1.5　AST295
11.2　原理概述295
11.3　案例295
11.4　完善方案306
11.5　扩展采集能力308
11.6　缺点317

第1章 探寻高效易用的反射API
1．1 反射的能力
1．1．1 得到Class对象
1．1．2 操作Field
1．1．3 调用Method
1．1．4 动态代理
1．2 反射封装库――JOOR
1．2．1 反射的流程
1．2．2 VirtualApp中的反射
1．2．3 一行代码建立对象
1．2．4 简化Field的相关操作
1．2．5 简化方法调用
1．2．6 封装动态代理
1．3 注意事项
1．3．1 反射的性能问题
1．3．2 反射的使用时机
1．3．3 如何降低反射的性能损耗
1．3．4 反射的危险性
1．3．5 反射和混淆的关系
1．4 总结
第2章 打造高扩展性的Log系统
2．1 基本概念
2．2 命令行操作Log
2．2．1 输出日志
2．2．2 过滤日志
2．3 Android Studio中的Log
2．3．1 设置模板
2．3．2 正则过滤
2．3．3 热部署Log
2．4 微信的Xlog
2．4．1 设计和开发目标
2．4．2 编译、引入和使用
2．4．3 对Log文件进行优化
2．5 美团的Logan
2．6 扩展Log的功能
2．6．1 TAG的自动化
2．6．2 文本内容的设计
2．6．3 开关的设计
2．7 封装Log库
2．7．1 Timber
2．7．2 LogDelegate
2．7．3 Logger
2．7．4 扩展Timber的功能
2．7．5 分发日志
2．8 实用日志
2．8．1 操作耗时日志
2．8．2 页面跳转日志
2．8．3 网络请求日志
2．9 总结
第3章 万变不离其宗的Intent
3．1 源码分析
3．1．1 静态变量的写法
3．1．2 Intent的深拷贝
3．1．3 makeMainActivity
3．1．4 Intent的Chooser
3．1．5 用URI代替Intent
3．1．6 存取值的底层实现
3．1．7 区分显式和隐式Intent
3．1．8 抛弃Bundle的传值策略
3．2 序列化方案
3．2．1 Serializable/Externalizable
3．2．2 Android中的Parcelable
3．2．3 Google的Protocol Buffer
3．2．4 Twitter的Serial
3．3 常见问题
3．3．1 父类的序列化
3．3．2 类型转换异常
3．3．3 重复启动的问题
3．3．4 传递大对象
3．4 简单的传值库――Parceler
3．4．1 降低Key的维护成本
3．4．2 自动维护Intent的Key
3．4．3 Jetpack中的自动化
3．4．4 自动保存状态
3．4．5 处理ClassCastException
3．4．6 IntentLauncher
3．4．7 统一存取的API
3．5 总结
第4章 SharedPrefrences的再封装
4．1 源码分析
4．1．1 缓存机制
4．1．2 SharedPreferencesImpl
4．1．3 值操作
4．1．4 提交操作
4．2 异常处理
4．2．1 name为null
4．2．2 管理好Key的取名
4．2．3 清空操作失效
4．2．4 磁盘写入异常
4．2．5 出现ANR
4．2．6 存序列化对象
4．2．7 多App和多进程访问异常
4．3 性能优化
4．3．1 避免储存大量数据
4．3．2 尽可能提前初始化
4．3．3 避免Key过长
4．3．4 多次操作，批量提交
4．3．5 缓存Editor对象
4．3．6 不存放HTML和JSON
4．3．7 拆分高频和低频操作
4．4 封装SharedPreferences
4．4．1 PreferenceDataStore
4．4．2 通过接口提高内聚
4．4．3 得到SharedPreferences
4．4．4 多用户存储设计
4．4．5 统一管理Key
4．4．6 自动判断返回值类型
4．4．7 决定是否使用Apply
4．4．8 存放序列化对象
4．4．9 支持数据格式转换器
4．5 思维扩展
4．5．1 偏好界面的实现方案
4．5．2 监听数据的改变
4．5．3 利用Tray实现多进程访问
4．5．4 React Native中的使用
4．6 总结
第5章 寻找Fragment的继任者
5．1 使用场景
5．1．1 日夜间模式
5．1．2 缓存界面数据
5．1．3 作为搜索页
5．1．4 作为Presenter
5．2 源码分析
5．2．1 Transaction简介
5．2．2 提交操作
5．2．3 commitAllowingStateLoss
5．2．4 Add操作的原理
5．2．5 Replace操作的本质
5．2．6 Fragment的可见性监听
5．2．7 ViewPager中的懒加载
5．3 常见问题
5．3．1 Activity为空
5．3．2 startActivityForResult
5．3．3 ViewPager的getItem
5．3．4 FragmentPagerAdapter
5．3．5 显示一个对话框
5．3．6 重叠显示的问题
5．3．7 Fragment的StateLoss
5．4 Fragment的替代品
5．4．1 Jetpack的Navigation
5．4．2 Square的Flow
5．4．3 简化版的Fragment
5．5 Shatter库
5．5．1 建立Shatter类
5．5．2 设计ShatterManager
5．5．3 分发生命周期
5．5．4 使用方式
5．6 总结
第6章 让alertDialog为我所用
6．1 Dialog
6．1．1 Dialog和Window
6．1．2 Show和Dismiss方法
6．2 alertDialog
6．2．1 alertController
6．2．2 alertDialog．Bulder
6．3 dialogFragment
6．3．1 Fragment和Dialog
6．3．2 Show和Dismiss方法
6．4 实际问题
6．4．1 无法弹出输入法
6．4．2 如何支持层叠弹窗
6．4．3 容易引起内存泄露
6．4．4 修改尺寸、背景和动画
6．4．5 点击后会自动关闭
6．4．6 在关闭或开启时出现崩溃
6．5 封装dialogFragment
6．5．1 用现成的alertParams
6．5．2 让Builder类支持继承
6．5．3 建立dialogFragment框架
6．6 easyDialog
6．6．1 基本用法
6．6．2 自定义一个Dialog
6．6．3 BottomSheetDialog
6．6．4 设置全局样式
6．6．5 支持动态样式
6．6．6 避免丢失监听器
6．7 可全局弹出的Dialog
6．8 总结
第7章 Gradle的使用技巧
7．1 全局配置
7．1．1 设定UTF-8
7．1．2 依赖Google仓库
7．1．3 支持Groovy
7．1．4 定义全局变量
7．1．5 配置Lint选项
7．2 操控Task
7．2．1 更改输出的APK的名字
7．2．2 更改AAR输出的位置
7．2．3 跳过AndroidTest
7．2．4 找出耗时的Task
7．2．5 抽离Task脚本
7．3 动态化
7．3．1 动态设置buildConfig
7．3．2 填充Manifest中的值
7．3．3 让buildType支持继承
7．3．4 让Flavor支持继承
7．3．5 内测版本用特定的Icon
7．3．6 不同渠道不同包名
7．3．7 自动填充版本信息
7．4 远程依赖
7．4．1 配置Maven仓库
7．4．2 依赖相关的API
7．4．3 组合依赖
7．4．4 依赖传递
7．4．5 动态版本号
7．4．6 强制版本号
7．4．7 exclude关键字
7．4．8 依赖管理
7．5 本地依赖
7．5．1 引用AAR
7．5．2 依赖Module/Jar
7．5．3 自建本地仓库
7．5．4 本地依赖React Native
7．5．5 重新打包第三方Jar
7．6 资源管理
7．7 总结
第8章 缩减APK的编译时间
8．1 分析项目现状
8．1．1 Gradle Profile
8．1．2 BuildTimeTracker
8．1．3 Dexcount GradlePlugin
8．1．4 经验小结
8．2 编译环境优化
8．2．1 升级硬件设备
8．2．2 升级软件
8．2．3 优化工程配置
8．2．4 配置Studio的可用内存
8．2．5 提升JVM的堆内存
8．2．6 开启并行编译
8．2．7 启用Demand模式
8．2．8 配置DexOptions
8．3 善用缓存
8．3．1 减少动态方法
8．3．2 硬编码BuildConfig和Res
8．3．3 拆分脚本
8．3．4 拆分代码
8．3．5 写死库的版本号
8．4 精简工程
8．4．1 差异化加载Plugin
8．4．2 使用WebP和SVG
8．4．3 精简语言和图片资源
8．4．4 善用no-op
8．4．5 Exclude无用库
8．4．6 删减Module
8．4．7 去掉MultiDex
8．4．8 删除无用的资源
8．5 综合技巧
8．5．1 构建开发时的Flavor
8．5．2 优化MultiDex
8．5．3 跳过无用的Task
8．5．4 关闭AAPT的图片优化
8．5．5 调试时关闭Crashlytics
8．5．6 谨慎使用AspectJ
8．6 多渠道打包工具
8．6．1 MultiChannelPackageTool
8．6．2 美团的Walle
8．6．3 腾讯的VasDolly
8．7 总结

第9章 APP终极瘦身实践
9．1 安装包的构成
9．1．1 Assets
9．1．2 Lib
9．1．3 Resources．arsc
9．1．4 META-INF
9．1．5 Res
9．1．6 Dex
9．2 优化Assets目录
9．2．1 删除无用的字体
9．2．2 减少IconFont的使用
9．2．3 动态下载资源
9．2．4 压缩资源文件
9．3 优化Lib目录
9．3．1 配置ABI Filters
9．3．2 根据CPU引入so
9．3．3 动态加载so
9．3．4 避免复制so
9．3．5 谨慎处理so
9．4 优化Resources．arsc
9．4．1 删除无用的映射
9．4．2 进行资源混淆
9．5 优化META-INF
9．5．1 MANIFEST．MF
9．5．2 CERT．SF
9．5．3 CERT．RSA
9．5．4 优化建议
9．6 优化Res目录
9．6．1 通过IDE删除无用资源
9．6．2 打包时剔除无用资源
9．6．3 删除无用的语言
9．6．4 控制Raw中的资源大小
9．6．5 减少Shape文件
9．6．6 减少Menu文件
9．6．7 减少Layout文件
9．6．8 动态下载图片
9．6．9 分目录放置图片
9．6．10 合理使用图片资源
9．6．11 丢弃特定的资源
9．6．12 开启严格模式
9．6．13 移除Lib库中的配置文件
9．7 优化图片资源
9．7．1 使用VectorDrawable
9．7．2 使用WebP
9．7．3 替换support库中的图
9．7．4 精简动画图片
9．7．5 复用相同的Icon
9．7．6 使用Tint
9．7．7 复用按压效果
9．7．8 通过旋转复用
9．8 优化Dex
9．8．1 分析Dex
9．8．2 利用Lint分析无用代码
9．8．3 删除R文件
9．8．4 启用ProGuard
9．8．5 使用拆分后的support库
9．8．6 尽量不用Mulitdex
9．8．7 使用更小库或合并现有库
9．8．8 根据环境依赖库
9．9 总结
第10章 编写针对性的TestCase
10．1 基础概念
10．1．1 什么代码应被测试
10．1．2 编写易于被测试的代码
10．1．3 测试框架的选型
10．2 逻辑测试
10．2．1 Junit测试
10．2．2 Mockito
10．2．3 Robolectric的使用
10．2．4 Espresso
10．3 集成测试网络层
10．3．1 编写网络层逻辑
10．3．2 建立测试对象
10．3．3 测试HTTP的异常情况
10．3．4 测试业务代码的正确性
10．3．5 用Interceptor模拟返回值
10．4 总结
第11章 Android Studio使用经验
11．1 调试篇
11．2 插件篇
11．2．1 统计相关
11．2．2 工具相关
11．3 总结
第12章 抓包工具Whistle实践
12．1 抓包工具
12．1．1 Charles
12．1．2 Fiddler
12．1．3 AnyProxy
12．1．4 Whistle
12．2 Whistle的安装和使用
12．2．1 安装和更新
12．2．2 查看Request和Response
12．2．3 代理技巧
12．2．4 过滤规则
12．3 Whistle的各项功能
12．3．1 替换域名
12．3．2 修改请求参数
12．3．3 修改返回值
12．3．4 模拟低网速的情形
12．3．5 查看WebView的Console

1.1 Android系统架构 1

1.2 Android系统源码目录 4

1.2.1 整体结构 4

1.2.2 应用层部分 5

1.2.3 应用框架层部分 6

1.2.4 C/C++程序库部分 6

1.3 源码阅读 7

1.3.1 在线阅读 7

1.3.2 使用Source Insight 9

1.4 本章小结 12

第2章 Android系统启动 13

2.1 init进程启动过程 13

2.1.1 引入init进程 13

2.1.2 init进程的入口函数 14

2.1.3 解析init.rc 17

2.1.4 解析Service类型语句 19

2.1.5 init启动Zygote 20

2.1.6 属性服务 23

2.1.7 init进程启动总结 27

2.2 Zygote进程启动过程 27

2.2.1 Zygote概述 28

2.2.2 Zygote启动脚本 28

2.2.3 Zygote进程启动过程介绍 30

2.2.4 Zygote进程启动总结 38

2.3 SystemServer处理过程 39

2.3.1 Zygote处理SystemServer进程 39

2.3.2 解析SystemServer进程 44

2.3.3 SystemServer进程总结 48

2.4 Launcher启动过程 48

2.4.1 Launcher概述 48

2.4.2 Launcher启动过程介绍 49

2.4.3 Launcher中应用图标显示过程 54

2.5 Android系统启动流程 59

2.6 本章小结 60

第3章 应用程序进程启动过程 61

3.1 应用程序进程简介 61

3.2 应用程序进程启动过程介绍 62

3.2.1 AMS发送启动应用程序进程请求 62

3.2.2 Zygote接收请求并创建应用程序进程 68

3.3 Binder线程池启动过程 75

3.4 消息循环创建过程 78

3.5 本章小结 80

第4章 四大组件的工作过程 81

4.1 根Activity的启动过程 82

4.1.1 Launcher请求AMS过程 82

4.1.2 AMS到ApplicationThread的调用过程 85

4.1.3 ActivityThread启动Activity的过程 94

4.1.4 根Activity启动过程中涉及的进程 99

4.2 Service的启动过程 101

4.2.1 ContextImpl到AMS的调用过程 101

4.2.2 ActivityThread启动Service 103

4.3 Service的绑定过程 110

4.3.1 ContextImpl到AMS的调用过程 111

4.3.2 Service的绑定过程 112

4.4 广播的注册、发送和接收过程 122

4.4.1 广播的注册过程 122

4.4.2 广播的发送和接收过程 127

4.5 Content Provider的启动过程 137

4.5.1 query方法到AMS的调用过程 137

4.5.2 AMS启动Content Provider的过程 143

4.6 本章小结 148

第5章 理解上下文Context 149

5.1 Context的关联类 149

5.2 Application Context的创建过程 151

5.3 Application Context的获取过程 156

5.4 Activity的Context创建过程 156

5.5 Service的Context创建过程 161

第6章 理解ActivityManagerService 164

6.1 AMS家族 164

6.1.1 Android 7.0的AMS家族 164

6.1.2 Android 8.0的AMS家族 170

6.2 AMS的启动过程 171

6.3 AMS与应用程序进程 174

6.4 AMS重要的数据结构 176

6.4.1 解析ActivityRecord 177

6.4.2 解析TaskRecord 177

6.4.3 解析ActivityStack 178

6.5 Activity栈管理 181

6.5.1 Activity任务栈模型 181

6.5.2 Launch Mode 182

6.5.3 Intent的FLAG 182

6.5.4 taskAffinity 185

第7章 理解WindowManager 187

7.1 Window、WindowManager和WMS 187

7.2 WindowManager的关联类 188

7.3 Window的属性 193

7.3.1 Window的类型和显示次序 193

7.3.2 Window的标志 195

7.3.3 软键盘相关模式 196

7.4 Window的操作 196

7.4.1 系统窗口的添加过程 197

7.4.2 Activity的添加过程 202

7.4.3 Window的更新过程 203

7.5 本章小结 206

第8章 理解WindowManagerService 207

8.1 WMS的职责 207

8.2 WMS的创建过程 209

8.3 WMS的重要成员 217

8.4 Window的添加过程（WMS处理部分） 219

8.5 Window的删除过程 225

8.6 本章小结 230

第9章 JNI原理 231

9.1 系统源码中的JNI 232

9.2 MediaRecorder框架中的JNI 233

9.2.1 Java Framework层的MediaRecorder 233

9.2.2 JNI层的MediaRecorder 234

9.2.3 Native方法注册 235

9.3 数据类型的转换 239

9.3.1 基本数据类型的转换 240

9.3.2 引用数据类型的转换 240

9.4 方法签名 242

9.5 解析JNIEnv 244

9.5.1 jfieldID和jmethodID 245

9.5.2 使用jfieldID和jmethodID 247

9.6 引用类型 249

9.6.1 本地引用 249

9.6.2 全局引用 249

9.6.3 弱全局引用 250

9.7 本章小结 251

第10章 Java虚拟机 252

10.1 概述 252

10.1.1 Java虚拟机家族 253

10.1.2 Java虚拟机执行流程 253

10.2 Java虚拟机结构 254

10.2.1 Class文件格式 255

10.2.2 类的生命周期 256

10.2.3 类加载子系统 257

10.2.4 运行时数据区域 258

10.3 对象的创建 260

10.4 对象的堆内存布局 262

10.5 oop-klass模型 263

10.6 垃圾标记算法 266

10.6.1 Java中的引用 266

10.6.2 引用计数算法 267

10.6.3 根搜索算法 269

10.7 Java对象在虚拟机中的生命周期 270

10.8 垃圾收集算法 271

10.8.1 标记—清除算法 271

10.8.2 复制算法 272

10.8.3 标记—压缩算法 273

10.8.4 分代收集算法 274

10.9 本章小结 275

第11章 Dalvik和ART 276

11.1 Dalvik虚拟机 276

11.1.1 DVM与JVM的区别 276

11.1.2 DVM架构 278

11.1.3 DVM的运行时堆 280

11.1.4 DVM的GC日志 280

11.2 ART虚拟机 281

11.2.1 ART与DVM的区别 281

11.2.2 ART的运行时堆 282

11.2.3 ART的GC日志 283

11.3 DVM和ART的诞生 285

11.4 本章小结 288

第12章 理解ClassLoader 289

12.1 Java中的ClassLoader 289

12.1.1 ClassLoader的类型 289

12.1.2 ClassLoader的继承关系 291

12.1.3 双亲委托模式 292

12.1.4 自定义ClassLoader 295

12.2 Android中的ClassLoader 298

12.2.1 ClassLoader的类型 298

12.2.2 ClassLoader的继承关系 300

12.2.3 ClassLoader的加载过程 302

12.2.4 BootClassLoader的创建 306

12.2.5 PathClassLoader的创建 309

12.3 本章小结 311

第13章 热修复原理 312

13.1 热修复的产生 312

13.2 热修复框架的种类和对比 313

13.3 资源修复 314

13.3.1 Instant Run概述 314

13.3.2 Instant Run的资源修复 315

13.4 代码修复 318

13.4.1 类加载方案 319

13.4.2 底层替换方案 321

13.4.3 Instant Run方案 322

13.5 动态链接库的修复 323

13.5.1 System的load和loadLibarary方法 323

13.5.2 nativeLoad方法分析 327

13.6 本章小结 333

第14章 Hook技术 334

14.1 Hook技术概述 334

14.2 Hook技术分类 336

14.3 代理模式 336

14.3.1 代理模式简单实现 337

14.3.2 动态代理的简单实现 338

14.4 Hook startActivity方法 339

14.4.1 Hook Activity的startActivity方法 340

14.4.2 Hook Context的startActivity方法 343

14.4.3 Hook startActivity总结 344

14.5 本章小结 345

第15章 插件化原理 346

15.1 动态加载技术 346

15.2 插件化的产生 347

15.2.1 应用开发的痛点和瓶颈 347

15.2.2 插件化思想 348

15.2.3 插件化定义 350

15.3 插件化框架对比 351

15.4 Activity插件化 352

15.4.1 Activity的启动过程回顾 352

15.4.2 Hook IActivityManager方案实现 354

15.4.3 Hook Instrumentation方案实现 364

15.4.4 总结 367

15.5 Service插件化 368

15.5.1 插件化方面Service与Activity的不同 368

15.5.2 代理分发实现 370

15.6 ContentProvider插件化 376

15.6.1 ContentProvider的启动过程回顾 376

15.6.2 VirtualApk的实现 377

15.7 BroadcastReceiver的插件化 385

15.7.1 广播插件化思路 386

15.7.2 VirtualApk的实现 386

15.8 资源的插件化 387

15.8.1 系统资源加载 387

15.8.2 VirtualApk实现 389

15.9 so的插件化 390

15.10 本章小结 393

第16章 绘制优化 394

16.1 绘制性能分析 394

16.1.1 绘制原理 395

16.1.2 Profile GPU Rendering 396

16.1.3 Systrace 398

16.1.4 Traceview 404

16.2 布局优化 407

16.2.1 布局优化工具 407

16.2.2 布局优化方法 411

16.2.3 避免GPU过度绘制 419

16.3 本章小结 420

第17章 内存优化 421

17.1 避免可控的内存泄漏 421

17.1.1 什么是内存泄漏 421

17.1.2 内存泄漏的场景 422

17.2 Memory Monitor 428

17.2.1 使用Memory Monitor 429

17.2.2 大内存申请与GC 430

17.2.3 内存抖动 430

17.3 Allocation Tracker 430

17.3.1 使用Allocation Tracker 431

17.3.2 alloc文件分析 431

17.4 Heap Dump 434

17.4.1 使用Heap Dump 434

17.4.2 检测内存泄漏 436

17.5 内存分析工具MAT 438

17.5.1 生成hprof文件 438

17.5.2 MAT分析hprof文件 440

17.6 LeakCanary 448

17.6.1 使用LeakCanary 449

17.6.2 LeakCanary应用举例 449


第1章　音视频基础知识 1
1．1　视频编码 1
1．2　音频编码 2
1．3　多媒体播放组件（Android、iOS） 2
1．4　常见的多媒体框架及解决方案 3
1．5　相关知识点 4
1．5．1　帧率 4
1．5．2　分辨率 4
1．5．3　刷新率 4
1．5．4　编码格式 4
1．5．5　封装格式 4
1．5．6　码率 5
1．5．7　画质与码率 5
1．5．8　DTS与PTS 5
1．5．9　YUV与RGB 5
1．5．10　视频帧及音频帧 5
1．5．11　量化精度 6
1．5．12　采样率 6
1．5．13　声道 6
第2章　常用的系统播放器MediaPlayer 8
2．1　状态图及生命周期 8
2．2　从创建到setDataSource过程 12
2．2．1　从创建到setDisplay过程 12
2．2．2　创建过程 13
2．2．3　setDataSource过程 16
2．2．4　setDisplay过程 20
2．3　开始prepare后的流程 22
2．4　C++中MediaPlayer的C/S架构 31
第3章　管理调度的服务者MediaPlayerService 40
3．1　Client/Server通过IPC的通信流程图 40
3．2　相关联的类图 42
3．3　产生过程 43
3．4　添加服务的过程 48
3．5　通过BinderDriver和MediaPlayer通信的过程 50
3．6　创建播放器 55
3．7　建立StageFright层交互 58
第4章　StagefrightPlayer（AwesomePlayer） 60
4．1　AwesomePlayer构造过程 60
4．2　AwesomePlayer使用MediaExtractor进行数据解析的过程 66
4．3　AwesomePlayer解码过程 69
4．3．1　AwesomePlayer中的prepare过程 69
4．3．2　初始化音视频解码器过程 73
4．3．3　使用OMXCodec的解码过程 75
4．4　AwesomePlayer的渲染输出过程 80
4．4．1　用一张图回顾数据处理过程 80
4．4．2　视频渲染器构建过程 81
4．4．3　将音频数据放到Buffer的过程 87
4．4．4　AudioPlayer在AwesomePlayer中的运行过程 91
4．4．5　音视频同步 93
4．4．6　音视频输出 96
4．5　概要总结 97
第5章　流媒体播放的新生力量NuPlayer 98
5．1　NuPlayer整体结构 98
5．2　NuPlayer的构建过程 100
5．3　NuPlayer的数据解析模块 102
5．4　NuPlayer的解码模块 107
5．5　NuPlayer的渲染模块 109
第6章　OpenMAX（OMX）框架 118
6．1　Codec部分中的AwesomePlayer到OMX服务 118
6．1．1　OpenMAX与StageFright框架层级的关系 118
6．1．2　OMX的初始化流程 120
6．1．3　OMX中NodeInstance列表的管理 127
6．1．4　OMX中NodeInstance节点的操作 127
6．1．5　总结AwesomePlayer到OMX服务过程 130
6．2　Codec部分中的OMXCodec与OMX事件回调流程 131
6．2．1　OMXCodec与OMX callback事件的处理时序图 132
6．2．2　如何从OMX中分发事件到OMXCodec 133
6．2．3　缓冲区更新过程 135
6．2．4　消息回调 137
6．3　MediaCodec相关知识 139
6．3．1　MediaCodec的基本认识 139
6．3．2　从创建到Start过程 148
6．3．3　MediaCodec到OMX框架过程 154
6．3．4　MediaCodec硬解码 158
第7章　FFmpeg项目 161
7．1　FFmpeg简介 161
7．2　在Windows下编译FFmpeg 163
7．2．1　MSYS2 164
7．2．2　Yasm 164
7．2．3　开始编译FFmpeg-3．1．3 166
7．2．4　创建shell编译脚本 167
7．2．5　编译动态库．so 169
7．2．6　编译静态库．a 171
7．3　在Linux下编译FFmpeg 172
7．3．1　在/etc/profile．d下配置环境变量 172
7．3．2　开始编译FFmpeg-3．1．3 174
7．3．3　编写shell脚本 175
7．3．4　编译动态库．so 176
7．3．5　编译静态库．a 178
7．4　在Mac OS下编译FFmpeg 179
7．4．1　下载源码及配置环境变量 179
7．4．2　开始编译FFmpeg-3．1．3 183
7．4．3　编写shell脚本 183
7．4．4　编译动态库．so 185
7．4．5　编译静态库．a 187
7．5　FFmpeg常用命令 189
7．5．1　改变帧率、码率和文件大小 189
7．5．2　调整视频分辨率 190
7．5．3　裁剪/填充视频 191
7．5．4　翻转和旋转视频 193
7．5．5　模糊和锐化视频 196
7．5．6　画中画 197
7．5．7　在视频上添加文字 201
7．5．8　文件格式转换 205
7．5．9　时间操作 207
第8章　FFmpeg源码分析及实战 208
8．1　FFmpeg常用结构体分析 208
8．1．1　AVFormatConext 209
8．1．2　AVInputFormat 211
8．1．3　AVStream 212
8．1．4　AVCodecContext 215
8．1．5　AVPacket 216
8．1．6　AVCodec 218
8．1．7　AVFrame 219
8．1．8　AVIOContext 222
8．1．9　URLProtocol 223
8．1．10　URLContext 224
8．2　FFmpeg关键函数介绍 225
8．2．1　av_register_all函数 225
8．2．2　avformat_alloc_context函数 226
8．2．3　avio_open函数 226
8．2．4　avformat_open_input函数 229
8．2．5　avformat_find_stream_info函数 232
8．2．6　av_read_frame函数 246
8．2．7　av_write_frame函数 252
8．2．8　avcodec_decode_video2函数 256
8．3　FFmpeg案例（代码实现） 264
8．3．1　利用FFmpeg转换格式 264
8．3．2　在实时流中抓取图像 269
8．3．3　在视频中加入水印 277
8．3．4　FFmpeg音频解码 288
8．3．5　FFmpeg视频解码 300
8．4　FFPlay原理 308
8．4．1　注册所有容器格式和Codec 309
8．4．2　打开流文件 309
8．4．3　读取数据 311
8．4．4　保存数据 318
8．4．5　音视频同步 322
8．4．6　音视频输出 326
第9章　直播技术 328
9．1　直播原理 328
9．2　直播架构 328
9．3　直播过程 329
9．3．1　采集数据 329
9．3．2　渲染处理 332
9．3．3　编码数据 333
9．3．4　推流 335
9．3．5　CDN分发 338
9．3．6　拉流 341
9．3．7　播放流数据 341
9．3．8　直播推流完整案例 343
9．4　流媒体服务器搭建 377
9．5　FFmpeg推流到流媒体服务器的过程 384
9．6　直播优化那些事 387
9．6．1　卡顿优化 387
9．6．2　延时优化 388
9．6．3　数据代理优化 389
9．6．4　首屏秒开优化 390
9．6．5　弱网优化 391
9．6．6　运营商劫持优化 391
9．6．7　CDN节点优化 393
第10章　H．264编码及H．265编码 395
10．1　H．264编码框架 395
10．2　H．264编码原理 395
10．3　H．264码流分析 397
10．3．1　H．264编码格式 397
10．3．2　NAL Header 397
10．3．3　H．264的传输 399
10．3．4　H．264码流结构 399
10．3．5　H．264的Level和Profile说明 406
10．4　H．265编码框架 408
10．4．1　背景知识 408
10．4．2　H．265码流结构 409
第11章　视频格式分析 414
11．1　MP4格式分析 414
11．1．1　Box结构 415
11．1．2　MP4总体结构 416
11．1．3　movie（moov）box 416
11．1．4　media box 418
11．1．5　sample table（stbl）box 420
11．2　FLV格式分析 422
11．2．1　FLV文件结构 422
11．2．2　File Header（文件头） 422
11．2．3　Body 423
11．2．4　Tag 423
11．3　F4V格式分析 428
11．3．1　file type box 429
11．3．2　movie box 430
11．3．3　movie header box 430
11．3．4　track box 430
11．3．5　media box 431
11．3．6　media information box 433
11．3．7　sample table box 433
11．4　TS格式分析 437
11．4．1　TS格式介绍 437
11．4．2　TS流包含的内容 438
11．4．3　TS包头解析 438
11．4．4　TS包传输部分 440
11．4．5　节目专用信息PSI（Program Specific Information） 440
11．5　AVI格式分析 444
11．5．1　AVI整体结构 445
11．5．2　AVI信息块（＇hdrl＇ LIST块） 446
11．5．3　AVI数据块（＇movi＇ LIST块） 447
11．5．4　AVI索引块（＇idxl＇子块） 448
11．6　ASF格式分析 448
11．6．1　认识ASF 448
11．6．2　ASF文件整体结构 449

第1章　搭建Android程序分析环境
1.1　搭建Windows分析环境 1
1.1.1　安装JDK 1
1.1.2　安装Android SDK 2
1.1.3　安装Android NDK 5
1.1.4　Android Studio集成开发环境 6
1.1.5　创建Android模拟器 7
1.1.6　Cygwin 9
1.1.7　Bash on Ubuntu on Windows 11
1.2　搭建macOS分析环境 12
1.2.1　安装JDK 12
1.2.2　安装Android SDK 14
1.2.3　安装Android NDK 14
1.2.4　Android Studio集成开发环境 15
1.3　搭建Ubuntu分析环境 15
1.3.1　安装JDK 16
1.3.2　安装Android SDK 17
1.3.3　安装Android NDK 17
1.3.4　Android Studio集成开发环境 18
1.4　常用逆向分析工具 19
1.5　常用Linux Shell命令 19
1.6　搭建源码分析环境 20
1.6.1　在macOS中编译Android源码 20
1.6.2　在Ubuntu中编译Android源码 26
1.6.3　在Windows中编译Android源码 26
1.7　本章小结 27



第2章　如何分析Android程序
2.1　编写第一个Android程序 28
2.1.1　创建Android工程 28
2.1.2　编译生成APK文件 30
2.2　破解第一个Android程序 35
2.2.1　破解入手 35
2.2.2　反编译APK文件 35
2.2.3　分析APK文件 36
2.2.4　修改smali文件的代码 44
2.2.5　重新编译APK文件并签名 45
2.2.6　安装和测试 47
2.2.7　小结 48
2.3　本章小结 48



第3章　Dalvik可执行格式与字节码规范
3.1　Dalvik虚拟机 49
3.1.1　Dalvik虚拟机的特点 49
3.1.2　Dalvik虚拟机与Java虚拟机的区别 49
3.1.3　虚拟机的执行流程 54
3.1.4　虚拟机的执行方式 56
3.2　Dalvik语言基础 56
3.2.1　Dalvik指令格式 57
3.2.2　DEX反汇编工具 58
3.2.3　Dalvik寄存器 59
3.2.4　寄存器命名法 61
3.2.5　Dalvik字节码 62
3.3　Dalvik指令集 63
3.3.1　指令类型 64
3.3.2　空操作指令 64
3.3.3　数据操作指令 64
3.3.4　返回指令 65
3.3.5　数据定义指令 65
3.3.6　锁指令 66
3.3.7　实例操作指令 66
3.3.8　数组操作指令 66
3.3.9　异常指令 67
3.3.10　跳转指令 67
3.3.11　比较指令 68
3.3.12　字段操作指令 69
3.3.13　方法调用指令 69
3.3.14　数据转换指令 70
3.3.15　数据运算指令 70
3.4　Dalvik指令练习 71
3.4.1　编写smali文件 71
3.4.2　编译smali文件 73
3.4.3　测试运行 73


第4章　常见Android文件格式
4.1　库文件 74
4.1.1　jar包 74
4.1.2　aar包 75
4.2　APK 78
4.2.1　APK文件结构 78
4.2.2　APK文件的生成流程 79
4.2.3　APK的安装流程 84
4.3　classes.dex 90
4.3.1　DEX文件结构 90
4.3.2　DEX文件的验证与优化过程 104
4.3.3　DEX文件的修改 108
4.3.4　MultiDex 111
4.4　AndroidManifest.xml 113
4.4.1　AndroidManifest.xml文件的格式 113
4.4.2　AXML文件格式 114
4.4.3　AXML文件的修改 121
4.5　resources.arsc 121
4.5.1　ARSC文件格式 122
4.5.2　ARSC文件的修改 128
4.6　META-INF目录 128
4.6.1　CERT.RSA 128
4.6.2　MANIFEST.MF 129
4.6.3　CERT.SF 130
4.7　ODEX 132
4.7.1　生成ODEX文件 132
4.7.2　ODEX文件格式 132
4.7.3　将ODEX文件转换成DEX文件 136
4.8　OAT 137
4.8.1　ART虚拟机 137
4.8.2　生成OAT文件 137
4.8.3　OAT文件格式 138
4.8.4　将OAT文件转换成DEX文件 141


第5章　静态分析Android程序
5.1　静态分析简介 145
5.2　阅读smali代码 145
5.2.1　smali文件结构 145
5.2.2　循环语句 148
5.2.3　switch分支语句 153
5.2.4　try/catch语句 158
5.3　阅读Java代码 163
5.3.1　将DEX文件转换成jar包 163
5.3.2　jar分析工具 163
5.4　代码定位技巧 164
5.4.1　入口分析法 164
5.4.2　信息反馈法 165
5.4.3　特征函数法 165
5.5　使用JEB进行静态分析 165
5.5.1　安装JEB 165
5.5.2　JEB的静态分析功能 166
5.5.3　JEB的脚本化与插件 169
5.6　使用IDA Pro进行静态分析 170
5.6.1　IDA Pro对Android的支持 170
5.6.2　分析DEX文件 170
5.6.3　定位关键代码 172
5.7　使用Androguard进行静态分析 174
5.7.1　安装Androguard 175
5.7.2　Androguard的使用方法 175
5.7.3　使用androlyze.py进行分析 179


第6章　动态分析Android程序
6.1　动态分析框架 183
6.2　动态分析技巧 189
6.2.1　代码注入法 189
6.2.2　栈跟踪法 192
6.2.3　Method Profiling 193
6.2.4　UI检查 196
6.3　使用JDB动态调试APK 198
6.4　使用JEB动态调试APK 200
6.5　使用IDA Pro动态调试APK 201


第7章　ARM反汇编基础
7.1　Android与ARM处理器 204
7.1.1　ARM处理器架构概述 204
7.1.2　Android支持的处理器架构 205
7.2　Android ARM EABI 206
7.2.1　armeabi 206
7.2.2　armeabi-v7a 207
7.2.3　arm64-v8a 208
7.3　ARM原生程序的生成过程 208
7.3.1　预处理 210
7.3.2　编译 211
7.3.3　汇编 215
7.3.4　链接 215
7.4　ARM汇编语言 216
7.4.1　ARM汇编程序结构 216
7.4.2　汇编指令 221
7.4.3　寄存器 223
7.4.4　处理器寻址方式 224
7.4.5　子程序参数传递 227
7.5　ARM汇编指令集 230
7.5.1　ARM指令集分类 230
7.5.2　ARM指令编码 231
7.5.3　ARM指令格式解析 233
7.5.4　常见ARM指令 234
7.6　Thumb汇编指令集 240
7.6.1　16位Thumb指令编码 240
7.6.2　16位Thumb指令格式解析 241
7.6.3　32位Thumb指令编码 242
7.6.4　32位Thumb指令格式解析 244
7.7　AArch64汇编指令集 246
7.7.1　AArch64指令编码 246
7.7.2　AArch64指令格式解析 247


第8章　Android原生程序开发与逆向分析
8.1　原生程序开发 251
8.1.1　原生程序工程 252
8.1.2　STL的选择 253
8.1.3　JNI 254
8.1.4　编译选项与配置项 256
8.2　原生程序移植 256
8.2.1　ADT项目的移植 257
8.2.2　UNIX开源项目的移植 258
8.2.3　CMake项目的移植 262
8.2.4　其他类型项目的移植 264
8.3　原生程序入口函数 264
8.3.1　原生程序入口函数分析 264
8.3.2　so入口函数分析 269
8.4　原生程序文件格式 271
8.4.1　原生程序的文件类型 271
8.4.2　AArch64 ELF文件格式 274
8.4.3　Program Header Table 278
8.4.4　Section Header Table 281
8.4.5　.dynamic节区 283
8.4.6　字符串表 285
8.4.7　符号表 286
8.4.8　got表与plt表 287
8.4.9　地址重定位表 291
8.5　原生程序逆向分析工具 295
8.5.1　NDK Toolchain 295
8.5.2　IDA Pro 297
8.5.3　Hopper 301
8.6　原生C程序逆向分析 302
8.6.1　编译原生C程序 303
8.6.2　for循环分支结构 305
8.6.3　while循环分支结构 309
8.6.4　if……else分支结构 312
8.6.5　switch循环分支结构 316
8.6.6　优化后的C程序 319
8.7　原生C++ 程序逆向分析 321
8.7.1　C++ STL的逆向分析 322
8.7.2　C++ 类的逆向分析 326
8.7.3　C++ 程序的RTTI 332
8.8　原生so动态库逆向分析 336


第9章　Android原生程序动态调试
9.1　gdb调试器 338
9.1.1　ndk-gdb脚本 338
9.1.2　配置gdb调试器 339
9.1.3　gdb调试器的常用命令 340
9.1.4　使用gdb调试Android原生程序 342
9.1.5　gdb调试器的GUI前端 344
9.2　lldb调试器 346
9.2.1　配置lldb调试器 346
9.2.2　lldb调试器的常用命令 348
9.2.3　使用lldb调试Android原生程序 350
9.2.4　lldb调试器的GUI前端 353
9.3　使用IDA Pro调试Android原生程序 353
9.4　本章小结 358



第10章　Hook与注入
10.1　Hook的类型 359
10.1.1　Dalvik Hook 359
10.1.2　ART Hook 362
10.1.3　LD_PRELOAD Hook 364
10.1.4　GOT Hook 366
10.1.5　Inline Hook 367
10.2　Hook框架Xposed 368
10.3　Hook场景与应用 372
10.3.1　开启日志调试输出 372
10.3.2　APK插件 373
10.3.3　绕过SSL Pinning 373
10.4　动态注入 374
10.4.1　so动态库注入 374
10.4.2　DEX注入 376
10.5　注入框架Frida 377
10.5.1　Frida的安装与配置 377
10.5.2　执行注入与Hook 378
10.5.3　跟踪Native方法 384

第11章　软件保护技术
11.1　软件保护技术简介 387
11.2　软件混淆技术 388
11.2.1　源码混淆 389
11.2.2　模板混淆 389
11.2.3　AST混淆 391
11.2.4　IR混淆 397
11.2.5　DEX混淆 397
11.2.6　DEX二次混淆 399
11.3　资源保护 401
11.4　完整性校验 403
11.5　反调试技术 404
11.5.1　调试器状态检测 404
11.5.2　调试器端口检测 404
11.5.3　进程状态检测 406
11.6　运行环境检测 407
11.6.1　模拟器检测 407
11.6.2　Root检测 409
11.6.3　Hook检测 409

12.1　Android软件壳 412
12.2　软件壳的特征与侦察 413
12.2.1　编译器指纹 413
12.2.2　软件壳的特征 416
12.2.3　查壳工具 418
12.3　动态加载型壳 418
12.3.1　缓存脱壳法 418
12.3.2　内存Dump脱壳法 419
12.3.3　动态调试脱壳法 420
12.3.4　Hook脱壳法 423
12.3.5　系统定制脱壳法 424
12.4　代码抽取型壳 425
12.4.1　内存重组脱壳法 425
12.4.2　Hook脱壳法 427
12.4.3　系统定制脱壳法 427
12.5　代码混淆壳 429
12.5.1　LLVM基础 430
12.5.2　编写Pass 434
12.5.3　Obfuscator-LLVM 440
12.5.4　代码混淆壳的脱壳 443


Android 实习生面试经历记录

链接：https://www.jianshu.com/p/3cd5ef51eed5

从 2018.12.28 的第一次面试到 2019.01.09 整整横跨了一年。也面试了几家公司的 Android 实习僧的岗位。

有大厂：滴滴、猪厂、字节等
也有中厂：玩吧App等
也有小厂：xxxxxx

给我的感觉就是
大厂更注重你的基本知识，你对待一个问题的思路。是否是以一个工程师的角度去看待问题。也更注重数据结构&&算法（我的痛）这一块的知识的考察。不会是简单的考你排序、查找这种考研层面上的东西。小厂的话，大概是因为需要即插即用，也没有很好的导师类资源，更看重你的自我学习能力和一个自我学习的过程，以及实际开发的能力。好了，话不多说，我们就直接进入面试的总结。题目旁边会标注是大厂中厂还是小厂的面试题，就不按公司整理啦，如果是All就是基本都会考到（需要重点理解）（部分问题的答案是自己 google 后的结果和学习的结果，部分问题的答案也来自厘米姑娘小姐姐的简书里的三份安卓面试题解（真的很详细很感谢了！）)

一、四大组件相关问题
是否了解Activity的四种启动模式？(All）


四种启动模式：Standerd、SingleTop、SingleTask、SingleInstance。


Standard(默认标准启动模式):每次启动都重新创建一个新的实例，不管它是否存在。且谁启动了这个Acitivity,那么这个Acitivity就运行在启动它的那个Acitivity的任务栈中。

SingleTop(栈顶复用模式):如果新的Activity已经位于任务栈的栈顶，那么不会被重新创建，而是回调onNewIntent()方法，通过此方法的参数可以取出当前请求的信息。

SingleTask(栈内复用模式):这是一种单例模式，在这种模式下，只要Acitivity在一个栈中存在，那么多次启动此Acitivity都不会重建实例，而是回调onNewIntent方法。同时由于SingleTask模式有ClearTop功能，因此会导致所要求的Acitivity上方的Acitivity全部销毁。

SingleInstance(单实例模式):和栈内复用类似，此种模式的Acitivity只能单独位于一个任务栈中。全局唯一性。单例实例，不是创建，而是重用。独占性，一个Acitivity单独运行在一个工作栈中。

如果假设A是Standard，B是SingleTop，C是SingleTask，D是SingleInstance的启动模式，那么以A->B->C->D->A->B->C->D这种情况开启Activity，分析一下最后的工作栈是怎样的情况？（大厂）

此题在理解启动模式的情况下解答。

栈内情况
栈内情况
Activity的生命周期？在横竖屏转换时候的生命周期流程是怎样的？（小厂）

onCreate()表示 Activity 正在创建，常做初始化工作，如 setContentView界面资源、初始化数据。
onStart()表示Activity 正在启动，这时Activity 可见但不在前台，无法和用户交互。
onResume()表示Activity 获得焦点，此时Activity 可见且在前台并开始活动。
onPause()表示Activity 正在停止，可做 数据存储、停止动画等操作。
onStop()表示activity 即将停止，可做稍微重量级回收工作，如取消网络连接、注销广播接收器等。
onDestroy()表示Activity 即将销毁，常做回收工作、资源释放。
onRestart()表示Activity由不可见到可见的过程，Activity重新启动。

屏幕旋转时的生命流程：
onPause()
onSaveInstanceState()
onStop()
onDestroy()
onCreate()
onStart()
onRestoreInstanceState()

onResume()为了避免由于配置改变导致 Activity 重建，可在AndroidManifest.xml中对应的 Activity中设置android:configChanges="orientation|screenSize"。此时再次旋转屏幕时，该Activity不会被系统杀死和重建，只会调用onConfigurationChanged。

在 SingleTop 模式中，我如果打开一个已经存在栈顶的Activity，他的生命流程是怎样的？（小厂）

打开第一个A：A.OnCreate()->A.onStart()->A.onResume()
此时由A跳转至B：A.onPause()->B.onCreate()->B.onStart()->B.onResume()->A.onStop()
此时B的启动模式是栈顶模式，再由B打开B：B.onPause()->B.onNewIntent()->B.onResume()

Service简要介绍一下？（基本都会问，但不可能只说概念上的，需要展开All）

Service是Android中实现程序后台运行的一种解决方案，适合执行那些不需要与用户交互而且要求长期运行的任务。

Service的两种启动方式简要介绍一下吧？（大厂、小厂)

①组件通过调用 Context 的 StartService()方法启动一个服务，回调服务中的onStartCommand()。如果该服务还没有被创建，则回调的顺序为 onCreate()->onStartCommand()。服务被启动后会一直保存运行的状态，直到 StopService()或者 StopSelf() 方法被调用，服务停止并回调 onDestroy()。无论调用多少次StartService()只需要调用一次 StopService() 就能终止服务。
②组件通过调用 Context 的 bindService() 可以绑定一个服务，回调服务中的onBind() 方法。类似地，如果该服务之前还没创建，那么回调的顺序是onCreate()->onBind()。之后调用方可以获取到 onBind() 方法里返回的IBinder 对象的实例，从而实现和服务的通信。直到调用了 unBindService() 方法使服务终止，回调顺序 onUnBind()->onDestroy()。

Service 如何和 Activity 进行通信？(中厂）

①通过绑定服务的方式。在绑定的服务中声明一个Binder类，并创建一个Binder对象，在onBind()函数中返回这个对象，并让Activity实现ServiceConnection接口，在OnServiceConnected方法中获取到Service提供的这个Binder对象，通过这个对象的各种自定义的方法就能完成Service与Activity的通信。
②通过Intent的方式，在StartService()中需要传入一个Intent对象作为参数，通过这个Intent实例对象进行实现通信。
③通过Callback和Handler的方式，在绑定的服务中声明一个Binder类，并创建一个Binder对象，在onBind()函数中返回这个对象，让Activity实现ServiceConnection接口，并且在OnserviceConnected方法中实例化Service中的CallBack接口，并且实现OnDataChange()方法，其中的实质是一段Handler代码，可以在其中完成耗时操作，以这种方式完成通信。

Android 数据持久化的方式有了解过嘛？ContentProvider 有接触过吗？（小厂）

①File文件存储方式：写入读取文件和Java中实现IO类似
②SharePreferences存储：一种轻型的数据存储方式，适用于基本类型数据，本质是以键值对存在的XML文件。
③SQLite数据库存储：   一款轻量级的关系型数据，运算速度快，资源占用少，存储复杂的关系型数据时候使用
④ContentProvider：四大组件，用于数据的存储和共享，不止局限于数据被该应用程序使用，且能让不同的应用之间进行数据共享，还能通过对指定的一部分数据进行共享，从而保证隐私数据不会有泄露的风险。


ContentProvider是安卓的四大组件之一，主要负责数据的存储和共享。与文件存储、sharePreferences存储、SQLite存储方式不同的是，后者保存的数据只能被该应用程序使用，而前者所保存的数据可以让不同应用之间的数据进行共享，还可以对指定的一部分数据进行共享，从而保证隐私数据不会有泄露的风险。

聊聊 Android 的广播机制吧？(All）

广播是一种运用在应用程序之间传输信息的机制，Android中我们发送广播内容实质是一个Intent，这个Intent中可以携带我们要发送的数据。（当然也不可以像Service一样简单的谈谈概念性的东西，你可以深入的展开。）

譬如广播的三大种类
①普通广播：一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们接收的先后是随机的。
②有序广播：一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递，所以此时的广播接收器是有先后顺序的，且优先级（priority）高的广播接收器会先收到广播消息。有序广播可以被接收器截断使得后面的接收器无法收到它。
③本地广播：发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收本应用程序发出的广播。

或者广播的两大注册方式？

静态注册：
① 创建一个广播接受器类，在onReceive()方法中Toast一段信息。
② 在AndroidMainfest.xml中注册才可以使用。

动态注册：
新建一个类，继承自BroadCastReceiver，并重写OnReceive函数。
由于动态注册是实现在OnCreate方法中的，因此存在一个缺点，必须启动后才能接受到广播。未启动之下就能接收到广播的话，使用静态注册广播接收器。

或者再深入可以聊聊本地广播的源码角度分析其高效、安全、内部协作是如何实现的。这里我们就不展开了。

二、Android 消息机制
简单的描述一下Handler消息传递机制是怎么实现的？（All）

① 概述：Handler是可以通过发送和处理Message和Runnable对象来进行消息传递，是一种异步消息机制。可以让对应的Message和Runnable在未来的某个时间点进行相应的处理。让耗时操作在子线程里执行，让更新UI的操作在主线程中完成，而子线程和主线程之间的通信就是靠Handler实现的。
② 成员：

Message(消息)：是线程之间传递的信息，可以携带少量的信息，用于在不同线程之间交换数据。

Handler(处理者)：负责Message的发送及处理。通过 Handler.sendMessage() 向消息池发送各种消息事件；通过 Handler.handleMessage() 处理相应的消息事件。

MessageQueue(消息队列)：用来存放Handler发送过来的消息，内部通过单链表的数据结构来维护消息列表，等待Looper的抽取。

Looper(消息泵)：通过Looper.loop()不断地从MessageQueue中抽取Message，按分发机制将消息分发给目标处理者。
③ 流程：

Handler信息传递机制
Handler信息传递机制
Handler.sendMessage()发送消息时，会通过MessageQueue.enqueueMessage()向 MessageQueue 中添加一条消息；

通过 Looper.loop() 开启循环后，不断轮询调用 MessageQueue.next()；

调用目标 Handler.dispatchMessage() 去传递消息，目标 Handler 收到消息后调用 Handler.handlerMessage() 处理消息。

子线程中使用 Handler 需要注意什么？(中厂)

和在主线程中直接 new 一个 Handler 不同，由于子线程的 Looper 需要手动去创建，需要手动编写 Looper.loop() 与 Looper.prepare() 方法。

            @Override
            public void run() {
                Looper.prepare();//调用Looper.prepare()
                new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    super.handleMessage(msg);
                }
            };
                Looper.loop(); //调用Looper.loop()
            }
        }).start();


Hanlder 的 postDealy()调用后消息队列会发生什么变化？（中厂）

这题我当时没回答上来，回来以后仔细查看了相关的答案。在这里直接引用的厘米姑娘小姐姐的答案回答的这个问题。

post delay 的 Message 并不是先等待一定时间再放入到 MessageQueue 中，而是直接进入并阻塞当前线程，然后将其 delay 的时间和队头的进行比较，按照触发时间进行排序，如果触发时间更近则放入队头，保证队头的时间最小、队尾的时间最大。此时，如果队头的 Message 正是被 delay 的，则将当前线程堵塞一段时间，直到等待足够时间再唤醒执行该 Message，否则唤醒后直接执行。

简要解释一下 ANR？为什么会发生 ANR？如何避免发生 ANR？如何定位 ANR？那你还了解哪些线程间切换的类？简要选一个进行一下阐述吧？（大厂）

先说点无关的，这是一连串的提问，涉及到性能优化->ANR问题定位->消息传递->实现原理，所以在面试的时候你尽量不要选择他问一个你答一句话，你可以把你有把握，之前有所准备的内容，按照一个条理跟面试官阐述清楚，他大概会好感度UP。当然必须要对你所说的东西保证充分的熟悉，因为他基本都会抓着你所说的继续跟你深入探讨下去。当然实习僧不会问的特别深入，但是你如果能把原理、机制都跟他说的很清晰有条理且有结构的话。会让面试官对你的好感有一定的上升（我猜的但应该没猜错）。也就是我们开题的时候所说的用工程师的眼光看待问题。什么问题？为什么发生问题？怎么定位并解决问题？


以下是我对这道题的回答，只是参考，如果有错误希望指正：
① ANR(Application Not Responding，应用程序无响应)：当操作在一段时间内系统无法处理时，譬如：应用在5秒内未相应用户的输入事件。广播接收器10秒内未完成相关的处理。服务20秒内无法处理完成，那么会在系统层面会弹出应用程序无响应的对话框。
② 所以为了避免发生ANR，我们尽量使用多线程，不要在主线程做耗时操作，而是通过开子线程，把耗时的工作放在工作线程中处理。所使用的方法比如继承自Thread类、实现Runnable接口、使用AsyncTask、IntentService、HandlerThread等机制。
③ 如果发生了ANR则可以通过data/anr找到traces.txt文件确定ANR发生的原因。
④ 关于上面说的这些多线程机制，如果您感兴趣的话我可以简要的跟你阐述其中的一个或几个机制的具体内容。比如AsyncTask机制，AsyncTask机制底层封装了线程池和Handler，便于执行后台任务以及在子线程中进行UI操作。使用AsyncTask要理解3个泛型参数和4个方法。

Params: 这个泛型指定的是我们传递给异步任务执行时的参数的类型。

Progress: 这个泛型指定的是我们的异步任务在执行的时候将执行的进度返回给UI线程的参数的类型。

Result: 这个泛型指定的异步任务执行完后返回给UI线程的结果的类型。
我们在定义一个类继承AsyncTask类的时候，必须要指定好这三个泛型的类型，如果都不指定的话，则都将其写成Void。
4个方法：当我们执行一个异步任务的时候，其需要按照下面的4个步骤分别执行
onPreExecute(): 这个方法是在执行异步任务之前的时候执行，并且是在主线程当中执行的，通常我们在这个方法里做一些UI控件的初始化的操作，例如弹出一给ProgressDialog。

doInBackground(Params… params): 在onPreExecute()方法执行完之后，会马上执行这个方法，这个方法就是来处理异步任务的方法，Android操作系统会在后台的线程池当中开启一个worker thread来执行我们的这个方法，所以这个方法是在工作线程当中执行的，这个方法执行完之后就可以将我们的执行结果发送给我们的最后一个 onPostExecute 方法，在这个方法里，我们可以从网络当中获取数据等一些耗时的操作。

onProgressUpdate(Progess… values): 这个方法也是在主线程当中执行的，我们在异步任务执行的时候，有时候需要将执行的进度返回给我们的UI界面，例如下载一张网络图片，我们需要时刻显示其下载的进度，就可以使用这个方法来更新我们的进度。在调用之前，我们要在 doInBackground 方法中调用publishProgress(Progress) 的方法来将我们的进度时刻传递给onProgressUpdate 方法来更新。

onPostExecute(Result… result): 当我们的异步任务执行完之后，就会将结果返回给这个方法，这个方法也是在UI Thread当中调用的，我们可以将返回的结果显示在UI控件上。

你可以不用说的这么具体，但是如果你能把这一系列都答上来，那面试官应该是不会在继续为难你。我在回答的时候还聊到了多线程可能发生内存泄露的问题，然后被面试官尴尬的说：“不用了不用了，我们继续下一个问题。”其实我也不懂这算不算一种好事吧，但是总归是你对整个知识体系的理解嘛。希望有大佬能指正什么的。感恩！

三、View 及其他控件的使用和优化
其实在这一块，主要还是按照你所做的项目的情况对你进行具体的提问，所以对你的项目所使用的框架、组件、控件必须要烂熟于心。知道为什么使用它，怎么使用它，使用它的结果是优化了些什么？

简要阐述一下消息分发机制吧？（All）

这也算是老生常谈的一道基本是必考题了，可以先谈谈MotionEvent的几种事件，分别在什么条件下会发生。再谈谈分发的本质、传递顺序、核心方法等，有一点非常关键，因为消息分发机制是一个责任链模式，所以在阐述的时候务必逻辑清晰。如果能结合源码的实现来谈大概也会让面试官好感Up。

MotionEvent 是手指触摸屏幕产生的一系列事件。包含的事件有：

ACTION_DOWN：手指接触屏幕

ACTION_MOVE：手指在屏幕上滑动

ACTION_UP：手指在屏幕上松开的一瞬间

ACTION_CANCEL：手指保持按下操作，并从当前控件转移到外层控件时会触发

事件分发本质：就是对MotionEvent事件分发的过程。即当一个MotionEvent产生了以后，系统需要将这个点击事件传递到一个具体的View上。
点击事件的传递顺序：Activity（Window） -> ViewGroup -> View
三个主要方法：

dispatchTouchEvent：进行事件的分发。返回值是 boolean 类型，受当前onTouchEvent和下级view的dispatchTouchEvent影响.

onInterceptTouchEvent：对事件进行拦截。该方法只在ViewGroup中有，一旦拦截，则执行ViewGroup的onTouchEvent，在ViewGroup中处理事件，而不接着分发给View。且只调用一次，所以后面的事件都会交给ViewGroup处理。

onTouchEvent：进行事件处理。

另外可以有选择性的记录两段源码，分别是 view 和 viewGroup 的dispatchTouchEvent 方法。以下是 view 的 dispatchTouchEvent()函数的主要部分，主要是三个判断条件的分析。

public boolean dispatchTouchEvent(MotionEvent event){
    ...//省略
    if(mOnTouchListener != null && (mViewFlags & ENABLED_MASK)==ENABLED &&
mOnTouchListener.onTouch(this,event)){
        return true;
    }
    return onTouchEvent(event);
}
以下是ViewGroup的dispatchTouchEvent()函数的主要部分：

public boolean dispatchTouchEvent(MotionEvent event){
   ...//省略
   if(disallowIntercept||!onInterceptTouchEvent(ev)){
       child.dispatchEvent()
}
你甚至可以和他谈一谈关于 disallowIntercept 去解决滑动冲突的问题。理论搭配源码，食用极佳。关于源码的分析很多大牛都写过了，我也是抱着学习的态度。这里就不贴出来了。

滑动冲突事件应该怎样去解决?(中厂、小厂）

这里当时第一次被问到的时候确实没有准备，之后看了厘米姑娘的面试题解（再次强力安利！）就回答上来了，以下直接贴小姐姐所写的解答，可以在这个解答的基础上加上一些自己的看法或者实际开发中遇到的类似问题。
（1）处理规则：
对于由于外部滑动和内部滑动方向不一致导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件。
对于由于外部滑动方向和内部滑动方向一致导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件何时由内部View拦截事件。
对于上面两种情况的嵌套，相对复杂，可同样根据需求在业务上找到突破点。
（2）实现方法：

外部拦截法：指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。具体方法：需要重写父容器的 onInterceptTouchEvent 方法，在内部做出相应的拦截。

内部拦截法：指父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法：需要配合requestDisallowInterceptTouchEvent 方法。

ListView 和 RecyclerView的选择？为什么？（中厂）

①布局效果：RecyclerView支持线性布局、网格布局、瀑布布局，可以控制横向纵向滚动，从布局效果上来看完爆ListView。
②基础使用：ListView需要继承重写BaseAdapter类，自定义ViewHolder和重用ConvertView完成优化工作。
RecyclerView继承重写RecyclerView.Adapter和RecyclerView.ViewHolder，设置布局管理器，控制整体布局。规范化了ViewHolder，复用item也不需要像ListView一样SetTag。
③空数据处理：ListView提供了setEmptyView这个API来处理Adapter中数据为空的情况，RecyclerView没提供相应API。
④HeaderFooter：ListView提供了AddRemoveHeaderView方法解决，RecyclerView没有提供。
⑤局部刷新：ListView刷新notifyDataSetChanged()方法，局部刷新需要自己实现。RecyclerView.Adapter则提供了notifyItemChanged()拥有更新单个itemView的刷新。
⑥动画效果：Recycler轻松实现，listview需要自己写属性动画，或者调用第三方库
⑦监听item事件：ListView专门提供了用于监听item的回调接口，RecyclerView提供的是addOnItemTouchListener。

ListView 怎么进行优化的？（All）

①ConvertView重用机制：在getView()方法中使用ConvertView，不需要每次都inflate一个View出来，这样既浪费时间又浪费内存。
②Viewholder：使用Viewholder，避免在getView()方法频繁调用去使用findViewById方法，节省时间和内存。
③分页加载：每加载一页的数据就覆盖上一页的数据。
④数据中有图片：使用第三方库（三级缓存机制）

ListView 是怎么实现 RecycleBin 并更新 View 的？（大厂）

关于这道题，第一次被问及的时候确实没回答上来，然后面试官就冲我笑笑：“嘿嘿没读过源码吧？”回去以后读了郭霖大佬的博客。做了以下记录：
在 Adapter 中的 getView()方法中执行 LayoutInflater.inflate()方法是很消耗资源的，所以ListView通过 RecycleBin 去维护两个数组 mActiveViews 和mScrapViews 用来进行 view 的复用工作。具体是在绘制 view 的(measure->layout->draw)的 layout 过程中实现。
主要有三个步骤：
①ListView的children->RecycleBin
②ListView清空children
③Recyclebin->ListView的children
举个例子，某一时刻ListView中显示10个子View，position依次是0-9，这时下滑，ListView需要绘制下一帧，这时候ListView在layoutchildren方法中把这10个子View都存入了mActiveViews数组中，然后清空children数组，调用filldown方法，向listview中依次添加position 1到10的子view，在填充1-9时，由于在上一帧position=1-9的view已经被放入了mActiveViews数组中，因此可以直接将其从数组中取出，直接复用。如果没能够从mActivieViews中直接复用View，那么就要调用obtainView方法获取View，该方法尝试间接复用RecycleBin中的mScrapViews中的View，如果不能间接复用，则创建新的View。这边去看郭霖大神的文章：ListView工作原理完全解析。https://blog.csdn.net/guolin_blog/article/details/44996879

四、Java 基础和计网基础
简要介绍一下HashMap的实现原理？（中厂、小厂）

HashMap 基于 AbstractMap类，实现了Map、Cloneable（能被克隆）、Serializable（支持序列化）接口； 非线程安全；允许存在一个为null的key和任意个为null的value；采用链表散列的数据结构，即数组和链表的结合；初始容量为16，填充因子默认为0.75，扩容时是当前容量翻倍，即2capacity。
1、Put方法的实现原理：比如hashMap.put(“Java”,0)，先使用hash函数来确定这个Entry的插入位置，下标为Index。即index=hash(“java”)，存入数组下标为Index的地方，但是因为hashmap长度有限，插入的Entry越来越多，Index值会发生冲突，此时可以用链表的方式解决，通过头插法，发生冲突时，插入对应的链表之中。
2、Get方法的实现原理，比如hashMap.get(“apple”)，同样对Key值做一次hash映射，算出其对应的index值，即Index = Hash(“apple”)这时从头结点开始，一个个向下查找，通过keys.equals()方法去找到链表中正确的节点。

HashMap 线程安全吗？那如何保证其线程安全呢？（中厂）

可以简单谈谈，使用 Hashtable 或者 ConcurrentHashMap。它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。而 ConcurrentHashMap 引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定 map 的某个部分，而其它的线程不需要等到迭代完成才能访问 map。简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 map 的某个部分，而 Hashtable 则会锁定整个map。在 jdk1.8 之后，取消了segments 的方式，而是使用了transient volatile HashEntry[] table 的方式保存数据，将数组元素作为锁，对每一行数据进行加锁，减少了并发冲突的概率。由数组+单向链表变为了数组+单向链表+红黑树，将查询的时间复杂度降至了O(logn)改进了一些性能。

HashMap 有序吗？如何实现有序呢？（中厂）

HashMap 是无序的，而 LinkedHashMap 是有序的 HashMap，默认为插入顺序，还可以是访问顺序，基本原理是其内部通过 Entry 维护了一个双向链表，负责维护 Map的迭代顺序。甚至可以深入的去谈谈 LinkHashMap 的底层实现机制。

你知道哪些垃圾回收算法?（小厂）

四种主要的垃圾回收算法：
新生代：大批对象死去，只有少量存活。
①复制算法：把可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块用尽时，把还活着的对象复制到另一块上，再将这块给一次性清理掉。
老生代：对象存活率高，只需标记少量回收的对象。
②标记-清除算法：首先标记出要回收的对象，然后统一清除带标记的对象。
③标记-整理算法：首先标记出要回收的对象，然后进行整理，使得存活的对象都向一端移动，直接清理掉端边界以外的对象。
④分代收集算法，集成以上的特点，对新生代和老生代分别使用不同的回收算法。

TCP如何保证传输是可靠的？数据不丢失？连续且按序？（中厂）

①校验和：在数据传输的过程中，将发送的数据段当做一个16位整数，将整数加起来。进位补到最后，最后取反，得到校验和。发送方和接收方对比校验和，一致不一定传输成功，但不一致一定失败。
②确认应答与序列号：TCP传输时每个字节的数据都编了号，这就是序列号seq。每当接收方接受到数据后，都会对传输方进行确认应答，也就是发送ACK报文。这个ACK报文携带者对应的确认序列号，告诉发送方，接收到了哪些数据，下次从哪里发。
③超时重传：两种情况没收到确认应答报文，A.数据丢包，接收方没接到。B.ACK报文丢失。
发送方会等待一段时间，没收到ACK的情况下重发刚才发送的数据包，如果是情况A，则接收方接到后回ACK，如果是第二种情况则接收方会发现重复，丢弃数据但仍然发送ACK。
④连接管理：三次握手、四次挥手，连接是传输的保证。
⑤流量控制：TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。在TCP协议的报头信息中，有一个16位的窗口大小，接收方在发送确认应答ACK时，把自己的即时窗口大小填入，接收方根据这个即时窗口大小决定发送的速度。如果为0，则停止发送，等待一个超时重传的时间，并发送窗口侦测数据段，直到接收端更新这个窗口大小。
⑥拥塞控制：如果一开始就发送大量的数据，那么可能刚开始就很拥堵，incident引入了慢启动的方式，先发送少量的数据探路，定义拥塞窗口为1，每次收到ACK就+1，然后两拥塞窗口和接受端的窗口大小进行比对，取较小的值作为实际发送的窗口。

TCP、UDP有什么区别？如果我要实现一个视频播放，我应该用TCP还是UDP，为什么？（中厂）

TCP：传输控制协议，面向连接的，使用全双工的可靠信道，提供可靠的服务，无差错，不丢失，不重复且按序到达。提供拥塞控制、流量控制、超时重发、丢弃重复数据等等可靠性检测手段，面向字节流，仅支持一对一，用于传输可靠性要求高的数据。
UDP：用户数据报协议，无连接的，使用不可靠信道。尽最大努力交付，不保证可靠交付，无拥塞控制等，面向报文，支持一对一、一对多、多对多的通信，用于传输可靠性要求不高的数据。
UDP适合于对网络通讯质量要求不高，要求网络通讯速度尽量快的应用。TCP则适合于对网络通讯质量要求高，且可靠的应用。视频播放分为关键帧和普通帧，且是实时应用，丢失一些普通帧并不会有什么影响，使用UDP更能保证其高效性和实时性。

get和post有什么区别？（中厂）

Get：当客户端要从服务器中读取某个资源时使用Get，一般用于获取、查询资源信息，Get参数通过URL传递，传递的参数有长度限制，不能用来传递敏感信息。
Post：当客户端给服务器提供信息较多时可以使用Post，Post附带有用户数据，一般用于更新资源信息，Post将请求参数封装在HTTP请求数据中，可以传输大量数据，传参方式也比Get更安全。

谈谈TCP为什么要三次握手、四次挥手？（中厂）

TCP建立连接时为了保证连接的可靠需要进行三次握手。客户端向服务端发送建立连接的SYN报文段，一旦包含SYN报文段的数据到达服务端，服务端从中提取出SYN报文段，为该TCP连接分配需要的缓存和变量。并向客户端发送允许连接的报文段ACK以及报文段SYN，在收到报文段ACK之后，客户端也要给连接分配需要的缓存和变量，再发送一个报文段ACK，表示确认。自此完成TCP连接。

由于TCP是全双工的，因此两方向需要单独关闭。客户端发起结束连接的数据段FIN，客户端确认后发送确认数据段ACK。此时结束了客户端-服务端的链接。服务端再向客户端发送数据段FIN和数据段ACK，客户端收到后回复ACK数据段。自此双方的连接正式结束。

请求报文和响应报文的报文格式是怎样的？（中厂）

啊啊啊讲道理，以上问题都出自同一家公司。主要是他问到了我大学期间哪门课比较擅长，我说是计算机网络。所以可见，你说你擅长的，你就一定要对它很了解。覆盖面要广，深度也要够。不然很容易被考倒，问题真的是一个接一个提出来。

请求报文：
＜request-line＞ 请求行
＜headers＞ 请求头
＜blank line＞ 空格
＜request-body＞ 请求数据
1.请求行：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，GET /index.html HTTP/1.1。
2.请求头部：由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。常见的请求头：
User-Agent：产生请求的浏览器类型。
Accept：客户端可识别的内容类型列表。
Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
3.空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。
4.请求数据：请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。

响应报文
＜status-line＞ 状态行
＜headers＞  消息报头
＜response-body＞ 响应正文
1.状态行：
HTTP-Version  Status-Code   Reason-Phrase   CRLF
其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。
状态码一般由三位数字组成，第一位数字表示相应的类型，常用的五大类型：
①1xx：表示服务器已接受了客户端请求，客户端可继续发送请求。
②2xx：表示服务器已接受了请求并进行处理。
200 OK：表示客户端请求成功。
③3xx：表示服务器要求客户端重定向。
④4xx：表示客户端的请求有非法内容。
400 Bad Request：表示客户端请求有语法错误，不能被服务器理解。
401 Unauthonzed：表示请求未经授权，该状态码与WWW-Authenticate报头域一起使用。
403 Forbidden：表示服务器接受到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因。
404 Not Found：请求的资源不存在，例如，收到了错误的url。
⑤5xx：表示服务器未能正确处理客户端的请求而产生意外错误。
500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求。
503 Service Unavailable：表示服务器当前不能处理客户端的请求，在一段时间之后，服务器可能恢复正常。
2.消息头部：如 Content-Type: text/html等。
3.响应正文

了解反射机制吗？简要的说一说？Class要获取的几种方式？（大厂、小厂）

Java 反射机制是在运行状态下，对任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息的方式称作反射机制。
①Object.getClass() （不适用于int、float等）
Car car = new Car();
Class clazz = car.getClass();
②.class标识 （用于未创建该类的实例时）
Class clazz = Car.class;
③Class.forName() （安卓中使用@hide注解隐藏起来的类）
Class clazz = Class.forName(com.example.test.Car);

简要的谈谈序列化的机制吧？(小厂)

序列化主要有两大接口 Srializable 接口和 Parcelable 接口。序列化将一个对象转换可存储可运输的状态，可以通过网络进行传递，也可以存储到本地。
应用场景：需要通过 Intent 和 Binder 等传输类的对象都需要完成对象的序列化过程。
①平台不同：S 是 Java 的序列化接口，P 是 Android 的序列化接口
②序列化原理不同：S将对象转换成可存储可运输的状态，P将对象分解，分解后的每一个部分都是可传递的数据类型。
③优缺点：S简单但是效率低，开销大，序列化、反序列化需要大量的IO操作，P高效但是编写麻烦。
④使用场景：S主要用于序列化到存储设备或者通过网络设备传输，P主要用于内存的序列化。

简要的谈谈注解的理解？(大厂)

这个问题我确实还是处在知识的盲区，还需要不断学习，这里就推荐一篇文章吧。Java注解相关。https://blog.csdn.net/ClAndEllen/article/details/79392453

五、项目相关问题
以下的问题就是仁者见仁、智者见智了。主要是关于你项目的问题，所以你必须对你简历上的项目负责。保证他不问倒你，如果你也有用到以下的这些框架，或者这些控件。你也可以跟下来继续看看。

你的项目中提到你使用 ViewPager+Fragment 实现相应的界面，那你了解过ViewPager 的滑动是如何实现的吗？ （中厂）

ViewPager是一个容器类，直接继承自ViewGroup，ViewPager主要就是根据重写OnInterceptTouchEvent()与onTouchEvent()两个事件分发的函数，而实现的手势滑动。有两种滑动方式：
1、在MOVE触摸事件中，页面随手指的拖动而移动。
2、在UP事件后，页面滑动到指定页面(通过Scroller实现的)
  先来看第一种情况，onInterceptTouchEvent()主要作用就是判断各种情况是不是在拖拽，是否要拦截此事件。在MOVE事件中，如果在拖拽，会调用performDrag()方法让当前页面移动。 performDrag()方法做了这么几件事：首先得到ViewPager需要滚动的距离，其次得到边界条件leftBound和rightBound，根据边界条件的约束得到真正的滚动距离，最后调用scrollTo()方法滚动到最终的位置。pageScrolled()简单来说就是根据当前的滑动位置，找到当前的页面信息，然后得到viewpager滑动距离，最后调用了onPageScrolled(currentPage, pageOffset, offsetPixels)。首先获得viewpager滑动过的距离比例，然后通过遍历mItems缓存列表，根据每个缓存页面的offset值得到该页面的左右边界，最后就是判断viewpager滑动过的距离比例在哪一个缓存页面的边界之内，这个缓存页面就是当前显示的页面。而如果viewpager显示区域内存在两个页面显示的时候，从缓存列表的遍历顺序就可以看出，返回的必然是最左边的页面。onPageScrolled()做了三件事：将DecorView显示在屏幕中，不移除屏幕、回调接口onPageScrolled()方法、回调接口的transformPage()方法，自定义实现页面转换动画。
简单总结下，就是在onInterceptTouchEvent()方法中根据不同情况对mIsBeingDragged进行赋值，对触摸事件是否进行拦截；如果在MOVE事件中是可滑动的，就调用performDrag()让视图跟着滑动，当然此方法中是调用scrollTo()方法形成拖拽效果，接着调用pageScrolled()对DecorView固定显示，回调接口，回调转换动画接口。
再来看第二种情况，另外一种移动方式在onTouchEvent()的UP事件中，调用setCurrentItemInternal()对平滑滑动进行处理，通过最后调用smoothScrollTo()方法，利用Scroller达到目的，当然最后也调用了pageScrolled()进行接口的回调等操作，在滑动结束的最后，调用completeScroll(boolean postEvents)完成滑动结束后的相关清理工作。
情况一：onInterceptTouchEvent()--->赋值mIsBeingDragged，判断是否拦截。--->performDrag()->ScrollTo()->pageScrolled()->onPageScrolled()->DecorView固定显示，回调接口，回调转换动画接口。
情况二：onTouchEvent()->UP事件->计算下一个应该显示的nextPage->setCurrentItemInternal()->smoothScrollTo()方法，利用Scroller达到目的 ->startScroll()->computeScroll()不断的重绘->completeScroll()完成滑动结束后的相关清理工作。

ViewPager加载Fragment时，使用什么适配器？有什么区别呢？（大厂）

两种适配器，FragmentPagerAdapter 和 FragmentStateAdapter。前者类内的每一个生成的 Fragment 都将保存在内存之中，因此适用于那些相对静态的页，数量也比较少的场景。如果需要处理有很多页，并且数据动态性较大、占用内存较多的情况，这时候，就需要用到后者。后者会把已经创建的Fragment进行保存。

你的项目中使用了Fragment，那在一个Fragment里面打开另一个Fragment（嵌套Fragment）要注意什么呢？（大厂）

在Fragment中嵌套Fragment时，一定要使用getChildFragmentManager();否则，会在ViewPager中出现fragment不会加载的情况，即fragment出现空白页的情况。

你的项目有没有进行相应的性能优化呢？从几个方面具体讲讲怎么做到的吧？（All）

关于这个问题有一些想说的，如果面试官询问你项目中有遇到什么难点，或者有什么你解决的不错的事情时，你也可以把这一块尝试着回答。毕竟优化对于一个移动应用开发是极其关键的。主要的方向是：流畅性、稳定性、资源节省性。毕竟是用户留存率的关键嘛。一个优化好的APP总是能提高其用户留存率，经常ANR的软件你巴不得卸载了他！主要从以下几个角度去切入主题：
1、布局优化：核心是减少层级：
①多嵌套情况下尽可能使用RelativeLayout减少嵌套。
②布局层级相同的情况下尽量使用LinearLayout(更加高效)。
③尽量使用标签重用布局，标签来减少层级，标签进行懒加载。
④使用布局调优工具，如AndroidStudio自带的Hierarchy Viewer，可以查看布局和绘制的时间。
⑤尽量少使用wrap_content这种测量耗时较长的属性。
2、绘制优化：①降低View.onDraw()的复杂度。不要在onDraw()中创建新的局部对象,因为onDraw会被频繁的调用。避免在onDraw()中执行大量&耗时的操作。
②避免过度绘制OverDraw，移除不必要的控件背景。减少布局的层级。
3、响应速度优化：ANR（应用程序无响应），应用在5秒内未相应用户的输入事件。广播接收器10秒内未完成相关的处理。服务20秒内无法处理完成。优化方案：使用多线程，把大量&耗时的工作放在工作线程中处理。比如AsyncTask、继承自Thread类，实现Runnable接口，Handler消息机制，HandlerThread进行异步消息传递等。 当发生ANR时，可以通过data/anr找到traces.txt文件确定ANR发生的原因。
4、内存优化：核心问题是内存泄露的问题：在申请内存后，不需使用时无法释放的现象，是导致内存溢出（程序所需的内存>所分配的内存资源）的原因。
①集合类，集合类添加元素后，仍引用着集合元素对象，导致集合元素对象不可被回收。
通过集合类的clear()方法&设置为null方式解决。
②Static关键字修饰的成员变量（单例模式）：由于引用耗费资源过多的实例（比如context）导致该成员变量的生命周期>引用实例的生命周期，导致实例无法被回收。
通过：
A、尽量避免Static成员变量引用消耗资源过多的实例（如Context），假设需要引用Context可以使用Application的Context。
B、使用弱引用代替强引用去持有实例。
③非静态内部类/匿名类：由于非静态内部类所创建的实例是静态的，会因非静态内部类默认持有外部类的引用而导致外部类无法被释放。
通过将非静态内部类设置为静态内部类，尽量避免费静态内部类所创建的实例=静态，或者将内部类抽取出来封装成单例。
④多线程：多线程大都是非静态内部类/匿名类，持有外部类的引用导致无法被销毁。或是线程的生命周期>Activity这种外部类的生命周期。
通过1、在Activity这种外部类的生命周期的onDestroy函数中强制关闭线程，或是将非静态内部类该为静态内部类，使引用关系不存在。
⑤资源对象使用后未关闭：比如广播、文件、数据库游标、图片资源未及时关闭、注销。通过在Activity的onDestroy()方法中调用相应的注销、关闭方法将其关闭或注销。
5、Bitmap优化：①使用完毕后，通过软引用释放掉图片资源。②根据分辨率适配&缩放图片。A.设置对应的图片资源(hdpi,xxhdpi,xhdpi)等。B.通过decodeResource()方法适配③选择合适的解码方式 ④设置图片缓存机制，如A.三级缓存机制（内存缓存-本地缓存-网络缓存）B.使用软引用的方式（内存空间不足时，才回收这些对象的内存）

你说你项目中使用了OkHttp框架，你可以说一下你为什么要使用该框架呢？->延伸，他的内部的拦截器机制是怎么实现的呢？（All）

关于框架类的题目，如果你体现在简历上，是一定会被问到的。所以一切要理解清楚，有时间还要去研读一下他的具体实现机制。面试官是很有可能会一路小跑问到底层。这里我们来聊聊OkHttp的内部拦截器机制以及OkHttp发起一次请求的过程。

创建一个 OkHttpClient（单例模式），重复创建 OkHttpClient 内存可能会爆掉，创建 request对象（建造者模式），初始化请求方式（Get/Post)，请求头（Header）以及请求的链接地址（url）。根据request对象，通过OkHttpClient的newCall()方法创建一个RealCall对象。判断是同步（execute）异步(enqueue) ，如果是异步则通过Dispatcher。RealCall通过执行getResponseWithInterceptorChain()返回Response。

OkHttp请求的流程
OkHttp请求的流程

okHttp的拦截器是一个责任链模式，真正的执行网络请求和返回相应结果是通过函数getResponseWithInterceptorChain()实现，通过实现Interceptor.Chain，并且执行了Chain.proceed()方法在拦截器间传递，责任链中每个拦截器都会执行chain.proceed()方法之前的代码，等责任链最后一个拦截器执行完毕后会返回最终的响应数据，而chain.proceed() 方法会得到最终的响应数据，这时就会执行每个拦截器的chain.proceed()方法之后的代码，其实就是对响应数据的一些操作。当责任链执行完毕，如果拦截器想要拿到最终的数据做其他的逻辑处理等，这样就不用在做其他的调用方法逻辑了，直接在当前的拦截器就可以拿到最终的数据。
五大拦截器的主要顺序是：
1.负责失败重试以及重定向的 RetryAndFollowUpInterceptor。
2.负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的BridgeInterceptor。
3.负责读取缓存直接返回、更新缓存的CacheInterceptor。
4.负责和服务器建立连接的ConnectInterceptor。
5.负责向服务器发送请求数据、从服务器读取响应数据的CallServerInterceptor。
拦截器顺序流程
拦截器顺序流程

其他的除了纯技术实现角度，你还可以聊一聊具体在项目中使用这个框架遇到的坑（比如怎么搞的内存又爆了，可能会引起共鸣，或者让面试官确认你确实使用过这个框架，有个实际操作，而不是纯粹的背知识点，这就和回答某种卷子的理论联系材料中是一个道理），或者说这个框架主要帮助你项目的点，以一个聊天的形式进行，我觉得就是很良好的面试心态了。


你说你项目中使用了Glide框架，说说你为什么要使用这个框架呢？->延伸：它的三级缓存机制是如何实现的呢？->你了解LRU缓存算法吗？->你了解LinkHashMap吗？->它是怎么实现的呢？(大厂)

大厂很多情况下不仅考察知识的广度、也考察知识的深度，因此可能会环环相扣，成为一个类责任链模式的问题链模式，所以如果你能够抢先一步，在他陈述这个问题最浅显的角度时，层层展开，完成知识的深度优先遍历。面试官的好感应该是up的。同时也是理论联系实际，可以谈谈实际开发遇到的一些问题。怎么使用的？

这里我们讨论一下，在使用Glide加载图片时with()方法有两种情况，传入Application类型的参数，和传入非Application类型的参数，那么如果是后者，如何保证Activity被关闭掉时，Glide也停止进行图片加载呢？

在Glide的With（）方法中返回的是一个RequestManager对象可以看出，在传入非Application类型的参数情况下，不管是Activity还是Fragment，都会向当前的Activity中添加一个隐藏的Fragment，可是Glide并没有办法知道Activity的生命周期，于是Glide就使用了添加隐藏Fragment的这种小技巧，因为Fragment的生命周期和Activity是同步的，如果Activity被销毁了，Fragment是可以监听到的，这样Glide就可以捕获这个事件并停止图片加载了。而如果是第一种情况，传入的是Application类型的参数，那么Glide的生命周期就和应用程序的周期同步，应用程序关闭，Glide也停止。  另外，如果如果我们是在非主线程当中使用的Glide，那么不管你是传入的Activity还是Fragment，都会被强制当成Application来处理。 详情见郭霖大神的文章详解Glide内部实现机制还。https://blog.csdn.net/sgiceleo/article/details/64440783 还是需要认真的去研读内部实现的。

你项目中有遇到什么问题吗？怎么解决的？

关于这个问题，我回答了ListView加载图片时出现的乱序问题，这个问题当时也困扰了我很久，图片怎么在乱闪！乱加载！所以，实际开发时遇到的问题一定要记下来！！！！
每当有新的元素进入界面时就会回调getView()方法，而在getView()方法中会开启异步请求从网络上获取图片，因为网络操作都是比较耗时的， 所以某一个位置上的元素进入屏幕后开始从网络上请求图片，但是还没等图片下载完成，它就又被移出了屏幕。这种情况下根据ListView的工作原理，被移出屏幕的控件将会很快被新进入屏幕的元素重新利用起来，而如果在这个时候刚好前面发起的图片请求有了响应，就会将刚才位置上的图片显示到当前位置上，因为虽然它们位置不同，但都是共用的同一个ImageView实例，这样就出现了图片乱序的情况。但是还没完，新进入屏幕的元素它也会发起一条网络请求来获取当前位置的图片，等到图片下载完的时候会设置到同样的ImageView上面，因此就会出现先显示一张图片，然后又变成了另外一张图片的情况。
有以下几种解决方案：
①使用findViewByTag。由于findViewByTag()方法需要有ListView的实例。恰好在getView()方法中的第三个参数就是ListView的实例，并且在getView()中调用ImageView的setTag()方法，并将当前图片的Url传进去，并在onpostExcute()里通过ListView的findViewByTag方法去获取ImageView实例，判断是否为空，不为空就填入图片。原因是getView方法调用时，setTag会覆盖旧的Url，如果这时候调用findViewBytag如果传的是旧的url则返回就是null，我们又规定只有不会Null时才会设置图片，因此解决这个问题。
②使用双向弱引用关联。BitmapWorkerTask指向ImageView：在BitmapWorkerTask中加一个构造函数，并在构造函数中要求ImageView这个参数。不过不是直接持有ImageView的引用，而是用WeakReference对ImageView进行一层封装。
ImageView指向BitmapWorkerTask：借助自定义Drawable的方式来实现。自定义一个AsyncDrawble类继承自BitmapDrawable，然后重写其构造函数，在构造函数中要求把BitmapWorkerTask传入，并包装一层弱引用。并在getView()方法中调用imageView.setImageDrawable()方法把AsyncDrawable设置进去，如此便关联完成。
通过getAttachImageView()方法和getBitmapWorkerTask()方法，如果获取到的BitmapWorkerTask等于this，那么就返回ImageView，否则返回null。
③使用NetWorkImageView。如果控件已经被移出了屏幕且被重新利用了，那么就把之前的请求取消掉。由于Volley在网络方面的封装非常优秀，它可以保证只要是取消掉的线程，就绝对不会进行回调。

六、算法与数据结构、设计模式
Talk is cheap.Show me the Code.
这一块毫无疑问是我相对比较薄弱的地方了！
手写算法。有时间限制的情况下。
在刷的题比较少的条件下。
确实还是有压力的。
慢慢学习吧！（LeetCode&剑指Offer）
先留着坑把碰到的题目都摆上来。
算法篇容我整理一下周末见。

最长回文子串问题？(大厂)

我给他写了暴力..他问我有时间复杂度上的改进吗…然后在他的指引下又写了中心波纹….然后…其实我是听了同学聊到马拉车算法的线性的。但是具体实现还没有看到…就只能跟他阐述了一下..也没有为难我…

给字符数组，去除字符串间多余的空格且将每个字符串首字母大写，不开辟新空间。(大厂)

给定字符串，要求翻转字符串里面的单词，但不改变字符串单词的顺序(大厂)。

关于这题我本来是觉得不能使用String的Split()和Reverse()函数的，但是先写在纸上试探了一下，没想到他说可以，那这题..就…有点太…简单了..

大数乘法（不能使用BigInteger类）（大厂）

这题不能用自带类的情况下，就是用数组存放乘法的局部结果之后再进位解决了。

给定数字n,1..n分布在二叉搜索树上，问有多少独一无二的二叉搜索树？

卡特兰数问题…当时确实有时间压力没有解出来，然后就凉凉了。(大厂)

快速排序（小厂）

这没什么好说的了，小厂大部分还是…比较尊重基础的….

二分排序（小厂）

其实从题目上来看，就很明显看出大小厂关于数据结构与算法要求的不同了…..

