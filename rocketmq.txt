
1.1　消息队列功能介绍1

1.1.1　应用解耦1

1.1.2　流量消峰2

1.1.3　消息分发3

1.2　RocketMQ简介4
1.3　快速上手RocketMQ4
1.3.1　RocketMQ的下载、安装和配置 5
1.3.2　启动消息队列服务6
1.3.3　用命令行发送和接收消息6
1.3.4　关闭消息队列6

第2章　生产环境下的配置和使用8
2.1　RocketMQ各部分角色介绍8
2.2　多机集群配置和部署9
2.2.1　启动多个NameServer和Broker10
2.2.2　配置参数介绍11
2.3　发送/接收消息示例13
2.4　常用管理命令15
2.5　通过图形界面管理集群21

第3章　用适合的方式发送和接收消息23
3.1　不同类型的消费者23
3.1.1　DefaultMQPushConsumer的使用23
3.1.2　DefaultMQPushConsumer的处理流程25
3.1.3　DefaultMQPushConsumer的流量控制28
3.1.4　DefaultMQPullConsumer30

3.1.5　Consumer的启动、关闭流程32
3.2　不同类型的生产者33
3.2.1　DefaultMQProducer 34
3.2.2　发送延迟消息36
3.2.3　自定义消息发送规则36
3.2.4　对事务的支持37
3.3　如何存储队列位置信息38
3.4　自定义日志输出42

第4章　分布式消息队列的协调者45
4.1　NameServer的功能45
4.1.1　集群状态的存储结构46
4.1.2　状态维护逻辑47
4.2　各个角色间的交互流程48
4.2.1　交互流程源码分析48
4.2.2　为何不用ZooKeeper50
4.3　底层通信机制50
4.3.1　Remoting模块51
4.3.2　协议设计和编解码54
4.3.3　Netty库56

5.1　消息存储和发送57
5.2　消息存储结构58
5.3　高可用性机制60
5.4　同步刷盘和异步刷盘61
5.5　同步复制和异步复制62

第6章　可靠性优先的使用场景64

6.1　顺序消息64
6.1.1　全局顺序消息64
6.1.2　部分顺序消息65

6.2　消息重复问题67
6.3　动态增减机器67
6.3.1　动态增减NameServer67
6.3.2　动态增减Broker69
6.4　各种故障对消息的影响70
6.5　消息优先级72

第7章　吞吐量优先的使用场景74
7.1　在Broker端进行消息过滤74
7.1.1　消息的Tag和Key74
7.1.2　通过Tag进行过滤75
7.1.3　用SQL表达式的方式进行过滤75
7.1.4　Filter Server方式过滤77
7.2　提高Consumer处理能力78
7.3　Consumer的负载均衡80
7.3.1　DefaultMQPushConsumer的负载均衡80
7.3.2　DefaultMQPullConsumer的负载均衡81

7.4　提高Producer的发送速度83
7.5　系统性能调优的一般流程85

第8章　和其他系统交互88
8.1　在SpringBoot中使用RocketMQ88
8.1.1　直接使用88
8.1.2　通过Spring Messaging方式使用90
8.2　直接使用云上RocketMQ91
8.3　RocketMQ与Spark、Flink对接93

8.4　自定义开发运维工具93
8.4.1　开源版本运维工具功能介绍94
8.4.2　基于Tools模块开发自定义运维工具95

第9章　首个Apache中间件顶级项目97

9.1　RocketMQ的前世今生97

9.2　Apache顶级项目（TLP）之路98
9.3　源码结构99
9.4　不断迭代的代码100

第10章　NameServer源码解析103
10.1　模块入口代码的功能103
10.1.1　入口函数103
10.1.2　解析命令行参数104
10.1.3　初始化NameServer的Controller105
10.2　NameServer的总控逻辑106
10.3　核心业务逻辑处理107
10.4　集群状态存储109


第11章　最常用的消费类112
11.1　整体流程112
11.1.1　上层接口类112
11.1.2　DefaultMQPushConsumer的实现者114
11.1.3　获取消息逻辑116
11.2　消息的并发处理118
11.2.1　并发处理过程118
11.2.2　ProcessQueue对象121

11.3　生产者消费者的底层类122
11.3.1　MQClientInstance类的创建规则122
11.3.2　MQClientInstance类的功能124


第12章　主从同步机制128
12.1　同步属性信息128
12.2　同步消息体130
12.3　sync_master和async_master132


第13章　基于Netty的通信实现135
13.1　Netty介绍135
13.2　Netty架构总览136
13.2.1　重新实现ByteBuffer136
13.2.2　统一的异步 I/O接口137
13.2.3　基于拦截链模式的事件模型138


13.3　Netty用法示例140
13.3.1　Discard服务器140
13.3.2　查看收到的数据144
13.4　RocketMQ基于Netty的通信功能实现145
13.4.1　顶层抽象类145
13.4.2　自定义协议148
13.4.3　基于Netty的Server和Client151


1.1　获取和调试RocketMQ的源代码 1
1.1.1　Eclipse获取RocketMQ源码 2
1.1.2　Eclipse调试RocketMQ源码 9
1.1.3　IntelliJ IDEA获取RocketMQ源码 15
1.1.4　IntelliJ IDEA调试RocketMQ源码 20
1.2　RocketMQ源代码的目录结构 27
1.3　RocketMQ的设计理念和目标 28
1.3.1　设计理念 28
1.3.2　设计目标 28


第2章　RocketMQ路由中心NameServer 31
2.1　NameServer架构设计 31
2.2　NameServer启动流程 32
2.3　NameServer路由注册、故障剔除 36
2.3.1　路由元信息 36
2.3.2　路由注册 38
2.3.3　路由删除 43
2.3.4　路由发现 46
2.4　本章小结 47
第3章　RocketMQ消息发送 49
3.1　漫谈RocketMQ消息发送 49
3.2　认识RocketMQ消息 50
3.3　生产者启动流程 51
3.3.1　初识DefaultMQProducer消息发送者 51
3.3.2　消息生产者启动流程 54
3.4　消息发送基本流程 56
3.4.1　消息长度验证 56
3.4.2　查找主题路由信息 56
3.4.3　选择消息队列 60
3.4.4　消息发送 65
3.5　批量消息发送 71
第4章　RocketMQ消息存储 75
4.1　存储概要设计 75
4.2　初识消息存储 76
4.3　消息发送存储流程 78
4.4　存储文件组织与内存映射 83
4.4.1　MappedFileQueue映射文件队列 84
4.4.2　MappedFile内存映射文件 87
4.4.3　TransientStorePool 93
4.5　RocketMQ存储文件 94
4.5.1　Commitlog文件 95
4.5.2　ConsumeQueue文件 97
4.5.3　Index索引文件 100
4.5.4　checkpoint文件 104
4.6　实时更新消息消费队列与索引文件 105
4.6.1　根据消息更新ConumeQueue 107
4.6.2　根据消息更新Index索引文件 108
4.7　消息队列与索引文件恢复 109
4.7.1　Broker正常停止文件恢复 112
4.7.2　Broker异常停止文件恢复 114
4.8　文件刷盘机制 115
4.8.1　Broker同步刷盘 116
4.8.2　Broker异步刷盘 119
4.9　过期文件删除机制 122
4.10　本章小结 126
第5章　RocketMQ消息消费 127
5.1　RocketMQ消息消费概述 127
5.2　消息消费者初探 128
5.3　消费者启动流程 130
5.4　消息拉取 133
5.4.1　PullMessageService实现机制 133
5.4.2　ProcessQueue实现机制 136
5.4.3　消息拉取基本流程 138
5.5　消息队列负载与重新分布机制 154
5.6　消息消费过程 162
5.6.1　消息消费 163
5.6.2　消息确认(ACK) 167
5.6.3　消费进度管理 171
5.7　定时消息机制 176
5.7.1　load方法 177
5.7.2　start方法 178
5.7.3　定时调度逻辑 179
5.8　消息过滤机制 181
5.9　顺序消息 186
5.9.1　消息队列负载 187
5.9.2　消息拉取 187
5.9.3　消息消费 188
5.9.4　消息队列锁实现 195
第6章　消息过滤FilterServer 198
6.1　ClassFilter运行机制 198
6.2　FilterServer注册剖析 199
6.3　类过滤模式订阅机制 202
6.4　消息拉取 205
6.5　本章小结 206
第7章　RocketMQ主从同步(HA)机制 207
7.1　RocketMQ主从复制原理 207
7.1.1　HAService整体工作机制 208
7.1.2　AcceptSocketService实现原理 208
7.1.3　GroupTransferService实现原理 210
7.1.4　HAClient实现原理 211
7.1.5　HAConnection实现原理 214
7.2　RocketMQ读写分离机制 220
7.3　本章小结 223
第8章　RocketMQ事务消息 225
8.1　事务消息实现思想 225
8.2　事务消息发送流程 226
8.3　提交或回滚事务 232
8.4　事务消息回查事务状态 233
8.5　本章小结 240
9.1　消息批量发送 242
9.2　消息发送队列自选择 243
9.3　消息过滤 243
9.3.1　TAG模式过滤 244
9.3.2　SQL表达模式过滤 244
9.3.3　类过滤模式 245
9.4　事务消息 247
9.5　Spring整合RocketMQ 250
9.6　Spring Cloud整合RocketMQ 251
9.7　RocketMQ监控与运维命令 258
9.7.1　RocktetMQ监控平台搭建 258
9.7.2　RocketMQ管理命令 261
9.8　应用场景分析 280
9.9　本章小结 281
附录A　参数说明 282