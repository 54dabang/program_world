第1章 Elasticsearch开发搜索引擎应用1
1.1 搜索引擎开发需求1
1.2 准备开发环境1
1.2.1 Windows命令行cmd1
1.2.2 在Windows下使用Java3
1.2.3 Linux终端5
1.2.4 在Linux下使用Java9
1.2.5 Eclipse集成开发环境10
1.3 了解Elasticsearch10
1.3.1 JSON数据格式11
1.3.2 Elasticsearch基本概念12
1.3.3 HTTP协议13
1.4 Elasticsearch安装和配置16
1.4.1 安装Elasticsearch16
1.4.2 运行Elasticsearch作为服务进程19
1.5 实现一个简单的网站搜索21
1.5.1 定义索引结构23
1.5.2 导入数据26
1.5.3 查询API27
1.5.4 实现搜索界面29
1.6 本章小结35
第2章 开发中文搜索引擎36
2.1 中文分词原理36
2.1.1 最长匹配方法36
2.1.2 自己写分析器42
2.1.3 概率语言模型的分词方法44
2.1.4 中文分词插件原理52
2.1.5 开发中文分词插件54
2.1.6 支持Elasticsearch的插件57
2.1.7 中文分析器提供者59
2.1.8 字词混合索引61
2.2 提高分词准确度63
2.3 本章小结65
第3章 Mapping详解66
3.1 索引模式66
3.1.1 创建模式66
3.1.2 修改模式68
3.2 Mapping数据类型69
3.3 Mapping参数70
3.4 动态Mapping71
3.4.1 使用动态Mapping72
3.4.2 实现原理72
3.5 本章小结74
第4章 深入源码分析75
4.1 Lucene源码分析75
4.1.1 使用Lucene75
4.1.2 Ivy管理依赖项77
4.1.3 源码结构介绍77
4.1.4 并发控制82
4.2 启动搜索服务88
4.3 Guice框架89
4.4 日期和时间库——Joda-Time91
4.5 Transport模块91
4.6 线程池92
4.7 模块93
4.8 Netty通信框架93
4.9 缓存94
4.10 分布式95
4.11 Zen发现机制95
4.12 联合搜索97
4.13 JVM字节码98
4.13.1 编译代码99
4.13.2 同步相关指令99
4.14 本章小结100
第5章 提高搜索相关性102
5.1 向量空间检索模型102
5.2 BM25检索模型105
5.2.1 使用BM25检索模型108
5.2.2 参数调优108
5.3 学习评分109
5.3.1 基本原理109
5.3.2 准备数据110
5.3.3 Elasticsearch学习排名112
5.4 查询意图识别112
5.5 图像特征提升检索体验113
5.6 本章小结116
第6章 搜索界面开发118
6.1 使用Searchkit实现搜索界面118
6.2 Spring Boot入门122
6.2.1 可执行的WAR125
6.2.2 spring-boot-devtools模块实现热部署136
6.3 Java模板引擎Pebble介绍136
6.4 通过Spring-data-elasticsearch 项目访问Elasticsearch141
6.5 REST基本概念149
6.6 使用Vue.js开发搜索界面154
6.7 使用Vue.js Paginator插件实现翻页157
6.8 实现搜索接口161
6.8.1 编码识别161
6.8.2 布尔搜索163
6.8.3 搜索结果重定向164
6.8.4 搜索结果排序165
6.8.5 实现相似文档搜索166
6.9 Suggester搜索词提示167
6.9.1 拼音提示169
6.9.2 部署总结169
6.9.3 相关搜索170
6.9.4 再次查找172
6.9.5 搜索日志172
6.10 Word2vec挖掘相关搜索词174
6.11 部署网站179
6.11.1 部署到Web服务器179
6.11.2 防止攻击181
6.12 使用Rust开发搜索界面184
6.13 本章小结184
第7章 Elastic栈系统监控186
7.1 管理Elasticsearch集群186
7.1.1 写入权限控制187
7.1.2 使用X-Pack188
7.1.3 快照189
7.2 Logstash数据处理工具190
7.2.1 使用Logstash190
7.2.2 插件192
7.2.3 数据库输入插件192
7.2.4 开发插件193
7.3 Filebeat文件收集器193
7.4 消息过期194
7.5 Kibana可视化平台195
7.6 Flume日志收集系统196
7.7 Kafka分布式流平台197
7.8 Graylog日志管理平台198
7.9 本章小结202
第8章 案例分析204
8.1 双语句对搜索204
8.1.1 爬虫抓取双语句对204
8.1.2 英文分词205
8.1.3 句子切分205
8.1.4 标注词性207
8.1.5 词对齐209
8.1.6 索引数据213
8.2 内容管理系统站内检索214
8.2.1 MySQL数据库214
8.2.2 RESTful API管理索引215
8.2.3 自动客服机器人217
8.3 搜索文档225
8.3.1 爬虫抓取信息225
8.3.2 在Linux下使用.NET233
8.3.3 NEST客户端235
8.4 本章小结239
参考文献240


1．1　用Elasticsearch解决搜索问题　3
1．1．1　提供快速查询　3
1．1．2　确保结果的相关性　4
1．1．3　超越精确匹配　5
1．2　探索典型的Elasticsearch使用案例　6
1．2．1　将Elasticsearch作为主要的后端系统　7
1．2．2　将Elasticsearch添加到现有的系统　7
1．2．3　将Elasticsearch和现有工具一同使用　8
1．2．4　Elasticsearch的主要特性　10
1．2．5　扩展Lucene的功能　10
1．2．6　在Elasticsearch中组织数据　12
1．2．7　安装Java语言　12
1．2．8　下载并启动Elasticsearch　13
1．2．9　验证是否工作　14
1．3　小结　16
第2章　深入功能　17
2．1　理解逻辑设计：文档、类型和索引　18
2．1．1　文档　19
2．1．2　类型　20
2．1．3　索引　21
2．2　理解物理设计：节点和分片　21
2．2．1　创建拥有一个或多个节点的集群　22
2．2．2　理解主分片和副本分片　23
2．2．3　在集群中分发分片　25
2．2．4　分布式索引和搜索　26
2．3　索引新数据　27
2．3．1　通过cURL索引一篇文档　28
2．3．2　创建索引和映射类型　30
2．3．3　通过代码样例索引文档　31
2．4　搜索并获取数据　32
2．4．1　在哪里搜索　33
2．4．2　回复的内容　33
2．4．3　如何搜索　36
2．4．4　通过ID获取文档　39
2．5　配置Elasticsearch　40
2．5．1　在elasticsearch．yml中指定集群的名称　40
2．5．2　通过logging．yml指定详细日志记录　41
2．5．3　调整JVM设置　41
2．6　在集群中加入节点　42
2．6．1　启动第二个节点　43
2．6．2　增加额外的节点　44
2．7　小结　45
第3章　索引、更新和删除数据　47
3．1　使用映射来定义各种文档　48
3．1．1　检索和定义映射　49
3．1．2　扩展现有的映射　50
3．2　用于定义文档字段的核心类型　51
3．2．1　字符串类型　52
3．2．2　数值类型　54
3．2．3　日期类型　55
3．2．4　布尔类型　56
3．3　数组和多字段　56
3．3．1　数组　56
3．3．2　多字段　57
3．4　使用预定义字段　58
3．4．1　控制如何存储和搜索文档　59
3．4．2　识别文档　61
3．5　更新现有文档　63
3．5．1　使用更新API　64
3．5．2　通过版本来实现并发控制　66
3．6　删除数据　69
3．6．1　删除文档　70
3．6．2　删除索引　71
3．6．3　关闭索引　72
3．6．4　重新索引样本文档　73
3．7　小结　73
第4章　搜索数据　74
4．1　搜索请求的结构　75
4．1．1　确定搜索范围　75
4．1．2　搜索请求的基本模块　76
4．1．3　基于请求主体的搜索请求　78
4．1．4　理解回复的结构　81
4．2　介绍查询和过滤器DSL　82
4．2．1　match查询和term过滤器　82
4．2．2　常用的基础查询和过滤器　85
4．2．3　match查询和term过滤器　91
4．2．4　phrase_prefix查询　92
4．3　组合查询或复合查询　93
4．3．1　bool查询　93
4．3．2　bool过滤器　96
4．4　超越match和过滤器查询　98
4．4．1　range查询和过滤器　98
4．4．2　prefix查询和过滤器　99
4．4．3　wildcard查询　100
4．5　使用过滤器查询字段的存在性　102
4．5．1　exists过滤器　102
4．5．2　missing过滤器　102
4．5．3　将任何查询转变为过滤器　103
4．6　为任务选择最好的查询　104
4．7　小结　105
第5章　分析数据　106
5．1　什么是分析　106
5．1．1　字符过滤　107
5．1．2　切分为分词　108
5．1．3　分词过滤器　108
5．1．4　分词索引　108
5．2　为文档使用分析器　109
5．2．1　在索引创建时增加分析器　109
5．2．2　在Elasticsearch的配置中添加分析器　111
5．2．3　在映射中指定某个字段的分析器　112
5．3　使用分析API来分析文本　113
5．3．1　选择一个分析器　114
5．3．2　通过组合即兴地创建分析器　115
5．3．3　基于某个字段映射的分析　115
5．3．4　使用词条向量API来学习索引词条　116
5．4　分析器、分词器和分词过滤器　117
5．4．1　内置的分析器　117
5．4．2　分词器　119
5．4．3　分词过滤器　122
5．5　N元语法、侧边N元语法和滑动窗口　128
5．5．1　一元语法过滤器　128
5．5．2　二元语法过滤器　129
5．5．3　三元语法过滤器　129
5．5．4　设置min_gram和max_gram　129
5．5．5　侧边N元语法过滤器　129
5．5．6　N元语法的设置　130
5．5．7　滑动窗口分词过滤器　131
5．6　提取词干　132
5．6．1　算法提取词干　133
5．6．2　使用字典提取词干　133
5．6．3　重写分词过滤器的词干提取　134
5．7　小结　134
第6章　使用相关性进行搜索　136
6．1　Elasticsearch的打分机制　137
6．1．1　文档打分是如何运作的　137
6．1．2　词频　137
6．1．3　逆文档频率　138
6．1．4　Lucene评分公式　138
6．2　其他打分方法　139
6．3　boosting　141
6．3．1　索引期间的boosting　142
6．3．2　查询期间的boosting　142
6．3．3　跨越多个字段的查询　143
6．4　使用“解释”来理解文档是如何被评分的　144
6．5　使用查询再打分来减小评分操作的性能影响　147
6．6　使用function_score来定制得分　148
6．6．1　weight函数　149
6．6．2　合并得分　150
6．6．3　field_value_factor函数　151
6．6．4　脚本　152
6．6．5　随机　152
6．6．6　衰减函数　153
6．6．7　配置选项　155
6．7　尝试一起使用它们吧　156
6．8　使用脚本来排序　157
6．9　字段数据　158
6．9．1　字段数据缓存　158
6．9．2　字段数据用在哪里　159
6．9．3　管理字段数据　160
6．10　小结　163
第7章　使用聚集来探索数据　164
7．1　理解聚集的具体结构　166
7．1．1　理解聚集请求的结构　166
7．1．2　运行在查询结果上的聚集　168
7．1．3　过滤器和聚集　169
7．2　度量聚集　170
7．2．1　统计数据　171
7．2．2　高级统计　172
7．2．3　近似统计　173
7．3　多桶型聚集　176
7．3．1　terms聚集　177
7．3．2　range聚集　183
7．3．3　histogram聚集　185
7．4　嵌套聚集　187
7．4．1　嵌套多桶聚集　189
7．4．2　通过嵌套聚集获得结果分组　190
7．4．3　使用单桶聚集　192
7．5　小结　196
第8章　文档间的关系　197
8．1　定义文档间关系的选项概览　197
8．1．1　对象类型　198
8．1．2　嵌套类型　200
8．1．3　父子关系　200
8．1．4　反规范化　200
8．2　将对象作为字段值　202
8．2．1　映射和索引对象　203
8．2．2　在对象中搜索　204
8．3　嵌套类型：联结嵌套的文档　206
8．3．1　映射并索引嵌套文档　207
8．3．2　搜索和聚集嵌套文档　210
8．4　父子关系：关联分隔的文档　216
8．4．1　子文档的索引、更新和删除　218
8．4．2　在父文档和子文档中搜索　220
8．5　反规范化：使用冗余的数据管理　227
8．5．1　反规范化的使用案例　228
8．5．2　索引、更新和删除反规范化的数据　230
8．5．3　查询反规范化的数据　233
8．6　应用端的连接　234
8．7　小结　235
第二部分
第9章　向外扩展　238
9．1　向Elasticsearch集群加入节点　238
9．2　发现其他Elasticsearch节点　241
9．2．1　通过广播来发现　241
9．2．2　通过单播来发现　242
9．2．3　选举主节点和识别错误　243
9．2．4　错误的识别　244
9．3　删除集群中的节点　245
9．4　升级Elasticsearch的节点　250
9．4．1　进行轮流重启　250
9．4．2　最小化重启后的恢复时间　251
9．5　使用_cat API　252
9．6　扩展策略　254
9．6．1　过度分片　254
9．6．2　将数据切分为索引和分片　255
9．6．3　最大化吞吐量　256
9．7　别名　257
9．7．1　什么是别名　258
9．7．2　别名的创建　259
9．8　路由　261
9．8．1　为什么使用路由　261
9．8．2　路由策略　262
9．8．3　使用_search_shards API来决定搜索在哪里执行　263
9．8．4　配置路由　265
9．8．5　结合路由和别名　265
9．9　小结　267
第10章　提升性能　268
10．1　合并请求　269
10．1．1　批量索引、更新和 删除　269
10．1．2　多条搜索和多条获取 API接口　273
10．2　优化Lucene分段的 处理　276
10．2．1　刷新和冲刷的阈值　276
10．2．2　合并以及合并策略　279
10．2．3　存储和存储限流　282
10．3　充分利用缓存　285
10．3．1　过滤器和过滤器 缓存　285
10．3．2　分片查询缓存　291
10．3．3　JVM堆和操作系统 缓存　293
10．3．4　使用预热器让缓存 热身　296
10．4　其他的性能权衡　297
10．4．1　大规模的索引还是 昂贵的搜索　298
10．4．2　调优脚本，要么 别用它　301
10．4．3　权衡网络开销，更少的 数据和更好的分布式 得分　305
10．4．4　权衡内存，进行深度 分页　308
10．5　小结　310
第11章　管理集群　311
11．1　改善默认的配置　311
11．1．1　索引模板　312
11．1．2　默认的映射　315
11．2　分配的感知　318
11．2．1　基于分片的分配　318
11．2．2　强制性的分配感知　319
11．3　监控瓶颈　320
11．3．1　检查集群的健康 状态　320
11．3．2　CPU：慢日志、热线程和 线程池　322
11．3．3　内存：堆的大小、字段和 过滤器缓存　326
11．3．4　操作系统缓存　330
11．3．5　存储限流　330
11．4　备份你的数据　331
11．4．1　快照API　331
11．4．2　将数据备份到共享的文件系统　332
11．4．3　从备份中恢复　335
11．4．4　使用资料库插件　336
11．5　小结　337
附录A　处理地理空间的数据（网上下载）
附录B　插件（网上下载）
附录C　高亮（网上下载）
附录D　Elasticsearch的监控插件（网上下载）
附录E　使用渗滤器将搜索颠倒过来（网上下载）
附录F　为自动完成和“您是指”功能使用建议器（网上下载）

第1章　走进Elasticsearch
1．1　基本概念和原理
1．1．1　索引结构
1．1．2　分片（shard）
1．1．3　动态更新索引
1．1．4　近实时搜索
1．1．5　段合并
1．2　集群内部原理
1．2．1　集群节点角色
1．2．2　集群健康状态
1．2．3　集群状态
1．2．4　集群扩容
1．3 客户端API
1．4　主要内部模块简介
1．4．1 模块结构
1．4．2 模块管理
第2章　准备编译和调试环境
2．1 编译源码
2．1．1 准备JDK和Gradle
2．1．2 下载源代码
2．1．3 编译项目，打包
2．1．4 将工程导入IntelliJ IDEA
2．2 调试Elasticsearch
2．2．1 本地运行、调试项目
2．2．2 远程调试
2．3 代码书签和断点组
第3章　集群启动流程
3．1 选举主节点
3．2　选举集群元信息
3．3　allocation过程
3．4　index recovery
3．5 集群启动日志
3．6 小结
第4章　节点的启动和关闭
4．1 启动流程做了什么
4．2 启动流程分析
4．2．1 启动脚本
4．2．2 解析命令行参数和配置文件
4．2．3 加载安全配置
4．2．4 检查内部环境
4．2．5 检测外部环境
4．2．6 启动内部模块
4．2．7 启动keepalive线程
4．3 节点关闭流程
4．4 关闭流程分析
4．5 分片读写过程中执行关闭
4．6 主节点被关闭
4．7 小结
第5章　选主流程
5．1 设计思想
5．2 为什么使用主从模式
5．3 选举算法
5．4 相关配置
5．5 流程概述
5．6 流程分析
5．6．1 选举临时Master
5．6．2 投票与得票的实现
5．6．3 确立Master或加入集群
5．7 节点失效检测
5．7．1 NodesFaultDetection事件处理
5．7．2 MasterFaultDetection事件处理
5．8 小结
第6章　数据模型
6．1 PacificA算法
6．1．1 数据副本策略
6．1．2 配置管理
6．1．3 错误检测
6．2 ES的数据副本模型
6．2．1 基本写入模型
6．2．2 写故障处理
6．2．3 基本读取模型
6．2．4 读故障处理
6．2．5 引申的含义
6．2．6 系统异常
6．3 Allocation IDs
6．3．1 安全地分配主分片
6．3．2 将分配标记为陈旧
6．2．3 一个例子
6．3．4 不会丢失全部
6．4 Sequence IDs
6．4．1 Primary Terms和Sequence Numbers
6．4．2 本地及全局检查点
6．4．3 用于快速恢复（Recovery）
6．5 _version
第7章　写流程
7．1 文档操作的定义
7．2 可选参数
7．3 Index/Bulk基本流程
7．4 Index/Bulk详细流程
7．4．1 协调节点流程
7．4．2 主分片节点流程
7．4．3 副分片节点流程
7．5 I/O异常处理
7．5．1 Engine关闭过程
7．5．2 Master的对应处理
7．5．3 异常流程总结
7．6 系统特性
7．7 思考
第8章　GET流程
8．1 可选参数
8．2 GET基本流程
8．3 GET详细分析
8．3．1 协调节点
8．3．2 数据节点
8．4 MGET流程分析
8．5 思考
第9章　Search流程
9．1 索引和搜索
9．1．1 建立索引
9．1．2 执行搜索
9．2 search type
9．3 分布式搜索过程
9．3．1 协调节点流程
9．3．2　执行搜索的数据节点流程
9．4 小结
第10章　索引恢复流程分析
10．1 相关配置
10．2 流程概述
10．3 主分片恢复流程
10．4 副分片恢复流程
10．4．1 流程概述
10．4．2 synced flush机制
10．4．3 副分片节点处理过程
10．4．4 主分片节点处理过程
10．5 recovery速度优化
10．6 如何保证副分片和主分片一致
10．7 recovery相关监控命令
10．8 小结
第11章　gateway模块分析
11．1 元数据
11．2 元数据的持久化
11．3 元数据的恢复
11．4 元数据恢复流程分析
11．4．1 选举集群级和索引级别的元数据
11．4．2 触发allocation
11．5 思考
第12章　allocation模块分析
12．1 什么是allocation
12．2 触发时机
12．3 allocation模块结构概述
12．4 allocators
12．5 deciders
12．5．1 负载均衡类
12．5．2 并发控制类
12．5．3 条件限制类
12．6 核心reroute实现
12．6．1 集群启动时reroute的触发时机
12．6．2 流程分析
12．6．3 gatewayAllocator
12．6．4 shardsAllocator
12．7 从gateway到allocation流程的转换
12．8 从allocation流程到recovery流程的转换
12．9 思考
第13章　Snapshot模块分析
13．1 仓库
13．2 快照
13．2．1 创建快照
13．2．2 获取快照信息
13．2．3 快照status
13．2．4 取消、删除快照和恢复操作
13．3 从快照恢复
13．3．1 部分恢复
13．3．2 恢复过程中更改索引设置
13．3．3 监控恢复进度
13．4 创建快照的实现原理
13．4．1 Lucene文件格式简介
13．4．2 协调节点流程
13．4．3 主节点流程
13．4．4 数据节点流程
13．5 删除快照实现原理
13．5．1 协调节点流程
13．5．2 主节点流程
13．6 思考与总结
第14章　Cluster模块分析
14．1 集群状态
14．2 内部封装和实现
14．2．1 MasterService
14．2．2 ClusterApplierService
14．2．3 线程池
14．3 提交集群任务
14．3．1 内部模块如何提交任务
14．3．2 任务提交过程实现
14．4 集群任务的执行过程
14．5 集群状态的发布过程
14．5．1 增量发布的实现原理
14．5．2 二段提交总流程
14．5．3 发布过程
14．5．4 提交过程
14．5．5 异常处理
14．6 应用集群状态
14．7 查看等待执行的集群任务
14．8 任务管理API
14．8．1 列出运行中的任务
14．8．2 取消任务
14．9 思考与总结
第15章　Transport模块分析
15．1 配置信息
15．1．1 传输模块配置
15．1．2 通用网络配置
15．2 Transport总体架构
15．2．1 网络层
15．2．2 服务层
15．3 REST解析和处理
15．4 RPC实现
15．4．1 RPC的注册和映射
15．4．2 根据Action获取处理类
15．5 思考与总结
第16章　ThreadPool模块分析
16．1 线程池类型
16．1．1 fixed
16．1．2 scaling
16．1．3 direct
16．1．4 fixed_auto_queue_size
16．2 处理器设置
16．3 查看线程池
16．3．1 cat thread pool
16．3．2 nodes info
16．3．3 nodes stats
16．3．4 nodes hot threads
16．3．5 Java的线程池结构
16．4 ES的线程池实现
16．4．1 ThreadPool类结构与初始化
16．4．2 fixed类型线程池构建过程
16．4．3 scaling类型线程池构建过程
16．4．4 direct类型线程池构建过程
16．4．5 fixed_auto_queue_size类型线程池构建过程
16．5 其他线程池
16．6 思考与总结
第17章　Shrink原理分析
17．1 准备源索引
17．2 缩小索引
17．3 Shrink的工作原理
17．3．1 创建新索引
17．3．2 创建硬链接
17．3．3 硬链接过程源码分析
第18章　写入速度优化
18．1 translog flush间隔调整
18．2 索引刷新间隔refresh_interval
18．3 段合并优化
18．4 indexing buffer
18．5 使用bulk请求
18．5．1 bulk线程池和队列
18．5．2 并发执行bulk请求
18．6 磁盘间的任务均衡
18．7 节点间的任务均衡
18．8 索引过程调整和优化
18．8．1 自动生成doc ID
18．8．2 调整字段Mappings
18．8．3 调整_source字段
18．8．4 禁用_all字段
18．8．5 对Analyzed的字段禁用Norms
18．8．6 index_options 设置
18．9 参考配置
18．10 思考与总结
第19章　搜索速度的优化
19．1 为文件系统cache预留足够的内存
19．2 使用更快的硬件
19．3 文档模型
19．4 预索引数据
19．5 字段映射
19．6 避免使用脚本
19．7 优化日期搜索
19．8 为只读索引执行force-merge
19．9 预热全局序号（global ordinals）
19．10 execution hint
19．11 预热文件系统cache
19．12 转换查询表达式
19．13 调节搜索请求中的batched_reduce_size
19．14 使用近似聚合
19．15 深度优先还是广度优先
19．16 限制搜索请求的分片数
19．17 利用自适应副本选择（ARS）提升ES响应速度
第20章　磁盘使用量优化
20．1 预备知识
20．1．1 元数据字段
20．1．2 索引映射参数
20．2 优化措施
20．2．1 禁用对你来说不需要的特性
20．2．2 禁用doc values
20．2．3 不要使用默认的动态字符串映射
20．2．4 观察分片大小
20．2．5 禁用_source
20．2．6 使用best_compression
20．2．7 Fource Merge
20．2．8 Shrink Index
20．2．9 数值类型长度够用就好
20．2．10 使用索引排序来排列类似的文档
20．2．11 在文档中以相同的顺序放置字段
20．3 测试数据
第21章　综合应用实践
21．1 集群层
21．1．1 规划集群规模
21．1．2 单节点还是多节点部署
21．1．3 移除节点
21．1．4 独立部署主节点
21．2 节点层
21．2．1 控制线程池的队列大小
21．2．2 为系统cache保留一半物理内存
21．3 系统层
21．3．1 关闭swap
21．3．2 配置Linux OOM Killer
21．3．3 优化内核参数
21．4 索引层
21．4．1 使用全局模板
21．4．2 索引轮转
21．4．3 避免热索引分片不均
21．4．4 副本数选择
21．4．5 Force Merge
21．4．6 Shrink Index
21．4．7 close索引
21．4．8 延迟分配分片
21．4．9 小心地使用fielddata
21．5 客户端
21．5．1 使用REST API而非Java API
21．5．2 注意429状态码
21．5．3 curl的HEAD请求
21．5．4 了解你的搜索计划
21．5．5 为读写请求设置比较长的超时时间
21．6 读写
21．6．1 避免搜索操作返回巨大的结果集
21．6．2 避免索引巨大的文档
21．6．3 避免使用多个_type
21．6．4 避免使用_all字段
21．6．5 避免将请求发送到同一个协调节点
21．7 控制相关度
第22章　故障诊断
22．1 使用Profile API定位慢查询
22．2 使用Explain API分析未分配的分片（Unassigned Shards）
22．2．1 诊断未分配的主分片
22．2．2 诊断未分配的副分片
22．2．3 诊断已分配的分片
22．3 节点CPU使用率高
22．4 节点内存使用率高
22．5 Slow Logs
22．6 分析工具
22．6．1 I/O信息
22．6．2 内存
22．6．3 CPU信息
22．6．4 网络连接和流量
22．7 小结
附录A　重大版本变化

1.1　Apache Lucene简介1
1.1.1　熟悉Lucene2
1.1.2　Lucene的总体架构2
1.1.3　分析数据4
1.1.4　Lucene查询语言5
1.2　何为Elasticsearch8
1.2.1　Elasticsearch的基本概念8
1.2.2　Elasticsearch架构背后的关键概念10
1.2.3　Elasticsearch的工作流程10
1.3　在线书店示例14
1.4　小结17
第2章　查询DSL进阶18
2.1　Apache Lucene默认评分公式解释18
2.1.1　何时文档被匹配上19
2.1.2　TF/IDF评分公式19
2.1.3　Elasticsearch如何看评分21
2.1.4　一个例子21
2.2　查询改写24
2.2.1　前缀查询示例24
2.2.2　回到Apache Lucene26
2.2.3　查询改写的属性28
2.3　查询模板30
2.3.1　引入查询模板31
2.3.2　Mustache模板引擎33
2.3.3　把查询模板保存到文件35
2.4　过滤器的使用及作用原理36
2.4.1　过滤及查询相关性36
2.4.2　过滤器的工作原理40
2.4.3　性能考量41
2.4.4　后置过滤和过滤查询42
2.4.5　选择正确的过滤方式44
2.5　选择正确的查询方式45
2.5.1　查询方式分类45
2.5.2　使用示例50
2.6　小结65
第3章　不只是文本搜索66
3.1　查询二次评分66
3.1.1　什么是查询二次评分67
3.1.2　一个查询例子67
3.1.3　二次评分查询的结构67
3.1.4　二次评分参数70
3.1.5　总结70
3.2　多匹配控制71
3.3　重要词项聚合78
3.3.1　一个例子79
3.3.2　选择重要词项81
3.3.3　多值分析81
3.3.4　额外的配置84
3.3.5　使用限制89
3.4　文档分组89
3.4.1　top_hits聚合90
3.4.2　一个例子90
3.5　文档关系95
3.5.1　对象类型95
3.5.2　嵌套文档98
3.5.3　parent-child关系99
3.5.4　其他解决方案102
3.6　Elasticsearch各版本中脚本的变化102
3.6.1　脚本变迁102
3.6.2　Groovy简单介绍103
3.6.3　全文检索中的脚本108
3.6.4　Lucene表达式115
3.7　小结118
第4章　改善用户搜索体验119
4.1　改正用户拼写错误119
4.1.1　测试数据120
4.1.2　深入技术细节121
4.1.3　suggester121
4.2　改善查询相关性142
4.2.1　数据142
4.2.2　改善相关性的探索之旅145
4.3　小结157
第5章　分布式索引架构159
5.1　选择合适的分片和副本数159
5.1.1　分片和过度分配160
5.1.2　一个过度分配的正面例子161
5.1.3　多分片与多索引161
5.1.4　副本161
5.2　路由162
5.2.1　分片和数据162
5.2.2　测试路由功能162
5.2.3　索引时使用路由166
5.2.4　别名169
5.2.5　多个路由值169
5.3　调整默认分片的分配行为170
5.3.1　部署意识171
5.3.2　过滤173
5.3.3　运行时更新分配策略174
5.3.4　确定每个节点允许的总分片数175
5.3.5　确定每个物理机器允许的总分片数175
5.4　查询执行偏好179
5.5　小结181
第6章　底层索引控制182
6.1　改变Apache Lucene的评分方式182
6.1.1　可用的相似度模型183
6.1.2　为每字段配置相似度模型183
6.1.3　相似度模型配置184
6.1.4　选择默认的相似度模型185
6.2　选择适当的目录实现—store模块188
6.3　准实时、提交、更新及事务日志191
6.3.1　索引更新及更新提交192
6.3.2　事务日志193
6.3.3　准实时读取194
6.4　控制索引合并195
6.4.1　选择正确的合并策略196
6.4.2　合并策略配置197
6.4.3　调度199
6.5　关于I/O调节200
6.5.1　控制I/O节流200
6.5.2　配置200
6.6　理解Elasticsearch缓存202
6.6.1　过滤器缓存203
6.6.2　字段数据缓存204
6.6.3　查询分片缓存212
6.6.4　使用circuit breaker213
6.6.5　清除缓存214
6.7　小结215
第7章　管理Elasticsearch216
7.1　发现和恢复模块216
7.1.1　发现模块的配置217
7.1.2　主节点218
7.1.3　网关和恢复模块的配置223
7.1.4　索引恢复API226
7.2　使用人类友好的Cat API 229
7.2.1　基础知识230
7.2.2　使用Cat API231
7.2.3　一些例子232
7.3　备份232
7.4　联盟搜索236
7.4.1　测试用的集群236
7.4.2　建立部落节点237
7.4.3　通过部落节点读取数据238
7.4.4　通过部落节点写入数据239
7.4.5　处理索引冲突240
7.4.6　屏蔽写操作241
7.5　小结242
第8章　提高性能243
8.1　使用doc values来优化查询243
8.1.1　字段缓存存在的问题244
8.1.2　使用doc values的例子245
8.2　了解垃圾回收器247
8.2.1　Java内存248
8.2.2　解决垃圾回收问题249
8.2.3　在类UNIX系统上避免内存交换254
8.3　对查询做基准测试255
8.3.1　为基准测试配置集群256
8.3.2　进行基准测试256
8.3.3　控制运行中的基准测试259
8.4　热点线程261
8.4.1　热点线程的使用说明261
8.4.2　热点线程API的响应262
8.5　扩展Elasticsearch263
8.5.1　垂直扩展263
8.5.2　水平扩展264
8.5.3　在高负载的场景下使用Elasticsearch271
8.6　小结283
第9章　开发Elasticsearch插件284
9.1　创建Maven项目284
9.2　了解基本知识285
9.2.1　Maven Java项目的结构285
9.2.2　POM的理念285
9.2.3　执行构建过程286
9.2.4　引入Maven装配插件287
9.3　创建自定义REST行为289
9.3.1　设定289
9.3.2　实现细节289
9.4　创建自定义分析插件295
9.4.1　实现细节295
9.4.2　测试自定义分析插件302


第1章 信息检索模型 1

1.1 信息检索概述 1

1.1.1 信息过载 1

1.1.2 信息检索定义 2

1.1.3 信息检索常用术语 3

1.1.4 信息检索系统 4

1.2 分词算法 5

1.2.1 分词算法概述 5

1.2.2 词典匹配分词法 6

1.2.3 语义理解分词法 6

1.2.4 词频统计分词法 7

1.3 倒排索引 7

1.4 布尔检索模型 9

1.5 tf-idf权重计算 11

1.6 向量空间模型 13

1.7 概率检索模型 16

1.7.1 贝叶斯决策理论 17

1.7.2 二值独立模型 18

1.7.3 Okapi BM25模型 20

1.7.4 BM25F模型 20

1.8 本章小结 21

第2章 Lucene开发入门 22

2.1 Lucene概述 22

2.1.1 Lucene简介 22

2.1.2 Lucene特点 22

2.1.3 Lucene架构 23

2.2 Lucene开发准备 25

2.2.1 下载Lucene文件库 25

2.2.2 工程中引入Lucene 26

2.2.3 下载Luke 27

2.2.4 下载IK分词工具 28

2.2.5 工程搭建 29

2.3 Lucene分词详解 30

2.3.1 Lucene分词系统 30

2.3.2 分词器测试 31

2.3.3 IK分词器配置 34

2.3.4 中文分词器对比 36

2.3.5 扩展停用词词典 38

2.3.6 扩展自定义词典 38

2.4 Lucene索引详解 40

2.4.1 Lucene字段类型 40

2.4.2 索引文档示例 41

2.4.3 Luke中查看索引 46

2.4.4 索引的删除 48

2.4.5 索引的更新 49

2.5 Lucene查询详解 50

2.5.1 搜索入门 51

2.5.2 多域搜索（MultiFieldQueryParser） 52

2.5.3 词项搜索（TermQuery） 53

2.5.4 布尔搜索（BooleanQuery） 53

2.5.5 范围搜索（RangeQuery） 54

2.5.6 前缀搜索（PrefixQuery） 55

2.5.7 多关键字搜索（PhraseQuery） 55

2.5.8 模糊搜索（FuzzyQuery） 55

2.5.9 通配符搜索（WildcardQuery） 56

2.6 Lucene查询高亮 56

2.7 Lucene新闻高频词提取 58

2.7.1 问题提出 58

2.7.2 需求分析 58

2.7.3 编程实现 58

2.8 本章小结 61

第3章 Lucene文件检索项目实战 62

3.1 需求分析 62

3.2 架构设计 63

3.3 文本内容抽取 64

3.3.1 Tika简介 64

3.3.2 Tika下载 64

3.3.3 搭建工程 65

3.3.4 内容抽取 66

3.3.5 自动解析 68

3.4 工程搭建 71

3.5 索引文档 72

3.6 查询界面 75

3.7 文件检索 77

3.8 结果展示 80

3.9 本章小结 85

第4章 从Lucene到Elasticsearch 86

4.1 Elasticsearch概述 86

4.1.1 诞生过程 86

4.1.2 流行度分析 88

4.1.3 架构解读 89

4.1.4 优点 89

4.1.5 应用场景 90

4.1.6 核心概念 92

4.1.7 对比RDMS 94

4.1.8 文档结构 94

4.2 安装Elasticsearch 95

4.2.1 安装Java 96

4.2.2 下载Elasticsearch 97

4.2.3 启动Elasticsearch 97

4.2.4 后台运行Elasticsearch 99

4.2.5 关闭Elasticsearch 99

4.2.6 基本配置 100

4.3 中文分词器配置 101

4.3.1 IK分词器安装 101

4.3.2 扩展本地词库 102

4.3.3 配置远程词库 103

4.4 Head插件使用指南 105

4.4.1 Head插件的安装 105

4.4.2 Head插件的使用 107

4.5 REST命令 109

4.5.1 CURL工具 110

4.5.2 Kibana Dev Tools 111

4.6 本章小结 112

第5章 Elasticsearch集群入门 113

5.1 索引管理 113

5.1.1 新建索引 113

5.1.2 更新副本 115

5.1.3 读写权限 115

5.1.4 查看索引 116

5.1.5 删除索引 117

5.1.6 索引的打开与关闭 118

5.1.7 复制索引 118

5.1.8 收缩索引 119

5.1.9 索引别名 120

5.2 文档管理 123

5.2.1 新建文档 123

5.2.2 获取文档 125

5.2.3 更新文档 127

5.2.4 查询更新 129

5.2.5 删除文档 129

5.2.6 查询删除 130

5.2.7 批量操作 130

5.2.8 版本控制 133

5.2.9 路由机制 136

5.3 映射详解 137

5.3.1 映射分类 137

5.3.2 动态映射 138

5.3.3 日期检测 140

5.3.4 静态映射 141

5.3.5 字段类型 142

5.3.6 元字段 156

5.3.7 映射参数 162

5.3.8 映射模板 180

==========

第1章 搜索的相关性问题

1.1 我们的目标：掌握相关性技术研发的技能

1.2 为什么搜索的相关性如此之难

1.2.1 什么是具备“相关性”的搜索结果

1.2.2 搜索：没有银弹

1.3 来自相关性研究的启示

1.3.1 信息检索

1.3.2 能否利用信息检索解决相关性问题

1.4 如何解决相关性

1.5 不只是技术：管理、协作与反馈

1.6 本章小结

第２章 搜索—幕后揭秘

2.1 搜索101

2.1.1 什么是搜索文档

2.1.2 对内容进行搜索

2.1.3 通过搜索来探索内容

2.1.4 获取进入搜索引擎的内容

2.2 搜索引擎的数据结构

2.2.1 倒排索引

2.2.2 倒排索引的其他内容

2.3 对内容进行索引：提取、充实、分析和索引

2.3.1 将内容提取为文档

2.3.2 充实文档以清理、强化与合并数据

2.3.3 执行分析

2.3.4 索引

2.4 文档的搜索和获取

2.4.1 布尔搜索： AND/OR/NOT

2.4.2 基于 Lucene搜索的布尔查询（MUST/MUST_NOT/SHOULD）

2.4.3 位置和短语匹配

2.4.4 助力用户浏览：过滤、切面和聚合

2.4.5 排序、结果排名，以及相关性

2.5 本章小结

第3章 调试我们的第一个相关性问题

3.1 Solr和Elasticsearch的应用：基于Elasticsearch的例子

3.2 最了不起的数据集：TMDB

3.3 用Python语言编写的例子

3.4 第一个搜索应用

3.4.1 针对 TMDB Elasticsearch索引的第一次搜索

3.5 调试查询匹配

3.5.1 检查底层查询策略

3.5.2 剖析查询解析

3.5.3 调试分析，解决匹配问题

3.5.4 比较查询条件和倒排索引

3.5.5 通过修改分析器来修正我们的匹配

3.6 调试排名

3.6.1 利用 Lucene的解释功能来剖析相关性评价

3.6.2 向量空间模型、相关性解释信息和我们

3.6.3 向量空间模型在实践中的注意事项

3.6.4 通过对匹配的评价来度量相关性

3.6.5 用 TF×IDF计算权重

3.6.6 谎言、该死的谎言和相似度

3.6.7 决定搜索词重要性的因素

3.6.8 解决 Space Jam和 alien的排名问题

3.7 问题解决了？工作永远做不完！

3.8 本章小结

第4章 驾驭token

4.1 将token作为文档特征

4.1.1 匹配的流程

4.1.2 token，不只是单词

4.2 控制查准率和查全率

4.2.1 查准率和查全率的例子

4.2.2 查准率或查全率的分析

4.2.3 一味提高查全率

4.3 查准率和查全率—让鱼和熊掌兼得

4.3.1 评价单一字段中特征的强度

4.3.2 超越 TF × IDF的评价：多搜索词与多字段

4.4 分析策略

4.4.1 处理分隔符

4.4.2 捕获同义词的语义

4.4.3 在搜索中为专指性建模

4.4.4 利用同义词为专指性建模

4.4.5 利用路径为专指性建模

4.4.6 对整个世界分词

4.4.7 对整数分词

4.4.8 对地理数据分词

4.4.9 对歌曲分词

4.5 本章小结

第5章 多字段搜索基础

5.1 信号及信号建模

5.1.1 什么是信号

5.1.2 从源数据模型开始

5.1.3 实现信号

5.1.4 信号建模：为数据的相关性建模

5.2 TMDB—搜索，人类最后的边疆

5.2.1 违反基本法则

5.2.2 让嵌套文档扁平化

5.3 在以字段为中心的搜索中给信号建模

5.3.1 从 best_.elds开始

5.3.2 控制搜索结果中的字段偏好

5.3.3 可以使用信号更精准的 best_.elds吗

5.3.4 让失败者分享荣耀：为 best_.elds校准

5.3.5 利用 most_.elds统计多个信号

5.3.6 在 most_.elds中缩放信号

5.3.7 什么时候其他匹配才无关紧要

5.3.8 有关 most_.elds的结论是什么

5.4 本章小结

第6章 以词为中心的搜索

6.1 什么是以词为中心的搜索

6.2 我们为什么需要以词为中心的搜索

6.2.1 猎寻“白化象”

6.2.2 在“星际迷航”的例子中寻找白化象问题

6.2.3 避免信号冲突

6.2.4 理解信号冲突的机理

6.3 完成第一个以词为中心的搜索

6.3.1 使用以词为中心的排名函数

6.3.2 运行以词为中心的查询解析器（深入底层）

6.3.3 理解字段同步

6.3.4 字段同步和信号建模

6.3.5 查询解析器和信号冲突

6.3.6 对以词为中心的搜索进行调优

6.4 在以词为中心的搜索中解决信号冲突

6.4.1 将字段合并成自定义全字段

6.4.2 利用 cross_.elds解决信号冲突

6.5 结合以字段为中心和以词为中心的策略：鱼与熊掌兼得

6.5.1 将“相似字段”分到一组

6.5.2 理解相似字段的局限

6.5.3 将贪婪的简单搜索和保守的放大器结合起来

6.5.4 以词为中心与以字段为中心，查准率与查全率

6.5.5 考虑过滤、放大，以及重新排名

6.6 本章小结

第7章 调整相关性函数

7.1 何谓评价调整

7.2 放大：通过突出结果来实现调整

7.2.1 放大：最后的边疆

7.2.2 放大时—选择加法运算还是乘法运算，布尔查询还是函数查询？

7.2.3 选择第一扇门：利用布尔查询进行加法放大

7.2.4 选择第二扇门：利用数学运算进行排名的函数查询

7.2.5 函数查询实践：简单的乘法放大

7.2.6 放大处理的基础：信号，处处是信号

7.3 过滤：通过排除的方法对结果进行调整

7.4 满足业务需求的评价调整策略

7.4.1 搜索所有影片

7.4.2 对放大信号进行建模

7.4.3 构造排名函数：增加具有较高价值的层级

7.4.4 利用函数查询对具有较高价值的层级进行评价

7.4.5 忽略 TF × IDF

7.4.6 捕捉综合质量指标

7.4.7 达成用户的时效性目标

7.4.8 结合函数查询

7.4.9 把一切联系起来

7.5 本章小结

第8章 提供相关性反馈

8.1 搜索框中的相关性反馈

8.1.1 利用“即输即搜”提供即时结果

8.1.2 利用“搜索补全”帮助用户找到最佳查询

8.1.3 利用搜索建议来修正输入和拼写错误

8.2 浏览期间的相关性反馈

8.2.1 构建基于切面的浏览

8.2.2 提供面包线导航

8.2.3 选择其他的结果排序方式

8.3 搜索结果清单中的相关性反馈

8.3.1 什么信息应该出现在搜索结果中

8.3.2 通过文本片段与高亮提供相关性反馈

8.3.3 对相似文档分组

8.3.4 在用户搜不到结果时给予帮助

8.4 本章小结

第9章 设计以相关性为核心的搜索应用

9.1 Yowl！一个绝佳的新起点

9.2 信息和需求的收集

9.2.1 理解用户及其信息需求

9.2.2 理解业务需求

9.2.3 找出必要及可用的信息

9.3 搜索应用的设计

9.3.1 将用户体验可视化

9.3.2 定义字段和模型的信号

9.3.3 信号的组合与平衡

9.4 部署、监控和改进

9.4.1 监控

9.4.2 找出问题并解决它们

9.5 知道什么是恰到好处

9.6 本章小结

第10章 以相关性为核心的企业

10.1 反馈：以相关性为核心的企业所依赖的基石

10.2 为什么以用户为中心的文化比数据驱动的文化更重要

10.3 无视相关性的天马行空

10.4 相关性反馈的觉醒：领域专家和专业用户

10.5 相关性反馈的成长：内容管理

10.5.1 内容管理员的角色

10.5.2 与内容管理员缺乏交流的风险

10.6 让相关性更加流畅：工程师/内容管理员的结对

10.7 让相关性加速：测试驱动的相关性

10.7.1 理解测试驱动的相关性

10.7.2 使用带用户行为数据的测试驱动相关性

10.8 超越测试驱动的相关性：学习排序

10.9 本章小结

第11章 语义和个性化搜索

11.1 基于用户概况的个性化搜索

11.1.1 收集用户的概况信息

11.1.2 将概要信息与文档索引紧密关联

11.2 基于用户行为的个性化搜索

11.2.1 引入协同过滤

11.2.2 使用共现计数的基本协同过滤算法

11.2.3 将用户行为信息与文档索引紧密关联

11.3 构建概念性搜索的基本方法

11.3.1 构建概念性信号

11.3.2 利用同义词对内容进行扩充

11.4 利用机器学习来构建概念性搜索

11.4.1 概念性搜索中短语的重要性

11.5 连接个性化搜索与概念性搜索

11.6 推荐是一种广义的搜索

11.6.1 用推荐代替搜索

附录A 直接根据TMDB建立索引

附录B Solr读者指南

1.1　Elasticsearch是什么1
1.1.1　Elasticsearch的历史2
1.1.2　相关产品3
1.2　全文搜索3
1.2.1　Lucene介绍4
1.2.2　Lucene倒排索引4
1.3　基础知识6
1.3.1　Elasticsearch术语及概念6
1.3.2　JSON介绍10
1.4　安装配置12
1.4.1　安装Java12
1.4.2　安装Elasticsearch12
1.4.3　配置13
1.4.4　运行15
1.4.5　停止17
1.4.6　作为服务17
1.4.7　版本升级19
1.5　对外接口21
1.5.1　API约定22
1.5.2　REST介绍25
1.5.3　Head插件安装26
1.5.4　创建库27
1.5.5　插入数据28
1.5.6　修改文档28
1.5.7　查询文档29
1.5.8　删除文档29
1.5.9　删除库30
1.6　Java接口30
1.6.1　Java接口说明30
1.6.2　创建索引文档33
1.6.3　增加文档34
1.6.4　修改文档35
1.6.5　查询文档35
1.6.6　删除文档35
1.7　小结36
第2章　索引37
2.1　索引管理37
2.1.1　创建索引37
2.1.2　删除索引39
2.1.3　获取索引39
2.1.4　打开/关闭索引40
2.2　索引映射管理41
2.2.1　增加映射41
2.2.2　获取映射44
2.2.3　获取字段映射45
2.2.4　判断类型是否存在46
2.3　索引别名46
2.4　索引配置51
2.4.1　更新索引配置51
2.4.2　获取配置52
2.4.3　索引分析52
2.4.4　索引模板54
2.4.5　复制配置55
2.4.6　重建索引56
2.5　索引监控60
2.5.1　索引统计60
2.5.2　索引分片62
2.5.3　索引恢复63
2.5.4　索引分片存储64
2.6　状态管理64
2.6.1　清除缓存64
2.6.2　索引刷新64
2.6.3　冲洗65
2.6.4　合并索引65
2.7　文档管理66
2.7.1　增加文档66
2.7.2　更新删除文档69
2.7.3　查询文档73
2.7.4　多文档操作76
2.7.5　索引词频率80
2.7.6　查询更新接口83
2.8　小结87
第3章　映射88
3.1　概念88
3.2　字段数据类型90
3.2.1　核心数据类型91
3.2.2　复杂数据类型96
3.2.3　地理数据类型100
3.2.4　专门数据类型106
3.3　元字段108
3.3.1　_all字段109
3.3.2　_field_names字段109
3.3.3　_id字段110
3.3.4　_index字段110
3.3.5　_meta字段111
3.3.6　_parent字段111
3.3.7　_routing字段112
3.3.8　_source字段114
3.3.9　_type字段115
3.3.10　_uid字段115
3.4　映射参数116
3.4.1　analyzer参数116
3.4.2　boost参数118
3.4.3　coerce参数119
3.4.4　copy_to参数120
3.4.5　doc_values参数121
3.4.6　dynamic参数122
3.4.7　enabled参数122
3.4.8　fielddata参数123
3.4.9　format参数126
3.4.10　geohash参数128
3.4.11　geohash_precision参数129
3.4.12　geohash_prefix参数130
3.4.13　ignore_above参数131
3.4.14　ignore_malformed参数131
3.4.15　include_in_all参数132
3.4.16　index参数133
3.4.17　index_options参数133
3.4.18　lat_lon参数134
3.4.19　fields参数135
3.4.20　norms参数136
3.4.21　null_value参数137
3.4.22　position_increment_gap参数137
3.4.23　precision_step参数138
3.4.24　properties参数138
3.4.25　search_analyzer参数139
3.4.26　similarity参数140
3.4.27　store参数141
3.4.28　term_vector参数141
3.5　动态映射142
3.5.1　概念142
3.5.2　_default_映射143
3.5.3　动态字段映射143
3.5.4　动态模板145
3.5.5　重写默认模板148
3.6　小结148
第4章　搜索149
4.1　深入搜索149
4.1.1　搜索方式149
4.1.2　重新评分153
4.1.3　滚动查询请求155
4.1.4　隐藏内容查询158
4.1.5　搜索相关函数161
4.1.6　搜索模板164
4.2　查询DSL167
4.2.1　查询和过滤的区别167
4.2.2　全文搜索168
4.2.3　字段查询179
4.2.4　复合查询183
4.2.5　连接查询188
4.2.6　地理查询190
4.2.7　跨度查询197
4.2.8　高亮显示200
4.3　简化查询203
4.4　小结206
第5章　聚合207
5.1　聚合的分类207
5.2　度量聚合209
5.2.1　平均值聚合209
5.2.2　基数聚合211
5.2.3　最大值聚合213
5.2.4　最小值聚合214
5.2.5　和聚合214
5.2.6　值计数聚合215
5.2.7　统计聚合215
5.2.8　百分比聚合215
5.2.9　百分比分级聚合216
5.2.10　最高命中排行聚合217
5.2.11　脚本度量聚合217
5.2.12　地理边界聚合221
5.2.13　地理重心聚合222
5.3　分组聚合223
5.3.1　子聚合224
5.3.2　直方图聚合226
5.3.3　日期直方图聚合230
5.3.4　时间范围聚合233
5.3.5　范围聚合234
5.3.6　过滤聚合235
5.3.7　多重过滤聚合236
5.3.8　空值聚合238
5.3.9　嵌套聚合239
5.3.10　采样聚合240
5.3.11　重要索引词聚合242
5.3.12　索引词聚合245
5.3.13　总体聚合251
5.3.14　地理点距离聚合251
5.3.15　地理散列网格聚合253
5.3.16　IPv4范围聚合255
5.4　管道聚合257
5.4.1　平均分组聚合259
5.4.2　移动平均聚合261
5.4.3　总和分组聚合262
5.4.4　总和累计聚合262
5.4.5　最大分组聚合264
5.4.6　最小分组聚合265
5.4.7　统计分组聚合266
5.4.8　百分位分组聚合268
5.4.9　差值聚合269


1.1 搜索引擎开发需求1
1.2 准备开发环境1
1.2.1 Windows命令行cmd1
1.2.2 在Windows下使用Java3
1.2.3 Linux终端5
1.2.4 在Linux下使用Java9
1.2.5 Eclipse集成开发环境10
1.3 了解Elasticsearch10
1.3.1 JSON数据格式11
1.3.2 Elasticsearch基本概念12
1.3.3 HTTP协议13
1.4 Elasticsearch安装和配置16
1.4.1 安装Elasticsearch16
1.4.2 运行Elasticsearch作为服务进程19
1.5 实现一个简单的网站搜索21
1.5.1 定义索引结构23
1.5.2 导入数据26
1.5.3 查询API27
1.5.4 实现搜索界面29
1.6 本章小结35
第2章 开发中文搜索引擎36
2.1 中文分词原理36
2.1.1 最长匹配方法36
2.1.2 自己写分析器42
2.1.3 概率语言模型的分词方法44
2.1.4 中文分词插件原理52
2.1.5 开发中文分词插件54
2.1.6 支持Elasticsearch的插件57
2.1.7 中文分析器提供者59
2.1.8 字词混合索引61
2.2 提高分词准确度63
2.3 本章小结65
第3章 Mapping详解66
3.1 索引模式66
3.1.1 创建模式66
3.1.2 修改模式68
3.2 Mapping数据类型69
3.3 Mapping参数70
3.4 动态Mapping71
3.4.1 使用动态Mapping72
3.4.2 实现原理72
3.5 本章小结74
第4章 深入源码分析75
4.1 Lucene源码分析75
4.1.1 使用Lucene75
4.1.2 Ivy管理依赖项77
4.1.3 源码结构介绍77
4.1.4 并发控制82
4.2 启动搜索服务88
4.3 Guice框架89
4.4 日期和时间库——Joda-Time91
4.5 Transport模块91
4.6 线程池92
4.7 模块93
4.8 Netty通信框架93
4.9 缓存94
4.10 分布式95
4.11 Zen发现机制95
4.12 联合搜索97
4.13 JVM字节码98
4.13.1 编译代码99
4.13.2 同步相关指令99
4.14 本章小结100
第5章 提高搜索相关性102
5.1 向量空间检索模型102
5.2 BM25检索模型105
5.2.1 使用BM25检索模型108
5.2.2 参数调优108
5.3 学习评分109
5.3.1 基本原理109
5.3.2 准备数据110
5.3.3 Elasticsearch学习排名112
5.4 查询意图识别112
5.5 图像特征提升检索体验113
5.6 本章小结116
第6章 搜索界面开发118
6.1 使用Searchkit实现搜索界面118
6.2 Spring Boot入门122
6.2.1 可执行的WAR125
6.2.2 spring-boot-devtools模块实现热部署136
6.3 Java模板引擎Pebble介绍136
6.4 通过Spring-data-elasticsearch 项目访问Elasticsearch141
6.5 REST基本概念149
6.6 使用Vue.js开发搜索界面154
6.7 使用Vue.js Paginator插件实现翻页157
6.8 实现搜索接口161
6.8.1 编码识别161
6.8.2 布尔搜索163
6.8.3 搜索结果重定向164
6.8.4 搜索结果排序165
6.8.5 实现相似文档搜索166
6.9 Suggester搜索词提示167
6.9.1 拼音提示169
6.9.2 部署总结169
6.9.3 相关搜索170
6.9.4 再次查找172
6.9.5 搜索日志172
6.10 Word2vec挖掘相关搜索词174
6.11 部署网站179
6.11.1 部署到Web服务器179
6.11.2 防止攻击181
6.12 使用Rust开发搜索界面184
6.13 本章小结184
第7章 Elastic栈系统监控186
7.1 管理Elasticsearch集群186
7.1.1 写入权限控制187
7.1.2 使用X-Pack188
7.1.3 快照189
7.2 Logstash数据处理工具190
7.2.1 使用Logstash190
7.2.2 插件192
7.2.3 数据库输入插件192
7.2.4 开发插件193
7.3 Filebeat文件收集器193
7.4 消息过期194
7.5 Kibana可视化平台195
7.6 Flume日志收集系统196
7.7 Kafka分布式流平台197
7.8 Graylog日志管理平台198
7.9 本章小结202
第8章 案例分析204
8.1 双语句对搜索204
8.1.1 爬虫抓取双语句对204
8.1.2 英文分词205
8.1.3 句子切分205
8.1.4 标注词性207
8.1.5 词对齐209
8.1.6 索引数据213
8.2 内容管理系统站内检索214
8.2.1 MySQL数据库214
8.2.2 RESTful API管理索引215
8.2.3 自动客服机器人217
8.3 搜索文档225
8.3.1 爬虫抓取信息225
8.3.2 在Linux下使用.NET233
8.3.3 NEST客户端235

1．1 基本概念 1
1．2 安装 2
1．3 搜索集群 5
1．4 创建索引 6
1．5 使用Java客户端接口 9
1．5．1 创建索引 11
1．5．2 增加、删除与修改数据 14
1．5．3 分析器 16
1．5．4 数据导入 17
1．5．5 通过摄取快速导入数据 17
1．5．6 索引库结构 17
1．5．7 查询 18
1．5．8 区间查询 22
1．5．9 排序 23
1．5．10 分布式搜索 23
1．5．11 过滤器 24
1．5．12 高亮显示 24
1．5．13 分页 25
1．5．14 通过聚合实现分组查询 26
1．5．15 文本列的聚合 27
1．5．16 遍历数据 28
1．5．17 索引文档 29
1．5．18 Percolate 29
1．6 RESTClient 30
1．6．1 使用摄取 31
1．6．2 代码实现摄取 33
1．7 使用Jest 33
1．8 Python客户端 37
1．9 Scala客户端 40
1．10 PHP客户端 43
1．11 SQL支持 44
1．12 本章小结 48
第2章 开发插件 49
2．1 搜索中文 49
2．1．1 中文分词原理 49
2．1．2 中文分词插件原理 51
2．1．3 开发中文分词插件 53
2．1．4 中文AnalyzerProvider 55
2．1．5 字词混合索引 57
2．2 搜索英文 60
2．2．1 句子切分 60
2．2．2 标注词性 62
2．3 使用测试套件 64
2．4 本章小结 68
第3章 管理搜索集群 69
3．1 节点类型 69
3．2 管理集群 69
3．3 写入权限控制 70
3．4 使用X-Pack 71
3．5 快照 72
3．6 Zen发现机制 73
3．7 联合搜索 74
3．8 缓存 74
3．9 本章小结 75
第4章 源码分析 76
4．1 Lucene源码分析 76
4．1．1 Ivy管理依赖项 76
4．1．2 源码结构介绍 76
4．2 Gradle 77
4．3 Guice 77
4．4 Joda-Time 79
4．5 Transport 80
4．6 线程池 80
4．7 模块 80
4．8 Netty 81
4．9 分布式 81
4．10 本章小结 82
第5章 搜索相关性 83
5．1 BM25检索模型 83
5．1．1 使用BM25检索模型 86
5．1．2 参数调优 86
5．2 学习评分 86
5．2．1 基本原理 87
5．2．2 准备数据 87
5．2．3 Elasticsearch学习排名 89
5．3 本章小结 91
第6章 搜索引擎用户界面 92
6．1 JSP实现搜索界面 92
6．1．1 用于显示搜索结果的自定义标签 93
6．1．2 使用Listlib 98
6．1．3 实现翻页 100
6．2 使用Spring实现的搜索界面 102
6．2．1 实现REST搜索界面 102
6．2．2 REST API中的HTTP PUT 104
6．2．3 Spring-data-elasticsearch 106
6．2．4 Spring HATEOAS 112
6．3 实现搜索接口 113
6．3．1 编码识别 113
6．3．2 布尔搜索 116
6．3．3 搜索结果排序 116
6．4 实现相似文档搜索 117
6．5 实现AJAX搜索联想词 119
6．5．1 估计查询词的文档频率 119
6．5．2 搜索联想词总体结构 119
6．5．3 服务器端处理 120
6．5．4 浏览器端处理 125
6．5．5 拼音提示 127
6．5．6 部署总结 127
6．5．7 Suggester 128
6．6 推荐搜索词 129
6．6．1 挖掘相关搜索词 130
6．6．2 使用多线程计算相关搜索词 132
6．7 查询意图理解 133
6．7．1 拼音搜索 133
6．7．2 无结果处理 133
6．8 集成其他功能 134
6．8．1 拼写检查 134
6．8．2 分类统计 135
6．8．3 相关搜索 141
6．8．4 再次查找 144
6．8．5 搜索日志 144
6．9 查询分析 146
6．9．1 历史搜索词记录 146
6．9．2 日志信息过滤 147
6．9．3 信息统计 148
6．9．4 挖掘日志信息 150
6．9．5 查询词意图分析 150
6．10 部署网站 150
6．10．1 部署到Web服务器 151
6．10．2 防止攻击 152
6．11 本章小结 156
第7章　OCR文字识别 157
7．1 Tesseract 157
7．2 使用TensorFlow识别文字 161
7．3 OpenCV 164
7．3．1 预处理 166
7．3．2 文字区域提取 169
7．3．3 纠正偏斜 171
7．3．4 Linux环境支持 172
7．4 JavaCV 172
7．5 本章小结 174
第8章　问答式搜索 176
8．1 生成表示语义的代码 176
8．2 信息整合 181
8．2．1 实体对齐 181
8．2．2 编辑距离 181
8．2．3 Jaro-Winkler距离 187
8．2．4 比较器 189
8．2．5 Cleaner 189
8．2．6 运行过程 190
8．2．7 遗传算法调整参数 192
8．3 自动问答 193
8．3．1 问句处理器 193
8．3．2 自动发现答案 198
8．4 本章小结 199
第9章　Elastic系统监控 201
9．1 Logstash 201
9．1．1 使用Logstash 201
9．1．2 插件 203
9．1．3 数据库输入插件 206
9．2 Filebeat 207
9．3 消息过期 208
9．4 Kibana 208
9．5 Flume 209
9．6 Kafka 210
9．7 Graylog 211
9．8 物联网数据 215

1.1　Apache Lucene简介1
1.1.1　熟悉Lucene2
1.1.2　Lucene的总体架构2
1.1.3　分析你的数据3
1.1.4　Lucene查询语言4
1.2　ElasticSearch简介6
1.2.1　ElasticSearch的基本概念7
1.2.2　ElasticSearch架构背后的关键概念8
1.2.3　ElasticSearch的工作流程9
1.3　小结13
第2章　查询DSL进阶14
2.1　Apache Lucene默认评分公式解释14
2.1.1　何时文档被匹配上15
2.1.2　TF/IDF评分公式15
2.1.3　ElasticSearch如何看评分16
2.2　查询改写17
2.2.1　前缀查询范例17
2.2.2　回顾Apache Lucene19
2.2.3　查询改写的属性20
2.3　二次评分21
2.3.1　理解二次评分21
2.3.2　范例数据21
2.3.3　查询22
2.3.4　二次评分查询的结构22
2.3.5　二次评分参数配置23
2.3.6　小结24
2.4　批量操作24
2.4.1　批量取24
2.4.2　批量查询26
2.5　排序27
2.5.1　基于多值字段的排序28
2.5.2　基于多值geo字段的排序28
2.5.3　基于嵌套对象的排序30
2.6　数据更新API31
2.6.1　简单字段更新31
2.6.2　使用脚本按条件更新32
2.6.3　使用更新 API创建或删除文档33
2.7　使用过滤器优化查询33
2.7.1　过滤器与缓存34
2.7.2　词项查找过滤器36
2.8　ElasticSearch切面机制中的过滤器与作用域40
2.8.1　范例数据40
2.8.2　切面计算和过滤41
2.8.3　过滤器作为查询的一部分42
2.8.4　切面过滤器44
2.8.5　全局作用域45
2.9　小结47
第3章　底层索引控制48
3.1　改变Apache Lucene的评分方式48
3.1.1　可用的相似度模型49
3.1.2　为每字段配置相似度模型49
3.2　相似度模型配置50
3.2.1　选择默认的相似度模型51
3.2.2　配置被选用的相似度模型52
3.3　使用编解码器53
3.3.1　简单使用范例53
3.3.2　工作原理解释54
3.3.3　可用的倒排表格式55
3.3.4　配置编解码器56
3.4　准实时、提交、更新及事务日志58
3.4.1　索引更新及更新提交59
3.4.2　事务日志60
3.4.3　准实时读取62
3.5　深入理解数据处理62
3.5.1　输入并不总是进行文本分析62
3.5.2　范例的使用65
3.5.3　索引期更换分词器67
3.5.4　搜索时更换分析器68
3.5.5　陷阱与默认分析68
3.6　控制索引合并68
3.6.1　选择正确的合并策略69
3.6.2　合并策略配置70
3.6.3　调度72
3.7　小结73
第4章　分布式索引架构74
4.1　选择合适的分片和副本数74
4.1.1　分片和过度分配75
4.1.2　一个过度分配的正面例子75
4.1.3　多分片与多索引76
4.1.4　副本76
4.2　路由76
4.2.1　分片和数据77
4.2.2　测试路由功能77
4.2.3　索引时使用路由80
4.2.4　别名83
4.2.5　多个路由值83
4.3　调整默认的分片分配行为84
4.3.1　分片分配器简介84
4.3.2　even_shard 分片分配器84
4.3.3　balanced分片分配器85
4.3.4　自定义分片分配器85
4.3.5　裁决者86
4.4　调整分片分配88
4.4.1　部署意识89
4.4.2　过滤91
4.4.3　运行时更新分配策略92
4.4.4　确定每个节点允许的总分片数93
4.4.5　更多的分片分配属性96
4.5　查询执行偏好97
4.6　应用我们的知识99
4.6.1　基本假定99
4.6.2　配置100
4.6.3　变化来了104
4.7　小结105
第5章　管理ElasticSearch106
5.1　选择正确的目录实现-存储模块106
5.2　发现模块的配置109
5.2.1　Zen发现109
5.2.2　亚马逊EC2发现111
5.2.3　本地网关114
5.2.4　恢复配置115
5.3　索引段统计116
5.3.1　segments API简介116
5.3.2　索引段信息的可视化118
5.4　理解ElasticSearch缓存119
5.4.1　过滤器缓存119
5.4.2　字段数据缓存121
5.4.3　清除缓存126
5.5　小结127
第6章　故障处理129
6.1　了解垃圾回收器129
6.1.1　Java内存130
6.1.2　处理垃圾回收问题131
6.1.3　在类UNIX系统中避免内存交换135
6.2　关于I/O调节136
6.2.1　控制IO节流136
6.2.2　配置136
6.3　用预热器提升查询速度138
6.3.1　为什么使用预热器138
6.3.2　操作预热器138
6.3.3　测试预热器141
6.4　热点线程144
6.4.1　澄清热点线程API的用法误区145
6.4.2　热点线程API的响应信息145
6.5　现实场景146
6.5.1　越来越差的性能146
6.5.2　混杂的环境和负载不平衡148
6.5.3　我的服务器出故障了149
6.6　小结150
第7章　改善用户搜索体验151
7.1　改正用户拼写错误151
7.1.1　测试数据152
7.1.2　深入技术细节152
7.1.3　completion suggester168
7.2　改善查询相关性172
7.2.1　数据172
7.2.2　改善相关性的探索之旅174
7.3　小结188
第8章　ElasticSearch Java API189
8.1　ElasticSearch Java API简介189
8.2　代码190
8.3　连接到集群191
8.3.1　成为ElasticSearch节点191
8.3.2　使用传输机连接方式192
8.3.3　选择合适的连接方式193
8.4　API剖析194
8.5　CRUD操作195
8.5.1　读取文档195
8.5.2　索引文档197
8.5.3　更新文档199
8.5.4　删除文档201
8.6　ElasticSearch查询203
8.6.1　准备查询请求203
8.6.2　构造查询203
8.6.3　分页206
8.6.4　排序207
8.6.5　过滤207
8.6.6　切面计算208
8.6.7　高亮209
8.6.8　查询建议209
8.6.9　计数210
8.6.10　滚动211
8.7　批量执行多个操作211
8.7.1　批量操作211
8.7.2　根据查询删除文档212
8.7.3　Multi GET212
8.7.4　Multi Search212
8.8　Percolator213
8.9　explain API214
8.10　构造JSON格式的查询和文档214
8.11　管理API216
8.11.1　集群管理API216
8.11.2　索引管理API219
8.12　小结226
第9章　开发ElasticSearch插件227
9.1　建立Apache Maven项目结构227
9.1.1　了解基本知识228
9.1.2　Maven Java项目的结构228
9.1.3　POM的理念228
9.1.4　运行构建过程229
9.1.5　引入Maven装配插件230
9.2　创建一个自定义river插件232
9.2.1　实现细节232
9.2.2　测试river238
9.3　创建自定义分析插件240
9.3.1　实现细节240
9.3.2　测试自定义分析插件247

