1 微服务架构概述 1
1．1 单体应用架构存在的问题 1
1．2 如何解决单体应用架构存在的问题 3
1．3 什么是微服务． 3
1．4 微服务架构的优点与挑战 4
1．4．1 微服务架构的优点 5
1．4．2 微服务架构面临的挑战 5
1．5 微服务设计原则6
1．6 如何实现微服务架构 7
1．6．1 技术选型7
1．6．2 架构图及常用组件 8


2 微服务开发框架――Spring Cloud 9
2．1 Spring Cloud 简介 ． 9
2．2 Spring Cloud 特点 ． 10
2．3 Spring Cloud 版本 ． 10
2．3．1 版本简介10
2．3．2 子项目一览 12
2．3．3 Spring Cloud/Spring Boot 版本兼容性 13


3 开始使用Spring Cloud 实战微服务．14
3．1 Spring Cloud 实战前提 14
3．1．1 技术储备14
3．1．2 工具及软件版本 15
3．2 服务提供者与服务消费者 16
3．3 编写服务提供者16
3．3．1 手动编写项目 ． 17
3．3．2 使用Spring Initializr 快速创建Spring Boot 项目． 21
3．4 编写服务消费者23
3．5 为项目整合Spring Boot Actuator 25
3．6 硬编码有哪些问题 28


4 微服务注册与发现
4．1 服务发现简介． 30
4．2 Eureka 简介 ． 32
4．3 Eureka 原理 ． 32
4．4 编写Eureka Server 34
4．5 将微服务注册到Eureka Server 上 ． 36
4．6 Eureka Server 的高可用 38
4．6．1 编写高可用Eureka Server ． 38
4．6．2 将应用注册到Eureka Server 集群上 41
4．7 用户认证 ． 41
4．7．1 为Eureka Server 添加用户认证 41
4．7．2 将微服务注册到需认证的Eureka Server 43
4．8 Eureka 的元数据43
4．8．1 改造用户微服务 43
4．8．2 改造电影微服务 44
4．9 Eureka Server 的REST 端点 46
4．9．1 示例 47
4．9．2 注销微服务实例 52
4．10 Eureka 的自我保护模式 53
4．11 多网卡环境下的IP 选择 54
4．12 Eureka 的健康检查 56
4．13 排除Jersey 依赖． 57


5 使用Ribbon 实现客户端侧负载均衡 59
5．1 Ribbon 简介 59
5．2 为服务消费者整合Ribbon 60
5．3 Ribbon 配置自定义 63
5．3．1 使用Java 代码自定义Ribbon 配置63
5．3．2 使用属性自定义Ribbon 配置 67
5．4 脱离Eureka 使用Ribbon ． 68
5．5 饥饿加载 ． 70


6 使用Feign 实现声明式REST 调用 72
6．1 Feign 简介 73
6．2 为服务消费者整合Feign ． 73
6．3 自定义Feign 配置 ． 75
6．3．1 使用Java 代码自定义Feign 配置75
6．3．2 使用属性自定义Feign 配置 79
6．4 手动创建Feign80
6．4．1 修改用户微服务 80
6．4．2 修改电影微服务 84
6．5 Feign 对继承的支持 86
6．6 Feign 对压缩的支持 87
6．7 Feign 的日志 87
6．7．1 编码方式设置日志级别 88
6．7．2 使用属性配置日志级别 89
6．8 使用Feign 构造多参数请求 90
6．8．1 GET 请求多参数的URL 90
6．8．2 POST 请求包含多个参数 ．91
6．9 使用Feign 上传文件 92


7 使用Hystrix 实现微服务的容错处理 94
7．1 实现容错的手段 94
7．1．1 雪崩效应95
7．1．2 如何容错95
7．2 使用Hystrix 实现容错 ． 97
7．2．1 Hystrix 简介 97

7．2．2 通用方式整合Hystrix． 98

7．2．3 Hystrix 断路器的状态监控与深入理解 102
7．2．4 Hystrix 线程隔离策略与传播上下文 103
7．2．5 Feign 使用Hystrix ． 106
7．3 Hystrix 的监控112
7．4 使用Hystrix Dashboard 可视化监控数据． 113
7．5 使用Turbine 聚合监控数据 116
7．5．1 Turbine 简介 116
7．5．2 使用Turbine 监控多个微服务． 117
7．5．3 使用消息中间件收集数据． 119


8 使用Zuul 构建微服务网关 124
8．1 为什么要使用微服务网关 124
8．2 Zuul 简介 ． 126
8．3 编写Zuul 微服务网关 ． 126
8．4 管理端点 ． 129
8．4．1 routes 端点 129
8．4．2 filters 端点 131
8．5 路由配置详解． 132
8．6 Zuul 的安全与Header ． 136
8．6．1 敏感Header 的设置 136
8．6．2 忽略Header 136
8．7 使用Zuul 上传文件 137
8．8 Zuul 的过滤器140
8．8．1 过滤器类型与请求生命周期 ． 140
8．8．2 内置过滤器详解 141
8．8．3 编写Zuul 过滤器 ． 144
8．8．4 禁用Zuul 过滤器 ． 146
8．9 Zuul 的容错与回退 146
8．10 饥饿加载 ． 149
8．11 Query String 编码 ． 150
8．12 Hystrix 隔离策略与线程池 150
8．12．1 隔离策略150
8．12．2 线程池配置 151
8．13 Zuul 的高可用152
8．13．1 Zuul 客户端也注册到了Eureka Server 上 152
8．13．2 Zuul 客户端未注册到Eureka Server 上． 152
8．14 使用Sidecar 整合非JVM 微服务 154
8．14．1 编写Node．js 微服务 154
8．14．2 编写Sidecar 155
8．14．3 Sidecar 的端点 ． 157
8．14．4 Sidecar 与Node．js 微服务分离部署． 158
8．14．5 Sidecar 原理分析 ． 158
8．15 使用Zuul 聚合微服务 ． 160


9 使用Spring Cloud Config 统一管理微服务配置． 166
9．1 为什么要统一管理微服务配置 166
9．2 Spring Cloud Config 简介 ． 167
9．3 编写Config Server ． 168
9．4 编写Config Client ． 171
9．5 Config Server 的Git 仓库配置详解 173
9．5．1 占位符支持 173
9．5．2 模式匹配174
9．5．3 搜索目录174
9．5．4 启动时加载配置文件． 175
9．6 Config Server 的健康状况指示器 176
9．7 配置内容的加解密 177
9．7．1 安装JCE 177
9．7．2 Config Server 的加解密端点 177
9．7．3 对称加密177
9．7．4 存储加密的内容 178
9．7．5 非对称加密 179
9．8 使用/refresh 端点手动刷新配置 180
9．9 使用Spring Cloud Bus 自动刷新配置 ． 181
9．9．1 Spring Cloud Bus 简介． 181
9．9．2 实现自动刷新 ． 182
9．9．3 局部刷新183
9．9．4 架构改进184
9．9．5 跟踪总线事件 ． 184
9．10 Spring Cloud Config 与Eureka 配合使用． 186
9．11 Spring Cloud Config 的用户认证 187
9．12 Config Server 的高可用 188
9．12．1 Git 仓库的高可用 ． 188
9．12．2 RabbitMQ 的高可用 189
9．12．3 Config Server 自身的高可用 189



10 使用Spring Cloud Sleuth 实现微服务跟踪 191

10．1 为什么要实现微服务跟踪 191
10．2 Spring Cloud Sleuth 简介 192
10．3 整合Spring Cloud Sleuth 194
10．4 Spring Cloud Sleuth 与ELK 配合使用 ． 196
10．5 Spring Cloud Sleuth 与Zipkin 配合使用 200
10．5．1 Zipkin 简介 200
10．5．2 编写Zipkin Server 200
10．5．3 微服务整合Zipkin 202
10．5．4 Zipkin 与Eureka 配合使用 205
10．5．5 使用消息中间件收集数据 ． 206
10．5．6 使用Elasticsearch 存储跟踪数据． 209
10．5．7 依赖关系图 211


11 Spring Cloud 常见问题与总结 213
11．1 Eureka 常见问题213
11．1．1 Eureka 注册服务慢 213
11．1．2 已停止的微服务节点注销慢或不注销 ． 214
11．1．3 如何自定义微服务的Instance ID 215
11．1．4 Eureka 的UNKNOWN 问题总结与解决 217
11．2 整合Hystrix 后首次请求失败． 218
11．2．1 原因分析218
11．2．2 解决方案218
11．3 Turbine 聚合的数据不完整 219
11．4 Spring Cloud 各组件超时 ． 220
11．4．1 RestTemplate 的超时 221
11．4．2 Ribbon 的超时 ． 221
11．4．3 Feign 的超时 221
11．4．4 Hystrix 的超时 222
11．4．5 Zuul 的超时 222
11．5 Spring Cloud 各组件重试 ． 223
11．5．1 重试步骤224
11．5．2 基于HTTP 响应码重试 224
11．5．3 关闭重试224
11．5．4 注意点224
11．6 Spring Cloud 各组件调优 ． 225
11．6．1 Tomcat 参数 225
11．6．2 Hystrix 参数 225
11．6．3 Feign 参数 226
11．6．4 Zuul 参数 ． 226
11．7 Spring Cloud 各组件配置属性． 228
11．7．1 Spring Boot 的配置 228
11．7．2 Spring Cloud 的配置 228
11．7．3 原生配置229
11．8 Spring Cloud 定位问题思路总结 229


12 Docker 入门232
12．1 Docker 简介 232
12．2 版本与迭代计划232
12．2．1 版本区别233
12．2．2 迭代计划233
12．3 Docker 的架构234
12．4 安装Docker 236
12．4．1 CentOS 7 安装Docker 236
12．4．2 Ubuntu 安装Docker 239
12．4．3 Windows 安装Docker． 244
12．4．4 Mac OS 安装Docker 245
12．5 配置镜像加速器245
12．6 Docker 常用命令246
12．6．1 Docker 镜像常用命令． 246
12．6．2 Docker 容器常用命令． 252


13 将微服务运行在Docker上 260
13．1 使用Dockerfile 构建Docker 镜像 ． 260
13．1．1 Dockerfile 常用指令 261
13．1．2 使用Dockerfile 构建镜像 ． 266
13．2 使用Docker Registry 管理Docker 镜像 268
13．2．1 使用Docker Hub 管理镜像 268
13．2．2 使用私有仓库管理镜像 270
13．3 使用Maven 插件构建Docker 镜像 271
13．3．1 快速入门272
13．3．2 插件读取Dockerfile 进行构建 273
13．3．3 将插件绑定在某个phase 执行 274
13．3．4 推送镜像 275
13．4 常见问题与总结277


14 使用Docker Compose 编排微服务 278
14．1 Docker Compose 简介 ． 278
14．2 安装Docker Compose ． 279
14．2．1 安装Compose ． 279
14．2．2 安装Compose 命令补全工具 ． 279
14．3 Docker Compose 快速入门 280
14．3．1 基本步骤 280
14．3．2 入门示例 280
14．3．3 工程、服务、容器 281
14．4 docker-compose．yml 常用命令281
14．5 docker-compose 常用命令 285
14．6 Docker Compose 网络设置 286
14．6．1 基本概念 286
14．6．2 更新容器 287
14．6．3 links 287
14．6．4 指定自定义网络 288
14．6．5 配置默认网络 ． 289
14．6．6 使用已存在的网络 289
14．7 综合实战：使用Docker Comose 编排Spring Cloud 微服务 289
14．7．1 编排Spring Cloud 微服务 ． 289
14．7．2 编排高可用的Eureka Server 293
14．7．3 编排高可用Spring Cloud 微服务集群及动态伸缩 295
14．8 常见问题与总结 297


后记 298
附录A：本书配套代码 299
附录B：Spring Cloud YES――快速开发脚手架 300
附录C：使用Docker 快速安装本书中的组件 301

1 微服务架构与 Spring Cloud 2

1.1 微服务概念的由来 2

1.2 微服务的定义 3

1.3 微服务架构与整体式架构的区别 5

1.4 微服务架构与SOA 的比较 8

1.5 为什么要使用微服务架构 9

1.6 为实施微服务架构做好准备 10

1.6.1 思想观念的转变 10

1.6.2 团队管理方式的改变 11

1.6.3 自动化基础设施的建设 11

1.7 为什么要使用Spring Cloud 12

1.8 Spring Cloud 组件介绍 13

1.9 Spring Cloud 的版本说明 15

1.10 小结 17



2 微服务架构最佳设计 18

2.1 合理划分微服务 19

2.2 微服务治理 19?

2.3 Rest API 微服务设计 21

2.3.1 使用数据库集群 22

2.3.2 读写分离设计 22

2.3.3 使用缓存 22

2.3.4 保证Rest API 微服务的独立性 23

2.4 Web UI 微服务设计 23

2.4.1 使用FeignClient 实现负载均衡调用 23

2.4.2 使用Hystrix 实现容错设计 23

2.4.3 使用非阻塞的异步编程技术实现高并发调用 24

2.4.4 使用分布式文件系统 24

2.5 微服务之间调用规则设计 24

2.6 数据最终一致性设计 25

2.7 分布式集群架构设计 26

2.8 微服务运行环境安全设计 27

2.9 小结 27



3 电商平台微服务设计实例 29

3.1 电商平台总体设计 29

3.1.1 总体业务流程设计 29

3.1.2 总体业务功能设计 31

3.2 电商平台业务模型设计 32

3.2.1 移动商城业务模型 32

3.2.2 商家管理后台业务模型 33

3.2.3 平台管理后台业务模型 33

3.3 创建Rest API 微服务 34

3.4 创建Web UI 微服务 36

3.4.1 移动商城Web UI 微服务 36

3.4.2 商家管理后台的Web UI 微服务 37

3.4.3 平台管理后台Web UI 微服务 37

3.5 电商平台微服务体系结构 38

3.6 小结 39



第二部分 开发篇

4 开发工具选用及 Spring Boot 基础 41

4.1 开发工具选择 42

4.2 开发环境配置 42

4.3 创建Spring Boot 工程 43

4.4 使用JPA 47

4.4.1 数据源配置 48

4.4.2 JPA 配置 48

4.4.3 数据实体设计 49

4.4.4 存储库接口设计 49

4.4.5 单元测试 50

4.5 使用Thymeleaf 51

4.5.1 控制器设计 51

4.5.2 视图设计 52

4.6 运行与部署 52

4.7 小结 54



5 电商平台微服务工程设计 55

5.1 微服务工程结构 55

5.2 电商平台微服务工程组建 57

5.3 数据库选型 57

5.4 微服务工程创建步骤 58

5.5 项目基本配置 60

5.6 创建模块 64

5.7 小结 66



6 微服务治理基础服务开发 67

6.1 注册管理中心 68

6.1.1 创建注册管理中心 68

6.1.2 运行注册管理中心 70

6.1.3 微服务怎样使用注册管理中心 70

6.1.4 构建高可用的注册管理中心 72

6.2 配置管理中心 73

6.2.1 创建配置管理中心 73

6.2.2 微服务如何使用配置管理中心 76

6.2.3 在线更新配置信息 77

6.3 微服务监控中心 78

6.3.1 使用断路器仪表盘实现监控 79

6.3.2 聚合服务监控管理中心 81

6.4 服务跟踪分析中心 86

6.4.1 创建服务跟踪分析中心 86

6.4.2 在微服务中启用服务跟踪功能 90

6.5 日志分析平台 93

6.5.1 创建日志分析平台 93

6.5.2 使用日志分析平台 93

6.6 小结 94



7 Rest API 微服务开发 96

7.1 领域业务开发 96

7.1.1 使用Druid 数据源 98

7.1.2 JPA 及其配置 100

7.1.3 数据实体建模 101

7.1.4 查询对象设计 104

7.1.5 实体持久化设计 106

7.1.6 持久化测试 107

7.1.7 领域服务开发 109

7.1.8 领域服务的单元测试 111

7.1.9 使用Redis 实现缓存设计 112

7.2 Rest API 应用开发 117

7.2.1 Rest API 应用配置 117

7.2.2 启动程序设计 119

7.2.3 接口开发 119

7.3 使用消息处理事件 123

7.3.1 消息生产者设计 124

7.3.2 消息消费者设计 125

7.3.3 使用消息测试 128

7.4 小结 129



8 Web UI 微服务开发 131

8.1 高并发接口调用分层设计 131

8.2 通过FeignClient 调用Rest API 132

8.3 使用Hystrix 断路器 134

8.4 使用非阻塞异步编程方法 136

8.4.1 CompletableFuture 介绍 137

8.4.2 性能比较测试 140

8.5 Web 应用开发 145

8.5.1 项目引用配置 145

8.5.2 应用程序配置 146

8.5.3 业务功能开发 148

8.6 开发环境的热部署设置 154

8.7 使用分布式文件系统 157

8.7.1 分布式文件系统客户端开发 157

8.7.2 商品图片上传设计 159

8.7.3 富文本编辑器上传文件设计 160

8.7.4 建立本地文件信息库 163

8.8 小结 166



9 电商平台移动商城开发 167

9.1 移动商城首页设计 168

9.2 使用负载均衡的导航设计 174

9.3 按分类查询设计 176

9.4 商品详情页设计 179

9.5 购买下单实现 181

9.6 用户登录与账户切换设计 184

9.6.1 用户登录设计 184

9.6.2 切换账号设计 186

9.7 订单查询设计 188

9.8 集成测试 191

9.9 小结 192



10 商家管理后台与 SSO 设计 193

10.1 商家权限管理体系设计及开发 194

10.1.1 商家权限体系建模 195

10.1.2 商家权限体系的持久化设计 199

10.1.3 商家权限体系的领域服务开发 201

10.2 商家管理微服务开发 204

10.2.1 商家领域服务层单元测试 204

10.2.2 商家服务的接口开发 208

10.3 SSO 设计 213

10.3.1 SSO 基本配置 213

10.3.2 在SSO 中使用商家的权限体系 214

10.3.3 用户登录设计 216

10.3.4 有关验证码的说明 218

10.3.5 SSO 的主页设计 220

10.3.6 OAuth2 服务端设计 222

10.4 SSO 客户端设计 224

10.4.1 客户端的项目管理配置 224

10.4.2 客户端的安全管理配置 225

10.4.3 权限验证实现原理 226

10.4.4 如何在应用中接入SSO 228

10.4.5 有关跨站请求伪造防御的相关设置 230

10.4.6 根据用户权限自动分配菜单 230

10.5 小结 232



11 平台管理后台开发 233

11.1 平台管理后台领域设计 233

11.1.1 领域实体建模 233

11.1.2 实体的行为设计 236

11.1.3 领域服务开发 236

11.1.4 领域服务单元测试 239

11.2 平台管理后台访问控制设计 240

11.2.1 使用平台管理的用户体系 240

11.2.2 权限管理设计 242

11.3 商家的注册设计 245

11.4 商家菜单体系管理开发 248

11.4.1 分类菜单管理开发 248

11.4.2 模块菜单管理开发 249

11.4.3 访问资源管理开发 252

11.5 商家角色管理开发 255

11.6 小结 257



第三部分 运维篇

12 服务器架构设计与 Docker 使用 259

12.1 服务器组建 259

12.2 安全的服务器架构设计 260

12.2.1 防火墙安装及配置 260

12.2.2 建立安全的局域网环境 264

12.3 服务器资源分配 266

12.4 CentOS 安装 269

12.4.1 IP 地址设置 270

12.4.2 安全设置 270

12.4.3 语言配置 270

12.4.4 时间同步配置 271

12.5 Docker 和docker-compose 安装 271

12.5.1 Docker 安装及使用 272

12.5.2 docker-compose 安装及使用 275

12.6 使用Docker 搭建微服务治理环境 279

12.6.1 服务器1 的部署配置 279

12.6.2 服务器2 的部署配置 281

12.7 使用Docker 部署日志分析平台 283

12.8 使用Docker 部署微服务应用 286

12.9 小结 286



13 数据库集群设计与高可用读写分离实施 288

13.1 MySQL 安装 289

13.2 主从同步设置 291

13.3 主主同步设置 294

13.4 数据库代理中间件选择 296

13.5 使用OneProxy 实现读写分离设计 297

13.5.1 OneProxy 安装 297

13.5.2 高可用读写分离配置 298

13.6 OneProxy 分库分区设计 302

13.6.1 按范围分库分表 303

13.6.2 按值分库分表 303

13.6.3 按哈希算法分库分表 304

13.7 双机热备设计 306

13.8 小结 307



14 分布式文件系统等基础设施安装与配置 308

14.1 高可用的分布式文件系统构建 308

14.1.1 FastDFS 安装 310

14.1.2 跟踪服务器配置 310

14.1.3 存储节点配置 311

14.1.4 上传文件测试 312

14.1.5 Nginx 安装及负载均衡配置 313

14.1.6 开机启动设置 317

14.2 GitLab 安装 322

14.3 Redis 安装 324

14.4 RabbitMQ 安装 326

14.5 小结 327



15 使用自动化构建工具 Jenkins 实现CI/CD 328

15.1 持续交付工作流程 330

15.2 Jenkins 安装 331

15.3 Jenkins 基本配置 333

15.4 Jenkins 自动部署实例 335

15.4.1 创建任务 336

15.4.2 任务配置 337

15.4.3 执行任务 340

15.5 小结 343

