

第1章　开始启程——你的第一行Android代码　　1

1.1.1　Android系统架构　　2

1.1.2　Android已发布的版本　　3

1.1.3　Android应用开发特色　　4

1.2　手把手带你搭建开发环境　　5

1.2.1　准备所需要的工具　　5

1.2.2　搭建开发环境　　5

1.3　创建你的第一个Android项目　　9

1.3.1　创建HelloWorld项目　　9

1.3.2　启动模拟器　　12

1.3.3　运行HelloWorld　　15

1.3.4　分析你的第一个Android程序　　16

1.3.5　详解项目中的资源　　22

1.3.6　详解build.gradle文件　　23

1.4　前行必备——掌握日志工具的使用　　26

1.4.1　使用Android的日志工具Log　　26

1.4.2　为什么使用Log而不使用System.out　　27

1.5　小结与点评　　29

第2章　先从看得到的入手——探究活动　　30

2.1　活动是什么　　30

2.2　活动的基本用法　　30

2.2.1　手动创建活动　　31

2.2.2　创建和加载布局　　32

2.2.3　在AndroidManifest文件中注册　　35

2.2.4　在活动中使用Toast　　37

2.2.5　在活动中使用Menu　　38

2.2.6　销毁一个活动　　40

2.3　使用Intent在活动之间穿梭　　41

2.3.1　使用显式Intent　　41

2.3.2　使用隐式Intent　　44

2.3.3　更多隐式Intent的用法　　46

2.3.4　向下一个活动传递数据　　50

2.3.5　返回数据给上一个活动　　51

2.4　活动的生命周期　　53

2.4.1　返回栈　　53

2.4.2　活动状态　　54

2.4.3　活动的生存期　　55

2.4.4　体验活动的生命周期　　56

2.4.5　活动被回收了怎么办　　62

2.5　活动的启动模式　　63

2.5.1　standard　　64

2.5.2　singleTop　　65

2.5.3　singleTask　　67

2.5.4　singleInstance　　68

2.6　活动的最佳实践　　71

2.6.1　知晓当前是在哪一个活动　　71

2.6.2　随时随地退出程序　　72

2.6.3　启动活动的最佳写法　　74

2.7　小结与点评　　75

第3章　软件也要拼脸蛋——UI开发的点点滴滴　　76

3.1　如何编写程序界面　　76

3.2　常用控件的使用方法　　77

3.2.1　TextView　　77

3.2.2　Button　　80

3.2.3　EditText　　82

3.2.4　ImageView　　86

3.2.5　ProgressBar　　88

3.2.6　AlertDialog　　91

3.2.7　ProgressDialog　　93

3.3　详解4种基本布局　　94

3.3.1　线性布局　　94

3.3.2　相对布局　　100

3.3.3　帧布局　　103

3.3.4　百分比布局　　105

3.4　系统控件不够用？创建自定义控件　　108

3.4.1　引入布局　　109

3.4.2　创建自定义控件　　111

3.5　最常用和最难用的控件——ListView　　113

3.5.1　ListView的简单用法　　114

3.5.2　定制ListView的界面　　115

3.5.3　提升ListView的运行效率　　119

3.5.4　ListView的点击事件　　120

3.6　更强大的滚动控件——RecyclerView　　122

3.6.1　RecyclerView的基本用法　　122

3.6.2　实现横向滚动和瀑布流布局　　125

3.6.3　RecyclerView的点击事件　　130

3.7　编写界面的最佳实践　　132

3.7.1　制作Nine-Patch图片　　132

3.7.2　编写精美的聊天界面　　135

3.8　小结与点评　　141

第4章　手机平板要兼顾——探究碎片　　142

4.1　碎片是什么　　142

4.2　碎片的使用方式　　144

4.2.1　碎片的简单用法　　144

4.2.2　动态添加碎片　　147

4.2.3　在碎片中模拟返回栈　　150

4.2.4　碎片和活动之间进行通信　　151

4.3　碎片的生命周期　　151

4.3.1　碎片的状态和回调　　151

4.3.2　体验碎片的生命周期　　153

4.4　动态加载布局的技巧　　156

4.4.1　使用限定符　　156

4.4.2　使用最小宽度限定符　　159

4.5　碎片的最佳实践——一个简易版的新闻应用　　160

4.6　小结与点评　　169

第5章　全局大喇叭——详解广播机制　　170

5.1　广播机制简介　　170

5.2　接收系统广播　　171

5.2.1　动态注册监听网络变化　　171

5.2.2　静态注册实现开机启动　　174

5.3　发送自定义广播　　177

5.3.1　发送标准广播　　177

5.3.2　发送有序广播　　179

5.4　使用本地广播　　183

5.5　广播的最佳实践——实现强制下线功能　　185

5.6　Git时间——初识版本控制工具　　192

5.6.1　安装Git　　192

5.6.2　创建代码仓库　　193

5.6.3　提交本地代码　　195

5.7　小结与点评　　195

第6章　数据存储全方案——详解持久化技术　　196

6.1　持久化技术简介　　196

6.2　文件存储　　197

6.2.1　将数据存储到文件中　　197

6.2.2　从文件中读取数据　　201

6.3　SharedPreferences存储　　203

6.3.1　将数据存储到SharedPreferences中　　203

6.3.2　从SharedPreferences中读取数据　　206

6.3.3　实现记住密码功能　　208

6.4　SQLite数据库存储　　211

6.4.1　创建数据库　　211

6.4.2　升级数据库　　216

6.4.3　添加数据　　219

6.4.4　更新数据　　222

6.4.5　删除数据　　224

6.4.6　查询数据　　225

6.4.7　使用SQL操作数据库　　228

6.5　使用LitePal操作数据库　　229

6.5.1　LitePal简介　　229

6.5.2　配置LitePal　　230

6.5.3　创建和升级数据库　　231

6.5.4　使用LitePal添加数据　　236

6.5.5　使用LitePal更新数据　　237

6.5.6　使用LitePal删除数据　　240

6.5.7　使用LitePal查询数据　　241

6.6　小结与点评　　243

第7章　跨程序共享数据——探究内容提供器　　244

7.1　内容提供器简介　　244

7.2　运行时权限　　245

7.2.1　Android权限机制详解　　245

7.2.2　在程序运行时申请权限　　249

7.3　访问其他程序中的数据　　254

7.3.1　ContentResolver的基本用法　　254

7.3.2　读取系统联系人　　256

7.4　创建自己的内容提供器　　260

7.4.1　创建内容提供器的步骤　　261

7.4.2　实现跨程序数据共享　　265

7.5　Git时间——版本控制工具进阶　　275

7.5.1　忽略文件　　275

7.5.2　查看修改内容　　276

7.5.3　撤销未提交的修改　　278

7.5.4　查看提交记录　　279

7.6　小结与点评　　280

第8章　丰富你的程序——运用手机多媒体　　281

8.1　将程序运行到手机上　　281

8.2　使用通知　　283

8.2.1　通知的基本用法　　283

8.2.2　通知的进阶技巧　　289

8.2.3　通知的高级功能　　291

8.3　调用摄像头和相册　　293

8.3.1　调用摄像头拍照　　294

8.3.2　从相册中选择照片　　298

8.4　播放多媒体文件　　303

8.4.1　播放音频　　303

8.4.2　播放视频　　307

8.5　小结与点评　　311

第9章　看看精彩的世界——使用网络技术　　312

9.1　WebView的用法　　312

9.2　使用HTTP协议访问网络　　314

9.2.1　使用HttpURLConnection　　315

9.2.2　使用OkHttp　　319

9.3　解析XML格式数据　　321

9.3.1　Pull解析方式　　324

9.3.2　SAX解析方式　　326

9.4　解析JSON格式数据　　329

9.4.1　使用JSONObject　　330

9.4.2　使用GSON　　331

9.5　网络编程的最佳实践　　334

9.6　小结与点评　　338

第10章　后台默默的劳动者——探究服务　　339

10.1　服务是什么　　339

10.2　Android多线程编程　　340

10.2.1　线程的基本用法　　340

10.2.2　在子线程中更新UI　　341

10.2.3　解析异步消息处理机制　　345

10.2.4　使用AsyncTask　　347

10.3　服务的基本用法　　349

10.3.1　定义一个服务　　349

10.3.2　启动和停止服务　　352

10.3.3　活动和服务进行通信　　355

10.4　服务的生命周期　　359

10.5　服务的更多技巧　　359

10.5.1　使用前台服务　　359

10.5.2　使用IntentService　　361

10.6　服务的最佳实践——完整版的下载示例　　365

10.7　小结与点评　　378

第11章　Android特色开发——基于位置的服务　　379

11.1　基于位置的服务简介　　379

11.2　申请API Key　　380

11.3　使用百度定位　　384

11.3.1　准备LBS SDK　　384

11.3.2　确定自己位置的经纬度　　386

11.3.3　选择定位模式　　391

11.3.4　看得懂的位置信息　　393

11.4　使用百度地图　　395

11.4.1　让地图显示出来　　395

11.4.2　移动到我的位置　　397

11.4.3　让“我”显示在地图上　　400

11.5　Git时间——版本控制工具的高级用法　　402

11.5.1　分支的用法　　403

11.5.2　与远程版本库协作　　404

11.6　小结与点评　　406

第12章　最佳的UI体验——MaterialDesign实战　　407

12.1　什么是Material Design　　407

12.2　Toolbar　　408

12.3　滑动菜单　　415

12.3.1　DrawerLayout　　415

12.3.2　NavigationView　　418

12.4　悬浮按钮和可交互提示　　423

12.4.1　FloatingActionButton　　424

12.4.2　Snackbar　　427

12.4.3　CoordinatorLayout　　428

12.5　卡片式布局　　430

12.5.1　CardView　　431

12.5.2　AppBarLayout　　437

12.6　下拉刷新　　440

12.7　可折叠式标题栏　　443

12.7.1　CollapsingToolbarLayout　　443

12.7.2　充分利用系统状态栏空间　　453

12.8　小结与点评　　456

第13章　继续进阶——你还应该掌握的高级技巧　　457

13.1　全局获取Context的技巧　　457

13.2　使用Intent传递对象　　461

13.2.1　Serializable方式　　461

13.2.2　Parcelable方式　　463

13.3　定制自己的日志工具　　464

13.4　调试Android程序　　466

13.5　创建定时任务　　469

13.5.1　Alarm机制　　469

13.5.2　Doze模式　　471

13.6　多窗口模式编程　　472

13.6.1　进入多窗口模式　　473

13.6.2　多窗口模式下的生命周期　　475

13.6.3　禁用多窗口模式　　479

13.7　Lambda表达式　　481

13.8　总结　　485

第14章　进入实战——开发酷欧天气　　486

14.1　功能需求及技术可行性分析　　486

14.2　Git时间——将代码托管到GitHub上　　489

14.3　创建数据库和表　　494

14.4　遍历全国省市县数据　　499

14.5　显示天气信息　　509

14.5.1　定义GSON实体类　　509

14.5.2　编写天气界面　　514

14.5.3　将天气显示到界面上　　520

14.5.4　获取必应每日一图　　526

14.6　手动更新天气和切换城市　　532

14.6.1　手动更新天气　　532

14.6.2　切换城市　　535

14.7　后台自动更新天气　　540

14.8　修改图标和名称　　542

14.9　你还可以做的事情　　543

第15章　最后一步——将应用发布到360应用商店　　545

15.1　生成正式签名的APK文件　　545

15.1.1　使用Android Studio生成　　546

15.1.2　使用Gradle生成　　548

15.1.3　生成多渠道APK文件　　551

15.2　申请360开发者账号　　554

15.3　发布应用程序　　556

15.4　嵌入广告进行盈利　　560

15.4.1　注册腾讯广告联盟账号　　560

15.4.2　新建媒体和广告位　　562

15.4.3　接入广告SDK　　564

15.4.4　重新发布应用程序　　569

15.5　结束语　　570

1.1 Android简介

1.1.1 Android起源

1.1.2 Android的优点

1.1.3 Android的系统架构

1.2 Android开发环境配置

1.3 第一个Android应用程序

第2章 Android应用程序

2.1 基本组件介绍

2.2 Activity生命周期

2.3 Android程序调试

第3章 Android常用基本控件

3.1 界面布局

3.1.1 线性布局

3.1.2 表格布局

3.1.3 相对布局

3.1.4 帧布局

3.1.5 绝对布局

3.2 界面控件

3.2.1 文本控件

3.2.2 按钮控件

3.2.3 图片控件

3.2.4 时钟控件

3.2.5 日期与时间选择控件

3.3 菜单

3.3.1 选项菜单和子菜单

3.3.2 上下文菜单

3.4 对话框

3.4.1 对话框简介

3.4.2 普通对话框

3.4.3 列表对话框

3.4.4 单选按钮和复选框对话框

3.4.5 日期及时间选择对话框

3.4.6 进度对话框

3.5 界面事件

3.5.1 onKeyDown方法简介

3.5.2 onKeyUp方法简介

3.5.3 onTouchEvent方法简介

3.5.4 onTrackBallEvent方法和onFocusChanged方法简介

3.5.5 OnClickListener接口简介

3.5.6 OnFocusChangeListener接口简介

3.5.7 OnKeyListener接口简介

3.5.8 OnTouchListener接口简介

3.5.9 OnCreateContextMenuListener接口简介

3.6 动画播放技术

3.6.1 帧动画

3.6.2 补间动画

第4章 Android常用高级控件

4.1 自动完成文本框

4.2 滚动视图和列表视图

4.2.1 滚动视图

4.2.2 列表视图

4.3 滑块与进度条

4.4 画廊控件与消息提示

4.4.1 画廊控件

4.4.2 Toast的使用

4.4.3 Notification的使用

4.5 下拉列表控件与选项卡

4.5.1 下拉列表控件

4.5.2 选项卡

第5章 Android游戏应用程序开发

5.1 自定义View的使用

5.2 SurfaceView的使用
5.3 游戏碰撞与检测技术
5.3.1 碰撞检测技术基础
5.3.2 游戏中实体对象之间的碰撞检测
5.3.3 游戏实体对象与环境之间的碰撞检测
5.4 扫雷游戏实例
第6章 Android消息与广播
6.1 Intent
6.1.1 启动Activity
6.1.2 获取Activity返回值
6.2 Intent过滤器
6.3 BroadcastReceive组件应用
第7章 Service后台服务
7.1 Service组件应用
7.2 进程内服务
7.2.1 服务管理
7.2.2 使用线程
7.2.3 服务绑定
7.3 Handler消息传递机制
7.4 单机版音乐盒实例
第8章 Android数据存储与访问
8.1 简单存储
8.2 文件存储
8.2.1 内部存储
8.2.2 外部存储
8.2.3 资源文件
8.3 SQLite数据库存储
8.3.1 SQLite数据库
8.3.2 手动建库
8.3.3 代码建库
8.3.4 数据操作
8.4 内容提供器——Content Providers
8.5 实训
第9章 Android位置服务与地图应用
9.1 位置服务
9.2 Google地图应用
9.2.1 申请地图密钥
9.2.2 使用Google地图
9.2.3 Google地图上贴上标记
9.3 利用Google API完成天气预报
9.3.1 信息来源
9.3.2 UI设计
9.3.3 解析XML
9.3.4 AndroidManifest.xml（限设置）
第10章 综合案例设计与开发
10.1 需求分析
10.2 策划与准备
10.2.1 图片资源的准备
10.2.2 数据库设计
10.3 程序设计
10.3.1 数据库适配器
10.3.2 主界面类PhotographActivity.java的实现
10.3.3 辅助类的设计


第1章 Android开发简介
1.1 Android介绍
1.2 Android系统构架
1.3 Android应用程序框架
1.4 本章小结
第2章 Android开发环境的搭建
2.1 获取Android源码
2.1.1 在Linux系统中获取Android源码
2.1.2 在Windows平台获取Android源码
2.1.3 编译源码
2.2 Android Studio应用开发
2.2.1 搭建Android Studio应用开发环境
2.2.2 创建第一个Android项目：HelloWorld
2.2.3 启动模拟器
2.2.4 运行到模拟器
2.2.5 下载到真机
2.2.6 详解项目中的资源
2.2.7 详解build.gradle文件
2.2.8 导入外部项目和Eclipse开发的Android项目
2.2.9 添加外部库
2.2.10 应用程序的调试
2.2.11 项目实战：下载Android的各个版本
2.3 本章小结
第3章 Android界面设计
3.1 用户界面基础
3.2 Android的Activity
3.2.1 Activity的介绍
3.2.2 Activity的生命周期
3.2.3 创建一个Activity
3.2.4 创建和加载布局
3.2.5 销毁一个Activity
3.2.6 使用Intent在Activity之间穿梭
3.2.7 Intent调用常见系统组件
3.3 常用控件的使用方法
3.3.1 TextView和EditText
3.3.2 Button、ToggleButton和ImageView
3.3.3 Spinner
3.3.4 ListView
3.3.5 AlertDialog
3.3.6 ProgressBar
3.4 Android布局
3.4.1 线性布局
3.4.2 相对布局
3.4.3 表格布局
3.4.4 百分比布局
3.4.5 嵌套布局实现计算器界面
3.5 样式和主题
3.5.1 定义样式
3.5.2 使用样式
3.5.3 主题
3.6 新控件RecyclerView、CardView和Palette的使用
3.6.1 新控件的使用
3.6.2 实现纵向滚动和横向滚动
3.6.3 RecyclerView的点击事件
3.7 Android新控件
3.8 综合项目实战：WebView实现监控界面
3.9 本章小结
第4章 创建Android应用程序
4.1 概述
4.2 事件处理机制
4.2.1 基于监听器的事件处理
4.2.2 基于回调的事件处理
4.2.3 事件响应的实现
4.2.4 项目实战：获取屏幕触点坐标
4.3 Android多线程
4.3.1 线程的基本用法
4.3.2 在子线程更新UI
4.3.3 Android线程池
4.3.4 Android四种线程池实例
4.4 Android广播组件
4.4.1 动态注册广播
4.4.2 静态注册广播
4.4.3 自定义本地广播
4.5 后台服务（Service）
4.5.1 定义一个服务
4.5.2 启动和停止服务
4.5.3 Service和Activity通信
4.6 Android实现多任务
4.6.1 多任务实现原理
4.6.2 用Handler实现多任务
4.6.3 项目实战：Handler实现模拟下载
4.6.4 AsyncTask实现多任务
4.6.5 项目实战：AsyncTask实现计时
4.7 本章小结
第5章 Android中数据的存储和访问
5.1 简介
5.2 使用共同偏好的存取数据
5.2.1 存取共享偏好
5.2.2 Preference框架
5.3 文件读取和保存
5.3.1 内部存储
5.3.2 扩展存储
5.4 存取结构化数据
5.4.1 SQLite简介
5.4.2 创建SQLite数据库
5.4.3 操作数据库
5.5 使用LitePal操作数据库
5.5.1 LitePal简介
5.5.2 配置LitePal
5.5.3 创建和升级数据库
5.5.4 SQLite命令调试
5.5.5 数据库操作
5.6 网络存储
5.7 本章小结
第6章 ContentProvider
6.1 查询记录
6.2 修改记录
6.3 添加记录
6.4 删除记录
6.5 创建Content Provider
6.6 本章小结
第二部分 物联网应用
第7章 移动智能终端访问网络摄像机
7.1 简介
7.2 网络摄像机
7.3 系统实现
7.3.1 介绍
7.3.2 网络摄像机参数设置
7.3.3 智能手机端视频监控软件
7.4 本章小结
第8章 物联网语音识别开发
8.1 语音识别技术概述
8.2 TTS语音识别技术
8.2.1 TTS基础
8.2.2 TTS开发流程
8.2.3 项目实战：TTS文字识别实例
8.3 Voice Recognition语言识别
8.3.1 Voice Recognition技术基础
8.3.2 项目实战：Voice Recognition语音识别
8.4 本章小结
第9章 在物联网中媒体动画的实现
9.1 Android多媒体系统架构基础
9.2 Graphics类详解
9.2.1 Graphics类基础
9.2.2 Android图形绘制类
9.2.3 绘制基本图形
9.3 二维动画
9.3.1 类Drawable
9.3.2 实现Tween动画效果
9.3.3 Tween动画的四种动画效果
9.3.4 实现Frame动画效果
9.4 项目实战：物联网环境控制动画
9.5 OpenGL ES详解
9.5.1 OpenGL ES基础
9.5.2 Android中的OpenGL ES
9.5.3 Open GL的基本操作
9.5.4 项目实战：利用OpenGL实现旋转的立方体
9.6 音频实现
9.6.1 音频接口类
9.6.2 AudioManager控制铃声
9.6.3 录音详解
9.6.4 项目实战：使用MediaPlay播放音乐
9.7 二维码的识别
9.7.1 二维码介绍
9.7.2 项目实战：Android实现二维码识别
9.8 本章小结
第10章 Android网络开发
10.1 Android Socket网络传输
10.1.1 什么是Socket
10.1.2 Socket的分类
10.1.3 Socket基本实现原理
10.1.4 Android实现Socket简单通信
10.1.5 Android客户端和PC服务器端通信
10.2 Android HTTP网络传输
10.2.1 HttpURLConnection接口
10.2.2 项目实战：HttpURLConnection获取信息
10.2.3 使用OkHttp
10.2.4 项目实战：OkHttp获取信息
10.3 Android应用程序的权限
10.3.1 Android权限机制详解
10.3.2 在程序运行时申请权限
10.4 解析XML格式数据
10.4.1 Pull解析方式
10.4.2 SAX解析方式
10.5 解析JSON格式数据
10.5.1 使用JSONObject
10.5.2 使用GSON
10.6 本章小结
第11章 Android无线通信
11.1 Android蓝牙传输数据
11.1.1 蓝牙介绍
11.1.2 蓝牙体系结构
11.1.3 蓝牙软件的实现
11.1.4 Android的蓝牙接口类
11.1.5 Android蓝牙开发步骤
11.1.6 项目实战：查找蓝牙设备
11.1.7 项目实战：Android手机蓝牙控制智能小车
11.2 Android系统中的NFC
11.2.1 近场通信技术基础
11.2.2 在Android系统中使用NFC
11.2.3 项目实战：在Android中使用NFC读取MifareClassic卡
11.3 本章小结
第12章 Android访问智能电表或智能插座
12.1 简介
12.1.1 RS-485接口智能插座
12.1.2 无线智能插座
12.1.3 智能电表
12.2 使用智能手机访问智能电表或智能插座
12.2.1 使用智能手机访问智能电表或智能插座的方案
12.2.2 使用智能手机访问Wi-Fi型智能插座或智能电表的方案
12.3 使用Android访问智能电表或智能插座
12.3.1 智能手机和Pad之间的数据通信
12.3.2 蓝牙通信实现
12.3.3 访问智能电表或智能插座的命令格式
12.4 本章小结
第三部分 综合实战
第13章 UI新体验——Material Design
13.1 什么是Material Design
13.2 Design Support库的使用
13.3 DrawerLayout和Navigation View
13.4 Material Design开源项目
13.5 本章小结
第14章 综合项目：Cool Weather
14.1 项目分析
14.2 创建数据库和表
14.3 遍历全国省、市、县数据
14.4 设计天气信息界面
14.5 省、市、县数据界面处理
14.6 处理返回的JSON数据
14.7 将天气信息显示到界面上
14.8 后台自动更新天气
第15章 Android应用程序托管和发布
15.1 Git版本控制工具
15.1.1 安装Git
15.1.2 创建代码仓库
15.1.3 提交本地代码
15.2 GitHub
15.2.1 在GitHub注册创建版本库
15.2.2 将代码托管到GitHub
15.3 将应用程序发布到360应用商店
15.3.1 生成正式签名的APK文件
15.3.2 申请360开发账号
15.3.3 发布应用程序
15.3.4 嵌入广告

　8种Android全埋点解决方案包括：
　　AppClick 全埋点方案1：代理 View.OnClickListener、
　　AppClick 全埋点方案2：代理 Window.Callback
　　AppClick 全埋点方案3：代理 View.AccessibilityDelegate
　　AppClick 全埋点方案4：透明层
　　AppClick 全埋点方案5：AspectJ
　　AppClick 全埋点方案6：ASM
　　AppClick 全埋点方案7：Javassist
　　AppClick 全埋点方案8：AST

第1章　全埋点概述1
1.1　Android View 类型3
1.2　View 绑定listener 方式7
第2章　$AppViewScreen全埋点
方案10
2.1　关键技术Application.Activity
LifecycleCallbacks10
2.2原理概述11
2.3　案例12
2.4　完善方案24
2.5　扩展采集能力30
第3章　$AppStart、$AppEnd
全埋点方案33
3.1　原理概述34
3.2　案例35
3.3　缺点46
第4章　$AppClick全埋点方案1：代理
View.OnClickListener47
4.1　关键技术47
4.2　原理概述48
4.3　案例49
4.4　引入DecorView62
4.5　引入ViewTreeObserver.
OnGlobalLayoutListener64
4.6　扩展采集能力67
4.7　缺点91
第5章　$AppClick 全埋点方案2：代理
Window.Callback92
5.1　关键技术92
5.2　原理概述93
5.3　案例93
5.4　扩展采集能力101
5.5　缺点111
第6章　$AppClick 全埋点方案3：代理
View.AccessibilityDelegate112
6.1　关键技术112
6.1.1　Accessibility112
6.1.2　View.AccessibilityDelegate113
6.2　原理概述114
6.3　案例114
6.4　扩展采集能力122
6.5　缺点129
第7章　$AppClick全埋点方案4：
透明层130
7.1　原理概述130
7.1.1　View onTouchEvent130
7.1.2　原理概述130
7.2　案例131
7.3　扩展采集能力139
7.4　缺点145
第8章　$AppClick全埋点方案5:
AspectJ146
8.1　关键技术146
8.1.1　AOP146
8.1.2　AspectJ148
8.1.3　AspectJ 注解148
8.1.4　切点表达式151
8.1.5　JoinPoint153
8.1.6　call与execution区别155
8.1.7　AspectJ 使用方法157
8.1.8　通过Gradle 配置使用 AspectJ157
8.1.9　自定义Gradle Plugin162
8.1.10　发布 Gradle 插件165
8.1.11　使用 Gradle Plugin167
8.1.12　Plugin Project168
8.2　原理概述171
8.3　案例171
8.4　完善方案193
8.5　扩展采集能力196
8.6　缺点202
第9章　$AppClick全埋点方案6：
ASM203
9.1　关键技术203
9.1.1　Gradle Transform203
9.1.2　Gradle Transform 实例207
9.1.3　ASM213
9.2　原理概述220
9.3　案例220
9.4　完善240
9.5　扩展采集能力241
9.6　缺点250
第10章　$AppClick全埋点方案7：
Javassist251
10.1　关键技术251
10.1.1　Javassist251
10.1.2　Javassist基础251
10.2　原理概述255
10.3　案例255
10.4　扩展采集能力272
第11章　$AppClick全埋点方案8：
AST280
11.1　关键技术280
11.1.1　APT280
11.1.2　Element280
11.1.3　APT实例282
11.1.4　javapoet293
11.1.5　AST295
11.2　原理概述295
11.3　案例295
11.4　完善方案306
11.5　扩展采集能力308
11.6　缺点317

第1章 探寻高效易用的反射API
1．1 反射的能力
1．1．1 得到Class对象
1．1．2 操作Field
1．1．3 调用Method
1．1．4 动态代理
1．2 反射封装库――JOOR
1．2．1 反射的流程
1．2．2 VirtualApp中的反射
1．2．3 一行代码建立对象
1．2．4 简化Field的相关操作
1．2．5 简化方法调用
1．2．6 封装动态代理
1．3 注意事项
1．3．1 反射的性能问题
1．3．2 反射的使用时机
1．3．3 如何降低反射的性能损耗
1．3．4 反射的危险性
1．3．5 反射和混淆的关系
1．4 总结
第2章 打造高扩展性的Log系统
2．1 基本概念
2．2 命令行操作Log
2．2．1 输出日志
2．2．2 过滤日志
2．3 Android Studio中的Log
2．3．1 设置模板
2．3．2 正则过滤
2．3．3 热部署Log
2．4 微信的Xlog
2．4．1 设计和开发目标
2．4．2 编译、引入和使用
2．4．3 对Log文件进行优化
2．5 美团的Logan
2．6 扩展Log的功能
2．6．1 TAG的自动化
2．6．2 文本内容的设计
2．6．3 开关的设计
2．7 封装Log库
2．7．1 Timber
2．7．2 LogDelegate
2．7．3 Logger
2．7．4 扩展Timber的功能
2．7．5 分发日志
2．8 实用日志
2．8．1 操作耗时日志
2．8．2 页面跳转日志
2．8．3 网络请求日志
2．9 总结
第3章 万变不离其宗的Intent
3．1 源码分析
3．1．1 静态变量的写法
3．1．2 Intent的深拷贝
3．1．3 makeMainActivity
3．1．4 Intent的Chooser
3．1．5 用URI代替Intent
3．1．6 存取值的底层实现
3．1．7 区分显式和隐式Intent
3．1．8 抛弃Bundle的传值策略
3．2 序列化方案
3．2．1 Serializable/Externalizable
3．2．2 Android中的Parcelable
3．2．3 Google的Protocol Buffer
3．2．4 Twitter的Serial
3．3 常见问题
3．3．1 父类的序列化
3．3．2 类型转换异常
3．3．3 重复启动的问题
3．3．4 传递大对象
3．4 简单的传值库――Parceler
3．4．1 降低Key的维护成本
3．4．2 自动维护Intent的Key
3．4．3 Jetpack中的自动化
3．4．4 自动保存状态
3．4．5 处理ClassCastException
3．4．6 IntentLauncher
3．4．7 统一存取的API
3．5 总结
第4章 SharedPrefrences的再封装
4．1 源码分析
4．1．1 缓存机制
4．1．2 SharedPreferencesImpl
4．1．3 值操作
4．1．4 提交操作
4．2 异常处理
4．2．1 name为null
4．2．2 管理好Key的取名
4．2．3 清空操作失效
4．2．4 磁盘写入异常
4．2．5 出现ANR
4．2．6 存序列化对象
4．2．7 多App和多进程访问异常
4．3 性能优化
4．3．1 避免储存大量数据
4．3．2 尽可能提前初始化
4．3．3 避免Key过长
4．3．4 多次操作，批量提交
4．3．5 缓存Editor对象
4．3．6 不存放HTML和JSON
4．3．7 拆分高频和低频操作
4．4 封装SharedPreferences
4．4．1 PreferenceDataStore
4．4．2 通过接口提高内聚
4．4．3 得到SharedPreferences
4．4．4 多用户存储设计
4．4．5 统一管理Key
4．4．6 自动判断返回值类型
4．4．7 决定是否使用Apply
4．4．8 存放序列化对象
4．4．9 支持数据格式转换器
4．5 思维扩展
4．5．1 偏好界面的实现方案
4．5．2 监听数据的改变
4．5．3 利用Tray实现多进程访问
4．5．4 React Native中的使用
4．6 总结
第5章 寻找Fragment的继任者
5．1 使用场景
5．1．1 日夜间模式
5．1．2 缓存界面数据
5．1．3 作为搜索页
5．1．4 作为Presenter
5．2 源码分析
5．2．1 Transaction简介
5．2．2 提交操作
5．2．3 commitAllowingStateLoss
5．2．4 Add操作的原理
5．2．5 Replace操作的本质
5．2．6 Fragment的可见性监听
5．2．7 ViewPager中的懒加载
5．3 常见问题
5．3．1 Activity为空
5．3．2 startActivityForResult
5．3．3 ViewPager的getItem
5．3．4 FragmentPagerAdapter
5．3．5 显示一个对话框
5．3．6 重叠显示的问题
5．3．7 Fragment的StateLoss
5．4 Fragment的替代品
5．4．1 Jetpack的Navigation
5．4．2 Square的Flow
5．4．3 简化版的Fragment
5．5 Shatter库
5．5．1 建立Shatter类
5．5．2 设计ShatterManager
5．5．3 分发生命周期
5．5．4 使用方式
5．6 总结
第6章 让alertDialog为我所用
6．1 Dialog
6．1．1 Dialog和Window
6．1．2 Show和Dismiss方法
6．2 alertDialog
6．2．1 alertController
6．2．2 alertDialog．Bulder
6．3 dialogFragment
6．3．1 Fragment和Dialog
6．3．2 Show和Dismiss方法
6．4 实际问题
6．4．1 无法弹出输入法
6．4．2 如何支持层叠弹窗
6．4．3 容易引起内存泄露
6．4．4 修改尺寸、背景和动画
6．4．5 点击后会自动关闭
6．4．6 在关闭或开启时出现崩溃
6．5 封装dialogFragment
6．5．1 用现成的alertParams
6．5．2 让Builder类支持继承
6．5．3 建立dialogFragment框架
6．6 easyDialog
6．6．1 基本用法
6．6．2 自定义一个Dialog
6．6．3 BottomSheetDialog
6．6．4 设置全局样式
6．6．5 支持动态样式
6．6．6 避免丢失监听器
6．7 可全局弹出的Dialog
6．8 总结
第7章 Gradle的使用技巧
7．1 全局配置
7．1．1 设定UTF-8
7．1．2 依赖Google仓库
7．1．3 支持Groovy
7．1．4 定义全局变量
7．1．5 配置Lint选项
7．2 操控Task
7．2．1 更改输出的APK的名字
7．2．2 更改AAR输出的位置
7．2．3 跳过AndroidTest
7．2．4 找出耗时的Task
7．2．5 抽离Task脚本
7．3 动态化
7．3．1 动态设置buildConfig
7．3．2 填充Manifest中的值
7．3．3 让buildType支持继承
7．3．4 让Flavor支持继承
7．3．5 内测版本用特定的Icon
7．3．6 不同渠道不同包名
7．3．7 自动填充版本信息
7．4 远程依赖
7．4．1 配置Maven仓库
7．4．2 依赖相关的API
7．4．3 组合依赖
7．4．4 依赖传递
7．4．5 动态版本号
7．4．6 强制版本号
7．4．7 exclude关键字
7．4．8 依赖管理
7．5 本地依赖
7．5．1 引用AAR
7．5．2 依赖Module/Jar
7．5．3 自建本地仓库
7．5．4 本地依赖React Native
7．5．5 重新打包第三方Jar
7．6 资源管理
7．7 总结
第8章 缩减APK的编译时间
8．1 分析项目现状
8．1．1 Gradle Profile
8．1．2 BuildTimeTracker
8．1．3 Dexcount GradlePlugin
8．1．4 经验小结
8．2 编译环境优化
8．2．1 升级硬件设备
8．2．2 升级软件
8．2．3 优化工程配置
8．2．4 配置Studio的可用内存
8．2．5 提升JVM的堆内存
8．2．6 开启并行编译
8．2．7 启用Demand模式
8．2．8 配置DexOptions
8．3 善用缓存
8．3．1 减少动态方法
8．3．2 硬编码BuildConfig和Res
8．3．3 拆分脚本
8．3．4 拆分代码
8．3．5 写死库的版本号
8．4 精简工程
8．4．1 差异化加载Plugin
8．4．2 使用WebP和SVG
8．4．3 精简语言和图片资源
8．4．4 善用no-op
8．4．5 Exclude无用库
8．4．6 删减Module
8．4．7 去掉MultiDex
8．4．8 删除无用的资源
8．5 综合技巧
8．5．1 构建开发时的Flavor
8．5．2 优化MultiDex
8．5．3 跳过无用的Task
8．5．4 关闭AAPT的图片优化
8．5．5 调试时关闭Crashlytics
8．5．6 谨慎使用AspectJ
8．6 多渠道打包工具
8．6．1 MultiChannelPackageTool
8．6．2 美团的Walle
8．6．3 腾讯的VasDolly
8．7 总结

第9章 APP终极瘦身实践
9．1 安装包的构成
9．1．1 Assets
9．1．2 Lib
9．1．3 Resources．arsc
9．1．4 META-INF
9．1．5 Res
9．1．6 Dex
9．2 优化Assets目录
9．2．1 删除无用的字体
9．2．2 减少IconFont的使用
9．2．3 动态下载资源
9．2．4 压缩资源文件
9．3 优化Lib目录
9．3．1 配置ABI Filters
9．3．2 根据CPU引入so
9．3．3 动态加载so
9．3．4 避免复制so
9．3．5 谨慎处理so
9．4 优化Resources．arsc
9．4．1 删除无用的映射
9．4．2 进行资源混淆
9．5 优化META-INF
9．5．1 MANIFEST．MF
9．5．2 CERT．SF
9．5．3 CERT．RSA
9．5．4 优化建议
9．6 优化Res目录
9．6．1 通过IDE删除无用资源
9．6．2 打包时剔除无用资源
9．6．3 删除无用的语言
9．6．4 控制Raw中的资源大小
9．6．5 减少Shape文件
9．6．6 减少Menu文件
9．6．7 减少Layout文件
9．6．8 动态下载图片
9．6．9 分目录放置图片
9．6．10 合理使用图片资源
9．6．11 丢弃特定的资源
9．6．12 开启严格模式
9．6．13 移除Lib库中的配置文件
9．7 优化图片资源
9．7．1 使用VectorDrawable
9．7．2 使用WebP
9．7．3 替换support库中的图
9．7．4 精简动画图片
9．7．5 复用相同的Icon
9．7．6 使用Tint
9．7．7 复用按压效果
9．7．8 通过旋转复用
9．8 优化Dex
9．8．1 分析Dex
9．8．2 利用Lint分析无用代码
9．8．3 删除R文件
9．8．4 启用ProGuard
9．8．5 使用拆分后的support库
9．8．6 尽量不用Mulitdex
9．8．7 使用更小库或合并现有库
9．8．8 根据环境依赖库
9．9 总结
第10章 编写针对性的TestCase
10．1 基础概念
10．1．1 什么代码应被测试
10．1．2 编写易于被测试的代码
10．1．3 测试框架的选型
10．2 逻辑测试
10．2．1 Junit测试
10．2．2 Mockito
10．2．3 Robolectric的使用
10．2．4 Espresso
10．3 集成测试网络层
10．3．1 编写网络层逻辑
10．3．2 建立测试对象
10．3．3 测试HTTP的异常情况
10．3．4 测试业务代码的正确性
10．3．5 用Interceptor模拟返回值
10．4 总结
第11章 Android Studio使用经验
11．1 调试篇
11．2 插件篇
11．2．1 统计相关
11．2．2 工具相关
11．3 总结
第12章 抓包工具Whistle实践
12．1 抓包工具
12．1．1 Charles
12．1．2 Fiddler
12．1．3 AnyProxy
12．1．4 Whistle
12．2 Whistle的安装和使用
12．2．1 安装和更新
12．2．2 查看Request和Response
12．2．3 代理技巧
12．2．4 过滤规则
12．3 Whistle的各项功能
12．3．1 替换域名
12．3．2 修改请求参数
12．3．3 修改返回值
12．3．4 模拟低网速的情形
12．3．5 查看WebView的Console
12．4 总结














1.1 Android系统架构 1

1.2 Android系统源码目录 4

1.2.1 整体结构 4

1.2.2 应用层部分 5

1.2.3 应用框架层部分 6

1.2.4 C/C++程序库部分 6

1.3 源码阅读 7

1.3.1 在线阅读 7

1.3.2 使用Source Insight 9

1.4 本章小结 12

第2章 Android系统启动 13

2.1 init进程启动过程 13

2.1.1 引入init进程 13

2.1.2 init进程的入口函数 14

2.1.3 解析init.rc 17

2.1.4 解析Service类型语句 19

2.1.5 init启动Zygote 20

2.1.6 属性服务 23

2.1.7 init进程启动总结 27

2.2 Zygote进程启动过程 27

2.2.1 Zygote概述 28

2.2.2 Zygote启动脚本 28

2.2.3 Zygote进程启动过程介绍 30

2.2.4 Zygote进程启动总结 38

2.3 SystemServer处理过程 39

2.3.1 Zygote处理SystemServer进程 39

2.3.2 解析SystemServer进程 44

2.3.3 SystemServer进程总结 48

2.4 Launcher启动过程 48

2.4.1 Launcher概述 48

2.4.2 Launcher启动过程介绍 49

2.4.3 Launcher中应用图标显示过程 54

2.5 Android系统启动流程 59

2.6 本章小结 60

第3章 应用程序进程启动过程 61

3.1 应用程序进程简介 61

3.2 应用程序进程启动过程介绍 62

3.2.1 AMS发送启动应用程序进程请求 62

3.2.2 Zygote接收请求并创建应用程序进程 68

3.3 Binder线程池启动过程 75

3.4 消息循环创建过程 78

3.5 本章小结 80

第4章 四大组件的工作过程 81

4.1 根Activity的启动过程 82

4.1.1 Launcher请求AMS过程 82

4.1.2 AMS到ApplicationThread的调用过程 85

4.1.3 ActivityThread启动Activity的过程 94

4.1.4 根Activity启动过程中涉及的进程 99

4.2 Service的启动过程 101

4.2.1 ContextImpl到AMS的调用过程 101

4.2.2 ActivityThread启动Service 103

4.3 Service的绑定过程 110

4.3.1 ContextImpl到AMS的调用过程 111

4.3.2 Service的绑定过程 112

4.4 广播的注册、发送和接收过程 122

4.4.1 广播的注册过程 122

4.4.2 广播的发送和接收过程 127

4.5 Content Provider的启动过程 137

4.5.1 query方法到AMS的调用过程 137

4.5.2 AMS启动Content Provider的过程 143

4.6 本章小结 148

第5章 理解上下文Context 149

5.1 Context的关联类 149

5.2 Application Context的创建过程 151

5.3 Application Context的获取过程 156

5.4 Activity的Context创建过程 156

5.5 Service的Context创建过程 161

5.6 本章小结 163

第6章 理解ActivityManagerService 164

6.1 AMS家族 164

6.1.1 Android 7.0的AMS家族 164

6.1.2 Android 8.0的AMS家族 170

6.2 AMS的启动过程 171

6.3 AMS与应用程序进程 174

6.4 AMS重要的数据结构 176

6.4.1 解析ActivityRecord 177

6.4.2 解析TaskRecord 177

6.4.3 解析ActivityStack 178

6.5 Activity栈管理 181

6.5.1 Activity任务栈模型 181

6.5.2 Launch Mode 182

6.5.3 Intent的FLAG 182

6.5.4 taskAffinity 185

6.6 本章小结 186

第7章 理解WindowManager 187

7.1 Window、WindowManager和WMS 187

7.2 WindowManager的关联类 188

7.3 Window的属性 193

7.3.1 Window的类型和显示次序 193

7.3.2 Window的标志 195

7.3.3 软键盘相关模式 196

7.4 Window的操作 196

7.4.1 系统窗口的添加过程 197

7.4.2 Activity的添加过程 202

7.4.3 Window的更新过程 203

7.5 本章小结 206

第8章 理解WindowManagerService 207

8.1 WMS的职责 207

8.2 WMS的创建过程 209

8.3 WMS的重要成员 217

8.4 Window的添加过程（WMS处理部分） 219

8.5 Window的删除过程 225

8.6 本章小结 230

第9章 JNI原理 231

9.1 系统源码中的JNI 232

9.2 MediaRecorder框架中的JNI 233

9.2.1 Java Framework层的MediaRecorder 233

9.2.2 JNI层的MediaRecorder 234

9.2.3 Native方法注册 235

9.3 数据类型的转换 239

9.3.1 基本数据类型的转换 240

9.3.2 引用数据类型的转换 240

9.4 方法签名 242

9.5 解析JNIEnv 244

9.5.1 jfieldID和jmethodID 245

9.5.2 使用jfieldID和jmethodID 247

9.6 引用类型 249

9.6.1 本地引用 249

9.6.2 全局引用 249

9.6.3 弱全局引用 250

9.7 本章小结 251

第10章 Java虚拟机 252

10.1 概述 252

10.1.1 Java虚拟机家族 253

10.1.2 Java虚拟机执行流程 253

10.2 Java虚拟机结构 254

10.2.1 Class文件格式 255

10.2.2 类的生命周期 256

10.2.3 类加载子系统 257

10.2.4 运行时数据区域 258

10.3 对象的创建 260

10.4 对象的堆内存布局 262

10.5 oop-klass模型 263

10.6 垃圾标记算法 266

10.6.1 Java中的引用 266

10.6.2 引用计数算法 267

10.6.3 根搜索算法 269

10.7 Java对象在虚拟机中的生命周期 270

10.8 垃圾收集算法 271

10.8.1 标记—清除算法 271

10.8.2 复制算法 272

10.8.3 标记—压缩算法 273

10.8.4 分代收集算法 274

10.9 本章小结 275

第11章 Dalvik和ART 276

11.1 Dalvik虚拟机 276

11.1.1 DVM与JVM的区别 276

11.1.2 DVM架构 278

11.1.3 DVM的运行时堆 280

11.1.4 DVM的GC日志 280

11.2 ART虚拟机 281

11.2.1 ART与DVM的区别 281

11.2.2 ART的运行时堆 282

11.2.3 ART的GC日志 283

11.3 DVM和ART的诞生 285

11.4 本章小结 288

第12章 理解ClassLoader 289

12.1 Java中的ClassLoader 289

12.1.1 ClassLoader的类型 289

12.1.2 ClassLoader的继承关系 291

12.1.3 双亲委托模式 292

12.1.4 自定义ClassLoader 295

12.2 Android中的ClassLoader 298

12.2.1 ClassLoader的类型 298

12.2.2 ClassLoader的继承关系 300

12.2.3 ClassLoader的加载过程 302

12.2.4 BootClassLoader的创建 306

12.2.5 PathClassLoader的创建 309

12.3 本章小结 311

第13章 热修复原理 312

13.1 热修复的产生 312

13.2 热修复框架的种类和对比 313

13.3 资源修复 314

13.3.1 Instant Run概述 314

13.3.2 Instant Run的资源修复 315

13.4 代码修复 318

13.4.1 类加载方案 319

13.4.2 底层替换方案 321

13.4.3 Instant Run方案 322

13.5 动态链接库的修复 323

13.5.1 System的load和loadLibarary方法 323

13.5.2 nativeLoad方法分析 327

13.6 本章小结 333

第14章 Hook技术 334

14.1 Hook技术概述 334

14.2 Hook技术分类 336

14.3 代理模式 336

14.3.1 代理模式简单实现 337

14.3.2 动态代理的简单实现 338

14.4 Hook startActivity方法 339

14.4.1 Hook Activity的startActivity方法 340

14.4.2 Hook Context的startActivity方法 343

14.4.3 Hook startActivity总结 344

14.5 本章小结 345

第15章 插件化原理 346

15.1 动态加载技术 346

15.2 插件化的产生 347

15.2.1 应用开发的痛点和瓶颈 347

15.2.2 插件化思想 348

15.2.3 插件化定义 350

15.3 插件化框架对比 351

15.4 Activity插件化 352

15.4.1 Activity的启动过程回顾 352

15.4.2 Hook IActivityManager方案实现 354

15.4.3 Hook Instrumentation方案实现 364

15.4.4 总结 367

15.5 Service插件化 368

15.5.1 插件化方面Service与Activity的不同 368

15.5.2 代理分发实现 370

15.6 ContentProvider插件化 376

15.6.1 ContentProvider的启动过程回顾 376

15.6.2 VirtualApk的实现 377

15.7 BroadcastReceiver的插件化 385

15.7.1 广播插件化思路 386

15.7.2 VirtualApk的实现 386

15.8 资源的插件化 387

15.8.1 系统资源加载 387

15.8.2 VirtualApk实现 389

15.9 so的插件化 390

15.10 本章小结 393

第16章 绘制优化 394

16.1 绘制性能分析 394

16.1.1 绘制原理 395

16.1.2 Profile GPU Rendering 396

16.1.3 Systrace 398

16.1.4 Traceview 404

16.2 布局优化 407

16.2.1 布局优化工具 407

16.2.2 布局优化方法 411

16.2.3 避免GPU过度绘制 419

16.3 本章小结 420

第17章 内存优化 421

17.1 避免可控的内存泄漏 421

17.1.1 什么是内存泄漏 421

17.1.2 内存泄漏的场景 422

17.2 Memory Monitor 428

17.2.1 使用Memory Monitor 429

17.2.2 大内存申请与GC 430

17.2.3 内存抖动 430

17.3 Allocation Tracker 430

17.3.1 使用Allocation Tracker 431

17.3.2 alloc文件分析 431

17.4 Heap Dump 434

17.4.1 使用Heap Dump 434

17.4.2 检测内存泄漏 436

17.5 内存分析工具MAT 438

17.5.1 生成hprof文件 438

17.5.2 MAT分析hprof文件 440

17.6 LeakCanary 448

17.6.1 使用LeakCanary 449

17.6.2 LeakCanary应用举例 449


第1章　音视频基础知识 1
1．1　视频编码 1
1．2　音频编码 2
1．3　多媒体播放组件（Android、iOS） 2
1．4　常见的多媒体框架及解决方案 3
1．5　相关知识点 4
1．5．1　帧率 4
1．5．2　分辨率 4
1．5．3　刷新率 4
1．5．4　编码格式 4
1．5．5　封装格式 4
1．5．6　码率 5
1．5．7　画质与码率 5
1．5．8　DTS与PTS 5
1．5．9　YUV与RGB 5
1．5．10　视频帧及音频帧 5
1．5．11　量化精度 6
1．5．12　采样率 6
1．5．13　声道 6
第2章　常用的系统播放器MediaPlayer 8
2．1　状态图及生命周期 8
2．2　从创建到setDataSource过程 12
2．2．1　从创建到setDisplay过程 12
2．2．2　创建过程 13
2．2．3　setDataSource过程 16
2．2．4　setDisplay过程 20
2．3　开始prepare后的流程 22
2．4　C++中MediaPlayer的C/S架构 31
第3章　管理调度的服务者MediaPlayerService 40
3．1　Client/Server通过IPC的通信流程图 40
3．2　相关联的类图 42
3．3　产生过程 43
3．4　添加服务的过程 48
3．5　通过BinderDriver和MediaPlayer通信的过程 50
3．6　创建播放器 55
3．7　建立StageFright层交互 58
第4章　StagefrightPlayer（AwesomePlayer） 60
4．1　AwesomePlayer构造过程 60
4．2　AwesomePlayer使用MediaExtractor进行数据解析的过程 66
4．3　AwesomePlayer解码过程 69
4．3．1　AwesomePlayer中的prepare过程 69
4．3．2　初始化音视频解码器过程 73
4．3．3　使用OMXCodec的解码过程 75
4．4　AwesomePlayer的渲染输出过程 80
4．4．1　用一张图回顾数据处理过程 80
4．4．2　视频渲染器构建过程 81
4．4．3　将音频数据放到Buffer的过程 87
4．4．4　AudioPlayer在AwesomePlayer中的运行过程 91
4．4．5　音视频同步 93
4．4．6　音视频输出 96
4．5　概要总结 97
第5章　流媒体播放的新生力量NuPlayer 98
5．1　NuPlayer整体结构 98
5．2　NuPlayer的构建过程 100
5．3　NuPlayer的数据解析模块 102
5．4　NuPlayer的解码模块 107
5．5　NuPlayer的渲染模块 109
第6章　OpenMAX（OMX）框架 118
6．1　Codec部分中的AwesomePlayer到OMX服务 118
6．1．1　OpenMAX与StageFright框架层级的关系 118
6．1．2　OMX的初始化流程 120
6．1．3　OMX中NodeInstance列表的管理 127
6．1．4　OMX中NodeInstance节点的操作 127
6．1．5　总结AwesomePlayer到OMX服务过程 130
6．2　Codec部分中的OMXCodec与OMX事件回调流程 131
6．2．1　OMXCodec与OMX callback事件的处理时序图 132
6．2．2　如何从OMX中分发事件到OMXCodec 133
6．2．3　缓冲区更新过程 135
6．2．4　消息回调 137
6．3　MediaCodec相关知识 139
6．3．1　MediaCodec的基本认识 139
6．3．2　从创建到Start过程 148
6．3．3　MediaCodec到OMX框架过程 154
6．3．4　MediaCodec硬解码 158
第7章　FFmpeg项目 161
7．1　FFmpeg简介 161
7．2　在Windows下编译FFmpeg 163
7．2．1　MSYS2 164
7．2．2　Yasm 164
7．2．3　开始编译FFmpeg-3．1．3 166
7．2．4　创建shell编译脚本 167
7．2．5　编译动态库．so 169
7．2．6　编译静态库．a 171
7．3　在Linux下编译FFmpeg 172
7．3．1　在/etc/profile．d下配置环境变量 172
7．3．2　开始编译FFmpeg-3．1．3 174
7．3．3　编写shell脚本 175
7．3．4　编译动态库．so 176
7．3．5　编译静态库．a 178
7．4　在Mac OS下编译FFmpeg 179
7．4．1　下载源码及配置环境变量 179
7．4．2　开始编译FFmpeg-3．1．3 183
7．4．3　编写shell脚本 183
7．4．4　编译动态库．so 185
7．4．5　编译静态库．a 187
7．5　FFmpeg常用命令 189
7．5．1　改变帧率、码率和文件大小 189
7．5．2　调整视频分辨率 190
7．5．3　裁剪/填充视频 191
7．5．4　翻转和旋转视频 193
7．5．5　模糊和锐化视频 196
7．5．6　画中画 197
7．5．7　在视频上添加文字 201
7．5．8　文件格式转换 205
7．5．9　时间操作 207
第8章　FFmpeg源码分析及实战 208
8．1　FFmpeg常用结构体分析 208
8．1．1　AVFormatConext 209
8．1．2　AVInputFormat 211
8．1．3　AVStream 212
8．1．4　AVCodecContext 215
8．1．5　AVPacket 216
8．1．6　AVCodec 218
8．1．7　AVFrame 219
8．1．8　AVIOContext 222
8．1．9　URLProtocol 223
8．1．10　URLContext 224
8．2　FFmpeg关键函数介绍 225
8．2．1　av_register_all函数 225
8．2．2　avformat_alloc_context函数 226
8．2．3　avio_open函数 226
8．2．4　avformat_open_input函数 229
8．2．5　avformat_find_stream_info函数 232
8．2．6　av_read_frame函数 246
8．2．7　av_write_frame函数 252
8．2．8　avcodec_decode_video2函数 256
8．3　FFmpeg案例（代码实现） 264
8．3．1　利用FFmpeg转换格式 264
8．3．2　在实时流中抓取图像 269
8．3．3　在视频中加入水印 277
8．3．4　FFmpeg音频解码 288
8．3．5　FFmpeg视频解码 300
8．4　FFPlay原理 308
8．4．1　注册所有容器格式和Codec 309
8．4．2　打开流文件 309
8．4．3　读取数据 311
8．4．4　保存数据 318
8．4．5　音视频同步 322
8．4．6　音视频输出 326
第9章　直播技术 328
9．1　直播原理 328
9．2　直播架构 328
9．3　直播过程 329
9．3．1　采集数据 329
9．3．2　渲染处理 332
9．3．3　编码数据 333
9．3．4　推流 335
9．3．5　CDN分发 338
9．3．6　拉流 341
9．3．7　播放流数据 341
9．3．8　直播推流完整案例 343
9．4　流媒体服务器搭建 377
9．5　FFmpeg推流到流媒体服务器的过程 384
9．6　直播优化那些事 387
9．6．1　卡顿优化 387
9．6．2　延时优化 388
9．6．3　数据代理优化 389
9．6．4　首屏秒开优化 390
9．6．5　弱网优化 391
9．6．6　运营商劫持优化 391
9．6．7　CDN节点优化 393
第10章　H．264编码及H．265编码 395
10．1　H．264编码框架 395
10．2　H．264编码原理 395
10．3　H．264码流分析 397
10．3．1　H．264编码格式 397
10．3．2　NAL Header 397
10．3．3　H．264的传输 399
10．3．4　H．264码流结构 399
10．3．5　H．264的Level和Profile说明 406
10．4　H．265编码框架 408
10．4．1　背景知识 408
10．4．2　H．265码流结构 409
第11章　视频格式分析 414
11．1　MP4格式分析 414
11．1．1　Box结构 415
11．1．2　MP4总体结构 416
11．1．3　movie（moov）box 416
11．1．4　media box 418
11．1．5　sample table（stbl）box 420
11．2　FLV格式分析 422
11．2．1　FLV文件结构 422
11．2．2　File Header（文件头） 422
11．2．3　Body 423
11．2．4　Tag 423
11．3　F4V格式分析 428
11．3．1　file type box 429
11．3．2　movie box 430
11．3．3　movie header box 430
11．3．4　track box 430
11．3．5　media box 431
11．3．6　media information box 433
11．3．7　sample table box 433
11．4　TS格式分析 437
11．4．1　TS格式介绍 437
11．4．2　TS流包含的内容 438
11．4．3　TS包头解析 438
11．4．4　TS包传输部分 440
11．4．5　节目专用信息PSI（Program Specific Information） 440
11．5　AVI格式分析 444
11．5．1　AVI整体结构 445
11．5．2　AVI信息块（＇hdrl＇ LIST块） 446
11．5．3　AVI数据块（＇movi＇ LIST块） 447
11．5．4　AVI索引块（＇idxl＇子块） 448
11．6　ASF格式分析 448
11．6．1　认识ASF 448
11．6．2　ASF文件整体结构 449

第1章　搭建Android程序分析环境
1.1　搭建Windows分析环境 1
1.1.1　安装JDK 1
1.1.2　安装Android SDK 2
1.1.3　安装Android NDK 5
1.1.4　Android Studio集成开发环境 6
1.1.5　创建Android模拟器 7
1.1.6　Cygwin 9
1.1.7　Bash on Ubuntu on Windows 11
1.2　搭建macOS分析环境 12
1.2.1　安装JDK 12
1.2.2　安装Android SDK 14
1.2.3　安装Android NDK 14
1.2.4　Android Studio集成开发环境 15
1.3　搭建Ubuntu分析环境 15
1.3.1　安装JDK 16
1.3.2　安装Android SDK 17
1.3.3　安装Android NDK 17
1.3.4　Android Studio集成开发环境 18
1.4　常用逆向分析工具 19
1.5　常用Linux Shell命令 19
1.6　搭建源码分析环境 20
1.6.1　在macOS中编译Android源码 20
1.6.2　在Ubuntu中编译Android源码 26
1.6.3　在Windows中编译Android源码 26
1.7　本章小结 27



第2章　如何分析Android程序
2.1　编写第一个Android程序 28
2.1.1　创建Android工程 28
2.1.2　编译生成APK文件 30
2.2　破解第一个Android程序 35
2.2.1　破解入手 35
2.2.2　反编译APK文件 35
2.2.3　分析APK文件 36
2.2.4　修改smali文件的代码 44
2.2.5　重新编译APK文件并签名 45
2.2.6　安装和测试 47
2.2.7　小结 48
2.3　本章小结 48



第3章　Dalvik可执行格式与字节码规范
3.1　Dalvik虚拟机 49
3.1.1　Dalvik虚拟机的特点 49
3.1.2　Dalvik虚拟机与Java虚拟机的区别 49
3.1.3　虚拟机的执行流程 54
3.1.4　虚拟机的执行方式 56
3.2　Dalvik语言基础 56
3.2.1　Dalvik指令格式 57
3.2.2　DEX反汇编工具 58
3.2.3　Dalvik寄存器 59
3.2.4　寄存器命名法 61
3.2.5　Dalvik字节码 62
3.3　Dalvik指令集 63
3.3.1　指令类型 64
3.3.2　空操作指令 64
3.3.3　数据操作指令 64
3.3.4　返回指令 65
3.3.5　数据定义指令 65
3.3.6　锁指令 66
3.3.7　实例操作指令 66
3.3.8　数组操作指令 66
3.3.9　异常指令 67
3.3.10　跳转指令 67
3.3.11　比较指令 68
3.3.12　字段操作指令 69
3.3.13　方法调用指令 69
3.3.14　数据转换指令 70
3.3.15　数据运算指令 70
3.4　Dalvik指令练习 71
3.4.1　编写smali文件 71
3.4.2　编译smali文件 73
3.4.3　测试运行 73
3.5　本章小结 73



第4章　常见Android文件格式
4.1　库文件 74
4.1.1　jar包 74
4.1.2　aar包 75
4.2　APK 78
4.2.1　APK文件结构 78
4.2.2　APK文件的生成流程 79
4.2.3　APK的安装流程 84
4.3　classes.dex 90
4.3.1　DEX文件结构 90
4.3.2　DEX文件的验证与优化过程 104
4.3.3　DEX文件的修改 108
4.3.4　MultiDex 111
4.4　AndroidManifest.xml 113
4.4.1　AndroidManifest.xml文件的格式 113
4.4.2　AXML文件格式 114
4.4.3　AXML文件的修改 121
4.5　resources.arsc 121
4.5.1　ARSC文件格式 122
4.5.2　ARSC文件的修改 128
4.6　META-INF目录 128
4.6.1　CERT.RSA 128
4.6.2　MANIFEST.MF 129
4.6.3　CERT.SF 130
4.7　ODEX 132
4.7.1　生成ODEX文件 132
4.7.2　ODEX文件格式 132
4.7.3　将ODEX文件转换成DEX文件 136
4.8　OAT 137
4.8.1　ART虚拟机 137
4.8.2　生成OAT文件 137
4.8.3　OAT文件格式 138
4.8.4　将OAT文件转换成DEX文件 141
4.9　本章小结 143



第5章　静态分析Android程序
5.1　静态分析简介 145
5.2　阅读smali代码 145
5.2.1　smali文件结构 145
5.2.2　循环语句 148
5.2.3　switch分支语句 153
5.2.4　try/catch语句 158
5.3　阅读Java代码 163
5.3.1　将DEX文件转换成jar包 163
5.3.2　jar分析工具 163
5.4　代码定位技巧 164
5.4.1　入口分析法 164
5.4.2　信息反馈法 165
5.4.3　特征函数法 165
5.5　使用JEB进行静态分析 165
5.5.1　安装JEB 165
5.5.2　JEB的静态分析功能 166
5.5.3　JEB的脚本化与插件 169
5.6　使用IDA Pro进行静态分析 170
5.6.1　IDA Pro对Android的支持 170
5.6.2　分析DEX文件 170
5.6.3　定位关键代码 172
5.7　使用Androguard进行静态分析 174
5.7.1　安装Androguard 175
5.7.2　Androguard的使用方法 175
5.7.3　使用androlyze.py进行分析 179
5.8　本章小结 182



第6章　动态分析Android程序
6.1　动态分析框架 183
6.2　动态分析技巧 189
6.2.1　代码注入法 189
6.2.2　栈跟踪法 192
6.2.3　Method Profiling 193
6.2.4　UI检查 196
6.3　使用JDB动态调试APK 198
6.4　使用JEB动态调试APK 200
6.5　使用IDA Pro动态调试APK 201
6.6　本章小结 203



第7章　ARM反汇编基础
7.1　Android与ARM处理器 204
7.1.1　ARM处理器架构概述 204
7.1.2　Android支持的处理器架构 205
7.2　Android ARM EABI 206
7.2.1　armeabi 206
7.2.2　armeabi-v7a 207
7.2.3　arm64-v8a 208
7.3　ARM原生程序的生成过程 208
7.3.1　预处理 210
7.3.2　编译 211
7.3.3　汇编 215
7.3.4　链接 215
7.4　ARM汇编语言 216
7.4.1　ARM汇编程序结构 216
7.4.2　汇编指令 221
7.4.3　寄存器 223
7.4.4　处理器寻址方式 224
7.4.5　子程序参数传递 227
7.5　ARM汇编指令集 230
7.5.1　ARM指令集分类 230
7.5.2　ARM指令编码 231
7.5.3　ARM指令格式解析 233
7.5.4　常见ARM指令 234
7.6　Thumb汇编指令集 240
7.6.1　16位Thumb指令编码 240
7.6.2　16位Thumb指令格式解析 241
7.6.3　32位Thumb指令编码 242
7.6.4　32位Thumb指令格式解析 244
7.7　AArch64汇编指令集 246
7.7.1　AArch64指令编码 246
7.7.2　AArch64指令格式解析 247
7.8　本章小结 250



第8章　Android原生程序开发与逆向分析
8.1　原生程序开发 251
8.1.1　原生程序工程 252
8.1.2　STL的选择 253
8.1.3　JNI 254
8.1.4　编译选项与配置项 256
8.2　原生程序移植 256
8.2.1　ADT项目的移植 257
8.2.2　UNIX开源项目的移植 258
8.2.3　CMake项目的移植 262
8.2.4　其他类型项目的移植 264
8.3　原生程序入口函数 264
8.3.1　原生程序入口函数分析 264
8.3.2　so入口函数分析 269
8.4　原生程序文件格式 271
8.4.1　原生程序的文件类型 271
8.4.2　AArch64 ELF文件格式 274
8.4.3　Program Header Table 278
8.4.4　Section Header Table 281
8.4.5　.dynamic节区 283
8.4.6　字符串表 285
8.4.7　符号表 286
8.4.8　got表与plt表 287
8.4.9　地址重定位表 291
8.5　原生程序逆向分析工具 295
8.5.1　NDK Toolchain 295
8.5.2　IDA Pro 297
8.5.3　Hopper 301
8.6　原生C程序逆向分析 302
8.6.1　编译原生C程序 303
8.6.2　for循环分支结构 305
8.6.3　while循环分支结构 309
8.6.4　if……else分支结构 312
8.6.5　switch循环分支结构 316
8.6.6　优化后的C程序 319
8.7　原生C++ 程序逆向分析 321
8.7.1　C++ STL的逆向分析 322
8.7.2　C++ 类的逆向分析 326
8.7.3　C++ 程序的RTTI 332
8.8　原生so动态库逆向分析 336
8.9　本章小结 337



第9章　Android原生程序动态调试
9.1　gdb调试器 338
9.1.1　ndk-gdb脚本 338
9.1.2　配置gdb调试器 339
9.1.3　gdb调试器的常用命令 340
9.1.4　使用gdb调试Android原生程序 342
9.1.5　gdb调试器的GUI前端 344
9.2　lldb调试器 346
9.2.1　配置lldb调试器 346
9.2.2　lldb调试器的常用命令 348
9.2.3　使用lldb调试Android原生程序 350
9.2.4　lldb调试器的GUI前端 353
9.3　使用IDA Pro调试Android原生程序 353
9.4　本章小结 358



第10章　Hook与注入
10.1　Hook的类型 359
10.1.1　Dalvik Hook 359
10.1.2　ART Hook 362
10.1.3　LD_PRELOAD Hook 364
10.1.4　GOT Hook 366
10.1.5　Inline Hook 367
10.2　Hook框架Xposed 368
10.3　Hook场景与应用 372
10.3.1　开启日志调试输出 372
10.3.2　APK插件 373
10.3.3　绕过SSL Pinning 373
10.4　动态注入 374
10.4.1　so动态库注入 374
10.4.2　DEX注入 376
10.5　注入框架Frida 377
10.5.1　Frida的安装与配置 377
10.5.2　执行注入与Hook 378
10.5.3　跟踪Native方法 384
10.6　本章小结 386



第11章　软件保护技术
11.1　软件保护技术简介 387
11.2　软件混淆技术 388
11.2.1　源码混淆 389
11.2.2　模板混淆 389
11.2.3　AST混淆 391
11.2.4　IR混淆 397
11.2.5　DEX混淆 397
11.2.6　DEX二次混淆 399
11.3　资源保护 401
11.4　完整性校验 403
11.5　反调试技术 404
11.5.1　调试器状态检测 404
11.5.2　调试器端口检测 404
11.5.3　进程状态检测 406
11.6　运行环境检测 407
11.6.1　模拟器检测 407
11.6.2　Root检测 409
11.6.3　Hook检测 409
11.7　本章小结 411



第12章　软件壳
12.1　Android软件壳 412
12.2　软件壳的特征与侦察 413
12.2.1　编译器指纹 413
12.2.2　软件壳的特征 416
12.2.3　查壳工具 418
12.3　动态加载型壳 418
12.3.1　缓存脱壳法 418
12.3.2　内存Dump脱壳法 419
12.3.3　动态调试脱壳法 420
12.3.4　Hook脱壳法 423
12.3.5　系统定制脱壳法 424
12.4　代码抽取型壳 425
12.4.1　内存重组脱壳法 425
12.4.2　Hook脱壳法 427
12.4.3　系统定制脱壳法 427
12.5　代码混淆壳 429
12.5.1　LLVM基础 430
12.5.2　编写Pass 434
12.5.3　Obfuscator-LLVM 440
12.5.4　代码混淆壳的脱壳 443