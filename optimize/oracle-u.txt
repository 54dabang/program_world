insert /*+ append parallel(a, 4) nologging */
into target_table a
select /*+ parallel(b, 4) */ *
from source_table b;
APPEND的作用是在表的高水位上分配空间,不去寻找 freelist 中的free block , 直接在table HWM 上面加入数据；
nologging 会大量减少日志；
parallel 并行。


 select
                /*+ parallel(p, 10) */


drop table CateringCustomer;
drop type EventNestedtable;
drop type Event_Type ;

Create or replace type Event_Type as object
(EventId varchar2(250),
Description varchar2 (250),
EventDate date,
Location varchar2(100));

Create or replace type EventNestedtable as table of Event_Type;

Create table CateringCustomer
(CustomerNo varchar2 (20),
Name varchar2(25),
Address varchar2 (100)，
Events eventNestedtable)
nested table Events store as EventNestedtable_tab;



insert into CateringCustomer values ('aaa','bbb','ccc', EventNestedtable(Event_Type('ddd','eee', sysdate, 'fff')) );


Oracle中的Hint可以用来调整SQL的执行计划，提高SQL执行效率。下面分类介绍Oracle数据库中常见的Hint。这里描述的是Oracle11gR2中的常见Hint，Oracle数据库中各个版本中的Hint都不尽相同，所以这里讲述的的Hint可能并不适用于Oracle早期的版本。
一、与优化器模式相关的Hint
1、ALL_ROWS
ALL_ROWS是针对整个目标SQL的Hint，它的含义是让优化器启用CBO，而且在得到目标SQL的执行计划时会选择那些吞吐量最佳的执行路径。这里的“吞吐量最佳”是指资源消耗量(即对I/O、CPU等硬件资源的消耗量)最小，也就是说在ALL_ROWS Hint生效的情况下，优化器会启用CBO而且会依据各个执行路径的资源消耗量来计算它们各自的成本。
ALL_ROWS Hint的格式如下：
/*+ ALL_ROWS */
使用范例：

1

2

3
select /*+ all_rows */ empno,ename,sal,job
  from emp
 where empno=7396;
从Oracle10g开始，ALL_ROWS就是默认的优化器模式，启用的就是CBO。

1

2

3

4

5
scott@TEST>show parameter optimizer_mode

NAME                     TYPE                 VALUE
------------------------------------ --------------------------------- ------------------------------
optimizer_mode               string                   ALL_ROWS
如果目标SQL中除了ALL_ROWS之外还使用了其他与执行路径、表连接相关的Hint，优化器会优先考虑ALL_ROWS。
2、FIRST_ROWS(n)
FIRST_ROWS(n)是针对整个目标SQL的Hint，它的含义是让优化器启用CBO模式，而且在得到目标SQL的执行计划时会选择那些能以最快的响应时间返回头n条记录的执行路径，也就是说在FIRST_ROWS(n) Hint生效的情况下，优化器会启用CBO，而且会依据返回头n条记录的响应时间来决定目标SQL的执行计划。
FIRST_ROWS(n)格式如下：
/*+ FIRST_ROWS(n) */
使用范例

1

2

3
select /*+ first_rows(10) */ empno,ename,sal,job
  from emp
 where deptno=30;
上述SQL中使用了/*+ first_rows(10) */，其含义是告诉优化器我们想以最短的响应时间返回满足条件"deptno=30"的前10条记录。
注意，FIRST_ROWS(n) Hint和优化器模式FIRST_ROWS_n不是一一对应的。优化器模式FIRST_ROWS_n中的n只能是1、10、100、1000。但FIRST_ROWS(n) Hint中的n还可以是其他值。

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20
scott@TEST>alter session set optimizer_mode=first_rows_9;
ERROR:
ORA-00096: invalid value FIRST_ROWS_9 for parameter optimizer_mode, must be from among first_rows_1000, first_rows_100, first_rows_10, first_rows_1, first_rows, all_rows, choose,rule

scott@TEST>set autotrace traceonly
scott@TEST>select /*+ first_rows(9) */ empno from emp;

14 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 179099197

---------------------------------------------------------------------------
| Id  | Operation    | Name   | Rows  | Bytes | Cost (%CPU)| Time    |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT |     |   9 |    36 |   1   (0)| 00:00:01 |
|   1 |  INDEX FULL SCAN | PK_EMP |  9 |    36 |   1   (0)| 00:00:01 |
---------------------------------------------------------------------------
如果在UPDATE、DELETE或者含如下内容的查询语句中使用了FIRST_ROWS(n) Hint，则该Hint会被忽略：
集合运算(如UNION,INTERSACT,MINUS,UNION ALL等)
GROUP BY
FOR UPDATE
聚合函数(比如SUM等)
DISTINCT
ORDER BY(对应的排序列上没有索引)
这里优化器会忽略FIRST_ROWS(n) Hint是因为对于上述类型的SQL而言，Oracle必须访问所有的行记录后才能返回满足条件的头n行记录，即在上述情况下，使用该Hint是没有意义的。
3、RULE
RULE是针对整个目标SQL的Hint，它表示对目标SQL启用RBO。
格式如下：
/*+ RULE */
使用范例：

1

2

3
select /*+ rule */ empno,ename,sal,job
  from emp
 where deptno=30;
RULE不能与除DRIVING_SITE以外的Hint联用，当RULE与除DRIVING_SITE以外的Hint联用时，其他Hint可能会失效；当RULE与DRIVING_SITE联用时，它自身可能会失效，所以RULE Hint最好是单独使用。
一般情况下，并不推荐使用RULE Hint。一来是因为Oracle早就不支持RBO了，二来启用RBO后优化器在执行目标SQL时可选择的执行路径将大大减少，很多执行路径RBO根本就不支持(比如哈希连接)，就也就意味着启用RBO后目标SQL跑出正确执行计划的概率将大大降低。
因为很多执行路径RBO根本就不支持，所以即使在目标SQL中使用了RULE Hint，如果出现了如下这些情况(包括但不限于)，RULE Hint依然会被Oracle忽略。
目标SQL除RULE之外还联合使用了其他Hint(如DRIVING_SITE)。
目标SQL使用了并行执行
目标SQL所涉及的对象有IOT
目标SQL所涉及的对象有分区表
......
二、与表访问相关的Hint
1、FULL
FULL是针对单个目标表的Hint，它的含义是让优化器对目标表执行全表扫描。
格式如下：
/*+ FULL(目标表) */
使用范例：

1

2

3
select /*+ full(emp) */ empno,ename,sal,job
  from emp
 where deptno=30;
上述SQL中Hint的含义是让优化器对目标表EMP执行全表扫描操作，而不考虑走表EMP上的任何索引(即使列EMPNO上有主键索引)。
2、ROIWD
ROIWD是针对单个目标表的Hint，它的含义是让优化器对目标表执行RWOID扫描。只有目标SQL中使用了含ROWID的where条件时ROWID Hint才有意义。
格式如下：
/*+ ROWID(目标表) */
使用范例：

1

2

3
select /*+ rowid(emp) */ empno,ename,sal,job
  from emp
 where rowid='AAAR3xAAEAAAACXAAA';
Oracle 11gR2中即使使用了ROWID Hint，Oracle还是会将读到的块缓存在Buffer Cache中。
三、与索引访问相关的Hint
1、INDEX
INDEX是针对单个目标表的Hint，它的含义是让优化器对目标表的的目标索引执行索引扫描操作。
INDEX Hint中的目标索引几乎可以是Oracle数据库中所有类型的索引(包括B树索引、位图索引、函数索引等)。
INDEX Hint的模式有四种：
格式1 /*+ INDEX(目标表 目标索引) */
格式2 /*+ INDEX(目标表 目标索引1 目标索引2 …… 目标索引n) */
格式3 /*+ INDEX(目标表 (目标索引1的索引列名) (目标索引2的索引列名) …… (目标索引n的索引列名)) */
格式4 /*+ INDEX(目标表) */
格式1表示仅指定了目标表上的一个目标索引，此时优化器只会考虑对这个目标索引执行索引扫描操作，而不会去考虑全表扫描或者对该目标表上的其他索引执行索引扫描操作。
格式2表示指定了目标表上的n个目标索引，此时优化器只会考虑对这n个目标索引执行索引扫描操作，而不会去考虑全表扫描或者对该目标表上的其他索引执行索引扫描操作。注意，优化器在考虑这n个目标索引时，可能是分别计算出单独扫描各个目标索引的成本后，再选择其中成本值最低的索引；也可能是先分别扫描目标索引中的两个或多个索引，然后再对扫描结果执行合并操作。当然，后面这种可能性的前提条件是优化器计算出来这样做的成本值是最低的。
格式三也是表是指定了目标表上的n个目标索引，只不过此时是用指定目标索引的索引列名来代替对应的目标索引名。如果目标索引是复合索引，则在用于指定该索引列名的括号内也可以指定该目标索引的多个索引列，各个索引列之间用空格分隔就可以了。
格式的表示指定了目标表上所有已存在的索引，此时优化器只会考虑对该目标表上所有已存在的索引执行索引扫描操作，而不会去考虑全表扫描操作。注意，这里优化器在考虑该目标表上所有已存在的索引时，可能是分别计算出单独扫描这些索引的成本后再选择其中成本值最低的索引；也可能是先分别扫描这些索引中的两个或多个索引，然后再对扫描结果执行合并操作。当然，后面这种可能性的前提条件是优化器计算出来这样做的成本值是最低的。
使用范例：

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15
select /*+ index(emp pk_emp) */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;

select /*+ index(emp pk_emp idx_emp_mgr idx_emp_dept) */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;

select /*+ index(emp (empno) (mgr) (deptno)) */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;

select /*+ index */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;
2、NO_INDEX
NO_INDEX是针对单个目标表的Hint，它是INDEX的反义Hint，其含义是让优化器不对目标表上的目标索引执行扫描操作。
INDEX Hint中的目标索引也几乎可以是Oracle数据库中所有类型的索引(包括B树索引、位图索引、函数索引等)。
格式有如下三种：
格式1 /*+ NO_INDEX(目标表 目标索引) */
格式2 /*+ NO_INDEX(目标表 目标索引1 目标索引2 …… 目标索引n) */
格式3 /*+ NO_INDEX(目标表) */
格式1表示仅指定了目标表上的一个目标索引，此时优化器只是不会考虑对这个目标索引执行索引扫描操作，但还是会考虑全表扫描或者对该目标表上的其他索引执行索引扫描操作。
格式2表示指定了目标表上的n个目标索引，此时优化器只是不会考虑对这n个目标索引执行索引扫描操作，但还是会考虑全表扫描或者对该目标表上的其他索引执行索引扫描操作。
格式3表示指定了目标表上的所有已存在的索引，即此时优化器不会考虑对该目标表上所有已存在的索引执行索引扫描操作，这相当于对目标表指定了全表扫描。
使用范例：

1

2

3

4

5

6

7

8

9

10

11
select /*+ no_index(emp pk_emp) */ empno,ename,sal,job
  from emp
where empno=7369 and mgr=7902 and deptno=20;

select /*+ no_index(emp pk_emp idx_emp_mgr idx_emp_dept) */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;

select /*+ no_index */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;
3、INDEX_DESC
INDEX_DESC是针对单个目标表的Hint，它的含义是让优化器对目标表上的目标索引执行索引降序扫描操作。如果目标索引是升序的，则INDEX_DESC Hint会使Oracle以降序的方式扫描该索引；如果目标索引是降序的，则INDEX_DESC Hint会使Oracle以升序的方式扫描该索引。
格式有三种：
格式1 /*+ INDEX_DESC(目标表 目标索引) */
格式2 /*+ INDEX_DESC(目标表 目标索引1 目标索引2 …… 目标索引n) */
格式3 /*+ INDEX_DESC(目标表) */
上述3种格式的含义和INDEX中对应格式的含义相同。
使用范例：

1

2

3

4

5

6

7

8

9

10

11
select /*+ index_desc(emp pk_emp) */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;

select /*+ index_desc(emp pk_emp idx_emp_mgr idx_emp_dept) */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;

select /*+ index_desc */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;
实例：

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33
scott@TEST>select /*+ index_desc(emp,pk_emp) */ empno from emp;

     EMPNO
----------
      7934
      7902
      7900
      7876
      7844
      7839
      7788
      7782
      7698
      7654
      7566
      7521
      7499
      7369

14 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 1838043032

-------------------------------------------------------------------------------------
| Id  | Operation          | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |     |    10 |  40 |   1   (0)| 00:00:01 |
|   1 |  INDEX FULL SCAN DESCENDING| PK_EMP |     10 |  40 |   1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------
......
4、INDEX_COMBINE
INDEX_COMBINE是针对单个目标表的Hint，它的含义是让优化器对目标表上的多个目标索引执行位图布尔运算。Oracle数据库里有一个映射函数(Mapping Function)，它可以实例B*Tree索引中的ROWID和对应位图索引中的位图之间的互相转换，所以INDEX_COMBINE Hint并不局限于位图索引，它的作用对象也可以是B*Tree索引。
格式有如下两种
格式1 /*+ INDEX_COMBINE(目标表 目标索引1 目标索引2 …… 目标索引n) */
格式2 /*+ INDEX_COMBINE(目标表) */
格式1表示指定了目标表上的n个目标索引，此时优化器会考虑对这n个目标索引中的两个或多个执行位图布尔运算。
格式2表示指定了目标表上所有已存在的索引，此时优化器会考虑对该表上已存在的所有索引中的两个或多个执行位图布尔运算。
使用范例：

1

2

3

4

5

6

7

8

9

10

11
select /*+ index_combine(emp pk_emp idx_emp_mgr) */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 ;

select /*+ index_combine(emp pk_emp idx_emp_mgr idx_emp_deptno) */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;

select /*+ index_combine(emp) */ empno,ename,sal,job
  from emp
 where empno=7369 and mgr=7902 and deptno=20;
下面看一个实例，在表EMP上创建两个索引

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36
scott@TEST>create index idx_emp_mgr on emp(mgr);

Index created.

scott@TEST>create index idx_emp_dept on emp(deptno);

Index created.

scott@TEST>select /*+ index_combine(emp pk_emp idx_emp_mgr idx_emp_deptno) */ empno,ename,sal,job
  2   from emp
  3   where empno=7369 and mgr=7902 and deptno=20;

     EMPNO ENAME               SAL JOB
---------- ------------------------------ ---------- ---------------------------
      7369 SMITH              800 CLERK


Execution Plan
----------------------------------------------------------
Plan hash value: 1816402415

-------------------------------------------------------------------------------------------------
| Id  | Operation            | Name  | Rows | Bytes | Cost (%CPU)| Time    |
-------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT       |     |     1 |    29 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID   | EMP        |     1 |    29 |     2   (0)| 00:00:01 |
|   2 |   BITMAP CONVERSION TO ROWIDS  |     |   |   |        |     |
|   3 |    BITMAP AND           |     |   |   |        |     |
|   4 |     BITMAP CONVERSION FROM ROWIDS|      |   |   |        |     |
|*  5 |      INDEX RANGE SCAN         | PK_EMP |   |   |     0   (0)| 00:00:01 |
|   6 |     BITMAP CONVERSION FROM ROWIDS|      |   |   |        |     |
|*  7 |      INDEX RANGE SCAN         | IDX_EMP_MGR    |   |   |     1   (0)| 00:00:01 |
|   8 |     BITMAP CONVERSION FROM ROWIDS|      |   |   |        |     |
|*  9 |      INDEX RANGE SCAN         | IDX_EMP_DEPT |    |   |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------
......
从上面的执行计划中可以看到关键字“BITMAP CONVERSION FROM ROWIDS”、“BITMAP AND”和“BITMAP CONVERSION TO ROWIDS”，这说明Oracle先分别对上述三个单键值的B*Tree索引IDX_EMP_MGR、IDX_EMP_DEPT和PK_EMP用映射函数将其中的ROWID转换成了位图，然后对转换后的位图执行了BITMAP AND(位图按位与)布尔运算，最后将布尔运算的结果再次用映射函数转换成了ROWID并回表得到最终的执行结果。能走出这样的执行计划显然是因为INDEX_COMBINE Hint生效了。
用映射函数将ROWID转换成了位图，然后再执行布尔运算，最后将布尔运算的结果再次用映射函数转换成了ROWID并回表得到最终的执行结果，这个过程在实际生产环境中的执行效率可能是有问题的，可以使用隐含参数_B_TREE_BITMAP_PLANS禁掉该过程中的ROWID到位图的转换：
alter session set "_b_tree_bitmap_plans"=false;

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25
scott@TEST>alter session set "_b_tree_bitmap_plans"=false;

Session altered.

scott@TEST>select /*+ index_combine(emp pk_emp idx_emp_mgr idx_emp_deptno) */ empno,ename,sal,job
  2    from emp
  3   where empno=7369 and mgr=7902 and deptno=20;

     EMPNO ENAME               SAL JOB
---------- ------------------------------ ---------- ---------------------------
      7369 SMITH              800 CLERK


Execution Plan
----------------------------------------------------------
Plan hash value: 2949544139

--------------------------------------------------------------------------------------
| Id  | Operation           | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |        |    1 |    29 |      1   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS BY INDEX ROWID| EMP    |       1 |    29 |      1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN     | PK_EMP |       1 |       |    0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------
......
从上面的执行计划中可以看出没有出现BITMAP相关的关键字，即INDEX_COMBINE Hint被Oracle忽略了。
5、INDEX_FFS
INDEX_FFS是针对单个目标表的Hint，它的含义是让优化器对目标表上的目标索引执行索引快速全扫描操作。注意，索引快速全扫描能成立的前提条件是SELECT语句中所有的查询列都存在于目标索引中，即通过扫描目标索引就可以得到所有的查询列而不用回表。
格式有如下三种：
格式1 /*+ INDEX_FFS(目标表 目标索引) */
格式2 /*+ INDEX_FFS(目标表 目标索引1 目标索引2 …… 目标索引n) */
格式3 /*+ INDEX_FFS(目标表) */
上述3种格式的含义和INDEX中对应格式的含义相同。
使用范例：

1

2

3

4

5

6

7

8

9

10

11
select /*+ index_ffs(emp pk_emp) */ empno
  from emp;

select /*+ index_ffs(emp idx_emp_1 idx_emp_2) */ empno
  from emp
 where mgr=7902 and deptno=20;
--create index idx_emp_1 on emp(mgr,deptno,1);
--create index idx_emp_2 on emp(mgr,deptno,2);

select /*+ index_ffs(emp) */ empno
  from emp;
看下面的实例：

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32
scott@TEST>select empno from emp;

14 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 179099197

---------------------------------------------------------------------------
| Id  | Operation    | Name   | Rows  | Bytes | Cost (%CPU)| Time    |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT |     |    10 |    40 | 1   (0)| 00:00:01 |
|   1 |  INDEX FULL SCAN | PK_EMP |    10 |    40 |    1   (0)| 00:00:01 |
---------------------------------------------------------------------------
......
scott@TEST>select /*+ index_ffs(emp) */empno from emp;

14 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 366039554

-------------------------------------------------------------------------------
| Id  | Operation        | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |         |    10 |    40 |     2  (0)| 00:00:01 |
|   1 |  INDEX FAST FULL SCAN| PK_EMP |    10 |    40 |     2 (0)| 00:00:01 |
-------------------------------------------------------------------------------
......
6、INDEX_JOIN
INDEX_JOIN是针对单个目标表的Hint，它的含义是让优化器对目标表上的多个目标索引执行INDEX JOIN操作。INDEX JOIN能成立的前提条件是SELECT语句中所有的查询列都存在于目标表上的多个目标索引中，即通过扫描这些索引就可以得到所有的查询列而不用回表。
格式如下：
格式1 /*+ INDEX_JOIN(目标表 目标索引1 目标索引2 …… 目标索引n) */
格式2 /*+ INDEX_JOIN */
上述两种格式的含义与INDEX_COMBINE Hint中对应格式的含义相同。
使用范例：

1

2

3

4

5

6

7
select /*+ index_join(emp pk_emp idx_emp_mgr) */ empno,mgr
  from emp
 where empno>7369 and mgr<7902;

select /*+ index_join(emp) */ empno,mgr
  from emp
 where empno>7369 and mgr<7902;
来看下面的实例：

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40
scott@TEST>select empno,mgr
  2    from emp
  3   where empno>7369 and mgr<7902;

12 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 2059184959

-------------------------------------------------------------------------------------------
| Id  | Operation           | Name   | Rows  | Bytes | Cost (%CPU)| Time   |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |         |    10 |    80 | 2   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS BY INDEX ROWID| EMP   |    10 |    80 | 2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN      | IDX_EMP_MGR |    11 |    |   1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
......
scott@TEST>select /*+ index_join(emp) */ empno,mgr
  2    from emp
  3   where empno>7369 and mgr<7902;

12 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 3030719951

---------------------------------------------------------------------------------------
| Id  | Operation      | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |             |    10 |    80 |     3  (34)| 00:00:01 |
|*  1 |  VIEW         | index$_join$_001 |    10 |    80 |     3  (34)| 00:00:01 |
|*  2 |   HASH JOIN     |           |       |       |       |       |
|*  3 |    INDEX RANGE SCAN| IDX_EMP_MGR      |    10 |    80 |     2  (50)| 00:00:01 |
|*  4 |    INDEX RANGE SCAN| PK_EMP         |    10 |    80 |     2  (50)| 00:00:01 |
---------------------------------------------------------------------------------------
......
7、AND_EQUAL
AND_EQUAL是针对单个目标表的Hint，它的含义是让优化器对目标表上的多个目标索引执行INDEX MERGE操作。INDEX MERGE能成立的前提条件是目标SQL的where条件里出现了多个针对不同单列的等值条件，并且这些列上都有单键值的索引。另外，在Oracle数据库里，能够做INDEX MERGE的索引数量的最大值是5。
格式如下：
/*+ AND_EQUAL(目标表 目标索引1 目标索引2 …… 目标索引n)*/
使用范例：

1

2

3
select /*+ and_equal(emp idx_emp_mgr idx_emp_dept) */ empno,mgr
  from emp
 where deptno=20 and mgr=7902;
看下面的实例：

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36
scott@TEST>select empno,mgr
  2    from emp
  3   where deptno=20 and mgr=7902;


Execution Plan
----------------------------------------------------------
Plan hash value: 2059184959

-------------------------------------------------------------------------------------------
| Id  | Operation           | Name   | Rows  | Bytes | Cost (%CPU)| Time   |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |         |   1 |    11 |   2   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS BY INDEX ROWID| EMP   |   1 |    11 |   2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN      | IDX_EMP_MGR |   2 |      |   1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
......
scott@TEST>select /*+ and_equal(emp idx_emp_mgr idx_emp_dept) */ empno,mgr
  2    from emp
  3   where deptno=20 and mgr=7902;


Execution Plan
----------------------------------------------------------
Plan hash value: 3295440569

--------------------------------------------------------------------------------------------
| Id  | Operation           | Name    | Rows  | Bytes | Cost (%CPU)| Time      |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |          |  1 |  11 |    3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS BY INDEX ROWID| EMP    |  1 |  11 |    3   (0)| 00:00:01 |
|   2 |   AND-EQUAL          |          |    |    |     |      |
|*  3 |    INDEX RANGE SCAN        | IDX_EMP_MGR  |  2 |     |  1   (0)| 00:00:01 |
|*  4 |    INDEX RANGE SCAN        | IDX_EMP_DEPT |   5 |     |  1   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
......
四、与表连接顺序相关的Hint
1、ORDERED
ORDERED是针对多个目标表的Hint，它的含义是让优化器对多个目标表执行表连接操作时，执照它们在目标SQL的where条件中出现的顺序从左到右依次进行连接。
格式如下：
/*+ ORDERED */
使用范例：

1

2

3

4

5

6
select /*+ ordered */ e.ename,j.job,e.sal,d.deptno
  from emp e,jobs j,dept d
 where e.empno=j.empno
   and e.deptno=d.deptno
   and d.loc='CHICAGO'
 order by e.ename;
实例：

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84
scott@TEST>select e.ename,j.job,e.sal,d.deptno
  2    from emp e,jobs j,dept d
  3   where e.empno=j.empno
  4     and e.deptno=d.deptno
  5     and d.loc='CHICAGO'
  6   order by e.ename;

6 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 4113290228

-----------------------------------------------------------------------------------------------
| Id  | Operation                      | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |              |     5 |   235 |     9  (23)| 00:00:01 |
|   1 |  SORT ORDER BY                 |              |     5 |   235 |     9  (23)| 00:00:01 |
|*  2 |   HASH JOIN                    |              |     5 |   235 |     8  (13)| 00:00:01 |
|   3 |    NESTED LOOPS                |              |       |       |            |          |
|   4 |     NESTED LOOPS               |              |     5 |   140 |     4   (0)| 00:00:01 |
|*  5 |      TABLE ACCESS FULL         | DEPT         |     1 |    11 |     3   (0)| 00:00:01 |
|*  6 |      INDEX RANGE SCAN          | IDX_EMP_DEPT |     5 |       |     0   (0)| 00:00:01 |
|   7 |     TABLE ACCESS BY INDEX ROWID| EMP          |     5 |    85 |     1   (0)| 00:00:01 |
|   8 |    TABLE ACCESS FULL           | JOBS         |    14 |   266 |     3   (0)| 00:00:01 |
-----------------------------------------------------------------------------------------------
......
scott@TEST>select /*+ ordered */ e.ename,j.job,e.sal,d.deptno
  2    from emp e,jobs j,dept d
  3   where e.empno=j.empno
  4     and e.deptno=d.deptno
  5     and d.loc='CHICAGO'
  6   order by e.ename;

6 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 3031293267

-----------------------------------------------------------------------------------------
| Id  | Operation                      | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |        |     5 |   235 |    11  (28)| 00:00:01 |
|   1 |  SORT ORDER BY                 |        |     5 |   235 |    11  (28)| 00:00:01 |
|*  2 |   HASH JOIN                    |        |     5 |   235 |    10  (20)| 00:00:01 |
|   3 |    MERGE JOIN                  |        |    14 |   504 |     6  (17)| 00:00:01 |
|   4 |     TABLE ACCESS BY INDEX ROWID| EMP    |    14 |   238 |     2   (0)| 00:00:01 |
|   5 |      INDEX FULL SCAN           | PK_EMP |    14 |       |     1   (0)| 00:00:01 |
|*  6 |     SORT JOIN                  |        |    14 |   266 |     4  (25)| 00:00:01 |
|   7 |      TABLE ACCESS FULL         | JOBS   |    14 |   266 |     3   (0)| 00:00:01 |
|*  8 |    TABLE ACCESS FULL           | DEPT   |     1 |    11 |     3   (0)| 00:00:01 |
-----------------------------------------------------------------------------------------
......
scott@TEST>select /*+ ordered */ e.ename,j.job,e.sal,d.deptno
  2    from emp e,dept d,jobs j
  3   where e.empno=j.empno
  4     and e.deptno=d.deptno
  5     and d.loc='CHICAGO'
  6   order by e.ename;

6 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 1175157407

-----------------------------------------------------------------------------------------------
| Id  | Operation                      | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |              |     5 |   235 |    11  (28)| 00:00:01 |
|   1 |  SORT ORDER BY                 |              |     5 |   235 |    11  (28)| 00:00:01 |
|*  2 |   HASH JOIN                    |              |     5 |   235 |    10  (20)| 00:00:01 |
|   3 |    MERGE JOIN                  |              |     5 |   140 |     6  (17)| 00:00:01 |
|   4 |     TABLE ACCESS BY INDEX ROWID| EMP          |    14 |   238 |     2   (0)| 00:00:01 |
|   5 |      INDEX FULL SCAN           | IDX_EMP_DEPT |    14 |       |     1   (0)| 00:00:01 |
|*  6 |     SORT JOIN                  |              |     1 |    11 |     4  (25)| 00:00:01 |
|*  7 |      TABLE ACCESS FULL         | DEPT         |     1 |    11 |     3   (0)| 00:00:01 |
|   8 |    TABLE ACCESS FULL           | JOBS         |    14 |   266 |     3   (0)| 00:00:01 |
-----------------------------------------------------------------------------------------------
......
从上面的执行计划可以看出不使用ordered Hint时表扫描的顺序是DEPT->EMP->JOBS，但是使用ordered Hint后，表扫描的顺序变为了EMP->JOBS->DEPT与目标SQL中的顺序一致了，在修改了目标SQL文本之后表的扫描顺序也相应地变为了EMP->DEPT->JOBS。
2、LEADING
LEADING是针对多个目标表的Hint，它的含义是让优化器将我们指定的多个表的连接结果作为目标SQL表连接过程中的驱动结果集，并且将LEADING Hint中从左至右出现的第一个目标表作为整个表连接过程中的首个驱动表。
LEADING比ORDERED要温和一些，因为它只是指定了首个驱动表和驱动结果集，没有像ORDERED那样完全指定了表连接的顺序，也就是说LEADING给了优化器更大的调整余地。
当LEADING Hint中指定的表并不能作为目标SQL的连接过程中的驱动表或者驱动结果集时，Oracle会忽略该Hint。
格式如下：
/*+ LEADING(目标表1 目标表2 …… 目标表n) */
使用范例：

1

2

3

4

5

6

7
select /*+ leading(t e) */ e.ename,j.job,e.sal,d.deptno
  from emp e,jobs j,dept d,emp_temp t
 where e.empno=j.empno
   and e.deptno=d.deptno
   and d.loc='CHICAGO'
   and e.ename=t.ename
 order by e.ename;
实例：

--不使用Hint
scott@TEST>select e.ename,j.job,e.sal,d.deptno
  2    from emp e,jobs j,dept d,emp_temp t
  3   where e.empno=j.empno
  4     and e.deptno=d.deptno
  5     and d.loc='CHICAGO'
  6     and e.ename=t.ename
  7   order by e.ename;

6 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 558051962

------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name         | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |              |     5 |   270 |    12  (17)| 00:00:01 |
|   1 |  SORT ORDER BY                  |              |     5 |   270 |    12  (17)| 00:00:01 |
|*  2 |   HASH JOIN                     |              |     5 |   270 |    11  (10)| 00:00:01 |
|*  3 |    HASH JOIN                    |              |     5 |   235 |     8  (13)| 00:00:01 |
|   4 |     NESTED LOOPS                |              |       |       |            |          |
|   5 |      NESTED LOOPS               |              |     5 |   140 |     4   (0)| 00:00:01 |
|*  6 |       TABLE ACCESS FULL         | DEPT         |     1 |    11 |     3   (0)| 00:00:01 |
|*  7 |       INDEX RANGE SCAN          | IDX_EMP_DEPT |     5 |       |     0   (0)| 00:00:01 |
|   8 |      TABLE ACCESS BY INDEX ROWID| EMP          |     5 |    85 |     1   (0)| 00:00:01 |
|   9 |     TABLE ACCESS FULL           | JOBS         |    14 |   266 |     3   (0)| 00:00:01 |
|  10 |    TABLE ACCESS FULL            | EMP_TEMP     |    14 |    98 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------------------------
......
--使用LEADING Hint
scott@TEST>select /*+ leading(t e) */ e.ename,j.job,e.sal,d.deptno
  2    from emp e,jobs j,dept d,emp_temp t
  3   where e.empno=j.empno
  4     and e.deptno=d.deptno
  5     and d.loc='CHICAGO'
  6     and e.ename=t.ename
  7   order by e.ename;

6 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 937897748

----------------------------------------------------------------------------------
| Id  | Operation             | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT      |          |     5 |   270 |    15  (20)| 00:00:01 |
|   1 |  SORT ORDER BY        |          |     5 |   270 |    15  (20)| 00:00:01 |
|*  2 |   HASH JOIN           |          |     5 |   270 |    14  (15)| 00:00:01 |
|*  3 |    HASH JOIN          |          |     5 |   175 |    10  (10)| 00:00:01 |
|*  4 |     HASH JOIN         |          |    14 |   336 |     7  (15)| 00:00:01 |
|   5 |      TABLE ACCESS FULL| EMP_TEMP |    14 |    98 |     3   (0)| 00:00:01 |
|   6 |      TABLE ACCESS FULL| EMP      |    14 |   238 |     3   (0)| 00:00:01 |
|*  7 |     TABLE ACCESS FULL | DEPT     |     1 |    11 |     3   (0)| 00:00:01 |
|   8 |    TABLE ACCESS FULL  | JOBS     |    14 |   266 |     3   (0)| 00:00:01 |
----------------------------------------------------------------------------------
......
--使用Ordered Hint
scott@TEST>select /*+ ordered */ e.ename,j.job,e.sal,d.deptno
  2    from emp e,jobs j,dept d,emp_temp t
  3   where e.empno=j.empno
  4     and e.deptno=d.deptno
  5     and d.loc='CHICAGO'
  6     and e.ename=t.ename
  7   order by e.ename;

6 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 2459794491

--------------------------------------------------------------------------------------------
| Id  | Operation                       | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |          |     5 |   270 |    14  (22)| 00:00:01 |
|   1 |  SORT ORDER BY                  |          |     5 |   270 |    14  (22)| 00:00:01 |
|*  2 |   HASH JOIN                     |          |     5 |   270 |    13  (16)| 00:00:01 |
|*  3 |    HASH JOIN                    |          |     5 |   235 |    10  (20)| 00:00:01 |
|   4 |     MERGE JOIN                  |          |    14 |   504 |     6  (17)| 00:00:01 |
|   5 |      TABLE ACCESS BY INDEX ROWID| EMP      |    14 |   238 |     2   (0)| 00:00:01 |
|   6 |       INDEX FULL SCAN           | PK_EMP   |    14 |       |     1   (0)| 00:00:01 |
|*  7 |      SORT JOIN                  |          |    14 |   266 |     4  (25)| 00:00:01 |
|   8 |       TABLE ACCESS FULL         | JOBS     |    14 |   266 |     3   (0)| 00:00:01 |
|*  9 |     TABLE ACCESS FULL           | DEPT     |     1 |    11 |     3   (0)| 00:00:01 |
|  10 |    TABLE ACCESS FULL            | EMP_TEMP |    14 |    98 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
......
从上面的执行计划可以看出不使用Hint时表扫描顺序是DEPT->EMP->JOBS->EMP_TEMP；使用LEADING Hint时表扫描顺序是EMP_TEMP->EMP->DEPT->JOBS，EMP_TEMP做首个驱动表和表EMP的连接结果做为驱动结果集，与Hint要求一致。；使用Ordered Hint时表扫描顺序是EMP->JOBS->DEPT->EMP_TEMP，与SQL中顺序一致。




基于oracle的sql优化

【博主】高瑞林

【博客地址】http://www.cnblogs.com/grl214

一．编写初衷描述
在应有系统开发初期，由于数据库数据较少，对于sql语句各种写法的编写体现不出sql的性能优劣，随着数据的不断增加，出现海量数据，劣质sql与优质sql在执行效率甚至存在百倍差距，可见sql优化的重要性

二．Sql语句性能优化
2.1 认识Oracle的执行过程


2.2 Oracle优化法则---漏斗法则


2.3 Oracle 执行计划
2.3.1 什么是Oracle执行计划
执行计划是一条查询语句在Oracle中执行过程或者访问路径的描述.

2.3.2 查看Oracle执行计划
1.执行计划常用的列字段解释

基数：返回的结果集行数

字节：执行该步骤后返回的字节数

耗费(cust),CPU耗费：Oracle估计的该步骤的执行成本，用于说明SQL执行的代价，理论上越小越好.

2.3.3 看懂Oracle执行计划


2.3.3.1执行顺序
根据缩进来判断，缩进最多的最先执行(缩进相同时，最上面的最先执行)

2.4 表的访问方式
TABLE ACCESS FULL(全表扫描)
TABLE ACCESS BY ROWID(通过rowid的表存取)
TABLE ACCESS BY INDEX SCAN(索引扫描)


2.4.1 ABLE ACCESS FULL(全表扫描)
Oracle会读取表中的所有行，并检查是否满足where语句中条件；

使用建议：数据量太大的表不建议全表扫描

2.4.2 TABLE ACCESS BY ROWID(通过ROWID的表存取)
ROWID的解释：oracle会自动加在表的每一行的最后一列伪列，表中并不会物理存储ROWID的值，一旦一行数据插入后，则其对应的ROWID在该行的生命周期内是唯一的，即使发生行迁移，该行的ROWID值也不变。

2.4.3 TABLE ACCESS BY INDEX SCAN(索引扫描)
在索引块中即存储每个索引的键值，也存储具有该键值所对的ROWID.

索引的扫描分两步：首先是找到索引所对的ROWID，其次通过ROWID读取改行数据

索引扫描又分五种：

INDEX UNIQUE SCAN（索引唯一扫描）
INDEX RANGE SCAN（索引范围扫描）
INDEX FULL SCAN（索引全扫描）
INDEX FAST FULL SCAN（索引快速扫描）
INDEX SKIP SCAN（索引跳跃扫描）
(a).INDEX UNIQUE SCAN（索引唯一扫描）：

针对唯一性索引（UNIQUE INDEX）的扫描，每次至多只返回一条记录,主要针对该字段为主键或者唯一；

(b). INDEX RANGE SCAN（索引范围扫描）

使用一个索引存取多行数据；

发生索引范围扫描的三种情况：

在唯一索引列上使用了范围操作符（如：>   <   <>   >=   <=   between）
在组合索引上，只使用部分列进行查询（查询时必须包含前导列，否则会走全表扫描）
对非唯一索引列上进行的任何查询
(c). INDEX FULL SCAN（索引全扫描）

进行全索引扫描时，查询出的数据都必须从索引中可以直接得到
(d). INDEX FAST FULL SCAN（索引快速扫描）

扫描索引中的所有的数据块，与 INDEX FULL SCAN 类似，但是一个显著的区别是它不对查询出的数据进行排序（即数据不是以排序顺序被返回）
(e). INDEX SKIP SCAN（索引跳跃扫描）：

Oracle 9i后提供，有时候复合索引的前导列（索引包含的第一列）没有在查询语句中出现，oralce也会使用该复合索引，这时候就使用的INDEX SKIP SCAN;

当Oracle发现前导列的唯一值个数很少时，会将每个唯一值都作为常规扫描的入口，在此基础上做一次查找，最后合并这些查询；

例如：

假设表emp有ename（雇员名称）、job（职位名）、sex（性别）三个字段，并且建立了如 create index idx_emp on emp (sex, ename, job) 的复合索引；

因为性别只有 '男' 和 '女' 两个值，所以为了提高索引的利用率，Oracle可将这个复合索引拆成 ('男', ename, job)，('女', ename, job) 这两个复合索引；

当查询 select * from emp where job = 'Programmer' 时，该查询发出后：

Oracle先进入sex为'男'的入口，这时候使用到了 ('男', ename, job) 这条复合索引，查找 job = 'Programmer' 的条目；

再进入sex为'女'的入口，这时候使用到了 ('女', ename, job) 这条复合索引，查找 job = 'Programmer' 的条目；

最后合并查询到的来自两个入口的结果集。

2.5 Sql语句的处理过程


1.在共享池中查找SQL语句

2.检查语法

3.检查语义和相关的权限

4.合并(MERGE)视图定义和子查询

5.确定执行计划

绑定(BIND)：

1.在语句中查找绑定变量

2.赋值(或重新赋值

执行(EXECUTE)：

1.应用执行计划

2.执行必要的I/O和排序操作

提取(FETCH)：

1.从查询结果中返回记录

2.必要时进行排序

3.使用ARRAY FETCH机制

共享游标：好处

1.减少解析

2.动态内存调整

3.提高内存使用率

2.5.1 Sql共享原理
Oracle将执行过程中的sql语句放在内存的共享池中，可以被所有的数据库用户共享到，当执行一条sql语句时，如果它和之前的sql执行语句完全相同时，oracle会快速获取被解析的语句以及最好的执行路劲。

这块系统属于全局的区域，但是oracle只对简单的表提供高速缓存，如果是多表的连接查询，数据库管理员必须在启动参数文件中为该区域设置合适的参数，增加共享的可能性。

2.5.2 Sql共享的条件(注意事项)
1.执行语句必须与共享池语句完全一样，包括(大小写，空格，换行等).

2.两条语句所指的对象必须完全相同。

3.两个SQL语句绑定变量的名字必须相同。

例子：字符级的比较

SELECT * FROM UR_USER_INFO

Select * from ur_user_info

例子：相同的绑定变量名

select pay_fee,pay_method from bal_payment_info where pay_sn= : pay_sn;

select pay_fee,pay_method from bal_payment_info where pay_sn= : pay_no;

绑定变量不一样，不能共享。

2.5.3共享sql区域


2.5.4 Sql解析与共享sql语句
当一个Oracle实例接收一条sql后

1、Create a Cursor 创建游标

2、Parse the Statement 分析语句

3、Describe Results of a Query 描述查询的结果集

4、Define Output of a Query 定义查询的输出数据

5、Bind Any Variables 绑定变量

6、Parallelize the Statement 并行执行语句

7、Run the Statement 运行语句

8、Fetch Rows of a Query 取查询出来的行

9、Close the Cursor 关闭游标

2.6 绑定变量
2.6.1 重编译问题
例如：

select  *from ur_user_info where contract_no = 32013484095139

下面这个语句每执行一次就需要在SHARE POOL 硬解析一

次，一百万用户就是一百万次，消耗CPU和内存，如果业务

量大，很可能导致宕库……

如果绑定变量，则只需要硬解析一次，重复调用即可

2.6.2 绑定变量解决重编译问题
例如：

select  *from ur_user_info where contract_no = 32013484095139

select  *from ur_user_info where contract_no = 12013481213149

使用绑定变量

select  *from ur_user_info where contract_no =：contract_no

2.6.3 绑定变量注意事项
a、不要使用数据库级的变量绑定参数cursor_sharing来强

制绑定，无论其值为 force 还是similar

b、有些带> < 的语句绑定变量后可能导致优化器无法正确

使用索引

2.5 SQL优化遵循的原则及注意事项
目标：
(1).SQL优化的一般性原则设计方面：

设计方面：
(1).尽量依赖oracle的优化器，并为其提供条件；

(2).合适的索引，索引的双重效应，列的选择性；

编码方面：
(1).利用索引，避免大表FULL TABLE SCAN；

(2).合理使用临时表；

(3).避免写过于复杂的sql，不一定非要一个sql解决问题；

(4).在不影响业务的前提下减小事务的粒度；

2.5.1 IS NULL 与IS NOT NULL
任何sql语句只要在where语句后面添加is null或者is not null，那么oracl优化器将不再使用索引。

2.5.2 使用带通配符（%）的语句
列举两个例子说明该问题：

查询ur_user_info表中phone_no带10的服务号码

例子1：Select *from ur_user_info where phone_no like ‘%10%’；

例子2：Select *from ur_user_info where phone_no like ‘10%’；

由于例1中通配符（%）在搜寻词首出现，所以oracle系统不使用phone_no的索引，通配符会降低查询的效率，但当通配符不再首出现，又能使用索引，如例2所示。



三．ORACLE语句优化规则


3.1 选择最有效的表名顺序
例如：TAB1 1000条记录， TAB2 1条记录

选择记录最少的作为基表

Select count(*) from tab1,tab2;

如果有3个或者3个以上的表则选择交叉表作为基表

3.2 where字句中的连接顺序
oracle的解析按照从上而下解析，因此表之间的连接必须写在where条件之前：

例如：

低效率：

select .. from

             emp e

             where sal > 50000 and job = 'manager'

             and 25 < (select count(*) from emp where mgr=e.empno);

高效率：

select .. from

emp e

where 25 < (select count(*) from emp where mgr=e.empno)

             and sal > 50000

             and job = 'manager';

3.3 通配符’*’的使用
Sql在执行带通配符的语句时，如果‘%’在首位，那么在字段上建立的主键或者索引将会失效！

应该避免类似语句的出现

Select name from user_info where name=’%A’;

3.4 使用truncate代替delete
当删除表时，使用delete执行操作，回滚端用来存放可恢复的信息，当没有提交事务的时候，执行回滚事务，数据会恢复到执行delete操作之前，而当用truncate是，回滚端则不会存放可恢复的信息，减少资源的调用。

3.5 用where字句替换HAVING字句
避免使用 HAVING 子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤. 这个处理需要排序,总计等操作. 如果能通过 WHERE 子句限制记录的数目,那就能减少这方面的开销.

3.6 减少对表的查询
低效：

Select tab_name from tables where tab_name = ( select

tab_name from tab_columns where version = 604) and db_ver=

( select db_ver from tab_columns where version = 604)

高效：

select tab_name from tables where (tab_name,db_ver) =

( select tab_name,db_ver) from tab_columns where version =604)

3.7 用in代替or
低效:

Select.. from location where loc_id = 10 or loc_id = 20 or loc_id = 30

高效:

Select..from location where loc_in in (10,20,30);

3.8 删除重复数据
最高效的删除重复记录的方法

Delete from ur_user_info a

     Where a.rowid>(select min(b.rowid)

              From ur_user_info b

         Where b. uid=a. uid);



3.9 避免使用耗费资源的操作
带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎执行耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序.

例如,一个UNION查询,其中每个查询都带有GROUP BY子句, GROUP BY会触发嵌入排序(NESTED SORT) ; 这样, 每个查询需要执行一次排序, 然后在执行UNION时, 又一个唯一排序(SORT UNIQUE)操作被执行而且它只能在前面的嵌入排序结束后才能开始执行. 嵌入的排序的深度会大大影响查询的效率.

3.10 自动选择索引
如果表中有两个以上（包括两个）索引，其中有一个唯一性索引，而其他是非唯一性．在这种情况下，ORACLE将使用唯一性索引而完全忽略非唯一性索引．

举例:

select ename from emp where empno = 2326  and deptno  = 20 ;这里，只有empno上的索引是唯一性的，所以empno索引将用来检索记录．

table access by rowid on emp index unique scan on emp_no_idx；

3.11 至少要包含组合索引的第一列
如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,优化器才会选择使用该索引. 当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引。

3.12 避免在索引列上使用函数
低效：

select ..

from dept

where sal * 12 > 25000;

高效:

select ..

from dept

where sal  > 25000/12;

3.13 避免出现索引列自动转换
当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换.

假设EMP_TYPE是一个字符类型的索引列.

select user_no,user_name,address

from user_files

where user_no = 109204421

这个语句被ORACLE转换为:

select user_no,user_name,address

from user_files

where to_number(user_no) = 109204421因为内部发生的类型转换, 这个索引将不会被用到!

3.14 避免出现索引列自动转换
如用 :

where a.order_no = b.order_no



不用 :

where to_number (substr(a.order_no, instr(b.order_no, '.') - 1)

= to_number (substr(a.order_no, instr(b.order_no, '.') - 1)

3.15 使用DECODE来减少处理时间
例如:

select count(*) sum(sal)

   from emp

  where dept_no = 0020

and ename like 'smith%';



 select count(*) sum(sal)

   from emp

  where dept_no = 0030

    and ename like 'smith%';



你可以用DECODE函数高效地得到相同结果

select count(decode(dept_no, 0020, 'x', null)) d0020_count,

       count(decode(dept_no, 0030, 'x', null)) d0030_count,

       sum(decode(dept_no, 0020, sal, null)) d0020_sal,

       sum(decode(dept_no, 0030, sal, null)) d0030_sal

  from emp

 where ename like 'smith%';



3.16 减少对表的查询
 低效

          select tab_name

          from tables

          where tab_name = ( select tab_name

                                from tab_columns

                                where version = 604)

          and db_ver= ( select db_ver

                           from tab_columns

                           where version = 604)

   高效

      select tab_name

          from tables

          where  (tab_name,db_ver)

        = ( select tab_name,db_ver)

                   from tab_columns

                   where version = 604)

3.17  Order by语句
(a).ORDER BY语句决定了Oracle如何将返回的查询结果排序。Order by语句对要排序的列没有什么特别的限制，也可以将函数加入列中（象联接或者附加等）。任何在Order by语句的非索引项或者有计算表达式都将降低查询速度。

(b). order by语句以找出非索引项或者表达式，它们会降低性能。解决这个问题的办法就是重写order by语句以使用索引，也可以为所使用的列建立另外一个索引，同时应绝对避免在order by子句中使用表达式。

3.18 用索引提高效率
索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡B-tree结构. 通常,通过索引查询数据比全表扫描要快. 当ORACLE找出执行查询和Update语句的最佳路径时, ORACLE优化器将使用索引. 同样在联结多个表时使用索引也可以提高效率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证。通常, 在大型表中使用索引特别有效. 当然,你也会发现, 在扫描小表时,使用索引同样能提高效率. 虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的。

3.19 避免在索引列上使用计算
WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．

低效：

     SELECT … FROM  DEPT  WHERE SAL * 12 > 25000;

高效:

     SELECT … FROM DEPT WHERE SAL > 25000/12;



3.20 用>= 替代 >
如果DEPTNO上有一个索引。

  高效:

   SELECT *

   FROM EMP

   WHERE DEPTNO >=4



   低效:

   SELECT *

   FROM EMP

   WHERE DEPTNO >3

3.21 通过使用>=、<=等，避免使用NOT命令
例子：

select * from employee where salary <> 3000;

对这个查询，可以改写为不使用NOT：

select * from employee where salary<3000 or salary>3000;

         虽然这两种查询的结果一样，但是第二种查询方案会比第一种查询方案更快些。第二种查询允许Oracle对salary列使用索引，而第一种查询则不能使用索引。

3.22 字符型字段的引号
比如有的表PHONE_NO字段是CHAR型,而且创建有索引，

但在WHERE条件中忘记了加引号，就不会用到索引。

WHERE PHONE_NO=‘13920202022’

WHERE PHONE_NO=13920202022



四．优化总结


a.创建表的时候。应尽量建立主键，尽量根据实际需要调整数据表的PCTFREE和PCTUSED参数；大数据表删除，用truncate table代替delete。

b. 合理使用索引，在OLTP应用中一张表的索引不要太多。数据重复量大的列不要建立二叉树索引，可以采用位图索引；组合索引的列顺序尽量与查询条件列顺序保持一致；对于数据操作频繁的表，索引需要定期重建，以减少失效的索引和碎片。

c.查询尽量用确定的列名，少用*号。

select count(key)from tab where key> 0性能优于select count(*)from tab；

d. 尽量少嵌套子查询，这种查询会消耗大量的CPU资源；对于有比较多or运算的查询，建议分成多个查询，用union all联结起来；多表查询的查询语句中，选择最有效率的表名顺序。Oracle解析器对表解析从右到左，所以记录少的表放在右边。

e.尽量多用commit语句提交事务，可以及时释放资源、解锁、释放日志空间、减少管理花费；在频繁的、性能要求比较高的数据操作中，尽量避免远程访问，如数据库链等，访问频繁的表可以常驻内存：alter table．．．cache；

f.在Oracle中动态执行SQL，尽量用execute方式，不用dbms_sql包。

参考文献
《Oracle SQL 语句优化》  2010 作者：Black_Snail

《基于Oracle的SQL优化典型案例分析》2013作者：dbsnake @dbsnake



好文要顶 关注我 收藏该文
高瑞林
关注 - 5
粉丝 - 23
+加关注
2 0
« 上一篇：使用递归和非递归算法实现二叉搜索树的遍历
» 下一篇：面向对象执行过程内存分析
posted @ 2017-10-29 17:28 高瑞林 阅读(12894) 评论(0) 编辑 收藏
刷新评论刷新页面返回顶部
注册用户登录后才能发表评论，请 登录 或 注册，访问网站首页。
【推荐】超50万C++/C#源码: 大型实时仿真组态图形源码
【推荐】Java工作两年，一天竟收到33份面试通知
【活动】“魔程”社区训练营--用实例教你快速学会Scratch和Python
【推荐】程序员问答平台，解决您开发中遇到的技术难题

相关博文：
· oracle性能优化
· OracleSQL优化
· oracle的优化
· SQL优化——ORACLE
· SQL SERVER 性能优化

最新新闻：
· 国内首家！腾讯云服务器数量超过100万台、带宽峰值突破100T
· 意大利国家级实验室遭起诉，当地环保组织称其对饮用水安全构成威胁
· 一线 | 科大讯飞追逐人工智能红利：加码消费者硬件业务
· 禁华为，硅谷坐立不安
· 微信支付回应尼泊尔封禁：一直通过技术手段严厉打击
» 更多新闻...
公告
昵称：高瑞林
园龄：2年11个月
粉丝：23
关注：5
+加关注
<	2019年5月	>
日	一	二	三	四	五	六
28	29	30	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	31	1
2	3	4	5	6	7	8
搜索




常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签
Jave(2)
随笔分类
Jave(1)
Scala
Spark
Spring
随笔档案
2017年10月 (2)
2017年4月 (1)
2017年3月 (3)
2017年1月 (1)
2016年10月 (1)
2016年9月 (2)
2016年8月 (1)
最新评论
1. Re:Spring 框架原理
写的很好!,感谢
--有_味
2. Re:Spring 框架原理
很棒！
--馒头2012
3. Re:Java构造器的深入理解
@侍琴壹生没毛病，老铁...
--高瑞林
4. Re:Java构造器的深入理解
我测出来了分享一下。具体的注释没写希望大家能看懂/** * 一个关于初始化代码块和一个非静态字段在构造器中执行的先后顺序的测试 * @author sunshine *测试结果：先执行的是非静态字段b......
--侍琴壹生
5. Re:Java构造器的深入理解
有个问题问一下，我们知道构造器 中省略了初始化代码块和对非静态字段的初始化。如果这两个同时存在，先执行哪个呢？我想到了，一会自己去写个程序运行一下。
--侍琴壹生
阅读排行榜
1. Spring 框架原理(32587)
2. Java构造器的深入理解(29167)
3. 基于oracle的sql优化(12894)
4. MyBatis 框架笔记(2695)
5. 深入理解Spring中bean的生命周期(1221)
评论排行榜
1. Java构造器的深入理解(3)
2. Spring 框架原理(2)
推荐排行榜
1. Spring 框架原理(2)
2. 基于oracle的sql优化(2)
3. 深入源码剖析String,StringBuilder,StringBuffer(1)
4. MyBatis 框架笔记(1)
5. Java构造器的深入理解(1)

-----------------------

explain plan for select * from emp;
 
select * from table(dbms_xplan.display);
 
 

 select count(*) from tab1,tab2
 
select count(*) from tab2,tab1

SELECT * FROM LOCATION L, CATEGORY C, EMP E

WHERE E.EMP_NO BETWEEN 1000 AND 2000

AND E.CAT_NO = C.CAT_NO

AND E.LOCN = L.LOCN;

 SELECT *   FROM EMP E   WHERE 25  50000  AND JOB = ‘MANAGER’;

--------


使用隐式的游标，将会执行两次操作。第一次检索记录，第二次检查TOO MANY ROWS 这个exception。而显式游标不执行第二次操作。

40. 分离表和索引

总是将你的表和索引建立在不同的表空间内（TABLESPACES）。
决不要将不属于ORACLE内部系统的对象存放到SYSTEM表空间里。
确保数据表空间和索引表空间置于不同的硬盘上。

a.创建表的时候。应尽量建立主键，尽量根据实际需要调整数据表的PCTFREE和PCTUSED参数；大数据表删除，用truncate table代替delete。

b. 合理使用索引，在OLTP应用中一张表的索引不要太多。数据重复量大的列不要建立二叉树索引，可以采用位图索引；组合索引的列顺序尽量与查询条件列顺序保持一致；对于数据操作频繁的表，索引需要定期重建，以减少失效的索引和碎片。

c.查询尽量用确定的列名，少用*号。

select count(key)from tab where key> 0性能优于select count(*)from tab；

d. 尽量少嵌套子查询，这种查询会消耗大量的CPU资源；对于有比较多or运算的查询，建议分成多个查询，用union all联结起来；多表查询的查询语句中，选择最有效率的表名顺序。Oracle解析器对表解析从右到左，所以记录少的表放在右边。

e.尽量多用commit语句提交事务，可以及时释放资源、解锁、释放日志空间、减少管理花费；在频繁的、性能要求比较高的数据操作中，尽量避免远程访问，如数据库链等，访问频繁的表可以常驻内存：alter table．．．cache；

f.在Oracle中动态执行SQL，尽量用execute方式，




优化器的基础知识
      1、优化器的模式

        Oracle中，优化器的模式是由参数OPTIMIZER_MODE的值来决定的。

        1、RULE：表示Oracle将使用RBO来解析目标SQL，此时SQL中涉及的各个对象的统计信息对于RBO没有任何作用。

        2、CHOOSE：Oracle 9i的默认值，表示在解析目标SQL时使用RBO还是CBO取决于SQL涉及的表对象是否有统计信息。

   3、FIRST_ROWS_n(n=1,10,100,1000)：此时CBO计算SQL的各条执行路径的成本值时的侧重点在于以最快的响应速度返回头n(n=1,10,100,1000)条记录。当选择这条记录的时候Oracle会修改执行步骤的成本值，修改为一个很小的值，从而达到不违背CBO原则的目的。

   4、FIRST_ROWS：Oracle 9i中就已经过时的参数，当一些特殊情况下的时候，会使用RBO中的一些内置的规则来选取执行计划不再考虑成本。

   5、ALL_ROWS：Oracle 10g及以后版本中OPTIMIZER_MODE的默认值，表示使用CBO解析目标SQL，此时CBO计算SQL的各条执行路径的成本值时的侧重点在于最佳的吞吐量(即最小的系统I/O和CPU资源的消耗量)。


  2、结果集

    指包含指定执行结果的集合。对RBO来说，对应的执行计划中没有对相关执行步骤对应的结果集的描述，虽然结果集的概念对RBO也是适用的。

  3、访问数据的方法

    访问数据的方法分为两种：直接访问表；先访问索引，再回表。

    直接访问表：

    1、全表扫描：指Oracle访问目标表里的数据时，会从该表所占用的第一个区(Extent)的第一个块(Block)开始扫描，一直扫描到该表的高水位线(HWM)，这段范围内所有的数据块都必须读到。

          2、ROEID扫描：指Oracle访问目标表里的数据时，直接通过数据所在的ROWID定位并访问这些数据。ROWID表示Oracle中的数据行记录所在的物理存储地址，也就是说ROWID实际上和Oracle中数据块里的行记录一一对应的。

ROWID扫描有两层含义：一种是根据用户在SQL语句中输入的ROWID的值直接访问对应的数据行记录；另外一种是先访问相关的索引，然后根据访问索引后得到的ROWID再回表访问对应的数据行记录。
对Oracle堆表而言，通过Oracle内置的ROWID伪列得到对应航记录所在的ROWID的值(注意：ROWID只是一个伪列，在实际的表块中并不存在该列)，然后还可以根据DBMS_ROWID包中的相关方法(dbms_rowid.rowid_relative_fno、dbms_rowid.rowid_block_number和dbms_rowid.rowid_row_number)将上述ROWID伪列的值翻译成对应数据行的实际物理存储地址。
   访问索引的方法：

    1、索引唯一性扫描：INDEX UNIQUE SCAN，仅适用于where条件中是等值查询的目标SQL。因为扫描的对象是唯一性索引，所以索引唯一性扫描的结果至多只会返回一条记录。

         2、索引范围扫描：INDEX RANGE SCAN，当扫描的对象是唯一性索引时，目标SQL的where条件一定是范围查询(谓词条件为BETWEEN、<、>等)；当扫描的对象是非唯一性索引时，对目标SQL的where条件没有限制(可以是等值查询，也可以是范围查询)。在同等条件下，当目标索引的索引行的数量大于1时，索引范围扫描所耗费的逻辑读至少会比相应的索引唯一性扫描多1。

         3、索引全扫描：指要扫描目标索引所有叶子块的所有索引行。但并不意味着需要扫描该索引的所有分支块。默认情况下，Oracle在做索引全扫描时只需要通过访问必要的分支块定位到位于该索引最左边的叶子块的第一行索引行，就可以利用该索引叶子块之间的双向指针链表，从左至右依次顺序扫描该索引所有叶子块的所有索引行了。按照索引键值顺序排序，即可达到排序的效果。避免真正的排序。默认情况下，索引全扫描的有序性就决定了所以全扫描不能并行执行，通常使用单块读。做索引全扫描的前提条件是目标索引至少有一个索引键值列的属性是NOT NULL。

        4、索引快速全扫描：INDEX FAST FULL SCAN，需要扫描目标索引所有叶子块的所有索引行。与索引全扫描的区别：

        （1）、索引快速全扫描只适用于CBO。
        （2）、索引快速全扫描可以使用多块读，也可以并行执行。
        （3）、索引快速全扫描结果不一定是有序的。因为索引快速全扫描时Oracle是根据索引行在磁盘上的物理存储顺序来扫描，而不是根据索引行的逻辑顺序来扫描的。所以扫描结果才不一定有序（对于单个索引叶子块中的索引行而言，其物理存储顺序和逻辑存储顺序一致，但对于物理存储位置相邻的索引叶子块而言，块与块之间索引行的物理存储顺序则不一定在逻辑上有序。
        5、索引跳跃式扫描：INDEX SKIP SCAN，它使那些在where条件中没有对目标索引的前导列指定查询条件但同时又对该索引的非前导列指定了查询条件的目标SQL依然可以用上该索引，这就像在扫描该索引时跳过了它的前导列。这是因为Oracle帮你对该索引的前导列的所有distinct值做了遍历。Oracle中的索引跳跃式扫描仅适用于那些目标索引前导列的distinct值数量较少，后续非前导列的可选择性又非常好的情形，因为索引跳跃式扫描的执行效率一定会随着目标索引前导列的distinct值数量的递增而递减。



（1）在使用 RBO 的情况下，我们可以通过调整相关对象在数据字典缓存中的缓存顺序，改变目标 sQL 中所涉及的各个对象在该 SQL 文本中出现的先后顺序，或者等价改写该 SQL 来调整其执行计划。

（2）成本是指 Oracle 根据相关对象的统计信息计算出来的一个值，它实际上代表了 Oracle 根据相关统计信息估算出来的目标 SQL 的对应执行路径的 I / O 、 CPU 和网络资源的消耗量。 

（3）cardinality 和 selectivity 的值会直接影响 cBO 对于相关执行步骤成本值的估算，进而影响 CBO 对于目标 SQL 执行计划的选择。

（4）可传递性的意义在于提供了更多的执行路径（ Access Path ）给 CBO 做选择，增加了走出更高效执行计划的可能性。

（5）优化器的模式对 CBO 计算成本（进而对 CBO 选择执行计划）有着决定性的影响。

（6）不是说全表扫描不好，事实上 Orade 在做全表扫描操作时会使用多块读，这在目标表的数据量不大时执行效率是非常高的，但全表扫描最大的问题就在于走全表扫描的目标 SQL 的执行时间会不稳定、不可控，这个执行时间一定会随着目标表数据量的递增而递增。

（7）通过 B 树索引访问表里行记录的效率并不会随着相关表的数据量的递增而显著降低，即通过走索引访问数据的时间是可控的、基本稳定的，这也是走索引和全表扫描的最大区别。

（8）Oracle 中索引全扫描的执行结果是有序的，并且是按照该索引的索引键位列来排序的，这意味右走索引全扫描能够既达到排序的效果，同时又能避免对该索引的索引键值列的真正排序操作。另外， Oracle 中能做索引全扫描的前提条件是目标索引至少有一个索引键值列的属性是 NOT NULL 。

（9）索引快速全扫描是可以并行执行的，它的执行结果不一定是有序的。

（10）Oracle 中的索引跳跃式扫描仅仅适用于那些目标索引的前导列的 distinct 值数量较少、后续非前导列的可选择性又非常好的情形，因为索引跳跃式扫描的执行效率 · 定会随着目标索引前导列的 distinct 值数量的递增而递减。

（11）关键字“ ( + ) ”出现在哪个表的连接列后面，就表明嘟个表会以 NULL 值来填充那些不满足连接条件并位于该表中的查询列，此时应该以关键字“ ( + ) ”对面的表来作为外连接的驱动表，这里的关键是决定哪个表是驱动表。

（12）通常情况 F下，排序合并连接的执行效率会远不如哈希连接的执行效率高，但排序合并连接的使用范围更广，因为哈希连接只能用干等值连接条件，而排序合并连接还能用于其他连接条件（例如＜、＜＝、 》 、＞二）。

（13）通常情况下，排序合并连接并不适合 OLTP 类型的系统，其本质原因是对于 OLTP 类型的系统而言，排序是非常昂贵的操作，当然，如果能避免排序操作，那么即使是 OLTP 类型的系统，还是可以使用排序合并连接的。

（14）如果驱动表所对应的驱动结果集的记录数较少，同时在被驱动表的连接列上又存在唯一性索引（或者在被驱动表的连接列上存在选择性很好的非唯一性索引），那么此时使用嵌套循环连接的执行效率就会非常高；但如果驱动表所对应的驱动结果集的记录数很大，即便在被驱动表的连接列上存在索引，此时使用嵌套循环连接的执行效率也不会高。

（15）大表也可以作为嵌套循环连接的驱动表，关键看目标 SQL 中指定的谓词条件（如果有的话）能否将驱动结果集的数据最降卜来。

（16）哈希连接只适用于 CBO ，它也只能用于等值连接条件（即使是哈希反连接， Oracle 实际上也是将其转换成了等价的等值连接）

（17）哈希连接很适合于小表和大表之间做表连接且．连接结果集的记录数较大的情形，特别是在小表的连接列的可选择性非常好的情况下，这时候哈希连接的执行时间就可以近似看作是和全表扫描那个大表所耗费的时间相当。

（18）半连接和普通的内连接不同，半连接实际上会去重
---------------------

表连接 
        当优化器解析含表连接的目标SQL时，它除了会根据目标SQL的SQL文本的写法来决定表连接的类型之外，还必须决定如下三件事情才能得到最终的执行计划。
        （1）表连接顺序
        （2）表连接方法
        （3）访问单表的方法
    
    表连接类型
        1、内连接  
        只要where条件中没有写那些标准SQL中定义或者Oracle中自定义的表示外连接的关键字，则该SQL的连接类型就是内连接。标准SQL中内连接的写法是用JOIN ON或者JOIN USING。
目标表1 join 目标表2 on （连接条件）
目标表1 join 目标表2 using （连接列集合）
        对于使用JOIN USING的标准SQL而言，如果连接列同时又出现在查询列中，则该连接列前不能带上表名或者表名的别名
   2、外连接 
        左连接：目标表1 left outer join 目标表2 on （连接条件）或  目标表1 left outer join 目标表2 u si n g （连接列集合）
left outer join左边的目标表1作为表连接的驱动表，即表明位置处于left的表就是outer table，驱动表。此时连接结果除了包含目标表1和目标表2中所有满足该连接条件的记录外，还会包含驱动表（目标表1）中所有不满足该连接条件的记录，同时，驱动表中所有不满足该连接条件的纪录所对应的被驱动表（目标表2）中的查询列均会以NULL值来填充。
        右连接：目标表1 right outer join 目标表2 on （连接条件）或目标表1 right outer join 目标表2 using （连接列集合）
right outer join右边边的目标表1作为表连接的驱动表，即表明位置处于right 的表就是outer table，驱动表。其他的属性和左连接基本相同。
        全连接：目标表1 full outer join 目标表2 on （连接条件）或  目标表1 full outer join 目标表2 u si n g （连接列集合）
全连接可以理解为先做左连接，再做右连接。最后把结果做一个union操作
   自定义关键字“（+）”：其含义是关键字出现在哪个表的连接列的后面，就表明那个表会以null值来填充那些不满足连接条件并位于该表的查询列，此时应该以关键字对面的表作为驱动表。

表连接方式

      1、排序合并连接  

    排序合并连接是一种两个表在做表连接时用排序操作（sort）和合并操作（merge）来得到连接结果集的表连接方法。


        排序合并连接的优缺点及适用场景：

   （1）排序合并连接的执行效率不如哈希连接，但是排序合并连接的使用范围更广，因为哈希连接只用于等值连接，排序合并连接除等值连接还用于其他连接条件（<、<=、>、>=）。

   （2）排序合并连接不适合OLTP系统，对OLTP系统来说，排序是非常昂贵的操作。如果能避免排序操作，OLTP系统也可以使用排序合并连接。比如两个表虽然是排序合并连接，实际上并不需要排序，因为这两个表在各自的连接列都有索引。

   （3）排序合并连接不存在驱动表的概念。

     2、嵌套循环连接  

    嵌套循环连接是一种两个表做表连接时依靠两层嵌套循环得到连接结果集的表连接方法。

    嵌套循环连接的优缺点及适用场景：
    （1）如果驱动表所对应的驱动结果集的记录数较少，同时在被驱动表的连接列存在唯一性索引（或者在被驱动表的连接列存在选择性很好的非唯一性索引），此时嵌套循环连接的执行效率非常高；如果驱动表所对应的驱动结果集的记录数很多，即使在被驱动表的连接列存在索引，此时使用嵌套循环连接的执行效率也不会高。
    （2）大表也可以做驱动表，关键在于目标SQL的谓词条件能否将驱动结果集的数量降下来。
    （3）嵌套循环连接可以快速响应。排序合并连接要等到做完排序后合并操作时才能开始返回数据，哈希连接要等到驱动结果集所对应的hash table全部建完后才能开始返回数据。

    在oracle11g中，oracle引入向量I/O(vector I/O)。在引入向量I/O后，oracle可以将原先一批单块读需要耗费的物理I/O组合起来，然后用一个向量I/O批量处理它们。这样就实现了在单块读的数量不降低的情况下减少这些单块读所要耗费的物理I/O数量，从而提高嵌套循环连接的效率。

  3、哈希连接  

    在oracle10g及以后的数据库版本中，优化器（实际上是CBO，哈希连接仅适用于CBO）在解析目标SQL时是否考虑哈希连接受限于隐含参数_HASH_JOIN_ENABLE，而在oracle10g以前受限于隐含参数HASH_JOIN_ENABLE。

USE_HASH Hint的优先级比参数_HASH_JOIN_ENABLE高，即使_HASH_JOIN_ENABLE参数值为FALSE，CBO解析SQL时仍使用哈希连接。

哈希连接的优缺点及适用场景：

    （1）哈希连接不一定会排序，大多数情况下不需要排序。
    （2）哈希连接的驱动表的连接列的可选择性应尽可能好，可选择性会影响Hash Bucket的记录数，Hash Bucket的记录数会影响从该Hash Bucket中查找匹配记录的效率。
    （3）哈希连接只适用于CBO和等值连接。
    （4）哈希连接很适合于小表和大表之间做表连接而且连接结果集的记录较多的情况，特别是小表的连接列的可选择性非常好的情况，这时哈希连接的直线时间近似于全表扫描大表的耗费时间。

  4、笛卡尔连接  

    笛卡尔连接又称笛卡尔乘积，是一种两个表在做表连接时没有任何连接条件的表连接方法。笛卡尔连接实际上一种特殊的合并连接，和排序合并连接类似，只是笛卡尔连接不需要排序，而且在执行合并操作时没有连接条件。

    笛卡尔连接的优缺点及适用场景：
    （1）笛卡尔连接的出现可能是由于漏写连接条件，可以利用笛卡尔连接减少对目标SQL中大表的全扫描次数。

    （2）有时出现笛卡尔连接是因为目标SQL使用ORDERED Hint，同时在该SQL的位置相邻的两个表之间没有直接的关联条件。

    （3）有时笛卡尔连接出现是因为统计信息不准确。

5、反连接        
            外部WHERE 条件中NOT EXISTS ,NOT IN 或是<>ALL的子查询转成对应的反连接。NOT EXISTS和<>ALL对NULL值敏感，一但子查询中有NULL，整个结果都是NULL。

6、半连接

            半连接会去重复数据。

            Oracle会把外部WHERE 中含有EXISTS,IN或是=ANY的子查询转换成半连接。

7、星连接     

            它是一种单个事实表（Fact Table）和多个维度表（Dimension Table）之间的连接。它既不是一种额外的连接类型，也不是一种额外的连接方法。星型连接的各维度之间没有直接的关联条件，其试试表和各维度表之间是基于事实表的外键列和对应维度表的主键列之间的连接，通常事实表的外键列上还会存在对应的位图索引。其示意图如下：



（1）在使用 RBO 的情况下，我们可以通过调整相关对象在数据字典缓存中的缓存顺序，改变目标 sQL 中所涉及的各个对象在该 SQL 文本中出现的先后顺序，或者等价改写该 SQL 来调整其执行计划。

（2）成本是指 Oracle 根据相关对象的统计信息计算出来的一个值，它实际上代表了 Oracle 根据相关统计信息估算出来的目标 SQL 的对应执行路径的 I / O 、 CPU 和网络资源的消耗量。 

（3）cardinality 和 selectivity 的值会直接影响 cBO 对于相关执行步骤成本值的估算，进而影响 CBO 对于目标 SQL 执行计划的选择。

（4）可传递性的意义在于提供了更多的执行路径（ Access Path ）给 CBO 做选择，增加了走出更高效执行计划的可能性。

（5）优化器的模式对 CBO 计算成本（进而对 CBO 选择执行计划）有着决定性的影响。

（6）不是说全表扫描不好，事实上 Orade 在做全表扫描操作时会使用多块读，这在目标表的数据量不大时执行效率是非常高的，但全表扫描最大的问题就在于走全表扫描的目标 SQL 的执行时间会不稳定、不可控，这个执行时间一定会随着目标表数据量的递增而递增。

（7）通过 B 树索引访问表里行记录的效率并不会随着相关表的数据量的递增而显著降低，即通过走索引访问数据的时间是可控的、基本稳定的，这也是走索引和全表扫描的最大区别。

（8）Oracle 中索引全扫描的执行结果是有序的，并且是按照该索引的索引键位列来排序的，这意味右走索引全扫描能够既达到排序的效果，同时又能避免对该索引的索引键值列的真正排序操作。另外， Oracle 中能做索引全扫描的前提条件是目标索引至少有一个索引键值列的属性是 NOT NULL 。

（9）索引快速全扫描是可以并行执行的，它的执行结果不一定是有序的。

（10）Oracle 中的索引跳跃式扫描仅仅适用于那些目标索引的前导列的 distinct 值数量较少、后续非前导列的可选择性又非常好的情形，因为索引跳跃式扫描的执行效率 · 定会随着目标索引前导列的 distinct 值数量的递增而递减。

（11）关键字“ ( + ) ”出现在哪个表的连接列后面，就表明嘟个表会以 NULL 值来填充那些不满足连接条件并位于该表中的查询列，此时应该以关键字“ ( + ) ”对面的表来作为外连接的驱动表，这里的关键是决定哪个表是驱动表。

（12）通常情况 F下，排序合并连接的执行效率会远不如哈希连接的执行效率高，但排序合并连接的使用范围更广，因为哈希连接只能用干等值连接条件，而排序合并连接还能用于其他连接条件（例如＜、＜＝、 》 、＞二）。

（13）通常情况下，排序合并连接并不适合 OLTP 类型的系统，其本质原因是对于 OLTP 类型的系统而言，排序是非常昂贵的操作，当然，如果能避免排序操作，那么即使是 OLTP 类型的系统，还是可以使用排序合并连接的。

（14）如果驱动表所对应的驱动结果集的记录数较少，同时在被驱动表的连接列上又存在唯一性索引（或者在被驱动表的连接列上存在选择性很好的非唯一性索引），那么此时使用嵌套循环连接的执行效率就会非常高；但如果驱动表所对应的驱动结果集的记录数很大，即便在被驱动表的连接列上存在索引，此时使用嵌套循环连接的执行效率也不会高。

（15）大表也可以作为嵌套循环连接的驱动表，关键看目标 SQL 中指定的谓词条件（如果有的话）能否将驱动结果集的数据最降卜来。

（16）哈希连接只适用于 CBO ，它也只能用于等值连接条件（即使是哈希反连接， Oracle 实际上也是将其转换成了等价的等值连接）

（17）哈希连接很适合于小表和大表之间做表连接且．连接结果集的记录数较大的情形，特别是在小表的连接列的可选择性非常好的情况下，这时候哈希连接的执行时间就可以近似看作是和全表扫描那个大表所耗费的时间相当。

（18）半连接和普通的内连接不同，半连接实际上会去重。


Oracle的执行计划
    执行计划的含义
        Oracle用来执行目标SQL语句的一系列步骤的组合就被称为执行计划。
            执行计划分为下面三个部分：
    （1）目标SQL的正文，SQL ID和其执行计划所对应的PLAN HASH VALUE。
    （2）执行计划的主体。
    （3）执行计划的额外补充信息。
如何查看执行计划
1、explain plan命令

        执行如下命令
        explain plan for + 目标SQL
        select * from table(dbms_xplan.display)
2、DBMS_XPLAN包

        它有四种方式，可以根据不同的场景进行应用。
        （1）select * from table(dbms_xplan.display);

        （2）select * from table(dbms_xplan.display_cursor(null,null,'advanced'/'all'));

          （3）select * from table(dbms_xplan.display_cursor ('sql_id/hash_value',child_cursor_number,'advanced'));

          （4）select * from table(dbms_xplan.display_awr('sql_id'));

    第一种就是上一节中提到的方法配合explain plan使用。

    第二种方式适合刚刚执行完要查询的SQL之后立刻使用。

    第三种用于查看指定SQL的执行计划，需要SQL ID和Child Cusor Number参数。

    第四种用于查看指定SQL的所有历史执行计划。

3、AUTOTRACE开关

    使用的命令是：

     set autotrace {off|on|traceonly}[explain][statistics]

4、10046事件与tkprof命令


        所得到的执行计划中明确显示目标SQL实际执行计划中每一个执行步骤所消耗的逻辑读，物理读和花费的时间。这种细粒度的明细显示在我们诊断复杂 sQL 的性能问题时尤为有用，而几这也是其他二种方法所不能提供的。
        其执行步骤是：
    （1）首先在当前 Session 中激活10046事件。
    （2）接着在此 Session 中执行目标 SQL 
    （3）最后在此 session 中关闭 10046事件。
当执行完上述步骤后，Oracle就会将目标SQL的执行计划和明细资源消耗写入此Session所对应的trace文件中，査看这个trace文件就能知道执行SQL的执行计划和资源消耗明细了。Oracle会在参数USER_DUMP_DEST所代表的目录下生成trace文件，命名格式为‘实例名_ora_当前session的spid_trc’。



执行效率或者一般说的执行时间，是和完成一次SQL所需要访问的资源总量（S）成正比以及单位时间内能够访问的资源量（V）成反比，S越大，效率越低，V越大效率越高。 比如通过并行查询，则可以提升单位时间内访问的资源量。

当然，这仅仅是从执行时间上考虑，SQL优化肯定不仅仅是执行时间降低，应该是资源使用与执行时间降低之间寻求一种平衡，否则，盲目并行，可能提升不了效率，反而让系统资源消耗殆尽。
最终来说，SQL优化的本质就是：1、缩短响应时间；2、提升系统吞吐量；3、提升系统负载能力。要使用多种手段，在提升系统吞吐量和增加系统负载能力，提高单个SQL效率之间寻求一种平衡。就是要尽量减少一条SQL需要访问的资源总量，比如走索引更好，那么不要使用全表扫描。


  如何得到真实的执行计划


        得到目标SQL的执行计划，大致有以下四种方式：

            1、explain plan 命令

      2、DBMS_XPLAN包

      3、SQLPLUS中的autotrace开关

      4、10046事件

    除了第四种，其他三种方法都有可能是不准的。判断一个sq计划任务任务是否准确，就要看目标SQL是否真正被执行。 

 对使用第一种方法（即使用 explain Plan 命令）得到的执行计划而言，因为此时目标 SQL 并没有被实际执行，所以用该方法得到的执行计划有可能是不准的，尤其是在日标 SQL 包含绑定变量时．在默认开启绑定变最窥探（ Bind Peeking ）的情况下，对含绑定变里的目标 sQL 使用 explain plan 得到的执行计划只是一个半成品，Oracle在随后对该 SQL 的绑定变量进行窥探后就得到了这些绑定变量具体的值，此时Oracle很可能会对上述半成品的执行计划做调整，一旦做了调整，使用 explain plan 命令得到的执行计划就不准了。

    第二种方法包里含有四种方式，第一种方式是用于查看explain plan命令得到的目标SQL的执行计划，显然是不准确的。所以如下方式：


    select * from table(dbms_xplan.display_cursor(null,null,'advanced'));

    select * from table(dbms_xplan.display_cursor('sql_id/hash_value',child_cursor_number,'advanced'));

    select * from table(dbms_xplan.display_awr('sql_id')); --用于已经被age out 出shared pool的情况

    第三种方法（即使SQLPLUS中的AUTOTRACE开关）而言，你可以选执行如下三种方式中的一种来幵启AUTOTRACE开关：

    SET AUTOTRACE ON (可以简写为 SET AUTOT ON):
    SET AUTOTRACE TRACEONLY (可以简写为 SET AUTOT TRACE);

    SET AUTOTRACE TRACEONLY EXPLAIN (可以 简写为 SET AUTOT TRACE EXP );

上述三种方式中，当使用SET AUTOTRACE ON和SET AUTOTRACE TRACEONLY时，目标SQL都已经被实际执行过了，正是因为被实际执行过,所以在SET AUTOTRACE ON和SET AUTOTRACE TRACEONLY的情况下我们能看到到目标SQL的实际资源消耗情况，当使用SET AUTOT TRACE EXP，如果执行的是SELECT语句，则该SELECT语句并没有被Oracle实际执行，但如果执行的是DML语句，情况况就不一样了，此时的DML语句是会被Oracle实际执行的.

如果目标SQL的执行计划还在Shared Pool中，那就可以以使用脚本display_cursor_9i.sql和存储过程printsql来得到其真实的执行计划和资源消耗情况，两个文件的地址是：

http://www.dbsnake.net/wp-content/uploads/2012/08/display_cursor_9i.sql_.txt

http://www.dbsnake.net/wp-content/uploads/2012/08/PRINTSQL.prc_.txt

如果目标sql的执行计划已经被age out出shared pool，可以执行DBMS_XPLAN.DISPLAY_AWR或者使用AWR SQL报告和statspack sql报告来得到历史执行计划和资源消耗。



        得到目标SQL的执行计划，大致有以下四种方式：

            1、explain plan 命令

      2、DBMS_XPLAN包

      3、SQLPLUS中的autotrace开关

      4、10046事件

    除了第四种，其他三种方法都有可能是不准的。判断一个sq计划任务任务是否准确，就要看目标SQL是否真正被执行。 

 对使用第一种方法（即使用 explain Plan 命令）得到的执行计划而言，因为此时目标 SQL 并没有被实际执行，所以用该方法得到的执行计划有可能是不准的，尤其是在日标 SQL 包含绑定变量时．在默认开启绑定变最窥探（ Bind Peeking ）的情况下，对含绑定变里的目标 sQL 使用 explain plan 得到的执行计划只是一个半成品，Oracle在随后对该 SQL 的绑定变量进行窥探后就得到了这些绑定变量具体的值，此时Oracle很可能会对上述半成品的执行计划做调整，一旦做了调整，使用 explain plan 命令得到的执行计划就不准了。

    第二种方法包里含有四种方式，第一种方式是用于查看explain plan命令得到的目标SQL的执行计划，显然是不准确的。所以如下方式：


    select * from table(dbms_xplan.display_cursor(null,null,'advanced'));

    select * from table(dbms_xplan.display_cursor('sql_id/hash_value',child_cursor_number,'advanced'));

    select * from table(dbms_xplan.display_awr('sql_id')); --用于已经被age out 出shared pool的情况

    第三种方法（即使SQLPLUS中的AUTOTRACE开关）而言，你可以选执行如下三种方式中的一种来幵启AUTOTRACE开关：

    SET AUTOTRACE ON (可以简写为 SET AUTOT ON):
    SET AUTOTRACE TRACEONLY (可以简写为 SET AUTOT TRACE);

    SET AUTOTRACE TRACEONLY EXPLAIN (可以 简写为 SET AUTOT TRACE EXP );

上述三种方式中，当使用SET AUTOTRACE ON和SET AUTOTRACE TRACEONLY时，目标SQL都已经被实际执行过了，正是因为被实际执行过,所以在SET AUTOTRACE ON和SET AUTOTRACE TRACEONLY的情况下我们能看到到目标SQL的实际资源消耗情况，当使用SET AUTOT TRACE EXP，如果执行的是SELECT语句，则该SELECT语句并没有被Oracle实际执行，但如果执行的是DML语句，情况况就不一样了，此时的DML语句是会被Oracle实际执行的.

如果目标SQL的执行计划还在Shared Pool中，那就可以以使用脚本display_cursor_9i.sql和存储过程printsql来得到其真实的执行计划和资源消耗情况，两个文件的地址是：

http://www.dbsnake.net/wp-content/uploads/2012/08/display_cursor_9i.sql_.txt

http://www.dbsnake.net/wp-content/uploads/2012/08/PRINTSQL.prc_.txt

如果目标sql的执行计划已经被age out出shared pool，可以执行DBMS_XPLAN.DISPLAY_AWR或者使用AWR SQL报告和statspack sql报告来得到历史执行计划和资源消耗。

如何查看执行计划的执行顺序
    查看执行顺序的口诀是：先从最开头一直连续往右看，直到看到最右边的并列的地方；对于不并列的，靠右的先执行；如果见到并列的，就从上往下看，对于并列的部分，靠上的先执行。

    对于复杂的SQL执行的语句，可以使用XPLAN包，包的源码的地址是：

    http://www.dbsnake.net/wp-content/uploads/2012/08/xplan.sql_.txt

Oracle中常见的执行计划
与表访问相关的执行计划

    Oracle中与表访问有关的两种方法：全表扫描和ROWID扫描。反应在执行计划上，与全表扫描对应的执行计划中的关键字是“TABLE ACCESS FULL”，与ROWID对应的执行计划中的关键字是“TABLE ACCESS BY ROWID”或“TABLE ACCESS BY INDEX ROWID”。如果ROWID来源于用户手工指定的话执行计划的关键字是“TABLE ACCESS BY ROWID”，如果来源于索引则是“TABLE ACCESS BY INDEX ROWID”。


与B树索引相关的执行计划

   Oracle中B树索引访问相关的方法是：索引唯一扫描、索引范围扫描、索引全扫描、索引快速全扫描和索引跳跃式扫描．反映在执行计划上与索引唯一扫描对应的关键字是“ INDEX UNIQUE SCAN ",与索引范围扫描对应的关键字是“ INDEX RANGE SCAN"，与索引全扫描对应的关键字是“ INOEX FULL SCAN "，与索引快速全扫描对应的关键字是“INDEX FAST FULL SCAN " ,与索引跳跃式扫描对应的关键字是"INDEX SKIP SCAN"

与位图索引相关的执行计划

   Oracle的位图索引的物理存储结构是：<被索引的键值，对应的rowid下限，对应的rowid上限,位图段>。这里位图段是被压缩存储的，解压缩后就是一连串 0 和 l 的二进制位图序列，其中 l 表示被索引键值的一个有效 rowid ,Oracle通过一个转换函数将解压缩后的位图段中的 l 结合对应 rowid 的上下限，转换为被索引键值所对应的有效 rowid．

   Oracle数据库中位图索引的锁的粒度是在索引行的位图段上。对干 Oracle数据库中的位图索引而言，它是没有行锁这个概念的，要锁就锁索引行的整个位图段，而多个数据行可能对应同一个索引行的位图段。这种锁的粒度就决定了位图索引不适用于高并发且频繁修改的 OLTp 系统，如果在高并发且绷繁修改的 OLTp 系统中使用了位图索引，很可能会导致严重的并发问题，甚至会产生死锁。

   与 B 树索引相比，位图索引的优势主要体现在如下几个方面：

   ( l ）因为位图索引的位图段是服后存储的，所以如果被索引的列的 diatind 位较少，那么位图索引与相同列上的 B 树索引比起来，会显著节省存储空间。

  ( 2 ）如果需要在多个列上创建索引，那么位图索引与同等条件下的 B 树索引比起来，往往会显著节省存储空间。

  ( 3 ）位图索引能够快速处理一些包含了各种 ANO 或 OR 查询条件的 SQL ，这主要是因为位图索引能够实现快捷的按位运算的缘故。

   Oracle 数据库里常见的与位图索引访问相关的方法包括如下这些类型：位图索引单键值扫描、位图索引范围扫描、位图索引全扫描、位图索引快速全扫描、位图按位与、位图按位或、位图按位减等。反映在执行计划上，与位图索引单键值扫描对应的关键字是“ BITMAP INDEX SINGLE VALUE " ，与位图索引范围扫描对应的关键字是“ BITMAP INDEX RANGE SCAN " ，与位图索引全扫描对应的关键字是“ BITMAP INDEX FULL SCAN " ，与位图索引快速全扫描对应的关链字是“ BITMAP INDEX FAST FULL SCAN " ，与位图按位与对应的关健字是“ BITMAP AND " ，与位图按位或对应的关键字是“ BITMAP OR " ，与位图按位减对应的关键字是“ BITMAP MINUS " . 另外需要注意的是，Oracle在使用完位图索引后通常会将最后的位图运算结果转化为 ROWID ，这一步转换过程对应的执行计划中的关键字是“ BITMAP CONVERSION TO ROWIDS "。

与表连接相关的执行计划

   Oracle中与表连接相关的方法有排序合并连接、嵌套循环连接、哈希连接、反连接和半连接。反映在执行计划上，与排序合并连接对应的关键字是“ SORT JoIN ”和“ MERGE JOIN " ，与嵌套循环连接对应的关健字是“ NESTED LOOPS " 与哈希连接对应的关健字是“ HASH JOIN”，与反连接对应的关键字是“ ANTI "（依据所采用的不同的反连接方法，所对应的关键字可能是“ HASH J01N ANTI ”、“ MERGE JOIN ANTI ”或“ NESTED LOOPS ANTI " ) ．与半连接对应的关键字是“ SEMI " （依据所采用的不同的半连接方法，所对应的关键字可能是' HASH JOIN SEMI ”、“ MERGE JOIN SEMI ”或“ NESTED L00PS SEMI " ）。

    

其他的典型的执行计划

    AND-EQUAL（INDEX MERGE）

  AND-EQUAL又称为INDEX MERGE，顾名思义，INDEX MERGE 就是指如果 where 条件里出现了多个针对不同单列的等值条件，并且这几列都有单键值的索引，则 oracle 可能会以相应的单个等值条件去分别扫描这些索引，然后 Oracle 会合并这些扫描单个索引所得到的 rowid 集合，如果能从这些集合中找到值相同的 rowid ，那么这个 rowid 就是目标 SQL 最终执行结果所对应的 rowid记录。最后Oracle只需用这些 rowid 回表就能得到目标SQL执行的结果。

    INDEX JOIN

  INDEX JOIN指的是针对单表上的不同索引之间的连接，在执行计划中对应的关键字与普通的表连接一样，只不过参与连接的对象不是表而是索引。


    VIEW

  Oracle 在处理包含视图的 SQL 时，根据该视图是否能做视图合并，其对应的执行计划有如下两种形式：

    1、如果可以做视图合并则 Orade 在执行该 SQL 时可以直接针对该视图的基表，此时 SQL 的执行计划中很可能不会出现关键字“ VIEW" （不能完全依赖关键字“ VIEW ”的出现与否来判断 Oracle是否做了视图合并，因为对于某些 SQL 而言，即使 oracle 已经做了视图合并但其所对应的执行计划中可能还是会显示关键字’VIEW" )。

    2、如果不能做视图合并，则 Oracle 将把该视图看作一个整体并独立地执行它，此时 SOL 的执行计划中将会出现关
键字“ VIEW ”。

    FILTER

  FILTER 直译过来就足过滤、筛选的意思．它是一种特殊的执行计划，所对应的执行过程就是如下三步：

    ( l ）得到一个驱动结果集。

    ( 2 ）根据一定的过滤条件从上述驱动结果集中滤除不满足条件的记录。

    ( 3 ）结果集中剩下的记录就会返回给最终用户或者继续参与下一个执行步骤。

   SORT

  执行计划中的SORT通常会以组合的方式出现，这些组合方式包括但不限于如下几种：

    （1）SORT AGGREGATE

    （2）SORT UNIQUE

    （3）SORT JOIN

    （4）SORT GROUP BY 

    （5）SORT ORDER BY 

    （6）BUFFRE SORT

   注意，执行计划中及时出现了关键字“SORT”，也不一定意味着就需要排序，比如SORT AGGREGATE和BUFFRE SORT就不一定需要排序。

    UNION/UNIONN ALL

  UNION/UNION ALL表示对两个结果集进行合并，如果他们出现在执行计划中也表示同样的含义。

 UNION和UNION ALL的区别是UNION ALL仅仅是简单的把两个结果集进行合并，并不做任何额外的处理，而UNION出了合并两个结果集之外，还会做对合并后的结果集进行去重和排序。

   CONCAT

  CONCAT就是IN-List扩展或OR扩展，IN-List扩展或OR扩展在执行计划中的关键字就是“CONCATENATION”。


  CONNECT BY

  CONNNECT BY 是Oracle中层次查询所对应的关键字，如果出现在执行计划中也表示同样的含义
---------------------
作者：PursueDreamZ
来源：CSDN
原文：https://blog.csdn.net/qq_34409900/article/details/80752587
版权声明：本文为博主原创文章，转载请附上博文链接！

Oracle里执行计划的稳定
 使用SQL Profile来稳定执行计划

   使用SQL Profile可以很容易的实现下面的目标：

    （1）锁定或者说稳定执行计划。

    （2）在不能修改目标SQL的SQL文本的情况下使目标SQL语句按指定的执行计划运行。

   SQL Profile有两种类型，一种是Automatic，一种是Manual。

   Automatic类型的SQL Profile

    Automatic 类型的 SQL Profile 其实就是针对目标 sQL 的一些额外的调整信息，这些信息存储在数据字典里．当有了 Automatic 类型的 SQL Profile 后，Oracle在产生执行计划时就会根据它对目标 sQL 所涉及的统计信息等内容做相应的调整，因而能够在一定程度上避免产生错误的执行计划。不用担心 Automatic 类型的 sQL Profile 的准确性，因为 oracle 会使用类似于动态采样技术那样的手段来保证这些额外调整信息相对准确。

    Automatic 类型的 SQL Profile 并不会像 Stored Outline 那样锁定目标 SOL 的执行计划，因为 Automatic 类型的 SQL Profile 的本质就是针对目标 SQL 的一些额外的调整信息，这些额外的调核信息需要与原目标 sQL 的相关统计信息等内容一起作用才能得到新的执行计划．即原始 sQL 的统计信息等内容一旦发生变化，即使原有 Automatic 类型的 SQL Profile 并没有改变，该 SQL 的执行计划也可能会发生变化．从这个意义上讲， Automatic 类型的 SOL Profile 并不能完全起到稳定目标 SOL 的执行计划的作用，虽然它确实可以用来调整执行计划。


Manual类型的SQL Profile

    Manual类型的 SQL Profile 本质上就是一堆 Hint 的组合，这一堆 Hint 的组合实际上来源于执行计划中 Outline Data 部分的 Hint 组合。 Manual 类型的 SQL Profile同样可以在不更改目标 SQL的 SQL 文本的情况下调整其执行计划，而且更为重要的是， Manual 类型的 SQL Profile可以起到很好的稳定目标 SQL 的执行计划的作用，这一点是 Automatic 类型的 SQL Pro file 所不具备的。

 使用SPM来稳定执行计划

   SPM 是一种主动的稳定执行计划的手段，能够保证只有被验证过的执行计划才会被启用，当由于种种原因（比如统计信息的变更）而导致目标 SQL 产生了新的执行计划后．这个新的执行计划并不会被马上启用，直到它己经被我们验证过其执行效率会比原先执行计划高才会被启用。

   当启用了SPM后每个SQL都会存在对应的SQL Plan Baseline，这个SQL Plan Baseline中存储的就是该SQL的执行计划，如果一个SQL有多个执行计划，那就有多个SQL Plan Baseline，可以从DBA_SQL_PLAN_BASELINE中查看目标SQL所有的SQL Plan Baseline。

   DBA_SQL_PLAN_BASELINE中的列ENABLED和ACCEPTED用来描述一个SQL Plan Baseline所对应的执行计划是否被Oracle启用，只有ENABLED和ACCEPTED的值均为YES的SQL Plan Baseline所对应的执行计划才会被Oracle启用，如果一个sql有超过1个以上的SQL Plan Baseline的ENABLED和ACCEPTED的值均为YES，则Oracle会从中选择成本值最小的一个所对应的执行计划来作为该SQL的执行计划。

    Oracle里的Cursor
        Oracle数据库中的Cursor分为两种类型：一种是Shared Cursor；另一种是Session Cursor。

    Oracle里的Shared Cursor
        库缓存：SGA中的一块内存区域，是缓存刚刚执行过的SQL语句和pl/sql语句（如存储过程、函数、包、触发器）所对应的执行计划、解析树、Pcode、Mcode等对象。

        对每一个库缓存对象而言，都或多或少需要往库缓存中存储一终该库缓存对象所特有的动态运行时 ( runtime ）数据，比如 SQL 语句所对应的库缓存对象就需要在库缓存中缓存该 sQL 语句所对应的编译好的二进制格式的执行计划。
        Oracle会用 Data Hcap 来存储这些动态运行时教据，所谓的“ Data Heap " ，可以简单地理解成是库缓存中的块连续的内存区域． Data Heap 是动态分配的，其大小并不固定．
        每一个库缓存对象都可能会拥有多个 Data Heap ，这里分别将它们命名为 Heap 1 . HeapZ 、 · · · 一 Heap n . 各个 Data Heap 之间独立的，没有关联关系， oracle 会在 Heap o 的属性“ Data Blocks Pointer ”中存储指向这些 Data Heap 的指针．这样 Oracle通过访问 Heapo 0就可以按需访问该 Heapo 0 所在的库缓存对象拥有的所有 Data Heap  .
        oracle 数据库中的 Shared Cursor 就是指缓存在库缓存里的一种库缓存对象，说白了就是指缓存在库缓存堆的 sQL 语句和匿名 PIJSQL 语句所对应的库缓存对象。 Shared Cursor是 oracle 缓存在 Library  Cache中的几十种库缓存对象之一，它所对应的库缓存对象句柄的 Namespace 属性的值是 CRSR （也就是Cursor 的缩写）。shared Cursor 里会存储目标 SQL 的 SQL 文本、解析树、该 SQL 所涉及的对象定义、该 sQL 所使用的绑定变量类型和长度．以及该 SQL 的执行计划等信息。

        Oracle数据库中的 Shared Cursor 又细分为 Parent Cursor （父游标）和 Child Cursor （子游标）这两种类型，我们可以通过分别查询视图 V $ SOLAREA 和V $ SOL 来查看当前缓存在库级存中的 parent Cursor 和 Child Cursor ，其中 V $ SQLAREA 用于变看 Parent Cursor ，V $ SOL用于变看 Child Cursor 。

        Parent Cursor 和 Child Cursor的结构是 ·一样的（它们都是以库缓存对象句柄的方式缓存在库缓存中， Namespace 属性的值均为 CRsR ) ．它们的区别在于目标 sQL 的 sQL 文本会存储在其Parent Cursor 所对应的库缓存对象句柄的属性 Name中（ Child Cursor 对应的库缓存对象句柄的 Name 属性值为空，这意味着只有通过 Parent Cursor 才能找到相应的 Child cursor ) ，而该 SQL 的解析树和执行计划则会存储在其 Child Cursor所对应的库缓存对象句柄的 Heap 6 中。同时Oracle会在该 sQL 所对应的 Parent Cursor的 Heap 0 的 child table 中．存储从属于该 Parent Cursor的所有 Child Cursor，的库级存对象句柄地址（这意味着 Oracle可以通过访问 Parent Cursor的 Heap 6的 child table而依次顺序访问从属于该 Parent Cursor 的所有 Child Cursor ) .

        这种Parent Cursor 和 Child Cursor的结构就决定了在 Oracle数据库里，任何一个目标 SQL 一定会同时对应两个Shared Cursor ，其中一个是 Parent Cursor．另外一个则是 Child Cursor.  Parent Cursor会存储该SQL的 SQL 文本．而该 SQL 其正的可以被重用的解析树和执行计划则存储在 child Cursor 中。

    硬解析

        硬解析（ Hard Parse ）是指 Oracle 在执行目标 SQL 时．在库缓存中找不到可以重用的解析树和执行计划，而不得不从头开始解析目标 SQL 并生成相应的 Parent Cursor 和 Child Cursor的过程。硬解析实际上有两种类型： ·一种是在库缓存中找不到匹配的 Parent Cursor ，此时 oradc 会从头开始解析目标 SQL ，新生成一个Parent Cursor 和 Child Cursor，并把它们挂在对应的 Hash Bucket 中：另外 一种是找到了匹配的 Parent Cursor未找到匹配的 child Cursor ．此时 oracle 也会从头开始解析该日标 SQL ．新生成一个 Child Cursor。并把这个 Child Cursor 挂在对应的 Parent Cursor下。

        硬解析很不好，有以下缺点：

        （1）硬解析可能会导致Shared Pool Latch的争用。

        （2）硬解析可能会导致库缓存相关Latch（如Library Cache Latch）和Mutex的争用。

 软解析

        软解析是指Oracle在执行目标SQL时，在Library Cache中找到匹配的Parent Cursor 和 Child Cursor，并将存储在Child Cursor中的解析树和执行计划直接拿过来重用而无须从头开始解析的过程。

        与硬解析相比，软解析优势是：

        （1）软解析不会导致Shared Pool Latch的争用。

        （2）软解析虽然也可能会导致库缓存相关 Latch 和 Mutex 的争用．但软解析持有库级存相关 Latch 的次数要少，而且软解析对某些 Latch （如 Library Cache Latch ）的持有时间会比硬解析短，这意味，即使产生了库级存相关 Latch 的争用，软解析的争用程度也没有硬解析那么严重即库级存相关 Lalch 和 Mutex 的争用所带来的系统性能和可扩展性的问从对软解析来说要比硬解析少很多。


Oracle里的Session Cursor
   Session Cursor的含义

   Oracle数据库里第二种类型的 Cursor 就是Session Cursor，它是当前Session 解析和执行 SQL 的载体．换句话说， Session Cursor 用于在当前 Session 中解析和执行 SQL ．和 Shared Cursor 一样， Session Cursor也是 oracle 自定义的 一种 C 语言复杂结构，它也是以哈希表的方式缓存起来的，只不过是缓存在 PGA 中，而不是像 Shared Cursor那样缓存在 SGA的库缓存里。

    关于Session Cursor，有以下需要注意：

    ( 1 )Session Cursor 与 session 是一一对应的，不同 session 的 session Cursor 之间没法共享，这与 Shared Cursor有本质区别． 

   ( 2 ) Session Cursor是有生命周期的，每个Session Cursor 在使用的过程中都至少会经历一次Open、Parse、 Bind 、 Execute 、 Fdch 和 Close中的一个或多个阶段，用过的 Session Cursor不 一定会缓存在对应义Session 的PGA中，这取决于参数SESSION_CACHED_CURSORS的值是否大于 0 

   ( 3 )既然 scssion Cursor 也是以哈希表的方式缓存在 PGA 中，意味着 Oracle会通过相关的哈希运算来存储和访问在当前 Session 的 PGA 中的对应 Session Cursor ．这种访问机制实际上和Shared Cursor是一样的，即可以简单地认为Oracle是根据目标 SQL 的 SQL 文本的哈希值去PAG中的相应 Hash Bucket 中找匹配的 Session Cursor。

    Oracle在解析和执行目标SQL时，会先去当前Session的PGA中找是否存在匹配的缓存Session Cursor。当Oracle第一次解析和执行目标SQL时，当前Session的PGA中肯定不存在匹配的Session Cursor，这时Oracle会新生成一个Session Cursor和一对Shared Cursor，这其中的Shared Cursor会存储能被所有Session共享、重用的内容。而Session Cursor则会经历一次Open、Parse、 Bind 、 Execute 、 Fdch 和 Close中的一个或多个阶段。


Session Cursor的相关参数解析

  OPEN_CURSORS

   参数 OPEN_CURSORS用于设定单个Session中同时能够以 Open状态并存的Session Cursor 的总数。
  SESSION_CACHED_CURSORS
   参数SESSION_CACHED_CURSORS用于设定单个Session中鞥能够以Soft Closed状态并存的Session Cursor 的总数。即用于设定单个Session能缓存在PGA中的Session Cursor 的总数。

  CURSOR_SOACE_FOR_TIME
   参数CURSOR_SOACE_FOR_TIME是为了环节发生在Child Cursor上的与库缓存相关的Latch争用。

Session Cursor的种类和用法

   隐式游标

    隐式游标是 Oracle数据库中最常见的一种 Session Cursor．它无处不在，我们在 SQLPLUs 或者在 PL/SQL 代码中直接执行 sQL 语句时， Oracle 实际上都帮我们自动创建了隐式游标来作为这些SQL 语句执行的载体．之所以称为隐式游标，是因为它的生命周期管理全部是由 SQL引擎或 PUSQL 引擎自动来完成，所以我们常常感觉不到它的存在。

    隐式游标的属性

    1、SQL%FOUND属性

    SQL%FOUND表示一条 sQL 语句被执行成功后受其影响而改变的记录数是否大于或等于 l 。既然是要改变记录，这意味着 SQL % FOUND 通常适用于那终执行 INSET、 UPDATE 和 DELETE 操作的 OML 语句，当然，它其实也可以用于 SELECT 语句．在一条 DML 语句被执行前，SQL%FOUND的值是 NULL ．当这条 DML 语句被执行并且成功改变了一条或者一条以卜记录的时候，又或者 SELECT语句成功返回一条或者条以上记录的时候，SQL%FOUND的值是 TRUE ，否则为 FALSE 。

    2、SQL%NOTFOUND

    SQL%FOUND表示一条SQL被执行成功后受其影响而改变的记录数是否为0。

    3、SQL%ISOPEN

    SQL%ISOPEN表示隐式游标是否处于Open状态。

    4、SQL%ROWCOUNT

    SQL%ROWCOUNT表示一条SQL语句成功执行后受其影响而改变的记录数的数量。

  显式游标

    显式游标通常用于PL/SQL代码中，它的定义和生命周期管理中的Open、 Fdch 和 Close均有我们在PL/SQL代码中显式控制。

    显式游标的属性：

    1、CURSORNAME%FOUND

    CURSORNAME%FOUND属性拜师指定的显式游标是否至少有一条记录被Fdch了。

    2、CURSORNAME%ISOPEN

    CURSORNAME%ISOPEN表示指定的显式游标是否被Open。

    3、CURSORNAME%NOTFOUND

    CURSORNAME%NOTFOUND表示指定的显示游标是否已经Fetch完毕。

    4、CURSORNAME%ROWCOUNT

    CURSORNAME%ROWCOUNT表示指定的显示游标迄今为止一共Fetch了多少行记录。


  参考游标

    参考游标通常用于PL/SQL代码中，它的定义和生命周期管理中的Open、 Fdch 和 Close均有我们在PL/SQL代码中显式控制。

    参考游标的属性和显示游标是一样的。其是Session Cursor中最灵活的，其灵活性体现在：

    1、它可以有多种定义方式。

    2、参考游标的 Open方式也非常灵活，它可以不和某个固定的 SQL 绑定，参考游标可以随时open ，并且每次Open所对应的 sQL 语句部可以是不一样的

    3、参考游标可以作为存储过程的输入参数和函数的输出参数
---------------------
作者：PursueDreamZ
来源：CSDN
原文：https://blog.csdn.net/qq_34409900/article/details/80808370
版权声明：本文为博主原创文章，转载请附上博文链接！

Oracle里的Cursor
        绑定变量（ Bind variable ）是一种特殊类型的变量，它又被称为占位符（ Placeholder ) ，绑定变量通常出现在目标 SQL 的 SQL 文本中，用于替换 SQL 文本中的 where 条件或者 values 子句（适用于 INSERT语句）中的具体愉入值。 oracle 数据库中绑定变量的使用语法是“ : variable_name " ，即用冒号和自定义变量名称的组合来转换目标 SQL 的 SQL 文本中的具体输入值，这里自定义的变量名称 variable _ name 可以是字母、数字或字母与数字的组合，例如原目标 SQL 为“ select ename from emp where empno =7369 " ，该 SQL 中的具体输入位是 7369 . 如果这里用绑定变最（假设是 x ）来转换上述具体输入值 7369 的话，则转换后的等价改写形式就足“select ename from emp where empno = : x " .

绑定变量的作用
        绑定变量的最大的作用是可以有效地降低系统硬解析的数量。

绑定变量的典型用法
        PL/SQL中的绑定变量的典型用法
    标准语法为：execute immediate [带 绑定变量的目标SQL] using [对应绑定变量的具体输入值]；

    在PL/SQL代码中给绑定变最从仇的关键字是“ using " ，目标 SQL 中有几个绑定变最．关键字“ using " 后就需要跟几个具体的输入值（各愉入位之间以逗号分隔），这一点与之前介绍的在 SQLPLUS 中直接用“ exec " 给 SQL 语句中的绑定变量赋值有区别。

    对于上述这种使用绑定变量的方式，关健字‘ using ’后传入的绑定变，具体输入值只与对应绑定变里在目标 SOL 中所处的位置有关，而与其名称无关，这意味着只要目标 SQL 中绑定变量所处的位置不同，它们所对应的绑定变量名称是可以相同的。

    动态SQL也可以使用绑定变量，关键字“returning”可以和带绑定变量的目标SQL连用，其目的是把受该SQL 影响的行记录的对应字段取出来。

    可以简单地将 PL/SQL看作 Orade 数据库中专门用来处理 PL/SQL代码中除 SQL语句之外所有到余部分的子系统，而 SQL则是 Orade 数据库中专门用来处理 SQL语句的子系统．这里的 PL/SQL引擎和 SQL 引擎上下文切换就是指它们之间的交互．PL/SQL中的批量绑定的优势在于它是一次处理一批数据．而不是常规方式那样一次只处理一条致据，所以它能够有效减少 PL/SQL引擎和 SQL引擎上下文切换的次数。


绑定变量的使用原则和最佳实践
        对于绑定变量，推荐的使用原则为：依据应用系统的类型来决定是否使用绑定变，具体来说就是：．
    1、对于 OLAP/DSS 类型的应用系统，可以不使用绑定变量。
    2、对于 OLTP类型的应用系统，在 SQL 语句中一定要使用绑定变量 ，并且最好是使用批量绑定，即尽可能在前台代码和后台 PL/SQL代码中都使用批量绑定
    3、对干 OLAP和 OLTP混合型的应用系统，如果有循环，不管这个循环是在前台代码还是在后台 PL/SQL代码中．循环内部的 SQL语句一定要使用绑定变量，并且最好是使用批量绑定至于循环外部的 SQL 语句，可以不使用绑定变量。
绑定变量的个数不宜太多
        目标 SQL 的 SQL 文本中的绑定变量个数不宜太多，否则可能会导致目标 SQL 总的执行时间大幅度增长。增长的时间主要耗费在执行目标 SQL 时对每一个绑定变量都用其实际的值来替换（这个过程就是所谓的绑定变量值替换），目标 SQL 的 SQL 文本中的绑定变量的个数越多，这个替换过程所耗费的时间就越长，该 sQL 总的执行时间也就越长。
如何得到已执行的目标SQL中绑定变量的值
        查询视图 V $ SQL_BIND _ CAPTURE 。如果 V $ SQL_BIND _ CAPTURE 中查不到，那么有可能对应的 Shared Cursor 已经被 age out 出 Shared PooI了 ，这时候可以尝试去 AWR Repository 相关的数据字典表 DBA_HIST_SQLSTAT或 DBA_HIST_SQLBIND 中查询。当 Orade 解析和执行含有绑定变量的目标 SQL 时，如果满足如下两个条件之一，则该 SQL 中的绑定变量的具体输入值就会被 Oracle 捕获，并可通过视图V $ SQL_BIND _ CAPTURE查询。
    （1）当含有绑定变量的目标 SQL 以硬解析的方式被执行时。
    （2）当含有绑定变量的目标 SQL 以软解析／软软解析的方式重复执行时，该 SQL 中的绑定变量的具体输入值也可能会被 Oracle 捕获，只不过默认情况下这种捕获操作 Oracle 至少得间隔 15 分钟才会做一次。也就是说当目标 SQL 以软解析／软软解析的方式重复执行时，本次捕获操作和上次捕获操作的时间间隔在默认情况下至少得间隔巧分钟。之所以间隔15分钟，是因为这可以避免频繁捕获而给系统性能带来的负面影响。我们当然希望目标 SQL 每次执行时其绑定变量输入值都被 Oracle 捕获，但这样一来会影响系统性能，二来也没必要（绑定变量窥探在默认情况下己被开启，所以默认情况下对于同一个反复执行的目标 SQL 而言，没必要每次执行时都捕获其绑定变量输入值）。
     Oracle 只会捕获那些位于目标 SQL 的 where 条件中的绑定变量的具体输入值，而对于那些使用了绑定变量的 INSERT 语句，不管该 INSERT 语句是否是以硬解析的方式执行， Oracle 始终不会捕获其 values 子句中对应绑定变量的具体输入值。
Oracle里的游标共享
    游标共享（ Cursor Sharing ）是指Shared Cursor 间的共享，说白了就是重用存储在 Child Cursor 中的解析树和执行计划而不用从头开始硬解析。
    游标共享对于应用系统在数据库端的性能和可扩展性是有至关重要的影响的，因为如果不能重用解析树和执行计划，就意味着同一类型的 SQL 在并发地被不同用户反复执行时每次都会用硬解析（这里“同一类型”的 SQL 是指除 SQL 文本中对应的输入值不同外，其他部分都一模一样的目标 SQL ）。
    常规游标共享
    当开启了常规游标共享后， Oracle 在实际解析目标 SQL 之前，会先用系统产生的绑定变量来替换目标 SQL 的 SQL 文本中 where 条件或者 values 子句（适用于 INSERT 语句）中的具体输入值，这样替换后实际执行的 SQL 就已经是使用了绑定变量的改写后的等价 SQL ，同时因为这个替换过程是 Oracle 帮你做的，所以常规游标共享就可以做到既有效降低系统硬解析的数量又对应用透明。
    Oracle数据库中的常规游标共享受参数 CURSOR_SHARING 的控制，其值可以被设置为 EXACT 、 SIMILAR 或 FORCE ，它们各自的含义为如下所示。 
    （1） EXACT 是CURSOR_SHARING的默认值，当CURSOR_SHARING的值为 EXACT 时， Oracle 不会用系统产生的绑定变量来替换目标 SQL 的 SQL 文本中 where 条件或者 values 子句（适用于 INSERT 语句）中的具体输入值。
    （2）当 CURSOR _ SHARING 的值为 sIMILAR 时， Oracle 会用系统产生的绑定变量来替换目标
SQL的SQL文本中 where 条件或者values子句（适用于 INSERT 语句）中的具体输入值，但这里替换归替换，替换后同一类型的 SQL 在并发地被不同的用户反复执行时是否能重用解析树和执行计划却是不一定的。因为当CURSOR _ SHARING 的值设为 SIMILAR 后， Oracle 只会对那些它认为是安全的谓词条件在替换后重用解析树和执行计划，对于它认为的不安全的谓词条件，即便用系统产生的绑定变量替换后的 SQL 文本是一模一样的，对于每一个不同的输入值， Oracle 都会执行一次硬解析，即此时会出现一个 Parent Cursor下挂一堆 Child Cursor 的现象，而这些Child Cursor中存储的解析树和执行计划很可能是一样的。
   （3） FORCE 和 SIMILAR 一样，当CURSOR _ SHARING的值为 FORCE 时， oracle 也会用系统产生的绑定变量来替换目标 SQL 的 SQL 文本中 where 条件或者 values 子句（适用于 INSERT 语句）中的具体输入值。但和 SIMILAR 不同的是，不管是“安全的谓词条件”还是“不安全的谓词条件”，当 CURSOR SHARING 的值为 FORCE 时，替换后同一类型的 SQL 总是会无条件地重用之前硬解析时的解析树和执行计划（注意，因为自适应游标共享的引入，这种行为不再适用于 Oracle 119 及其后续的版本）。
    总结来看SIMILAR 是一个即将过时的值，它有太多的副作用，无论什么时候都不要将CURSOR _ SHARING 的值设为 SIMILAR 。，如果想在不改一行应用代码的情况下，使那些仅仅是 SQL 文本中的 where 条件或者 values 子句（适用于 INSERT 语句）中的具体输入值不同的目标 SQL 共享解析树和执行计划，以达到有效降低系统硬解析数量的目的，那就将 CURSOR SHARING 的值设成 FORCE 吧，虽然这不是最理想的方案（最理想的方案当然还是修改应用的代码，在 SQL 语句里使用绑定变量，并且尽可能使用批量绑定），但这也许是最省事的方案。
---------------------
作者：PursueDreamZ
来源：CSDN
原文：https://blog.csdn.net/qq_34409900/article/details/80833783
版权声明：本文为博主原创文章，转载请附上博文链接！

基于Oracle的SQL优化--学习（十一）
2018年07月02日 15:47:29 PursueDreamZ 阅读数：71
绑定变量窥探
        当绑定变量窥探被启用后，每当 Oracle 以硬解析的方式解析使用了绑定变量的目标 SQL 时， Oracle 都会实际窥探（ Peeking ）一下对应绑定变量的具体输入值，并以这些具体输入值为标准，来决定这些使用了绑定变量的目标 SQL 的 where 条件的 Selectivity 和 Cardinality 的值，并据此来选择该 SQL 的执行计划。注意，这里这个“窥探（ Peeking ) ”的动作只有在硬解析的时候才会执行，当使用了绑定变量的目标 sQL 再次执行时
（此时对应的是软解析／软软解析），即便此时对应绑定变量的具体输入值和之前硬解析时对应的值不同， Orade 也会沿用之前硬解析时所产生的解析树和执行计划，而不再重复执行上述“窥探”的动作。
        让 oracle 的表执行 DDL 再次执行目标 SQL 时使用硬解析的方法有很多，其中很常见的一种方法是对目标操作。因为一旦对某个表执行了 DDL 操作，库缓存中所有在 SQL 中所涉及 Cursor 都会被 oracle 标记为失效（ invalid ) ，这意味着这些 Shared Cursor 被重用，所以当 Oracle 再次执行与这个表相关的 SQL 时就会使用硬解析 SQL 文本中包含了这个表的 Shared 中存储的解析树和执行计划将不再能重用，所以再执行目标SQL时就会使用硬解析。DDL 操作有很多种，通常会选择添加注释的 COMMENT 语句，因为使用 COMMENT 添加注释操作，但同时它的杀伤力和对生产环境的影响又微乎其微。
        使用 DBMS_SHARED POOL.PURGE 可以做到让Oracle只在执行目标SQL时进行硬解析。 DBMS_SHARED POOL.PURGE 是从 oracle 10 . 2 . 0 . 4 它可以用来删除指定的缓存在库缓存中的 Shared Cursor。 DBMS_SHARED POOL.PURGE  可以让 oracle 在执行目标 SQL 时使用硬解析的原理是显而易见的 ― 如果某个 SQL 对应的 Shared Cursor 被删除了， oracle 再次执行该 SQL 时自然就会使用硬解析。
绑定变量分级
        绑定变量分级（ Bind Graduation ）是指 oracle 在 PL / SQL 代码中会根据文本型绑定变量的定义长度而将这些文本型绑定变量分为四个等级。
    （1）定义长度在 32 字节（ Byte ）以内的文本型绑定变量被分在第一个等级。
    （2）定义长度在 33 一 128 字节之间的被分在第二个等级。
    （3）定义长度在 129 一 2 , 000 字节之间的文本型绑定变量被分在第三个等级。
    （4）定义长度在 2000 字节以上被分在第四个等级。
        在执行目标 SQL 时，对目标 SQL 中的每一个绑定变量 oracle 都要用其实际的值来替换，所以该 SQL 的 Session Cursor 必须为这些绑定变量在 PGA 中预留一定长度的内存，这个预留的内存空间必须能够容纳这些绑定变量实际的值。当然，这里最理想的方式就是预留的内存空间恰好等于这些绑定变量的定义长度，但这样一来 Orade 处理起来就会比较麻烦（因为绑定变量的定义长度千差万别）。为了简化处理流程， Oracle 就分了上述四个等级，这样一来，不管目标 SQL 中文本型的绑定变量的定义长度为多少， Oracle 只需要对不同等级的文本型绑定变量分别分配固定大小的内存空间就可以了。


 自适应游标共享
    绑定变量窥探的副作用就在于，使用了绑定变量的目标 SQL 只会沿用之前硬解析时所产生的解析树和执行计划，即使这种沿用完全不适合于当前的情形．在 Oracle 10g及其后续的版本中， Oracle 会自动收集直方图统计信息，这意味着与之前的版本相比，在Oracle 10g 及其后续的版本中 Orade 有更大的概率会知道目标列实际数据的分布情况，也就是说绑定变量窥探的副作用将会更加明显。
    自适应游标共享可以让使用了绑定变量的目标 SQL 在启用了绑定变量窥探的前提条件下，不再只沿用之前硬解析时所产生的解析树和执行计划，也就是说自适应游标共享可以在启用了绑定变量窥探的前提条件下，让目标 SQL 在其可能的多个执行计划之间“自适应”地做出选择，而不再像之前那样必须得刻板地沿用该 SQL 硬解析时所产生的解析树和执行计划。

    Oracle 只需要在它认为目标 SQL 的执行计划可能发生变化时，触发该 SQL 再做一次硬解析就好了。因为一旦触发了硬解析这个动作， Oracle 就会将目标 SQL 重新再解析一遍，其中就包括对该 SQL 再做一次绑定变量窥探。显然，再做一次绑定变量窥探后所对应的执行计划就是当前情形下 CBO 认为的最优执行计划，这个执行计划很可能和该 SQL 硬解析时所产生的执行计划不一样了。也就是说，一个简单的适时触发目标 SQL 再做一次硬解析的动作就在一定程度上缓解了绑定变量窥探所带来的副作用。
    Oracle 会根据执行目标 SQL 时所对应的 runtime 统计信息（比如所耗费的逻辑读和 CPU 时间，对应结果集的行数等）的变化，以及当前传入的绑定变量输入值所在的谓词条件的可选择率，来综合判断是否需要触发目标 SQL 的硬解析动作。对于这一点，我们会在阐述自适应游标共享的整体执行流程时详细说明。
    自适应游标共享要做的第一件事就是所谓的扩展游标共享（ Extended Cursor Sharing ) ，而扩展游标共享做的主要事情就是将目标 SQL 所对应的 Child Cursor 标记为 Bind Sensitive 。所谓“ Bind Sensitive " ，就是指 oracle 觉得某个含绑定变量的目标 SQL 的执行计划可能会随着所传入的绑定变量输入值的变化而变化。当满足如下三个条件时，目标 SQL 所对应的 Child Cursor 就会被 oracle 标记为 Bind Sensitive 。
    （1）启用了绑定变量窥探。
    （2）该 SQL 使用了绑定变量（不管是该 SQL 自带的绑定变量，还是开启常规游标共享后系统产生的绑定变量）。 
    （3） 该 SQL 使用的是不安全的谓词条件（例如范围查询，目标列上有直方图统计信息的等值查询等）。
    自适应游标共享要做的第二件事情就是将目标 SQL 所对应的 Child Cursor 标记为 Bind Aware 。所谓“ Bind Aware " ，就是指 Oracle已经确定某个含绑定变量的目标 SQL 的执行计划会随着所传入的绑定变量输入值的变化而变化。当满足如下两个条件时，目标 SQL 所对应的 Child Curso ：就会被Oracle 标记为 Bind Aware . 
    （1）该 SQL 所对应的 Child Cursor 在之前已经被标记为 Bind Sensitive 。
    （2）该 SQL 在接下来连续两次执行时，所对应的 runtime 统计信息与该 SQL 之前硬解析时所对应的 runtime统计信息存在较大的差异。
    对于自适应游标共享而言，V$SQL中的列IS_BIND_SENSITIVE、IS_BIND_AWARE和IS_SHAREABLE分别用来表示ChildCursor是否是BindSensitive、BindAware和共享的。这里“共享”的含义是指存储在该ChildCursor中的解析树和执行计划是否能被重用，一个非共享的ChildCursor中存储的执行计划和解析树是不能被重用的，并且该ChildCursor也会在第一时间被ageout出SharedPool。
    与自适应游标共享相关的有两个重要视图，分别是V$SQL_CS_STATISTICS和V$SQL_CS_SELECTIVITY。
    V$SQL_CS_STATISTICS用于显示指定ChildCursor中存储的runtime统汁信息。V$SQL_CS_SELECTIVITY用于显示指定的、已经被标记为BindAware的ChildCursor中存储的含绑定变量的谓词条件所对应的可选择率的范围。当一个被标记为BindAware的ChildCursor所对应的目标SQL再次被执行时，Oracle就会比较当前传入的绑定变量值所在的谓词条件的可选择率，以及该SQL之前硬解析时同名谓词条件在V$SQL_CS_SELECTIVITY中对应的可选择率的范围，并以此来决定此时的执行是用硬解析还是软解析/软软解析。
    Oracle数据库中自适应游标共享的整体执行流程为如下所示。
    (1)当目标SQL第一次被执行时，Oracle会用硬解析，同时Oracle会根据一系列条件（如该SQL有没有使用绑定变量，参数CURSOR_SHAR〖NG的值是多少，绑定变量所在的列是否有直方图，该SQL的where条件是等值查询还是范围查询等）来判断是否将该SQL所对应的ChildCursor标记为BindSensitive。对于标记为BindSensitive的ChildCursor,Oracle会把执行该SQL时所对应的runtime统计信息额外地存储在该SQL所对应的ChildCursor中。
    (2)当目标SQL第二次被执行时，Oracle会用软解析，并且会重用该SQL第一次执行时所产生的ChildCursor中存储的解析树和执行计划。
    (3)当目标SQL第三次被执行时，如果该SQL所对应的ChildCursor已经被标记成了BindSensitive，同时Oracle在第二次和第三次执行该SQL时所记录的runtime统计信息和该SQL第一次硬解析时所记录的runtime统计信息均存在较大差异，则该SQL在第三次被执行时就会使用硬解析，Oracle此时会产生一个新的ChildCursor(这个新的ChildCursor会挂在原ParentCursor下），并且Oracle会把这个新的ChildCursor标记为BindAware。

    (4)对于标记为BindAware的ChildCursor所对应的目标SQL，当该SQL再次被执行时，Oracle就会根据当前传入的绑定变量值所对应的谓词条件的可选择率，来决定此时是用硬解析还是用软解析/软软解析。这里的判断原则是，如果当前传入的绑定变量值所在的谓词条件的可选择率处于该SQL之前硬解析时同名谓词条件在V$SQL_CS_STATISTICS中记录的可选择率的范围之内，则此时Oracle就会使用软解析/软软解析，并重用相关ChildCursor中存储的解析树和执行计划，反之则是硬解析。
    另外，如果是硬解析，且该次硬解析所产生的执行计划和原有ChildCursor中存储的执行计划相同，则Oracle此时除了会新生成一个ChildCursor之外，还会把存储相同执行计划的原有ChildCursor标记为非共享(原有ChildCursor在V$SQL中对应记录的列1S_SHAREABLE的值也会从Y变为N)，在把原有ChildCursor标记为非共享的同时，Oracle还会对新生成的ChildCursor执行一个Cursor合并的过程（这里Cursor合并的含义是指Oracle会合并存储相同执行计划的原有Child Cursor和新生成的Child Cursor）；如果是软解析/软软解析，则Oracle会重用相关Child Cursor中存储的解析树和执行计划。 
---------------------
作者：PursueDreamZ
来源：CSDN
原文：https://blog.csdn.net/qq_34409900/article/details/80889212
版权声明：本文为博主原创文章，转载请附上博文链接！


Oracle里的应用类型
    Session Cursor的生命周期
         Session Cursor是有生命周期的，每个 Session Cursor 在使用的过程中都至少会经历一次 Open、 Parse 、 Bind 、 Execute 、 Fetch 和 Close 中的 一个或多个阶段。
        Session Cursor的生命周期中各个阶段的先后顺序和关联关系可以用下图 来说明。

        作为Oracle数据库中当前Session解析和执行的SQL的载体，Session Cursor的整改生命周期大致可以分为以下9个阶段：
        阶段 1 : Open 
        阶段2 : Parse 
        阶段 3 : Describe （仅适用于查询语句）
        阶段 4 : Define （仅适用于查询语句）
        阶段 5 : Bind （仅适用于使用了绑定变量的目标 SQL ) 
        阶段 6 : Parallelize （仅适用于开启了并行的情形）
        阶段 7 : Execute 
        阶段 8 : Fetch （仅适用于查询语句）
        阶段 9 : Close

        对于査询语句而言，其对应的SessionCursor可能会经历上述所有的9个阶段。当然，如果该査询语句没有使用绑定变量则其对应的SessionCursor就不需要经历阶段5:如果该査询语句没有使用并行査询，则其对应的SessionCursor就不需要经历阶段6。对于DML语句而言，其对应的SessionCursor可能会经历阶段1、2、5、6、7和9。和查询语句一样，如果该DML语句没有使用绑定变量，则其对应的SessionCursor就不需要经历阶段5;如果该DML语句没有使用并行（ParallelDML)，则其对应的SessionCursor就不需要经历阶段6。和查询语句以及DML语句不同，DDL语句的SessionCursor只会经历阶段1和2，也就是说，DDL语句实际上在解析（Parse)完后就已经执行完毕了。
        SessionCursor的Parse阶段大致会做如下事情。
        （1）执行对目标SQL的校验。在这个校验过程中，Oracle会执行对目标SQL的语法、语义和权限的检查。
        （2）执行对目标SQL的查询转换
        （3）执行对目标SQL的查询优化（QueryOptimization)。在这个过程中，Oracle会根据不同的优化器类型，按照不同的判断原则，从执行完查询转换这一步后得到的目标SQL诸多可能的执行路径中选择一条来作为其执行计划。
        SessionCursor的Describe阶段仅适用于查询语句，它用于明确目标SQL所涉及的具体查询列的名称、类型和长度，比如要执行的SQL是“se丨ect*fromemp”，当经过Describe阶段后，Oracle就会知道要执行的SQL实际上是要查询表EMP的所有列（表EMP共有8列，分别为EMPNO、ENAME、JOB、MGR、HIREDATE、SAL、COMM和DEPTNO),以及这些列的名称、类型和长度。
        SessionCursor的Define阶段也只适用于査询语句，它发生在Describe阶段之后，用于决定一组变量在PGA中的位置、大小和数据类型，这组变量用于存储目标SQL的各个具体査询列所对应的查询结果。SessionCursor的Bind阶段只适用于那些在SQL文本中使用了绑定变量的目标SQL，Oracle在执行含绑定变量的目标SQL时，对目标SQL中的每一个绑定变量都要用其实际的值来替换（即所谓的“绑定变量值替换”)，所以Bind阶段要做的事情就是为这些绑定变量在PGA中预留内存空间（预留的空间必须要能够容纳这些绑定变量实际的值），并创建指向这些预留内存空间的指针（这些指针会用于后续的绑定变量值替换）。
        SessionCursor的Execute阶段就是目标SQL的实际执行阶段，这个阶段的执行结果就是目标SQL的执行结果。对于那些在SQL文本中使用了绑定变量的目标SQL而言，Oracle在实际执行该SQL之前会做绑定变量值替换，即对该SQL中的每一个绑定变量都用其实际的值来替换。
        基于Oracle数据库的应用分为如下四种类型：
        应用类型一：不使用绑定变量。
        应用类型二：每次Open、Parse、Bind、Execute、Fetch、Close。
        应用类型三：一次Open+每次Parse、Bind、Execute、Fetch+—次Close。
        应用类型四：一次Open、Parse、Bind+每次Execute、Fetch+—次Close。

    应用类型一的特点是SQL语句没有使用绑定变量，这意味着硬解析的比率会非常高，正因为如此，我们通常把该种类型的应用系统的特点概括为“硬解析”。这里不使用绑定变量的原因通常是因为开发人员并未意识到硬解析的危害，即开发人员并未意识到硬解析会严重阻碍OLTP类型应用系统在数据库端的性能和可扩展性。
    应用类型二的特点是SQL语句使用了绑定变量，同时数据库端参数SESSION_CACHED_CURSORS的值为0,这意味着硬解析的比率与应用类型一相比会少很多，正因为如此，我们通常会把该种类型的应用系统的特点概括为“软解析”。应用类型二由于参数SESSION_CACHED_CURSORS的值为0，所以SessionCursor不能以SoftClosed状态缓存在PGA中，这意味着Oracle在执行该类型应用系统中的每一条SQL语句时，其对应的SessionCursor都需要经历Open、Parse、Bind、Execute、Fetch和Close这些阶段。
    应用类型三的特点是SQL语句使用了绑定变量，而且数据库端参数SESSION_CACHED_CURSORS的值大于0，这意味着这种类型的应用系统中的每一条SQL语句所对应的SessionCursor在经历Execute阶段后，当满足一定的额外条件时（在OraclellgR2中，这个额外条件是该SessionCursor所对应的SQL解析和执行的次数要超过3次），Oracle就不会对上述SessionCursor执行Close操作，而是将其标记为SoftClosed，并将其缓存在当前Session的PGA中。这样做的好处是，当目标SQL再次被执行时，Oracle就不需要为其再生成一个SessionCursor了，只需要从当前Session的PGA中将之前已经被标记为SoftClosed的匹配SessionCursor直接拿过来用就可以了（当然，剩下的Parse、Bind、Execute、Fetch还是需要做的）。所以应用类型三和应用
类型二比起来，可以省掉Open—个新的SessionCursor及Close—个现有SessionCursor所耗费的资源和时间。Oracle可以通过己缓存的SessionCursor中存储的目标SQL对应的ParentCursor的库缓存对象句柄地址，来建立目标SQL的SessionCursor与其ParentCursor之间的联系，这意味着Oracle可以直接通过己缓存的SessionCursor来定位其对应的ParentCursor，而不再需要先持有库缓存相关Latch，然后再去库缓存的相应HashBucket中的库缓存对象句柄链表中査找匹配的ParentCursor。所以在Oracle 11g之前，应用类型三在对库缓存相关Latch的争用方面会比应用类型二要好
       应用类型四的特点为如下所示:
    （1）SQL语句使用了绑定变量。
    （2）数据库端参数SESSION_CACHED_CURSORS的值大于0。
    （3）该类型应用系统通过一些手段（例如在Pro*C/C++代码里通过设置HOLD_CURSOR=YES和RELEASE_CURSOR=NO,或者在PL/SQL代码的循环内部执行目标SQL)，使得每一条SQLi吾句所对应的SessionCursor会反复经历Execute和Fetch，但Open、Parse、Bind和Close只用经历一次。

    总结：使用绑定变量（最好是用批量绑定）来有效的降低系统硬解析的数量，并且将应用系统设计成“一次解析，多次执行”的方式。
Oracle里查询转换的作用
    oracle 里的查询转换，又称为查询改写，它是 oracle 在解析目标 SQL 的过程中的重要一步，其含义是指oracle 在解析目标 SQL 时可能会对其做等价改写，目的是为了能更高效地执行目标 SQL ，即oracle 可能会将目标 SQL 改写成语义上完全等价但执行效率却更高的形式。
oracle 数据库里 SQL 语句的执行过程可以用下图 来表示
---------------------
作者：PursueDreamZ
来源：CSDN
原文：https://blog.csdn.net/qq_34409900/article/details/80901680
版权声明：本文为博主原创文章，转载请附上博文链接！

子查询展开
    子查询展开（SubqueryUnnesting)是优化器处理带子査询的目标SQL的一种优化手段，它是指优化器不再将目标SQL中的子查询当作一个独立的处理单元来单独执行，而是将该子査询转换为它自身和外部查询之间等价的表连接。这种等价表连接转换要么是将子查询拆开（即将该子查询中的表、视图从子查询中拿出来，然后和外部査询中的表、视图做表连接），要么是不拆开但是会把该子査询转换为一个内嵌视图（InlineView),然后再和外部查询中的表、视图做表连接。
    Oracle会确保子查询展开所对应的等价表连接转换的正确性，即转换后的SQL和原SQL在语义上一定是等价的。当然，不是所有的子查询都能做子查询展开，有些子查询是不能做这种等价表连接转换的，这种情况下Oracle就不会对其做子查询展开，也就是说此时Oracle还是会将该子查询当作一个独立的处理单元来单独执行。另外，在Oracle10g及其以后的版本中，对于那种不拆开子查询但是会把该子查询转换成一个内嵌视图的子查询展开（即子查询展开的第二种情形），只有当经过子查询展开后的等价改写SQL的成本值小于原SQL的成本值时，Oracle才会对原SQL执行子查询展开。
    子査询展开通常都会提高原SQL的执行效率，因为如果原SQL不做子查询展开，那么通常情况下该子查询就会在其执行计划的最后一步才被执行，并且会走FILTER类型的执行计划，这也就意味着对于外部查询所在结果集中的每一条记录，该子查询都会被当作一个独立的执行单元来执行一次，外部查询所在的结果集有多少条记录，该子查询就会被执行多少次（可以近似这么理解，实际上并不完全是这样）。这种执行方式的执行效率通常情况下都不会太高，尤其是在子查询中包含两个或者两个以上表连接时，此时做子查询展开后的执行效率往往会比走FILTER类型的执行计划高很多，因为此时优化器就会有其他更多、更高效的执行路径（比如哈希连接）可以选择。
    Oracle数据库里子查询前的where条件如果是如下这些条件之一，那么这种类型的目标SQL在满足了一定的条件后就可以做子查询展开：
    （1）SINGLE-ROW(即=、<、>、<=、>=和?)
    （2）EXISTS
    （3）NOTEXISTS
    （4）IN
    （5）NOTIN
    （6）ANY
    （7）ALL
     如果一个子查询前的where条件是SINGLE-ROW条件，则意味着该子查询的返回结果至多只会返回一条记录；如果该子査询前的where条件是除SINGLE-ROW条件之外的上述其他类型的条件，则该子查询的返回结果就可以包含多条记录。ANY和ALL通常和SINGLE-ROW条件联用，虽然这两个条件我们不常用，但它们的应用范围其实比EXISTS、NOTEXISTS、IN和NOTIN要广很多，比如IN实际上就相当于=ANY,NOT IN实际上就相当于<> ALL。
    子査询是否能做子杳询展开取决于如下两个条件:
    （1）了査询展开所对应的等价改写SQL和原SQL在语义上一定要是完全等价的。如果改写后的SQL和原SQL并不一定能保持语义上的完全等价，这种类型的子查询就不能做子查询展开
    （2）对于不拆开子杳询但是会把它转换为一个内嵌视图的子査询展开，只有当经过子查询展开后的等价改写SQL的成本值小于原SQL的成本值时，Oracle才会对0标SQL执行子查询展开。
    需要注意的是，对于子査询展开的第一种情形（即将子査询拆开，把该子査询中的表、视图从子査询中拿出来，然后和外部査询中的表、视图做表连接），即使是在Oracle10g及其以后的版本中，Oracle也不会考虑子査询展开的成本，即Oracle此时会认为这种情形下子査询展开的效率始终比不展开的效率要离，这也就意味着如果目标SQL满足子査询展开的第一种情形，则Oracle始终会对其做子査询展开，而不管经过子查询展开后的等价改写SQL的成本值是否小于原SQL的成本值。
视图合并
    视图合并（ViewMerging)是优化器处理带视图的目标SQL的一种优化手段，它是指优化器不再将目标SQL中视图的定义SQL语句当作一个独立的处理单元来单独执行，而是会将其拆开，把其定义SQL语句中的基表拿出来与外部査询中的表合并，这样合并后的SQL将只剩下外部查询中的表和原视图中的基表，不再会有视图出现。
    Oracle会确保视图合并的正确性，即合并后的SQL和原SQL在语义上一定是完全等价的。当然，不是所有的视图都能做视图合并，有些视图是不能做视图合并的，这种情况下Oracle就会将该视图的定义SQL语句当作一个独立的处理单元来单独执行。视图合并的好处和子查询展开一样，都是让优化器有更多的执行路径可以选择，而不再拘泥于原视图定义QL语句中的谓词条件、表连接方法、表连接顺序等。    
    Oracle数据库里的视图合并分为简单视图合并、外连接视图合并和复杂视图合并这三种类型。对于符合简单视图合并条件的目标SQL，Oracle始终会对其做视图合并，而不管经过视图合并后的等价改写SQL的成本值是否小于原SQL的成本值。但在Oracle10g及其以后的版本中，对于复杂视图合并，只有等价改写SQL的成本值小于原SQL的成本值时，Oracle才会对目标SQL做复杂视图合并。
简单视图合并

    简单视图合并（SimpleViewMerging)是指针对那些不含外连接，以及所带视图的视图定义SQL语句中不含distinct、groupby等聚合函数的目标SQL的视图合并。
外连接视图合并

    外连接视图合并（OuterJoinViewMerging)是指针对那些使用了外连接，以及所带视图的视图定义SQL语句中不含distinct、groupby等聚合函数的目标SQL的视图合并。这里“使用外连接”的含义是指外部查询的表和视图之间使用了外连接，或者该视图的视图定义SQL语句中使用了外连接。
    外连接会给视图合并带来很多限制，很多在内连接情形下可以做的视图合并一旦换成了外连接就不能做了，因为Oracle能做视图合并的前提条件就是视图合并后的等价改写SQL—定要和原SQL在语义上是完全等价，但对于使用了外连接的目标SQL而言，在很多情况下这种语义上的完全等价性并不能得到保证。
    关于外连接视图合并有一个很常用的限制，即当目标视图在和外部查询的表做外连接时，该目标视图可以做外连接视图合并的前提条件是，要么该视图被作为外连接的驱动表，要么该视图虽然被作为外连接的被驱动表但它的视图定义SQL语句中只包含一个表。
---------------------

复杂视图合并
    复杂视图合并（ComplexViewMerging)是指针对那些所带视图的视图定义SQL语句中含有groupby或distinct的目标SQL的视图合并。

    和简单视图合并、外连接视图合并一样，对这种视图定义SQL语句中含有groupby或distinct的复杂视图做视图合并也同样意味着要把其定义SQL语句拆开，并把其中的基表拿出来和外部査询中的表合并。这通常意味着上述视图定义SQL语句中的groupby或distinct操作会被推迟执行，也就是说，这种情况下通常会先做表连接，再做groupby或distinct操作，而不是像未做复杂视图合并时那样先在视图内部做完groupby或distinct操作，然后才和外部查询中的表做表连接。

    复杂视图合并所对应的这种groupby或distinct操作的延迟，并不一定总是能带来执行效率以及性能上的提升。例如，如果groupby或distinct操作能过滤掉绝大部分的数据且表连接并不能有效过滤数据的话，那么先在视图内部做groupby或distinct操作，然后才和外部查询中的表做表连接的执行效率就会更高一些；但如果表连接能过滤掉绝大部分的数据而groupby或distinct操作并不能有效过滤数据的话，那么先做表连接，再做groupby或distinct操作的执行效率显然会更好一些。

    正是因为复杂视图合并并不一定总是能带来目标SQL的执行效率及性能上的提升，所以在Oracle10g及其以后的版本中，对于复杂视图合并，只有当经过复杂视图合并后的等价改写SQL的成本值小于原SQL的成0本值时，Oracle才会对目标SQL执行复杂视图合并。

    

星型转换
    星型转换（StarTransformation)是优化器处理表连接方法为星型连接的目标SQL时的一种优化手段，它的核心是将原星型连接中针对各个维度表（DimensionTable)的限制条件，通过等价改写的方式以额外的子査询施加到事实表（FactTable)上，然后再通过对事实表上各连接列上已存在的位图索引间的位图操作（如按位与、按位或等），来达到有效减少事实表上待访问的数据量，避免对事实表做全表扫描的目的，这就可以有效缩短原目标SQL的执行时间，提高其执行效率。

    星型转化的核心是将原星型连接中针对各个维度表的限制条件通过等价改写的方式以额外的子查询施加到事实表上，然后再通过对事实表上各个连接列上已存在的位图索引间的位图操作来达到有效减少事实表上带访问的互数据量，避免对事实表做全表扫描。
---------------------
作者：PursueDreamZ
来源：CSDN
原文：https://blog.csdn.net/qq_34409900/article/details/80932212
版权声明：本文为博主原创文章，转载请附上博文链接！

连接谓语推入
   连接谓词推入（JoinPredicatePushdown)是优化器处理带视图的目标SQL的另外一种优化手段，它是指虽然优化器还是会把该SQL中视图的定义SQL语句当作一个独立的处理单元来单独执行，但此时优化器会把原本处于该视图外部査询中和该视图之间的连接条件推入到该视图的定义SQL语句内部，这样做是为了能使用上该视图内部相关基表上的索引，进而能走出基于索引的嵌套循环连接。和之前介绍的各种查询转换一样，连接谓词推入使优化器在选择目标SQL的执行计划时多出了走基于索引的嵌套循环连接这种选择，这就增加了走出更高效执行计划的可能性。
    但是请注意，连接谓词推入所带来的基于索引的嵌套循环连接并不一定能走出更高效的执行计划，因为当做了连接谓词推入后，原目标SQL中的视图就和外部査询产生了关联，同时Oracle又必须将该视图的定义SQL语句当作一个独立的处理单元来单独执行，这也就意味着对于外部查询所在结果集中的每一条记录，上述视图的定义SQL语句都得单独执行一次，这样一旦外部査询所在结果集的Cardinality比较大的话，即便在执行上述视图的定义SQL语句时能用上索引，整个SQL的执行效率也不一定会比不做连接谓词推入时的哈希连接或排序合并连接髙。所以，Oracle在做连接谓词推入时会考虑成本，只有当经过连接谓词推入后走嵌套循环连接的等价改写SQL的成本值小于原SQL的成本值时，Oracle才会对目标SQL做连接谓词推入。
    Oracle是否能做连接谓词推入与目标视图的类型、该视图与外部查询之间的连接类型以及连接方法有关。到目前为止，Oracle仅仅支持对如下类型的视图做连接谓词推入。
    （1）视图定义SQL语句中包含UNIONALL/UNION的视图

    （2）视图定义SQL语句中包含DISTINCT的视图

    （3）视图定义SQL语句中包含GROUP BY的视图

    （4）和外部查询之间的连接类型是外连接的视图

    （5）和外部查询之间的连接方法是反连接的视图

    （6）和外部查询之间的连接方法是半连接的视图

连接因式分解
   连接因式分解（Join Factorization)是优化器处理带UNIONALL的目标SQL的一种优化手段，它是指优化器在处理以UNIONALL连接的目标SQL的各个分支时，不再原封不动地分别重复执行每个分支，而是会把各个分支中公共的部分提出来作为一个萆独的结果集，然后再和原UNIONALL中剩下的部分做表连接。连接因式分解在OraclellgR2中才被引入，它的好处是显而易见的。如果不把UNIONALL中公共的部分提出来，则意味着这些公共部分中所包含的表会在UNIONALL的各个分支中被重复访问；而连接因式分解则能够在最大程度上避免这种重复访问现象的产生，当UNIONALL的公共部分所包含的表的数据量很大时，即便是只减少一次对大表的重复访问，那也意味着执行效率上的巨大提升。 

    在Oracle11gR2及其后续的版本中，即使由于在视图定义SQL语句中包含了集合运算符UNIONALL而导致Oracle不能对其做视图合并，Oracle也不一定会把该视图的定义SQL语句当作一个整体来单独执行，因为此时Oracle还可能会对其做连接因式分解。这里需要注意的是，Oracle对包含UNIONALL的目标SQL做连接因式分解的前提条件是，连接因式分解后的等价改写SQL和原SQL在语义上完全等价，如果不能满足这一点，那么Oracle就不会做连接因式分解。

    

表扩展
   表扩展（TableExpansion)是优化器处理针对分区表的目标SQL的一种优化手段，它是指当目标SQL中分区表的某个局部分区索引由于某种原因在某些分区上变得不可用（索引状态为UNUSABLE)时，Oracle能将原目标SQL等价改写成按分区UNIONALL的形式，这样除了那些不可用的分区所对应的UNIONALL分支之外，其他分区所对应的UNIONALI：分支还是可以正常使用该局部分区索引。

    我们都知道，当查询的数据只是全部数据中的少部分时，使用索引确实能极大提高查询的速度，但索引的维护必然会同时减慢相关DML操作的执行速度，所以使用索引是有副作用的。有的系统的业务特点就是要尽可能快地往目标表的当前分区中导入数据，其修改的数据也仅限于该表中处于当前分区的活动数据，同时还会有针对目标表的査询，这个査询并不局限于当前分区。针对这种类型的系统,为了尽可能快地对当前分区执行DML操作，往往人为地把当前分区的局部分区索引的状态设为UNUSABLE,这样就省去了对当前分区执行DML操作时同步维护相关局部分区索引的成本，所以这样做是能够提高相关DML操作的速度的。但现在的问题是，在OraclellgR2之前，这样做会导致所有原本可以使用该局部分区索引的査询语句都无法正常使用该局部分区索引。。


表移除
   表移除是优化器处理带多表连接的目标SQL的一种优化手段，它是指优化器会把虽然在目标SQL中存在，但是其存在与否对最终执行结果没有影响的表从该目标SQL中移除，这样优化器至少可以少做一次表连接，进而就能提高原目标SQL的执行效率。

Oracle如何处理SQL语句中的IN
   优化器在处理带IN的目标SQL时，可能也会用到査询转换，也即本节要介绍的IN-ListExpansion(又称为ORExpansion，两者等价）。为了能让大家明白IN-ListExpansion的优缺点，本节除了会介绍IN-ListExpansion之外，还会介绍优化器在处理带IN的目标SQL时可能会使用的其他方法。在Oracle数据库里，IN和OR是等价的，优化器在处理带IN的目标SQL时实际上会将其转换为带OR的等价改写SQL,也就是说，本节介绍的处理带IN的目标SQL的方法也同样适用于带OR的目标SQL。

    优化器在处理带IN的目标SQL时，通常会采用如下这四种方法:
    （1）使用IN-List Iterator。
    （2）使用IN-List Expansion。
    （3）使用IN-List Filter。
    （4）对IN做子査询展开，或者既做子查询展开又做视图合并。

IN-List Iterator

    IN-List Iterator是针对IN后面是常量集合的一种处理方法。此时优化器会遍历目标SQL中IN后面的常量集合中的每一个值，然后去做比较，看目标结果集中是否存在和这个值匹配的记录。如果存在匹配记录，则这个记录就会成为该SQL的最终返回结果集中的一员；如果不存在匹配记录，则优化器会继续遍历IN后面的常量集合中的下一个值，直到该常量集合遍历完毕。
关于IN-ListIterator，有如下几点需要注意：
（1）IN-ListIterator是Oracletf对目标SQL的IN后面是常量集合的首选处理方法，它的处理效率通常都会比IN-ListExpansion高。

（2）Oracle能用IN-ListIterator来处理IN的前提条件是IN所在的列上一定要有索引。

（3）不能强制让Oracle走IN-ListIterator类型的执行计划，Oracle里也没有相关的强制走IN-ListIterator的Hint,但可以通过联合设置10142和10157事件来禁掉IN-ListIterator。


IN-List Expansion/OR Expansion

   IN-List Expansion/OR Expansion(IN-List Expansion又称为OR Expansion，两者等价）是针对IN后面是常量集合的另外一种处理方法，它是指优化器会把目标SQL中IN后面的常量集合拆开，把里面的每个常量都提出来形成一个分支，各分支之间用UNIONALL来连接，即IN-ListExpansion的本质是把带IN的目标SQL等价改写成以UNIONALL连接的各个分支。

    IN-List Expansion的好处是改写成以UNIONALL连接的分支后，各个分支就可以各自走索引、分区修剪(PartitionPruning)、表连接等相关的执行计划而互不干扰。它的坏处是未做IN-ListExpansion之前优化器只需要解析一个目标SQL并决定其执行计划，而一旦做了IN-ListExpansion后优化器就要对等价改写后的每一个UNIONALL分支都执行同样的解析、决定执行计划的工作，也就是说，等价改写后的目标SQL的解析时间会随着UNIONALL分支的递增而递增。这意味着当IN后面的常量集合所包含的元素数量非常多的时候，做IN-ListExpansion仅解析的时间可能就会非常长，这就是IN-ListIterator通常会比FN-ListExpansion的效率高的原因。正是基于上述原因，做了IN-ListExpansion的等价改写SQL的执行效率并不一定会比原SQL高，这也就意味着IN-ListExpansion—定也是基于成本的，即只有当经过IN-ListExpansion后的等价改写SQL的成本值小于原SQL的成本值时，Oracle才会对目标SQL执行IN-ListExpansion。

IN-List Filter

    IN-List Filter是针对IN后面是子查询的一种处理方法，优化器会把IN后面的子査询所对应的结果集当作过滤条件，并且走FILTER类型的执行计划IN后面是子查询，意味着IN后面是变量的集合；走的是FILTER类型的执行计划，意味着Oracle并没有对IN后面的子査询做子查询展幵。所以，能走IN-ListFiltei类型的执行计划就意味着目标SQL要满足如下两个条件：

    （1）目标SQL的IN后面是子査询而不是常量的集合。
    （2）Oracle未对目标SQL的IN后面的子査询做子査询展开。


二SQL优化Road Map 
 

一条SQL的优化路线图如下所示：

具体操作步骤：

2.1 制定SQL优化目标

获取待优化SQL、制定优化目标：从AWR、ASH、ORA工具等主动发现有问题的SQL、用户报告有性能问题DBA介入等，通过对SQL的执行情况进行了解，先初步制定SQL的优化目标。

2.2 检查执行计划
explain工具、sql*plus autotrace、dbms_xplan、10046、10053、awrsqrpt.sql等。 执行计划是我们进行SQL优化的核心内容，无计划，不优化。看执行计划有一些技巧，也有很多方式，各种方式之间是有区别的。

2.3 检查统计信息

ORACLE使用DBMS_STATS包对统计信息进行管理，涉及系统统计信息、表、列、索引、分区等对象的统计信息，统计信息是SQL能够使用正确执行计划的保证。我们知道，ORACLE CBO优化器是利用统计信息来判断正确的执行路径，JOIN方式的，因此，准确的统计信息是产生正确执行计划的首要条件。
可以从这个图看出，一条SQL产生执行计划需要经过哪些步骤，在我看来：1、正确的查询转换；2、准确的统计信息，是产生正确执行计划的重要保证。当然，还有BUG，或优化器限制等也会导致SQL效率低下，无法产生正确的执行计划。

如图所示：

2.4 检查高效访问结构

重要的访问结构，诸如索引、分区等能够快速提高SQL执行效率。表存储的数据本身，如碎片过多、数据倾斜严重、数据存储离散度大，也会影响效率。

2.5 检查影响优化器的参数

optimizer_mode、optimizer_index_cost_adj、optimizer_dynamic sampling、_optimizer_mjc_enabled、_optimizer_cost_based_transformation、hash_join_enable等对SQL执行计划影响较大。比如有时候我们通过禁用_optimizer_mjc_enabled 参数，让执行计划不要使用笛卡尔积来提升效率，因为这个参数开启有很多问题，所以一般生产库都要求禁用。

还有什么能够影响执行计划呢？对，new features,每个版本的new features，引入的目的都是好的，但是实际使用中，可能触发BUG。比如11g的ACS(自适应游标共享）、automatic serial direct path（自动串行直接路径读）、extended statistics、SQL query result cache等。有的新特性会导致问题，所以需要谨慎使用。

比如11g adaptive cursor sharing,自适应游标共享，它的引入是为了解决使用绑定变量与数据倾斜值，要产生多样性执行计划。因为绑定变量是为了共享执行计划，但是数据倾斜了，有的值要求走索引，有的值要求走全表，这样与使用绑定变量就产生了矛盾。以前是通过cursor_sharing=similar这样的设置可以解决，但是有很多BUG，会产生version count过高的问题，或者我们对不同的值（如果值很少），可以写多条SQL来解决，这都不是好的方案，11g acs引入就是为了解决这些问题，让这些东西交给oracle来做。但是事与愿违，以后你们遇到执行计划一会变一下，有快有慢，首先可以检查acs有没有关闭。

 

alter system set “_optimizer_extended_cursor_sharing_rel”=’NONE';

 

2.6 SQL语句编写问题

 

SQL语句结构复杂、使用了不合理的语法，比如UNION代替UNION ALL都可能导致性能低下。 并不是说ORACLE优化器很强大了，我们就可以随便写SQL了，那是不正确的。SQL是一门编程语言，它能够执行的快，是有一些普遍的规则的，遵循这种编程语言特性，简化语句，才能写出好的程序。SQL语句编写出了问题，我们就需要改写，就需要调整业务，改涉及等。

 

2.7 SQL优化器限制导致的执行计划差

 

这个很重要，统计信息准确，SQL也不复杂，索引也有。。。都满足，为什么我的SQL还是差，那么得考虑优化器限制因素了。这里说1点常见的执行计划限制，当semi join与or连用的时候（也就是exists(subquery) or ...或者in (subquery) or...，如果执行计划中因为OR导致有FILTER操作符，就得注意了，可能慢的因素就和OR有关。这时候我们得改写SQL，当然改写为UNION或UNION ALL了。

 

OK，以上全部检查完毕，我的系统还是很差，功能还是很慢，或者已经无法从SQL本身进行调整提升性能了，那咋办？优化设计，这是终极方法。有些东西不优化设计是无法解决的，比如业务高峰期跑了一堆SQL，CPU已经很吃紧，又不给增加，突然上线一个耗资源的业务，其他SQL已无法调整。那只能优化设计，比如有些耗资源的业务可以换时间段执行等。

 

以上几点，是我们进行优化需要考虑的地方，可以逐步检查。当然，80%到90%的纯SQL性能调整，我们通过建立索引，收集正确统计信息，改写避免优化器限制，已经能够解决了。

 

三SQL优化案例 
 

看第一个获取待优化的SQL.......如果主动优化，一般从AWR、ASH等里面找到性能差的SQL，然后优化之。

 



 



 

看一个案例，占CPU 72%的SQL来自于同一模块，第一行是存储过程，通过下面绿色框住的SQL与第一行比较，主要通过EXECUTION，基本判断下面的绿色框住的SQL就是那个存储过程中的。也可以和业务确认下，OK，这些SQL的执行频次很高，因为是营销业务，如果要优化，就得搞定这些SQL。

 

这些SQL，单条SQL的buffer gets也就1000多点，效率还是很高的，但是因为执行的太过于频繁，所以资源消耗极大，因此，得检查下，能不能更优呢？

 

以第1条SQL：58q183atbusat为例：

 

SELECT B.ACT_ID,

B.ACT_NAME,

B.TASK_ID,

B.MKT_DICTION,

B.CUST_GROUP_ID,

NVL(B.ATTEST_FLAG, 'N'),

NVL(B.DOUWIN_FLAG, 'N'),

B.CHN_DESC,

NVL(B.SIGN_FLAG, 'N'),

B.MAX_EXECUTE_NUM

FROM (SELECT DISTINCT (ACT_ID)

FROM MK_RULECHN_REL

WHERE CHN_STATUS = '04'

AND CHN_TYPE = :B1) A,

TABLE(CAST(:B2 AS TYPE_MK_ACTIONINFO_TABLE)) B

WHERE A.ACT_ID = B.ACT_ID

 

SQL其实很简单，一个查询构建的A表，一个TABLE函数构建的B表关联..... 不知道大家对这个TABLE函数熟悉不熟悉？也就是将一个集合转成表，是PL/SQL里的东西

那个collection部分就是TABLE函数，下面的表走了全表扫描：

 



 



 

按步骤检查，发现不了问题，但是知道，可能是因为HASH JOIN导致全表扫描的问题，是否走NESTED LOOPS+INDEX更好，很显然，要检查TABLE函数大概返回多少行。

 

经过确认，最多也就返回200-300行，最终结果集也是几百行而已。

 

那么猜测，问题就在于TABLE函数，走了HASH JOIN，上面的执行计划，TABLE函数部分，ROWS为空。

 

来单独检查一把：返回8168行，返回8000多行，足以导致走HASH JOIN了....而事实，我们至多返回200-300行：

 



 

所以每个步骤返回的行，是JOIN方式选择的重要因素，可以谷歌一把，TABLE函数返回8168就是个固定值，block_size=8K的时候就是这么大，可以说，这是ORACLE的一个限制。

 



 

只要你用了TABLE函数，就偏向于走HASH JOIN了

http://www.oracle-developer.net/display.php?id=427 有兴趣的可以看这个链接的内容。

 

解决方式很多了，也就是要走NESTED LOOPS+index, 既然8168很大，那么我们就让优化器知道TABLE函数返回的行少点，才百行左右。

 

以下些都可以，当然也可以使用hint:use_nl等

CARDINALITY hint (9i+) undocumented;

OPT_ESTIMATE hint (10g+) undocumented;

DYNAMIC_SAMPLING hint (11.1.0.7+);

Extensible Optimiser (10g+).

 

因为SQL的SELECT部分只访问B，全部来自于TABLE函数，所以改写为子查询就可以了，使用子查询，自然distinct也就没有必要了，因为是semi join(半连接）。

 

最终改写使用cardinality hint让优化器知道B返回的行只有100行，你给我走NESTED LOOPS+INDEX，然后解决。

 

原来的sql：

 



 

修改后的sql：

 



 

效率提升几十倍：

 



 

一个占72%的应用，我们提升几十倍后，那对系统性能明显是极好的。最终，在执行次数增加50%的情况下，w4sd08pa主机CPU使用率由原来的高峰期平均47%的使用率降低为23%。

 

这个问题能够解决有两个方面：

 

1、猜测并测试优化器的限制（table函数固定返回行8168)；2、实际返回的行200-300。两者缺一不可。如果实际返回的行就是几千上万，那么，单纯通过优化SQL，也是无法取得良好效果的。

 

四SQL执行计划获取 
 

执行计划就是SQL调优的核心，上面的SQL也是通过看到执行计划走HASH JOIN可能有问题出发的。

 



 

那么首先要搞定2个问题：

 

1、如何获取我要的执行计划（准确的计划）；

2、怎么看懂并找出执行计划里的问题。

 

4.1 如何获取准确的执行计划

 

获取SQL执行计划的方式：

EXPLAIN PLAN

估算

忽略绑定变量

非执行

SQL_TRACE

真实计划，需要用TKPROF工具解析

可以获得绑定变量值

EVENT 10053

真实计划

研究执行计划产生的原因

AUTOTRACE

内部使用EXPLAIN PLAN

DBMS_XPLAN

dbms_xplan.display_cursor

dbms_xplan.display_awr

真实计划

OTHERS

如awrsqrpt、sqlt、pl/sql、sql developer、toad等

 

大家一般怎么获取执行计划？我一般用的较多的是dbms_xplan.display_cursor，优点很明显：1、获取的是真实执行的计划；2、多种参数。还可以获取绑定变量的值方便验证。

 

10053是检查优化器行为的，实在搞不懂为什么走那个计划可以看看，用得较少。

 

10046可以检查一些等待事件的内容，也可以获取绑定变量，一般用得也比较少。

 

set autotrace traceonly或者explain,他们的执行计划是同一来源，记住，都来自plan_table，是估算的，可能不是真实执行的计划，可能是不准的。

 

所以，你看得不对劲了，就得质疑它的准确性，autotrace traceonly的好处是可以看到一致性读，物理读，返回行等，这是真实的。因为可以用一致性读，物理读来验证优化效果

 

其他的，比如awrsqrpt等都可以获取执行计划，不过我很少用，特别是plsq developer这种工具，F5看计划，我几乎是不用的，他也是plan table里的估算计划。如果很长，那无法分析。

 

建议大家看真实的计划，说一点，我经常通过alter session set statistics_level=all或者gather_plan_statistics hint，然后执行sql,然后通过

select * from table(dbms_xplan.display_cursor(null,null,'allstats last'));来看实际执行的信息

好处很明显，能够看到执行计划每步的E-ROWS（估算的行）,A-ROWS（真实的行）,STARTS,BUFFER GETS，A-TIME（真实的执行时间）等信息。。。我们通过对比估算的与真实的差距，可以判断哪些表统计信息可能有问题，执行计划是不是走错了，省的我们自己根据谓词去计算这步导致返回多少行。

 

注意一点，如果一SQL执行很长时间，通过上面的方式来看计划，我们是可以终止的，比如执行2小时执行不玩的SQL，一般我没有耐心，最多5分钟，我就终止。终止完，通过display_cursor也是可以看出执行信息的。

比如某个步骤执行100万次，我这条SQL才能执行完，要3小时才可以，我5分钟执行了100次，我终止了SQL我要看的就是一个比例情况，可以通过这个比例来判断，哪个步骤耗的时间最长，哪里大概有问题，然后解决。

 

优化器很多限制的，比如刚才的TABLE函数固定返回8168，或者算法限制.....很多不准的，如果算法算出来的与真实差别很大，那可能就会导致问题。统计信息有时候也无法收集准确的，比如直方图，就有很多问题，所以12c的直方图多了几种....之前只有等高和等频直方图。

 

刚才的set statistics_level直接写会输出结果，我们可以让他不输出结果：

 

1、sql内容放到文件中，前面加上set termout off （这样可以对输出结果不输出）

2、然后display_cursor文件中

 



 

用这种东西看执行计划，有时候很方便找出问题,否则我们自己得手动根据每个步骤对应的谓词，自己写SQL去计算真实返回的行，然后再来比较，用这个，ORACLE全帮我们干好了。

 

4.2  看懂执行计划执行顺序

 

一般怎么看执行计划呢？

 



 

COPY到UE里去。

 



 

用光标大法，找到入口，最先执行的，光标定位ID=0的，然后一直缩进向下，如果被挡住了，那么这部分就是入口了。

 

比如ID=10的继续索引，就被ID=11的挡住了，所以第10步就是入口。

 



 

找到入口后，反向光标来，利用平行级别的最上最先执行，最右最先执行原则，来看父操作与子操作的关系，移动光标即可。

 

比如这里的第13步，我只需要定位光标在PARTITION这个P前面，然后向上移动，立马就知道，它的驱动表是ID=5的VIEW，因为他们是对齐的。

 



 

然后看看之间的JOIN关系是不是有问题，返回的行估算等。

 

执行计划最右最上最先执行规则，有个例外，大家知道不？？就是通过以上规则，是不正确的。

（标量子查询）

 

SELECT a.employee_id,

a.department_id,

(SELECT COUNT(*) FROM emp_b b

WHERE a.department_id=b.department_id

) cnt

FROM emp_a a;

 

比如这个ID=2的在前面，但是它事实上是被ID=3的驱动的，也就是被emp_a驱动的，这违背了一般的执行计划顺序规则，平时注意点就行了，标量子查询谓词里会出现绑定变量，比如这里的：B1，因为每次带一个值去驱动子查询。

 



 

搞清楚执行计划怎么干，那么看执行计划看啥？

 

1、看JOIN的方式

2、看表的访问方式，走全表，走索引

3、看有没有一些经常影响性能的操作，比如FILTER

4、看cardinality(rows)与真实的差距

 

不要太过于关注COST，COST是估算的，大不一定就慢，小不一定就快……当然比如COST很小，rows返回的都是很小的，很慢。那么，我们可能得考虑统计信息是不是过旧问题。

 

统计信息很重要，就说一个例子：

 



 

走了索引，COST很小，一切都很完美，但是AWR现实占80%的资源。一般啥情况？单纯从SQL上看，也就是这执行计划估计不对，自己测一下，很慢。也就是COST很小，ROWS很小，走索引，很完美的计划是错误的，那么很显然，基本就是统计信息导致的了。

 

实际第4步走sendtime索引，应该返回1689393行，但是执行计划估算返回1行，统计信息不准确，再次检查统计信息收集日期是5月前的。

 

SQL> SELECT COUNT(1) FROM MSP.T_MS_MEDIA_TASK WHERE SENDTIME >=TRUNC(SYSDATE,'dd') AND MONTHDAY = TO_CHAR(SYSDATE,'mmdd') ;

? COUNT(1)

----------

? ?1689393

 

收集统计信息，for all columns size repeat 保持原有直方图信息

 

?exec DBMS_STATS.GATHER_TABLE_STATS(ownname=>'MSP',tabname=>'T_MS_MEDIA_TASK',estimate_percent=>10,method_opt=>'for all columns size repeat', no_invalidate=>false,cascade=>true,degree => 10);

 

返回168万行，但是现有统计信息却让cbo认为是1行，这差别也太大了。

 

method_opt=>'for all columns size repeat', 这里说下，更新统计信息，最好使用for all columns size repeat...

 

repeat的好处是啥，比如列有直方图，会给你保留，列没有统计信息会按照for all columns size 1收集。。。其他原来怎么收就怎么收。

 

你用一个for all columns size 1或size skewonly,或者不写（auto)都可能改变原有统计信息的收集方式，都有可能影响SQL的执行效率。

 

高效访问结构让SQL更快，这个不说了，主要是建索引。如何建索引也是一个很复杂的问题，说一点，一般复合索引，等值查询条件频率高的，作为前导列较好。因为直接访问可能效率比>,<...等高，后者访问了还需要过滤。

 

下面看下影响优化器的参数导致的性能问题。

 

这是10g执行计划，一个视图是UNION ALL做的，全部走索引：

 



 

但是11.2.0.4全表扫描了。

 



 

10g视图有谓词推荐，也就是查询转换里的一种OJPPD=OLD JOIN PUSH PREDICATE

 

升级到11.2.0.4，视图里的10张表都变成FULL SCAN。

连接谓词(A.“PAYIO_SN”=“B”.“WRTOFF_SN”)未推入到视图中。

 

执行时间从0.01s到4s,buffer gets从212到99w。

 

很显然，我要检查，统计信息没有问题，然后怎么干？？看在11g里做优化器降级如何。

 

在11.2.0.4中使用optimizer_features_enable分别测试10.2.0.4和11.2.0.3均可谓词推入到视图中走索引。那么问题就出现在11.2.0.4了，因为11.2.0.3都是可以的。说明11.2.0.4对视图谓词推入算法有了改变。很多优化器的东西，oracle都有参数控制的，除了参数，还有各补对应的fix control。那么先检查补丁相关的

 

from v$system_fix_control WHERE sql_feature LIKE ‘%JPPD%’

 

查到了，各种开启关闭，没有用。最后看10053，分析10053，详细参看是否是BUG导致，还是优化器改进问题，参数设置问题：

 



 

10053看到默认参数被关了，检查下，大概和查询转换的两个参数:

_optimizer_cost_based_transformation

_optimizer_squ_bottomup

都被关了，当然10.2.0.4和11.2.0.3被关了也是可以的。

 



 

还看到基于CBO的查询转换失败，因为参数被关了，OJPPD（10g那种方式）失效了……那当然走不了，JPPD是11g的，也失效了。

 

基本知道执行计划如何看，关注哪些就很有用了，不要太关注啥COST前面讲了11.2.0.3都可以，到11.2.0.4不行了，那可能有2种原因：1、算法改了；2、BUG。

 

当然基于正常的理解，视图谓词推荐，ORACLE是必须支持的，也是不存在问题的，所以肯定有正规的解决方式。先看第2个 BUG，按理说，这种常见的东西，特别是这SQL不算复杂，ORACLE应该不会触发BUG，当然，查询转换是存在各种BUG的，11.2.0,4少了很多MOS中搜一下，比如这个JPPD，就有很多BUG，但是没有看到11.2.0.4对应的。

 



 

**************************

Predicate Move-Around (PM)

**************************

。。。

OJPPD: OJPPD bypassed: View semijoined to table.

JPPD: JPPD bypassed: View not on right-side of outer-join.

 

通过这个判断，10.2.0.4那种OJPPD，基于规则的查询转换不行了，也就是算法改变，因为cost_base_query_transformation参数关了，应该走OJPPD的。现在JPPD也走不了，因为参数被关了，这个是基于成本的查询转换才可以。

 

所以，这是由于算法更新导致的问题，要求必须按照ORACLE官方建议，恢复对应查询转换参数默认值：在基于COST的查询转换部分，只能走JPPD（和OJPPD类似），ORACLE建议设置CBQT参数，基于COST查询转换更准确。

 

开启COST查询转换，初始化优化器参数 _optimizer_cost_based_transformation设为默认值(linear)。CBQT参数有如下值：

"exhaustive", "iterative", "linear", "on", "off"。

 

另外通过测试得知，还需要设置_optimizer_squ_bottomup （enables unnesting of subquery in a bottom-up manner）

参数默认值true.

 

这个问题，但是发了SR，老外也不知道，然后我发现这2个参数恢复默认值可以，当然首先cbqt参数我认为肯定有关系，后面的squ_bottomup是测试出来的。。。后来告诉老外，老外也认可算法改变导致的问题。所以核心参数的默认值改变，是很危险的，可能影响全局，如果这两个参数不恢复，涉及数百条核心SQL就无法正常执行，也就是系统不具有可用性了。

 

最后说一下，经常碰到的一个优化器缺陷：

SELECT ELEMENT_TYPEA,

ELEMENT_IDA,

ELEMENT_TYPEB,

ELEMENT_IDB,

RELATION_TYPE,

EFF_RULE_ID,

EXP_RULE_ID,

CTRL_CODE,

EFF_DATE,

EXP_DATE,

GROUP_ID,

BASE_TIME_ TYPE,

POWER_RIGHT,

POSITIVE_TYPE,

BOTHWAY_FLAG

FROM DBPRODADM.pd_prc_rel a

WHERE EXISTS (SELECT 1

FROM DBPRODADM.pd_prc_dict b

WHERE a.element_ida = b.prod_prcid

AND b.prod_prc_type = '1')

AND a.exp_date > SYSDATE

AND (EXISTS (SELECT 1

FROM DBPRODADM.pd_prc_dict c

WHERE a.element_idb = c.prod_prcid

AND c.prod_prc_type = '1')

OR a.element_idb = 'X')

AND a.relation_type = '10'

 

当OR与semi join放在一起的时候，会触发无法进行subquery unnest的问题，也就是可能会产生FILTER,导致SQL非常缓慢，有的甚至几天，几十天也别想运行结束了。

 



 

第5、6步执行92万多次，那肯定慢了……问题就是有个FILTER……

 

FILTER类似循环，在无法unnest子查询中存在，类似标量子查询那种走法，谓词里也有绑定变量的东西。

 

他们唯一的好处就是内部构建HASH 表，如果匹配的重复值特别多，那么探测次数少，效率好，但是大部分时候，重复值不多，那么就是灾难了

对于这种优化器限制的，一般就是得改写了，因为SQL结构决定无法走高效的执行计划。。。因为我这里虽然走了所以，但是执行次数太多，如果执行次数少，到也无所谓。

 

改写后的sql：

SELECT ELEMENT_TYPEA,

ELEMENT_IDA,

ELEMENT_TYPEB,

ELEMENT_IDB,

RELATION_TYPE,

EFF_RULE_ID,

EXP_RULE_ID,

CTRL_CODE,

EFF_DATE,

EXP_DATE,

GROUP_ID,

BASE_TIME_ TYPE,

POWER_RIGHT,

POSITIVE_TYPE,

BOTHWAY_FLAG

FROM DBPRODADM.pd_prc_rel a

WHERE EXISTS (SELECT 1

FROM DBPRODADM.pd_prc_dict b

WHERE a.element_ida = b.prod_prcid

AND b.prod_prc_type = '1')

AND a.exp_date > SYSDATE

AND (EXISTS (SELECT 1

FROM DBPRODADM.pd_prc_dict c

WHERE a.element_idb = c.prod_prcid

AND c.prod_prc_type = '1')

OR a.element_idb = 'X')

AND a.relation_type = '10'

 

很显然，这里的条件是exists or ...那么改写得用UNION或UNION ALL了，为了避免有重复行，用UNION

select ELEMENT_TYPEA,ELEMENT_IDA,ELEMENT_TYPEB,ELEMENT_IDB,RELATION_TYPE

,EFF_RULE_ID,EXP_RULE_ID,CTRL_CODE,EFF_DATE,EXP_DATE,GROUP_ID,BASE_TIME_TYPE,

POWER_RIGHT,POSITIVE_TYPE,BOTHWAY_FLAG

from DBPRODADM.pd_prc_rel a

where exists

(select 1

from DBPRODADM.pd_prc_dict b

where a.element_ida = b.prod_prcid

and b.prod_prc_type = '1')

and a.exp_date > sysdate

and exists (select 1

from DBPRODADM.pd_prc_dict c

where a.element_idb = c.prod_prcid

and c.prod_prc_type = '1')

and a.relation_type = '10'

union

select ELEMENT_TYPEA,ELEMENT_IDA,ELEMENT_TYPEB,ELEMENT_IDB,RELATION_TYPE

,EFF_RULE_ID,EXP_RULE_ID,CTRL_CODE,EFF_DATE,EXP_DATE,GROUP_ID,BASE_TIME_TYPE,

POWER_RIGHT,POSITIVE_TYPE,BOTHWAY_FLAG

from DBPRODADM.pd_prc_rel a

where exists

(select 1

from DBPRODADM.pd_prc_dict b

where a.element_ida = b.prod_prcid

and b.prod_prc_type = '1')

and a.exp_date > sysdate

and a.element_idb = 'X'

and a.relation_type = '10';

 

两个分支都走HASH JOIN，starts全部为1，虽然全部是全表扫描，但是执行效率提升很明显，执行时间从12s到7s,gets从222w到4.5w之后，是否还有优化空间？

 



 

特别逻辑读少了很多。后续优化：

 

1)改写使用了UNION,是否能改成UNION ALL避免排序？

 

2)这么多全表扫描，是否能够让一些可以走索引？当然，这些是可以做到的，但是不是主要工作了。这个案例告诉我们，优化器是有很多限制的，不是万能的。

 



 

除了统计信息正确，良好的SQL结构，能够让SQL正确进行查询转换，正确的访问结构，如索引等……都是让SQL高效执行的前提条件。复杂！=低效，简单！=高效。让优化器理解，并且有合适的访问结构支持，才是王道！

 

简单的SQL不是快的保证，复杂的也不一定见得慢，高效的执行计划才是最重要的，索引优化SQL，最重要的就是让不好的执行计划变得好。

 

也就是从多个方面入手，最终达到我们的优化目标。

 
      1、优化器的模式

        Oracle中，优化器的模式是由参数OPTIMIZER_MODE的值来决定的。

        1、RULE：表示Oracle将使用RBO来解析目标SQL，此时SQL中涉及的各个对象的统计信息对于RBO没有任何作用。

        2、CHOOSE：Oracle 9i的默认值，表示在解析目标SQL时使用RBO还是CBO取决于SQL涉及的表对象是否有统计信息。

   3、FIRST_ROWS_n(n=1,10,100,1000)：此时CBO计算SQL的各条执行路径的成本值时的侧重点在于以最快的响应速度返回头n(n=1,10,100,1000)条记录。当选择这条记录的时候Oracle会修改执行步骤的成本值，修改为一个很小的值，从而达到不违背CBO原则的目的。

   4、FIRST_ROWS：Oracle 9i中就已经过时的参数，当一些特殊情况下的时候，会使用RBO中的一些内置的规则来选取执行计划不再考虑成本。

   5、ALL_ROWS：Oracle 10g及以后版本中OPTIMIZER_MODE的默认值，表示使用CBO解析目标SQL，此时CBO计算SQL的各条执行路径的成本值时的侧重点在于最佳的吞吐量(即最小的系统I/O和CPU资源的消耗量)。


  2、结果集

    指包含指定执行结果的集合。对RBO来说，对应的执行计划中没有对相关执行步骤对应的结果集的描述，虽然结果集的概念对RBO也是适用的。

  3、访问数据的方法

    访问数据的方法分为两种：直接访问表；先访问索引，再回表。

    直接访问表：

    1、全表扫描：指Oracle访问目标表里的数据时，会从该表所占用的第一个区(Extent)的第一个块(Block)开始扫描，一直扫描到该表的高水位线(HWM)，这段范围内所有的数据块都必须读到。

          2、ROEID扫描：指Oracle访问目标表里的数据时，直接通过数据所在的ROWID定位并访问这些数据。ROWID表示Oracle中的数据行记录所在的物理存储地址，也就是说ROWID实际上和Oracle中数据块里的行记录一一对应的。

ROWID扫描有两层含义：一种是根据用户在SQL语句中输入的ROWID的值直接访问对应的数据行记录；另外一种是先访问相关的索引，然后根据访问索引后得到的ROWID再回表访问对应的数据行记录。
对Oracle堆表而言，通过Oracle内置的ROWID伪列得到对应航记录所在的ROWID的值(注意：ROWID只是一个伪列，在实际的表块中并不存在该列)，然后还可以根据DBMS_ROWID包中的相关方法(dbms_rowid.rowid_relative_fno、dbms_rowid.rowid_block_number和dbms_rowid.rowid_row_number)将上述ROWID伪列的值翻译成对应数据行的实际物理存储地址。
   访问索引的方法：

    1、索引唯一性扫描：INDEX UNIQUE SCAN，仅适用于where条件中是等值查询的目标SQL。因为扫描的对象是唯一性索引，所以索引唯一性扫描的结果至多只会返回一条记录。

         2、索引范围扫描：INDEX RANGE SCAN，当扫描的对象是唯一性索引时，目标SQL的where条件一定是范围查询(谓词条件为BETWEEN、<、>等)；当扫描的对象是非唯一性索引时，对目标SQL的where条件没有限制(可以是等值查询，也可以是范围查询)。在同等条件下，当目标索引的索引行的数量大于1时，索引范围扫描所耗费的逻辑读至少会比相应的索引唯一性扫描多1。

         3、索引全扫描：指要扫描目标索引所有叶子块的所有索引行。但并不意味着需要扫描该索引的所有分支块。默认情况下，Oracle在做索引全扫描时只需要通过访问必要的分支块定位到位于该索引最左边的叶子块的第一行索引行，就可以利用该索引叶子块之间的双向指针链表，从左至右依次顺序扫描该索引所有叶子块的所有索引行了。按照索引键值顺序排序，即可达到排序的效果。避免真正的排序。默认情况下，索引全扫描的有序性就决定了所以全扫描不能并行执行，通常使用单块读。做索引全扫描的前提条件是目标索引至少有一个索引键值列的属性是NOT NULL。

        4、索引快速全扫描：INDEX FAST FULL SCAN，需要扫描目标索引所有叶子块的所有索引行。与索引全扫描的区别：

        （1）、索引快速全扫描只适用于CBO。
        （2）、索引快速全扫描可以使用多块读，也可以并行执行。
        （3）、索引快速全扫描结果不一定是有序的。因为索引快速全扫描时Oracle是根据索引行在磁盘上的物理存储顺序来扫描，而不是根据索引行的逻辑顺序来扫描的。所以扫描结果才不一定有序（对于单个索引叶子块中的索引行而言，其物理存储顺序和逻辑存储顺序一致，但对于物理存储位置相邻的索引叶子块而言，块与块之间索引行的物理存储顺序则不一定在逻辑上有序。
        5、索引跳跃式扫描：INDEX SKIP SCAN，它使那些在where条件中没有对目标索引的前导列指定查询条件但同时又对该索引的非前导列指定了查询条件的目标SQL依然可以用上该索引，这就像在扫描该索引时跳过了它的前导列。这是因为Oracle帮你对该索引的前导列的所有distinct值做了遍历。Oracle中的索引跳跃式扫描仅适用于那些目标索引前导列的distinct值数量较少，后续非前导列的可选择性又非常好的情形，因为索引跳跃式扫描的执行效率一定会随着目标索引前导列的distinct值数量的递增而递减。



SELECT VALUE FROM v$parameter t WHERE t.name = 'optimizer_mode';

showparameter optimizer_mode


CBO用到了字典中的Statistics

analyze table tablename compute statistics;
analyze table tablename compute statistics for all indexes
analyze table tablename delete statistics


* Full Table Scans 全表扫描

* Rowid Scans  rowid扫描

* Index Scans 索引扫描

* Index Unique Scans

* Index Range Scans

* Index Range Scans Descending

* Index Skip Scans

* Full Scans

* Fast Full Index Scans（CBO）

* Index Joins

* Bitmap Joins

* Cluster Scans  簇扫描

* Hash Scans   散列扫描

* Sample Table Scans  表取样扫描

²在RBO时代，关于access path，很简单，有index就用，而对于join方法，编程人员一般会通过调整关联表之间的先后顺序来获得比较好的运行结果。有什么缺点呢？

²有了CBO，简单就是两个字-----CBO走的是包办婚姻：你的事交给我办。

ORACLE默认情况下，周一到周五每天晚上10点到第二天早上6点以及整个周末期间会自动收集统计信息

可以查看参数：

show parameter STATISTICS_LEVEL


²问题：CBO执行计划依赖的statistic不准确（缺失或者太旧），导致在计算执行成本时就会出现偏差，很可能会产生错误的执行计划，怎么办呢？
第一步：重新收集统计信息！
第二部：第一部解决不了的情况下，使用Hints

3.合理应用Hints
3.1Hints

慎用hint，可能会产生严重的后果，比如append会产生锁块，导致并发资源等待等

Hints的分类：





*Hints forOptimization Approaches and Goals(4)

    /*+ ALL_ROWS */

    /*+ FIRST_ROWS ( n )*/

    /*+ CHOOSE */

    /*+ RULE */


*Hints for AccessPaths(12)

    /*+ FULL ( table ) */

    /*+ INDEX ( tableindex) */

    /*+ INDEX_ASC ( tableindex) */

    /*+ INDEX_COMBINE (table index) */

    /*+ INDEX_JOIN (table index) */

    /*+ INDEX_DESC (table index) */

    /*+ INDEX_FFS ( tableindex) */

    /*+ NO_INDEX ( tableindex) */

    /*+ AND_EQUAL ( tableindex index) */



*Hints for QueryTransformations(10)

*Hints for JoinOrders(2)

*Hints for JoinOperations(11)

    /*+ USE_NL ( table )*/

    /*+ USE_MERGE ( table) */

    /*+ USE_HASH ( table) */

    /*+ LEADING ( table )*/



*Hints for ParallelExecution(5)

*Additional Hints(13)


以下为使用Hints的例子







create table t_1(owner varchar2(30),table_name varchar2(30));

create table t_2(owner varchar2(30),table_name varchar2(30));

insert into t_1 SELECT owner,table_name FROM dba_tables;

insert into t_2 SELECT owner,view_name FROM dba_views t;

create index idx_t_1 on t_1(table_name);

create index idx_t_2 on t_2(table_name);

analyze table t_1 compute statistics;

analyze table t_2 compute statistics;


SELECT *

FROM (SELECT * FROM t_1

UNION ALL

SELECT * FROM t_2) aa

WHERE aa.table_name LIKE 'Z%'; ---- Full Table Scans


SELECT /*+ index(AA.t_1 idx_t_1) index(AA.t_2 idx_t_2)*/ *

FROM (SELECT * FROM t_1

UNION ALL

SELECT * FROM t_2) AA

WHERE AA.table_name LIKE 'Z%'; ---- Index Scans


贴上执行图：







4.索引及应用实例


4.1什么是索引



*Oracle的索引是一种自平衡的B*Tree存储结构，其基本存储单位为数据块，称之为节点，共有三种类型的节点：根（root）节点，分枝（Branch）节点，叶（leaf）节点。

*分枝节点存储{索引值，键值对应下一级节点块地址，lmc指针}

*叶节点存储{索引值及其rowid，当前节点的前后节点的数据块地址}
所有叶节点上的两个指针形成一个双向链表，在这个双向链表上的所有索引值，从小到大排列，而对于倒序desc索引，则是从大到小排列

B*TREE索引图：


4.2索引分类



逻辑上：
Single column 单列索引
Concatenated 多列索引
Unique 唯一索引
Non-Unique 非唯一索引
Function-based函数索引
Domain 域索引

物理上：
Partitioned 分区索引
Non-Partitioned 非分区索引
B*tree：
  Normal 正常型B树
  ReverseKey 反转型B树
  Bitmap 位图索引



4.3什么时候使用索引



*如果要检索全表，不必要建索引，因为索引会带来额外的IO操作。

*如果检索的记录数占全部表记录的10%以下可以考虑建索引(大表)。

*表之间的关联字段可以考虑建索引，特别是一张大表和一张小表的关联。

*B*Tree索引适合于大量的增、删、改（OLTP）；
     不适合用包含OR操作符的查询；一般不适用NULL判断；
     适合高基数的列（重复值少）

*Bitmap索引适合于决策支持系统OLAP；
    做UPDATE代价比较高；会锁块；
    非常适合OR操作符的查询；
    适合低基数的列（比如，只有Y和N两种值） ；

*Reverse索引反转了b*tree索引码中的字节，是索引条目分配更均匀，多用于并行服务器环境下，用于减少索引叶的竞争。

    索引是’双刃剑’，在查询与DML之间寻求平衡



4.4改写SQL使用索引

*普通索引列 a is not null 按逻辑改为a>0或a>''

*like操作改写

*能用union all绝不用union，除非要去重



*in操作虽然简单易懂，但oracle内部会转换为表连接查询，使用in会多一步转换操作，所以建议使用表关联查询

*not in 强烈建议使用not exists或（外连接+判断为空）

*<>（不等于）操作不走索引，推荐a<>0改为(a>0 ora<0)    a<>’’改为a>’’

*提防隐式类型转换， oracle内部处理a=0与a=‘0’是完全不同的，甚至会导致不走索引，这个深有体会，最近一个项目就是这个隐式类型转换出了问题，导致速度

很慢





4.5索引应用



例1.用合适的索引来避免不必要的全表扫

    如果要在索引列查询is not null条件，建议列加上is not null约束，默认值约束，

    然而确实由于某种原因索引列设计为null，还想通过is null条件走索引，该如何是好呢？请看





drop table t_tab1;

create table t_tab1 as

SELECT t.owner,

t.object_name,

t.object_type,

t.created,

t.last_ddl_time

FROM dba_objects t;

analyze table t_tab1 compute statistics;

create index idx01_t_tab1 on t_tab1(last_ddl_time);--普通索引

set autotrace trace;

SELECT * FROM t_tab1 t where t.last_ddl_time is null;


执行计划如下图：





如上情况调整为复合索引





drop index idx01_t_tab1;

create index idx01_t_tab1 on t_tab1(last_ddl_time,1);--加了个常量

set autotrace trace;

SELECT * FROM t_tab1 t where t.last_ddl_time is null;


执行计划如下图：







 例2：用合适的函数索引来避免看似无法避免的全表扫描





drop table t_tab1 purge;

create table t_tab1 as

SELECT t.owner,

t.object_name,

t.object_type,

t.OBJECT_ID,

t.created,

t.last_ddl_time

FROM dba_objects t;

CREATE INDEX IDX01_T_TAB1 ON T_TAB1(object_name);

analyze table t_tab1 compute statistics;

set autot trace

SELECT * FROM t_tab1 t where t.object_name like '%20121231';


执行计划如下：





改进索引，此处使用反转函数索引，此外经常用到的函数索引还有，instr(),substr()等





drop index IDX01_T_TAB1;

CREATE INDEX IDX02_T_TAB1 ON T_TAB1(reverse(object_name));

analyze table t_tab1 compute statistics;

SELECT * FROM t_tab1 t where reverse(t.object_name) like reverse('%20121231');

执行计划如下：









5.其他优化技术及应用


5.1其他优化技术及思路



并行技术，并行执行目标SQL语句，这实际上是以额外的资源消耗来换取执行时间的缩短，很多情况下使用并行是针对某些SQL的唯一优化手段。

使用shell调度或其他调度工具。

      SQL语句级别的并行：/*+parallel*/

       /*+ parallel(table_name 4)*/

表压缩技术

  compress

NOLOGGING

  减少日志

Partition技术

  分而治之

中间表/临时表事务分解思路

  ‘大事化小’

求平衡

    CPU，Memory很强大，IO存在瓶颈（最普遍的情况）

使用新特性

     insertall 啦       使用listagg()比wm_concat()快大概50倍、row_number()等分析函数

软硬件资源合理搭配

       黔驴技穷，要求加硬件资源？ Boss会对你说，找会计去吧，提前给你开工资 ……

5.2 SQL优化总结



SQL的优化的手段是五花八门、不一而足的，包括但不限于如下措施：

*如果是统计信息不准或是因为CBO计算某些SQL的执行路径（Access Path）的成本所用公式的先天不足而导致的SQL性能问题，
 我们可以通过重新收集统计信息或者手工修改统计信息或者使用Hint来加以解决；

*如果是SQL语句的写法问题，我们可以通过在不更改业务逻辑的情况下改写SQL来加以解决；

*如果是不必要的全表扫描/排序而导致了目标SQL的性能问题，我们可以通过建立合适的索引（包括函数索引、位图索引等）来加以解决；

*如果是表或者索引的不良设计导致的目标SQL的性能问题，我们可以通过重新设计表/索引，重新组织表里的数据来加以解决；

*如果上述调整措施都失效，我们可以考虑用并行来缩短目标SQL的执行时间；

*如果上述调整措施、包括并行都失效，我们还可以在联系实际业务的基础上更改目标SQL的执行逻辑，甚至不执行目标SQL，这是最彻底的优化:)

  1）语法分析，分析语句的语法是否符合规范，衡量语句中各表达式的意义。

  2）语义分析，检查语句中涉及的所有数据库对象是否存在，且用户有相应的权限。

  3）视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。

  4）表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。

  5）选择优化器，不同的优化器一般产生不同的“执行计划”

  6）选择连接方式， ORACLE 主要有三种连接方式，对多表连接ORACLE会选择适当的连接方式。

  7）选择连接顺序， 对多表连接 ORACLE 选择哪一对表先连接，选择这两表中哪张表做为基础数据表。

  8）选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，比如，是选用全表搜索还是利用索引或是其他的方式。

  9）运行“执行计划”

我们可以通过如下语句来查询缓存中的执行计划：





SELECT t1.*,

't2-->',

t2.*

FROM v$sql_plan t1

JOIN v$sql t2

ON t1.address = t2.address

AND t1.hash_value = t2.hash_value

AND t1.child_number = t2.child_number;--缓存中的执行计划。



1.2 典型SELECT语句完整的执行顺序



  1）from子句组装来自不同数据源的数据；

  2）where子句基于指定的条件对记录行进行筛选；

  3）group by子句将数据划分为多个分组；

  4）使用聚集函数进行计算；

  5）使用having子句筛选分组；

  6）计算所有的表达式；

  7）计算select的字段；

  8）使用order by对结果集进行排序。

1.3 SQL语句执行过程

如下图所示：



说明：

*这是一张SQL语句执行过程图

*执行计划是SQL语句执行过程中必然用到的

*执行计划是优化器（Optimizer）的产物

*两种不同的方式：CBO和RBO

查看优化器设置：

方法一：



SELECT VALUE FROM v$parameter t WHERE t.name = 'optimizer_mode';

方法二(SQLPLUS下执行)：





showparameter optimizer_mode


*CBO用到了字典中的Statistics,而RBO没有

分析统计信息相关SQL：



analyze table tablename compute statistics;
analyze table tablename compute statistics for all indexes
analyze table tablename delete statistics


2.优化器及执行计划


2.1 SQL优化方法论



*ORACLE10g以后的版本，SQL优化的本质是基于对CBO和执行计划的深刻理解，进入CBO时代，一定要理解执行计划。
*查看执行计划有好多方式，比如使用PL/SQL Developer工具，选中select语句，按F5键就可以显示其执行计划，不过显示的不完全


*最好使用在Oracle官方的sqlplus工具，性能最好，方便直观，下面介绍两种查看执行计划方式（也是最简单的两种方式）







关于执行计划的一些知识：



* Full Table Scans 全表扫描

* Rowid Scans  rowid扫描

* Index Scans 索引扫描

* Index Unique Scans

* Index Range Scans

* Index Range Scans Descending

* Index Skip Scans

* Full Scans

* Fast Full Index Scans（CBO）

* Index Joins

* Bitmap Joins

* Cluster Scans  簇扫描

* Hash Scans   散列扫描

* Sample Table Scans  表取样扫描


²在RBO时代，关于access path，很简单，有index就用，而对于join方法，编程人员一般会通过调整关联表之间的先后顺序来获得比较好的运行结果。有什么缺点呢？

²有了CBO，简单就是两个字-----CBO走的是包办婚姻：你的事交给我办。

ORACLE默认情况下，周一到周五每天晚上10点到第二天早上6点以及整个周末期间会自动收集统计信息

可以查看参数：

show parameter STATISTICS_LEVEL


²问题：CBO执行计划依赖的statistic不准确（缺失或者太旧），导致在计算执行成本时就会出现偏差，很可能会产生错误的执行计划，怎么办呢？
第一步：重新收集统计信息！
第二部：第一部解决不了的情况下，使用Hints

3.合理应用Hints
3.1Hints

慎用hint，可能会产生严重的后果，比如append会产生锁块，导致并发资源等待等

Hints的分类：





*Hints forOptimization Approaches and Goals(4)

    /*+ ALL_ROWS */

    /*+ FIRST_ROWS ( n )*/

    /*+ CHOOSE */

    /*+ RULE */


*Hints for AccessPaths(12)

    /*+ FULL ( table ) */

    /*+ INDEX ( tableindex) */

    /*+ INDEX_ASC ( tableindex) */

    /*+ INDEX_COMBINE (table index) */

    /*+ INDEX_JOIN (table index) */

    /*+ INDEX_DESC (table index) */

    /*+ INDEX_FFS ( tableindex) */

    /*+ NO_INDEX ( tableindex) */

    /*+ AND_EQUAL ( tableindex index) */



*Hints for QueryTransformations(10)

*Hints for JoinOrders(2)

*Hints for JoinOperations(11)

    /*+ USE_NL ( table )*/

    /*+ USE_MERGE ( table) */

    /*+ USE_HASH ( table) */

    /*+ LEADING ( table )*/



*Hints for ParallelExecution(5)

*Additional Hints(13)


以下为使用Hints的例子







create table t_1(owner varchar2(30),table_name varchar2(30));

create table t_2(owner varchar2(30),table_name varchar2(30));

insert into t_1 SELECT owner,table_name FROM dba_tables;

insert into t_2 SELECT owner,view_name FROM dba_views t;

create index idx_t_1 on t_1(table_name);

create index idx_t_2 on t_2(table_name);

analyze table t_1 compute statistics;

analyze table t_2 compute statistics;


SELECT *

FROM (SELECT * FROM t_1

UNION ALL

SELECT * FROM t_2) aa

WHERE aa.table_name LIKE 'Z%'; ---- Full Table Scans


SELECT /*+ index(AA.t_1 idx_t_1) index(AA.t_2 idx_t_2)*/ *

FROM (SELECT * FROM t_1

UNION ALL

SELECT * FROM t_2) AA

WHERE AA.table_name LIKE 'Z%'; ---- Index Scans


贴上执行图：







4.索引及应用实例


4.1什么是索引



*Oracle的索引是一种自平衡的B*Tree存储结构，其基本存储单位为数据块，称之为节点，共有三种类型的节点：根（root）节点，分枝（Branch）节点，叶（leaf）节点。

*分枝节点存储{索引值，键值对应下一级节点块地址，lmc指针}

*叶节点存储{索引值及其rowid，当前节点的前后节点的数据块地址}
所有叶节点上的两个指针形成一个双向链表，在这个双向链表上的所有索引值，从小到大排列，而对于倒序desc索引，则是从大到小排列

B*TREE索引图：


4.2索引分类



逻辑上：
Single column 单列索引
Concatenated 多列索引
Unique 唯一索引
Non-Unique 非唯一索引
Function-based函数索引
Domain 域索引

物理上：
Partitioned 分区索引
Non-Partitioned 非分区索引
B*tree：
  Normal 正常型B树
  ReverseKey 反转型B树
  Bitmap 位图索引



4.3什么时候使用索引



*如果要检索全表，不必要建索引，因为索引会带来额外的IO操作。

*如果检索的记录数占全部表记录的10%以下可以考虑建索引(大表)。

*表之间的关联字段可以考虑建索引，特别是一张大表和一张小表的关联。

*B*Tree索引适合于大量的增、删、改（OLTP）；
     不适合用包含OR操作符的查询；一般不适用NULL判断；
     适合高基数的列（重复值少）

*Bitmap索引适合于决策支持系统OLAP；
    做UPDATE代价比较高；会锁块；
    非常适合OR操作符的查询；
    适合低基数的列（比如，只有Y和N两种值） ；

*Reverse索引反转了b*tree索引码中的字节，是索引条目分配更均匀，多用于并行服务器环境下，用于减少索引叶的竞争。

    索引是’双刃剑’，在查询与DML之间寻求平衡



4.4改写SQL使用索引

*普通索引列 a is not null 按逻辑改为a>0或a>''

*like操作改写

*能用union all绝不用union，除非要去重



*in操作虽然简单易懂，但oracle内部会转换为表连接查询，使用in会多一步转换操作，所以建议使用表关联查询

*not in 强烈建议使用not exists或（外连接+判断为空）

*<>（不等于）操作不走索引，推荐a<>0改为(a>0 ora<0)    a<>’’改为a>’’

*提防隐式类型转换， oracle内部处理a=0与a=‘0’是完全不同的，甚至会导致不走索引，这个深有体会，最近一个项目就是这个隐式类型转换出了问题，导致速度

很慢





4.5索引应用



例1.用合适的索引来避免不必要的全表扫

    如果要在索引列查询is not null条件，建议列加上is not null约束，默认值约束，

    然而确实由于某种原因索引列设计为null，还想通过is null条件走索引，该如何是好呢？请看





drop table t_tab1;

create table t_tab1 as

SELECT t.owner,

t.object_name,

t.object_type,

t.created,

t.last_ddl_time

FROM dba_objects t;

analyze table t_tab1 compute statistics;

create index idx01_t_tab1 on t_tab1(last_ddl_time);--普通索引

set autotrace trace;

SELECT * FROM t_tab1 t where t.last_ddl_time is null;


执行计划如下图：





如上情况调整为复合索引





drop index idx01_t_tab1;

create index idx01_t_tab1 on t_tab1(last_ddl_time,1);--加了个常量

set autotrace trace;

SELECT * FROM t_tab1 t where t.last_ddl_time is null;


执行计划如下图：







 例2：用合适的函数索引来避免看似无法避免的全表扫描





drop table t_tab1 purge;

create table t_tab1 as

SELECT t.owner,

t.object_name,

t.object_type,

t.OBJECT_ID,

t.created,

t.last_ddl_time

FROM dba_objects t;

CREATE INDEX IDX01_T_TAB1 ON T_TAB1(object_name);

analyze table t_tab1 compute statistics;

set autot trace

SELECT * FROM t_tab1 t where t.object_name like '%20121231';


执行计划如下：





改进索引，此处使用反转函数索引，此外经常用到的函数索引还有，instr(),substr()等





drop index IDX01_T_TAB1;

CREATE INDEX IDX02_T_TAB1 ON T_TAB1(reverse(object_name));

analyze table t_tab1 compute statistics;

SELECT * FROM t_tab1 t where reverse(t.object_name) like reverse('%20121231');

执行计划如下：









5.其他优化技术及应用


5.1其他优化技术及思路



并行技术，并行执行目标SQL语句，这实际上是以额外的资源消耗来换取执行时间的缩短，很多情况下使用并行是针对某些SQL的唯一优化手段。

使用shell调度或其他调度工具。

      SQL语句级别的并行：/*+parallel*/

       /*+ parallel(table_name 4)*/

表压缩技术

  compress

NOLOGGING

  减少日志

Partition技术

  分而治之

中间表/临时表事务分解思路

  ‘大事化小’

求平衡

    CPU，Memory很强大，IO存在瓶颈（最普遍的情况）

使用新特性

     insertall 啦       使用listagg()比wm_concat()快大概50倍、row_number()等分析函数

软硬件资源合理搭配

       黔驴技穷，要求加硬件资源？ Boss会对你说，找会计去吧，提前给你开工资 ……

5.2 SQL优化总结



SQL的优化的手段是五花八门、不一而足的，包括但不限于如下措施：

*如果是统计信息不准或是因为CBO计算某些SQL的执行路径（Access Path）的成本所用公式的先天不足而导致的SQL性能问题，
 我们可以通过重新收集统计信息或者手工修改统计信息或者使用Hint来加以解决；

*如果是SQL语句的写法问题，我们可以通过在不更改业务逻辑的情况下改写SQL来加以解决；

*如果是不必要的全表扫描/排序而导致了目标SQL的性能问题，我们可以通过建立合适的索引（包括函数索引、位图索引等）来加以解决；

*如果是表或者索引的不良设计导致的目标SQL的性能问题，我们可以通过重新设计表/索引，重新组织表里的数据来加以解决；

*如果上述调整措施都失效，我们可以考虑用并行来缩短目标SQL的执行时间；






基于规则的优化器——Rule Based Optimizer，即RBO
基于成本的优化器——Cost Based Optimizer，即CBO。


Oracle优化器也被称为查询优化器，因为查询是影响数据库性能最主要的因素。不单单select语句是查询，DML语句带有where条件的也是需要做查询的。
优化器应该是数据库引擎中最神秘也最吸引人的一部分，对性能的影响也是最大的，它的好坏直接决定数据库性能的好坏。
Oracle优化器在分析sql语句时，会依据自己内部的一些规则来决定一个sql的执行计划。


基于规则的优化器——Rule Based Optimizer，即RBO
下面简单介绍下RBO的相关内容

在oracle较早的版本oracle 7以前，使用的优化器是RBO。顾名思义，这是一个基于规则的优化器。
ORACLE在基于规则的优化器中采用启发式的方法(Heuristic Approach)或规则(Rules)来生成执行计划。。例如，如果一个查询的where条件(where clause)包含一个谓词(predicate，其实就是一个判断条件，如”=”, “>”, ”<”等)，而且该谓词上引用的列上有有效索引，那么优化器将使用索引访问这个表，而不考虑其它因素，如表中数据的多少、表中数据的易变性、索引的可选择性等。此时数据库中没有关于表与索引数据的统计性描述，如表中有多上行，每行的可选择性等。优化器也不考虑实例参数，如multi block i/o、可用排序内存的大小等，所以优化器有时就选择了次优化的计划作为真正的执行计划，导致系统性能不高。


RBO也会导致很多优化方法无法使用：1. Hash join2. 数据仓库中的 star transformation3. Unnested sub query4. Push predicate

RBO有自己的执行路径顺序规则（见下页）。RBO认为越往下执行的代价越大，即等级越低。在RBO生成执行计划时，如果它发现有等级高的执行路径可用，则肯定会使用等级高的路径，而不管任何其它影响性能的元素，即RBO通过下面的路径的等级决定执行路径的代价，执行路径的等级越高，则使用该执行路径的代价越小。


9i库中rbo的访问路径顺序：
RBO Path 1: Single Row by Rowid
RBO Path 2: Single Row by Cluster Join
RBO Path 3: Single Row by Hash Cluster Key with Unique or Primary Key
RBO Path 4: Single Row by Unique or Primary Key
RBO Path 5: Clustered Join
RBO Path 6: Hash Cluster Key
RBO Path 7: Indexed Cluster Key
RBO Path 8: Composite Index
RBO Path 9: Single-Column Indexes
RBO Path 10: Bounded Range Search on Indexed Columns
RBO Path 11: Unbounded Range Search on Indexed Columns
RBO Path 12: Sort Merge Join
RBO Path 13: MAX or MIN of Indexed Column
RBO Path 14: ORDER BY on Indexed Column
RBO Path 15: Full Table Scan

可以看到，优先级最高的是Single Row by Rowid，这就意味着在基于规则的优化器如果有索引可以利用，即使全表扫描更有效率，也不会使用全表扫描，因为Full Table Scan 的优先级是最低的。这也是大家通常所说的RBO总是认为索引最优的原因。
RBO的缺点很显而易见，就是对数据不敏感，也就是说，数据的变化是不会影响执行计划的生成，优化器不会考虑数据的多少、数据分布、索引的可选择性等等，而这是非常不好的。
RBO对于开发人员的要求也会相对比较高，在RBO模式，需要按照一定的规则来写SQL。
由于RBO有这么多的缺点，所以oracle推出了CBO，虽然在早期的版本中存在很多缺点，但是在oracle每个版本中都对它有增强，在常用的版本10.2.0.4以上已相对比较稳定了。


基于成本的优化器——Cost Based Optimizer，即CBO。
下面简单的介绍下CBO的相关内容

数据库把一个代价引擎集成到数据库内核中，用来估计每个执行计划需要的代价，选择代价最小的一个执行计划作为这个sql的执行计划。
一个查询耗费的资源可以被分成3个基本组成部分：I/O代价、CPU代价、network代价。I/O代价是将数据从磁盘读入内存所需的代价。访问数据包括将数据文件中数据块的内容读入到SGA的数据高速缓存中，在一般情况下，该代价是处理一个查询所需要的最主要代价，所以我们在优化时，一个基本原则就是降低查询所产生的I/O总次数。CPU代价是处理在内存中数据所需要的代价，如一旦数据被读入内存，则我们在识别出我们需要的数据后，在这些数据上执行排序(sort)或连接(join)操作，这需要耗费CPU资源，常见的消耗CPU的操作：
1. Sum, Decode, Avg
2. Filter
3. Join
4. Sort



对于需要访问跨节点(即通常说的服务器)数据库上数据的查询来说，存在network代价，用来量化传输操作耗费的资源。查询远程表的查询或执行分布式连接的查询会在network代价方面花费比较大。
在使用CBO时，需要有表和索引的统计数据(分析数据)作为基础数据，有了这些数据，CBO才能为各个执行计划计算出相对准确的代价，从而使CBO选择最佳的执行计划。如果统计信息为空，oracle会做动态采样，会读取少量数据块来分析块中的数据分布来评估表中的数据分布以及索引的选择性等等信息。



判断当前数据库使用何种优化器


主要是由optimizer_mode初始化参数决定的。如下：
RULE：RBO优化器。
CHOOSE：根据实际情况，如果数据字典中包含被引用的表的统计数据，即引用的对象已经被分析，则就使用CBO优化器，否则为RBO优化器。
ALL_ROWS：是CBO优化器使用的第一种具体的优化方法，是以数据的吞吐量为主要目标，以便可以使用最少的资源完成语句。
FIRST_ROW：是优化器使用的第二种具体的优化方法，是以数据的响应时间为主要目标，以便快速查询出开始的几行数据。在使用first rows时，会更偏向于使用索引。
FIRST_ROWS_[1 | 10 | 100 | 1000] ：是优化器使用的第三种具体的优化方法，让优化器选择一个能够把响应时间减到最小的查询执行计划，以迅速产生查询结果的前 n 行。该参数为ORACLE 9I新引入的。
注意，在使用这个参数时，由于某些bug会导致优化器选择次优化的执行计划。

从ORACLE V7以来，optimizer_mode参数的缺省设置应是"choose"，即如果对已分析的表查询的话选择CBO，否则选择RBO。在此种设置中，如果采用了CBO，则缺省为CBO中的all_rows模式，目前10g以上包括10g的库现在采用的都是ALL_ROWS的优化器。
需要注意的是，不管optimizer_mode参数如何设置，只要满足下面3个条件，就一定使用CBO：
1）如果使用Index Organized Tables(IOTs), 自动使用CBO。
2）Oracle 7.3以后，如果表上的Paralle degree option设为>1，则自动使用CBO, 而不管是否用rule hints.。
3）除rule以外的任何hints都将导致自动使用CBO来执行语句。

通常我们遇到一个sql执行缓慢时，会先去看它的执行计划，那么什么是执行计划呢？我们又有哪几种常用方式来看执行计划呢？
一个sql的执行分为多个阶段，语义解析阶段、sql parse阶段、执行阶段、fetch阶段。
为了不重复解析相同的SQL语句(因为解析操作比较费资源)，在第一次解析之后，ORACLE将SQL语句及解析后得到的执行计划存放在内存中。这块位于系统全局区域SGA(system global area)的共享池(shared buffer pool)中的内存可以被所有的数据库用户共享。因此，当你执行一个SQL语句(有时被称为一个游标)时，如果该语句和之前的执行过的某一语句完全相同，并且之前执行的该语句与其执行计划仍然在内存中存在，则ORACLE就不需要再进行分析，直接得到该语句的执行路径。ORACLE的这个功能大大地提高了SQL的执行性能并大大节省了内存的使用。使用这个功能的关键是将执行过的语句尽可能放到内存中，所以这要求有大的共享池(通过设置shared buffer pool参数值)和尽可能的使用绑定变量的方法执行SQL语句。


Sql parse的种类


Sql parse又通常分为硬解析和软解析（软软解析我们暂时不做讨论），当sql第一次执行的时候，会发生硬解析，之后的执行如果在shared pool中能找到就是软解析。

sql会在以下情况下发生硬解析：
1）统计信息改变
2）Sql中的表上有做ddl操作，包括grant和revoke。
3）执行计划被踢出shared pool
4）开启了trace
5）绑定变量长度变化
6)启用outline，11g启用SPM
7)SQL语句相同但是所引用的表不同，例如不是同一属主
8)环境发生变化，如Sort area size、Hash area size和locale setting发生变化

软解析
当你向ORACLE 提交一个SQL语句，ORACLE会首先在共享内存中查找是否有相同的语句。这里需要注明的是，ORACLE对两者采取的是一种严格匹配，要达成共享，SQL语句必须完全相同(包括空格,换行等)。如果完全相同，才会有软解析。


如何判断两个sql语句是否是同一个sql语句呢？

1）大小写和空格以及字母值不一致：
SELECT * FROM emp WHERE empno = 1000;
和下列每一个都不同
SELECT * from emp WHERE empno = 1000;
SELECT * FROM emp WHERE  empno = 1000;
SELECT * FROM emp WHERE empno = 2000;
在上面的语句中列值都是直接SQL语句中的，我们将这类sql称为硬编码SQL或字面值SQL


2）绑定变量名称不同
使用绑定变量的SQL语句中必须使用相同的名字的绑定变量(bind variables)
例如：
a. 该2个sql语句被认为相同
select * from emp where empno = :empno;
select * from emp where empno = :empno;
b. 该2个sql语句被认为不相同
select * from emp where empno = :empno1;
select * from emp where empno = :empno2;
我们将上面的这类语句称为绑定变量SQL。


3）对象名称相同，但是属主不同
将所发出语句中涉及的对象与已存在语句所涉及对象相比较。
例如:
如用户user1与用户user2下都有EMP表，则
用户user1发出的语句：SELECT * FROM EMP; 与
用户user2发出的语句：SELECT * FROM EMP; 被认为是不相同的语句，
因为两个语句中引用的EMP不是指同一个表。

4) 在SQL语句中使用的捆绑变量的捆绑类型必须一致

Cursor_sharing简介

1）exact:
只有当发布的SQL语句与缓存中的语句完全相同时才用已有的执行计划。也是cursor_sharing的默认值
2）force:
如果SQL语句是字面量，则迫使Optimizer始终使用已有的执行计划,无论已有的执行计划是不是最佳的。
3）similar:
如果SQL语句是字面量，则只有当已有的执行计划是最佳时才使用它，如果已有执行计划不是最佳则重新对这个SQL语句进行分析来制定最佳执行计划。


EXPLAIN_PLAN
格式：explain plan for sql_text

Example:
SQL> explain plan for select * from t_test;

Explained
SQL> select * from table(dbms_xplan.display);

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 4036493941
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |     1 |    13 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS FULL| T_TEST |     1 |    13 |     2   (0)| 00:00:01 |
----------------------------------------------------------------------------
Note
-----
   - dynamic sampling used for this statement

12 rows selected

通过这种方式就可以简单地查看执行计划，plsql dev中的F5看执行计划其实使用的就是explain plan，toad的也一样。
但是这种方式查看的执行计划并不一定是sql实际执行时会选择的执行计划，它只是优化器根据现有的统计信息来计算生成的，得到的cost值也只是根据现有的统计信息得到的，而现在的统计信息有可能已经是好几个月前的了，后面在经常碰到的几个误区中会详细讲到这个问题。
对于explain plan，所有的参数的类型都被默认为是varchar2，也不支持绑定变量代入值，这种方式得到的执行计划，只能是作为参考，但的确是我们做sql优化经常会使用到的方法。


SQLPLUS的AUTOTRACE

example：
SQL> set autot trace
SQL> set timing on
SQL> set time on
15:18:17 SQL> select * from t_test;

未选定行

已用时间:  00: 00: 00.19

执行计划
----------------------------------------------------------
Plan hash value: 4036493941

----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |     1 |    13 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS FULL| T_TEST |     1 |    13 |     2   (0)| 00:00:01 |
----------------------------------------------------------------------------

Note
-----
   - dynamic sampling used for this statement


统计信息
----------------------------------------------------------
          1  recursive calls
          0  db block gets
          4  consistent gets
          0  physical reads
          0  redo size
        153  bytes sent via SQL*Net to client
        240  bytes received via SQL*Net from client
          1  SQL*Net roundtrips to/from client
          0  sorts (memory)
sorts (disk)
0  rows processed

可以看到sql的执行计划以及相关的统计信息（此统计信息非对象统计信息）

这种方式看到的执行计划已经是sql实际的执行计划了，不过存在一个问题，必须sql执行后才能看到执行计划，如果sql执行时间很长，那岂不是要等很久才能看到执行计划？
我前面提到过，一个sql的执行需要经过很多阶段，在执行阶段前的是sql parse阶段，这个时候sql的执行计划已经生成了，也就是说我们已经可以查到它了。
select * from v$sql t where upper(t.SQL_FULLTEXT) like upper('%select * from t_test%');
通过这个sql就可以找到我们刚执行的sql的sql_id，然后用第三种查看执行计划的方法来看。
如果sql很复杂，而且类似的sql很多不好找，这时候一个个筛选就很痛苦。这种情况下，可以使用一个小技巧，在你调优的sql中加入一个你特有的hint：
select /*+ jinhf*/* from t_test;
查v$sql的条件改下，如下：
select * from v$sql t where upper(t.SQL_FULLTEXT) like upper('%jinhf%');
就可以很方便的找到刚执行的sql_id了。
在优化sql的过程中，经常配合使用explain plan和autotrace，还是非常好用的。

DBMS_XPLAN

dbms_xplan包很强大，提供了多种方法，这边只介绍以下4种:
Dbms_xplan.display
Dbms_xplan.display_cursor
Dbms_xplan.display_awr
Dbms_xplan.display_sql_plan_baseline

1）Dbms_xplan.display：
已经介绍过了，在使用explain plan解析sql后，可以使用Dbms_xplan.display来查看执行计划。

2）Dbms_xplan.display_cursor：
SQL> desc dbms_xplan.display_cursor
Parameter       Type                      Mode Default?
--------------- ------------------------- ---- --------
(RESULT)        SYS.DBMS_XPLAN_TYPE_TABLE
SQL_ID          VARCHAR2                  IN   Y
CURSOR_CHILD_NO NUMBER                    IN   Y
FORMAT          VARCHAR2                  IN   Y
这个function可以查shared pool中的执行计划。提供了三个参数，可以查看指定sql_id指定child_no的执行计划。
如果不输入任何参数，则取数据库中最近一次执行的sql的执行计划。


3）Dbms_xplan.display_awr：
查看历史的执行计划，从10g开始，oracle提供了awr来记录数据库的信息，默认保留时间是90天。对于某个sql的历史执行情况，包括执行计划和逻辑读、物理读、cpu time以及elapsed time等信息，这个在9i的数据库中是无从查询的。
SQL> desc dbms_xplan.display_awr
Parameter       Type                      Mode Default?
--------------- ------------------------- ---- --------
(RESULT)        SYS.DBMS_XPLAN_TYPE_TABLE
SQL_ID          VARCHAR2                  IN
PLAN_HASH_VALUE NUMBER                    IN   Y
DB_ID           NUMBER                    IN   Y
FORMAT          VARCHAR2                  IN   Y
Sql_id是必输的，其他的参数可以灵活选择。
缺点：无法显示谓词、存取路径。


三、如何看执行计划


看一个简单的例子：
--------------------------------------------------------------------------------
| Id  | Operation                        | Name                    | Rows  | Byt
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |                         |     |
|   1 |  SORT AGGREGATE                  |                         |     1 |
|   2 |   TABLE ACCESS BY INDEX ROWID    | T_PUB_TASK_GROUP        |     1 |
|   3 |    INDEX RANGE SCAN              | IX_TASK_GRP_BAT_SUP_STA |     3 |
|   4 |  VIEW                            |                         |     2 |  21
|   5 |   COUNT STOPKEY                  |                         |       |
|   6 |    VIEW                          |                         |     2 |  21
|   7 |     SORT ORDER BY                |                         |     2 |   4
|   8 |      NESTED LOOPS                |                         |     2 |   4
|   9 |       NESTED LOOPS               |                         |     2 |   2
|  10 |        TABLE ACCESS FULL         | T_PUB_QUEUE             |     2 |   2
|  11 |        INDEX UNIQUE SCAN         | PK_T_PUB_ASSIGNED_QUEUE |     1 |
|  12 |       TABLE ACCESS BY INDEX ROWID| T_PUB_BATCH             |     1 |
|  13 |        INDEX UNIQUE SCAN         | PK_T_PUB_BATCH          |     1 |
--------------------------------------------------------------------------------
简单来讲，是从右到左，从上到下的原则。
从横向来看10、11、13都是在最右端，优先级是一样的，这时候就需要看纵向的。对于10和11的执行顺序，是先执行步骤10，再执行步骤11，步骤9结束后，再和步骤12得到的结果集做步骤8的nested loop操作。


Card
是指计划中这一步所处理的行数。
Cost
是指cbo中这一步所耗费的资源，以单块读的IO成本来表示。
Bytes
是指cbo中这一步所处理所有记录的字节数，是估算出来的一组值。
Predicate(谓词)
一个查询中的WHERE限制条件
Probed Table(被探查表)
该表又称为内层表(INNER TABLE)。在我们从驱动表中得到具体一行的数据后，在该表中寻找符合连接条件的行。所以该表应当为返回较大row source的表且相应的列上应该有索引，索引扫描的范围越小，效率越高。

rowid

rowid是一个伪列，是系统自己给加上的。对每个表都有一个rowid的伪列，但是表中并不物理存储ROWID列的值。不过你可以像使用其它列那样使用它，但是不能删除该列，也不能对该列的值进行修改、插入。一旦一行数据插入数据库，则rowid在该行的生命周期内是唯一的，即即使该行产生行迁移，行的rowid也不会改变。 也有例外的情况，在分区表中，如果对分区列的值进行修改，这一行的数据会从一个分区迁移到另一个分区，那么这行数据对应的rowid也会改变；表做shrink或者move的操作时，rowid也会改变。
rowid对访问一个表中的给定的行提供了最快的访问方法，通过ROWID可以直接定位到相应的数据块上，然后将其读到内存。我们创建一个索引时，该索引不但存储索引列的值，而且也存储索引值所对应的行的ROWID，这样我们通过索引快速找到相应行的ROWID后，通过该ROWID，就可以迅速将数据查询出来。这也就是我们使用索引查询时，速度比较快的原因。
在ORACLE 8以前的版本中，ROWID由FILE 、BLOCK、ROW NUMBER构成。随着oracle8中对象概念的扩展，ROWID发生了变化，ROWID由OBJECT、FILE、BLOCK、ROW NUMBER构成。利用DBMS_ROWID可以将rowid分解成上述的各部分，也可以将上述的各部分组成一个有效的rowid。

Resuive SQL


有时为了执行用户发出的一个sql语句，Oracle必须执行一些额外的语句，我们将这些额外的语句称之为‘recursive calls’或‘recursive SQL statements’。比如创建一个表，ORACLE总是隐含的发出一些recursive SQL语句来修改数据字典信息如tab$等。当需要的数据字典信息没有在共享内存中时，经常会发生Recursive calls，这些Recursive calls会将数据字典信息从硬盘读入内存中。用户不比关心这些recursive SQL语句的执行情况， ORACLE会自动的在内部执行这些语句。当然DML语句与SELECT、sql parse或者在执行过程中需要空间扩展都可能引起recursive SQL。


Row Source(行源)

用在查询中，由上一操作返回的符合条件的行的集合，即可以是表的全部行数据的集合；也可以是表的部分行数据的集合；也可以为对上2个row source进行连接操作(如join连接)后得到的行数据集合。



Driving Table(驱动表)
该表又称为外层表(OUTER TABLE)。这个概念用于嵌套与HASH连接中。如果该row source返回较多的行数据，则对所有的后续操作有负面影响。一般说来，是应用查询的限制条件后，返回较少行源的表作为驱动表，所以如果一个大表在WHERE条件有有限制条件(如等值限制)，则该大表作为驱动表也是合适的，所以并不是只有较小的表可以作为驱动表，正确说法应该为应用查询的限制条件后，返回较少行源的表作为驱动表。在执行计划中，应该为靠上的那个row source。


组合索引(composite index)
组合索引就是由多个列构成的索引。在组合索引中有一个重要的概念：引导列(leading column)，创建组合索引时最前面的列即为引导列。如
Create index idx_test on table_name(col1,col2,…);
当我们进行查询时可以使用”where col1 = ? ”，也可以使用”where col1 = ? and col2 = ?”，这样的限制条件都会使用索引，但是”where col2 = ? ”查询就不会使用该索引。所以限制条件中包含先导列时，该限制条件才会使用该组合索引。
有些情况下，”where col2 = ? ”也会使用索引，使用的是index skip scan，col1的distinct值有N个，那么就相当于N个基于col2的查询的union。N这个值越大，union的个数就越多，index skip scan的效率就越低，所以大部分情况下，当我们看到执行计划中出现index skip scan时，需要加以关注。


可选择性(selectivity)

比较一下列中唯一键的数量和表中的行数，就可以判断该列的可选择性。如果该列的唯一键的数量/表中的行数”的比值越接近1，则该列的可选择性越高，该列就越适合创建索引，同样索引的可选择性也越高。在可选择性高的列上进行查询时，返回的数据就较少，比较适合使用索引查询。

常见的连接类型

Join是一种试图将两个表结合在一起的谓词，一次只能连接2个表，表连接也可以被称为表关联。在后面的叙述中，我们将会使用”row source”来代替”表”，因为使用row source更严谨一些，并且将参与连接的2个row source分别称为row source1和row source 2。Join过程的各个步骤经常是串行操作，即使相关的row source可以被并行访问，但是在将表中符合限制条件的数据读入到内存形成row source后，join的其它步骤一般是串行的。有多种方法可以将2个表连接起来，当然每种方法都有自己的优缺点，每种连接类型只有在特定的条件下才会发挥出其最大优势。
row source(表)之间的连接顺序对于查询的效率有非常大的影响。通过首先存取特定的表，即将该表作为驱动表，这样可以先应用某些限制条件，从而得到一个较小的row source，使连接的效率较高，这也就是我们常说的要先执行限制条件的原因。一般是在将表读入内存时，应用where子句中对该表的限制条件。
根据2个row source的连接条件的中操作符的不同，可以将连接分为等值连接(如WHERE A.COL1 = B.COL2)、非等值连接(WHERE A.COL1> B.COL2)、外连接(WHERE A.COL1= B.COL2+)).


NESTED LOOP JOIN


这个连接方法有驱动表(外部表)的概念。其实，该连接过程就是一个2层嵌套循环，所以外层循环的次数越少越好，这也就是我们为什么将小表或返回较小row source的表作为驱动表(用于外层循环)的理论依据。但是这个理论只是一般指导原则，因为遵循这个理论并不能总保证使语句产生的I/O次数最少。有时不遵守这个理论依据，反而会获得更好的效率。如果使用这种方法，决定使用哪个表作为驱动表很重要。有时如果驱动表选择不正确，将会导致语句的性能很差。
内部连接过程：
Row source1的Row 1 -------------- -- Probe -> Row source 2
Row source1的Row 2 -------------- -- Probe -> Row source 2
Row source1的Row 3 -------------- -- Probe -> Row source 2
…….
Row source1的Row n -------------- -- Probe -> Row source 2
从内部连接过程来看，需要用row source1中的每一行，去匹配row source2中的所有行，所以此时保持row source1尽可能的小与高效的访问row source2(一般通过索引实现)是影响这个连接效率的关键问题。这只是理论指导原则，目的是使整个连接操作产生最少的物理I/O次数，而且如果遵守这个原则，一般也会使总的物理I/O数最少。
在上面的连接过程中，我们称Row source1为驱动表或外部表。Row Source2被称为被探查表或内部表。

在NESTED LOOPS连接中，Oracle读取row source1中的每一行，然后在row source2中检查是否有匹配的行，所有被匹配的行都被放到结果集中，然后处理row source1中的下一行。这个过程一直继续，直到row source1中的所有行都被处理。这是从连接操作中可以得到第一个匹配行的最快的方法之一，这种类型的连接可以用在需要快速响应的语句中，以响应速度为主要目标。
如果driving row source(外部表)比较小，并且在inner row source(内部表)上有唯一索引，或有高选择性非唯一索引时，使用这种方法可以得到较好的效率。NESTED LOOPS有其它连接方法没有的的一个优点是：可以先返回已经连接的行，而不必等待所有的连接操作处理完才返回数据，这可以实现快速的响应时间。





例子：
SQL> explain plan for
  2  select /*+ use_nl(a, b)*/a.dname, b.sal
  3  from scott.dept a, scott.emp b
  4  where a.deptno = b.deptno;

Explained

SQL> select * from table(dbms_xplan.display);

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 3338707304
---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |    14 |   280 |     9   (0)| 00:00:01 |
|   1 |  NESTED LOOPS      |      |    14 |   280 |     9   (0)| 00:00:01 |
|   2 |   TABLE ACCESS FULL| DEPT |     4 |    52 |     3   (0)| 00:00:01 |
|*  3 |   TABLE ACCESS FULL| EMP  |     4 |    28 |     2   (0)| 00:00:01 |
---------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   3 - filter("A"."DEPTNO"="B"."DEPTNO")

15 rows selected



HASH JOIN
这种连接是在oracle 7.3以后引入的，从理论上来说比NL与SMJ更高效，而且只用在CBO优化器中。
较小的row source被用来构建hash table与bitmap，第2个row source被用来被hashed，并与第一个row source生成的hash table进行匹配，以便进行进一步的连接。Bitmap被用来作为一种比较快的查找方法，来检查在hash table中是否有匹配的行。特别的，当hash table比较大而不能全部容纳在内存中时，这种查找方法更为有用。这种连接方法也有NL连接中所谓的驱动表的概念，被构建为hash table与bitmap的表为驱动表，当被构建的hash table与bitmap能被容纳在内存中时，这种连接方式的效率极高。
Hash join处理的两个数据集分布称为构造输入(build input)和探测输入(probe input)。


Hash join有3种不同的类型：
1）Optimal hash join
整个join过程都是在位于PGA中的SQL WORKAREA中进行的，也就是说hash join也有其界限约束，通常如果build table能够完全cache在SQL WORKAREA指定的内存中，那么就最能体现hash join在其性能上的优势。这种情况下的hash join我们称作Optimal hash join。


2）one pass hash join
如果build table不能完全cache在内存中（workarea有一部分block支持probe table dump的I/O需求），那么oracle会对build table进行partition，partition数取决于oracle的一种内部算法，如果在partition后单个partition能够完全cache在内存中，那么我们称作这种hash join为one pass hash join，因为此时需要将其余的partition dump到temp段中，并且对于probe table，首先会进行位图扫描，直接丢弃不匹配的记录，然后会通过hash函数分布映射到对应的build table partition上，最后dump到临时段(ORACLE会产生有一个地址列表，列出了剩余build table partition和剩余probe table partition的在temp段中的位置和对应关系)，当然如果匹配当前partition的probe table部分，那么处理会像Optimal一样，直接传输至客户端进行输出。当dump 完整个probe table 以后，我们拥有了3对不同build probe partition。之后Oracle会从temp段dump出第二个build partition（或者是probe partition，此时会进行动态驱动分区选择），然后从地址列表中找到对应的probe partition，再次进行类似Optimal hash join。从整个join周期来看，bulid table和probe table都在temp中dump了一遍，所以这种类型的hash join被称为one pass hash join。


3）mutiple pass hash join
最后，如果我们的内存特别小或者相对而言需要hash的数据特别大，hash join就会以最恶劣的方式执行：multipass hash join。如果说onepass是只需要多从磁盘做一次probe table的读取，那么multipass就需要做多次读取，这往往发生在可用内存和数据量相差很大的情况下。multipass hash join是我们需要尽量避免的东西。


好在现在的PGA是采样自动管理，而不是手动管理。自动管理可以合理使用我们有限的内存，使更多的 hash join可以在optimal下完成， hash join所使用的内存在整个处理的阶段是会一直改变的，也就是说可能在最开始的时候需要很多内存，后来就只需要很少的内存，如果我们是运行在PGA自动管理模式下，oracle可以在hash join不需要太多内存做hash join的时候回收这些内存，而这在手动管理模式下是做不到的。

例子：
SQL> explain plan for
  2  select /*+ use_hash(a, b)*/a.dname, b.sal
  3  from scott.dept a, scott.emp b
  4  where a.deptno = b.deptno;

Explained

SQL> select * from table(dbms_xplan.display);

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 1093152308
---------------------------------------------------------------------------
| Id  | Operation          | Name | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |      |    14 |   280 |     7  (15)| 00:00:01 |
|*  1 |  HASH JOIN         |      |    14 |   280 |     7  (15)| 00:00:01 |
|   2 |   TABLE ACCESS FULL| DEPT |     4 |    52 |     3   (0)| 00:00:01 |
|   3 |   TABLE ACCESS FULL| EMP  |    14 |    98 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   1 - access("A"."DEPTNO"="B"."DEPTNO")

15 rows selected

SORT MERGE JOIN


内部连接过程：
1) 首先生成row source1需要的数据，然后对这些数据按照连接操作关联列进行排序。
2) 随后生成row source2需要的数据，然后对这些数据按照与sort source1对应的连接操作关联列进行排序。
3) 最后两边已排序的行被放在一起执行合并操作，即将2个row source按照连接条件连接起来
下面是连接步骤的图形表示：
 MERGE
       /     \
    SORT     SORT
     |         |
Row Source 1 Row Source 2

如果row source已经在连接关联列上被排序，则该连接操作就不需要再进行sort操作，这样可以大大提高这种连接操作的连接速度，因为排序是个极其费资源的操作，
特别是对于较大的表。 预先排序的row source包括已经被索引的列或row source已经在前面的步骤中被排序了。尽管合并两个row source的过程是串行的，但是可以并行访问这两个row source(如并行读入数据，并行排序).
排序是一个费时、费资源的操作，特别对于大表。基于这个原因，SMJ经常不是一个特别有效的连接方法，但是如果2个row source都已经预先排序，则这种连接方法的效率也是蛮高的

如果row source已经在连接关联列上被排序，则该连接操作就不需要再进行sort操作，这样可以大大提高这种连接操作的连接速度，因为排序是个极其费资源的操作，
特别是对于较大的表。 预先排序的row source包括已经被索引的列或row source已经在前面的步骤中被排序了。尽管合并两个row source的过程是串行的，但是可以并行访问这两个row source(如并行读入数据，并行排序).
排序是一个费时、费资源的操作，特别对于大表。基于这个原因，SMJ经常不是一个特别有效的连接方法，但是如果2个row source都已经预先排序，则这种连接方法的效率也是蛮高的

SQL> explain plan for
  2  select /*+ use_mj(a, b)*/a.dname, b.sal
  3  from scott.dept a, scott.emp b
  4  where a.deptno = b.deptno;

Explained

SQL> select * from table(dbms_xplan.display);

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 2865896559
--------------------------------------------------------------------------------
| Id  | Operation                    | Name    | Rows  | Bytes | Cost (%CPU)| Ti
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |         |    14 |   280 |     6  (17)| 00
|   1 |  MERGE JOIN                  |         |    14 |   280 |     6  (17)| 00
|   2 |   TABLE ACCESS BY INDEX ROWID| DEPT    |     4 |    52 |     2   (0)| 00
|   3 |    INDEX FULL SCAN           | PK_DEPT |     4 |       |     1   (0)| 00
|*  4 |   SORT JOIN                  |         |    14 |    98 |     4  (25)| 00
|   5 |    TABLE ACCESS FULL         | EMP     |    14 |    98 |     3   (0)| 00
--------------------------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   4 - access("A"."DEPTNO"="B"."DEPTNO")
       filter("A"."DEPTNO"="B"."DEPTNO")


总结：
总结一下，在哪种情况下用哪种连接方法比较好：
排序 - - 合并连接(Sort Merge Join, SMJ)：
如果在关联的列上都有索引，那么效率会比较好，因为省却了排序的步骤
嵌套循环(Nested Loops, NL)：
a) 如果driving row source(外部表)比较小，并且在inner row source(内部表)上有唯一索引，或有高选择性非唯一索引时，使用这种方法可以得到较好的效率。
b) NESTED LOOPS有其它连接方法没有的的一个优点是：可以先返回已经连接的行，而不必等待所有的连接操作处理完才返回数据，这可以实现快速的响应时间。
哈希连接(Hash Join, HJ)：
a) 这种方法是在oracle7后来引入的，使用了比较先进的连接理论，
一般来说，其效率应该好于其它2种连接，但是这种连接只能用在
CBO优化器中。
b) 在2个较大的row source之间连接时会取得相对较好的效率，在一个row source较小时则能取得更好的效率。
c) 只能用于等值连接中
在这个大家都关心的章节开篇前，先介绍下几个简单概念
物理读
数据只要从除了buffer cache以外的地方读入到buffer cache或PGA就是数据库的物理读。
逻辑读
逻辑读指的就是Buffer Cache中读取数据块。按照访问数据块的模式不同，可以分为即时读（Current Read）和一致性读（Consistent Read）。
Cpu time
Sql执行所消耗的cpu时间，影响这部分时间的因素有很多，有逻辑读、物理读、过滤、排序以及hash join等等操作。


DB time
DB time=DB CPU+ DB waiting time(no-idle time)，不包括网络传输时间

Elapsed time
Sql的执行时间。这部分时间包括了DB time和 网络传输时间，调整客户端的array size能够影响网络传输时间。

Array size
是sqlplus中的一个设置，定义了一次返回到客户端的行数，默认是15行。假设一个块中平均有270条数据，当array size为5的时候，从服务器到客户端传输需要24个buffer gets；当调大array size到50时，只需要6个buffer gets，大大减少了逻辑读次数，同时网络传输开销也可以大大节约。

介绍了那么多知识点，还没有涉及到实际的优化工作。在接触第一个例子前，来问一个问题。什么是优化？优化的目的是什么？
优化是选择较优的执行计划来执行SQL语句的过程，对于复杂的sql，有时是需要取权衡的，可能在一个场景中是最优，但是另一个场景中不是好的执行计划。
优化的目的我认为可以分多种。大多数人的理解可能是执行时间的降低，如果是通过降低资源的消耗来达到降低执行时间，那是最好的，也是最常见的。但某些情况下，可能需要增加cpu的使用来缩短sql执行时间，如在晚上数据库相对比较空闲的时候对一个跑批的sql加并行处理以加快处理速度，而这种方法在系统繁忙时候就不能采用。

对于最常见的优化方式，我们关注的是逻辑读和cpu time，可能大家还会说需要关注物理读，物理读也是影响sql执行效率的一个因素，但是这是一个可变的因素，sql第一次执行时因为需要从磁盘读取数据块到buffer cache中，所以逻辑读会相对较高。但之后的执行物理读就会降下来了，对于一个频繁读取的sql，物理读不适合作为评判sql执行效率的依据。

优化器总是希望以最小的代价（cost）来完成任务，我们的思路也应该是这样的。要学会像优化器一样去思考，需要关注几点：
1)表之间的连接类型是什么，哪个表做驱动表
2)走全表扫描还是走索引
3)如果是走索引，那个索引是最优的

我们看一个案例：
SELECT COUNT(A.ASSIST_NO)
  FROM T_PUB_ASSIST_APPLY A, T_PC_VEHICLE V, T_PUB_TASK T
WHERE A.VEHICLE_ID = V.NETS_VEHICLE_ID
   AND A.TASK_GROUP_ID = T.TASK_GROUP_ID
   AND T.COVERAGE_ID IN (1, 2)
   AND A.ASSISTANT = :V_ASSISTANT
   AND T.STATUS IN ('1', '2', '3')
   AND A.STATUS IN ('7', '9');


这个sql共有三张表做关联：
T_PUB_ASSIST_APPLY A, T_PC_VEHICLE V, T_PUB_TASK T
关联条件为：
A.VEHICLE_ID = V.NETS_VEHICLE_ID
   AND A.TASK_GROUP_ID = T.TASK_GROUP_ID
谓词条件为：
AND T.COVERAGE_ID IN (1, 2)
   AND A.ASSISTANT = :V_ASSISTANT
   AND T.STATUS IN ('1', '2', '3')
   AND A.STATUS IN ('7', '9')

优化器先通过谓词条件过滤再做表关联, 所以我们先看谓词条件，。
谓词条件分别在两张表上：
T_PUB_TASK的COVERAGE_ID和STATUS
T_PUB_ASSIST_APPLY的ASSISTANT和STATUS。
分布查看这两张表上这几个字段相关的索引：


表T_PUB_ASSIST_APPLY：
SQL>  col index_name format a25
SQL> col column_name format a25
SQL> col column_position format a1
SQL>
SQL> SELECT INDEX_NAME, COLUMN_NAME, COLUMN_POSITION
  2    FROM DBA_IND_COLUMNS
  3   WHERE INDEX_NAME IN
  4         (SELECT DISTINCT INDEX_NAME
  5            FROM DBA_IND_COLUMNS
  6           WHERE TABLE_NAME = 'T_PUB_ASSIST_APPLY'
  7             AND COLUMN_NAME IN ('ASSISTANT', 'STATUS'))
  8   ORDER BY INDEX_NAME, COLUMN_POSITION;

INDEX_NAME                COLUMN_NAME               C
------------------------- ------------------------- -
IX_ASSITAPPLY_APPL_STAT   APPLY_UMID                1
IX_ASSITAPPLY_APPL_STAT   STATUS                    2
IX_ASSITAPPLY_ASSI_STAT   ASSISTANT                 1
IX_ASSITAPPLY_ASSI_STAT   STATUS                    2
IX_ASSITAPPLY_DEPA_STAT   DEPARTMENT_THIRD_CODE     1
IX_ASSITAPPLY_DEPA_STAT   STATUS                    2
6 rows selected

表：T_PUB_TASK
SQL> col index_name format a30
SQL> col column_name format a25
SQL> col column_position format a1
SQL>
SQL>
SQL> SELECT INDEX_NAME, COLUMN_NAME, COLUMN_POSITION
  2    FROM DBA_IND_COLUMNS
  3   WHERE INDEX_NAME IN
  4         (SELECT DISTINCT INDEX_NAME
  5            FROM DBA_IND_COLUMNS
  6           WHERE TABLE_NAME = 'T_PUB_TASK'
  7             AND COLUMN_NAME IN ('COVERAGE_ID', 'STATUS'))
  8   ORDER BY INDEX_NAME, COLUMN_POSITION;

INDEX_NAME                     COLUMN_NAME               C
------------------------------ ------------------------- -
IDX_TASK_GROUP_ID_STATUS       TASK_GROUP_ID             1
IDX_TASK_GROUP_ID_STATUS       STATUS                    2
IDX_TASK_TEAM_STATUS_POLICY    TEAM_ID                   1
IDX_TASK_TEAM_STATUS_POLICY    STATUS                    2
IDX_TASK_TEAM_STATUS_POLICY    POLICY_END_DATE           3
IDX_TASK_TEAM_STATUS_POLICY    TASK_GROUP_ID             4
IDX_TASK_TMR_APPOINT_STATUS    TMR_ID                    1
IDX_TASK_TMR_APPOINT_STATUS    APPOINTMENT_DATE          2
IDX_TASK_TMR_APPOINT_STATUS    STATUS                    3



可以看到，只有索引IX_ASSITAPPLY_ASSI_STAT适合，那么应该是先通过索引查表，然后再做关联。
那么IX_ASSITAPPLY_ASSI_STAT的选择率怎样呢？
SQL> SELECT t.distinct_keys, 1/distinct_keys FROM DBA_IND_STATISTICS t WHERE INDEX_NAME='IX_ASSITAPPLY_ASSI_STAT';

DISTINCT_KEYS 1/DISTINCT_KEYS
------------- ---------------
           21 0.0476190476190
表中ASSISTANT的值大部分都是空值，所以选择率还可以，实际的情况是：
SELECT count(ASSISTANT), ASSISTANT
  FROM T_PUB_ASSIST_APPLY
  where  STATUS IN ('7', '9')
  group by
  order by count(ASSISTANT);
的ASSISTANT的共有1669个，其中1448个的的count值在100以下，最大的为count值为2873，也就是说row resource1比较小。

看关联条件
A.VEHICLE_ID = V.NETS_VEHICLE_ID
   AND A.TASK_GROUP_ID = T.TASK_GROUP_ID
对应的表T_PUB_TASK字段TASK_GROUP_ID上的索引
SQL>  SELECT INDEX_NAME, COLUMN_NAME, COLUMN_POSITION
  2    FROM DBA_IND_COLUMNS
  3   WHERE INDEX_NAME IN
  4         (SELECT DISTINCT INDEX_NAME
  5            FROM DBA_IND_COLUMNS
  6           WHERE TABLE_NAME = 'T_PUB_TASK'
  7             AND COLUMN_NAME IN ('TASK_GROUP_ID'))
  8   ORDER BY INDEX_NAME, COLUMN_POSITION;

INDEX_NAME                     COLUMN_NAME               C
------------------------------ ------------------------- -
IDX_TASK_GROUP_ID_STATUS       TASK_GROUP_ID             1
IDX_TASK_GROUP_ID_STATUS       STATUS                    2
IDX_TASK_TEAM_STATUS_POLICY    TEAM_ID                   1
IDX_TASK_TEAM_STATUS_POLICY    STATUS                    2
IDX_TASK_TEAM_STATUS_POLICY    POLICY_END_DATE           3
IDX_TASK_TEAM_STATUS_POLICY    TASK_GROUP_ID             4
IX_TASK_UD_AP_GID              UPDATED_DATE              1
IX_TASK_UD_AP_GID              AFTER_APPOINT_PRIORITY    2
IX_TASK_UD_AP_GID              TASK_GROUP_ID             3

9 rows selected

对应的表T_PC_VEHICLE字段NETS_VEHICLE_ID上的索引
SQL>
SQL>  SELECT INDEX_NAME, COLUMN_NAME, COLUMN_POSITION
  2    FROM DBA_IND_COLUMNS
  3   WHERE INDEX_NAME IN
  4         (SELECT DISTINCT INDEX_NAME
  5            FROM DBA_IND_COLUMNS
  6           WHERE TABLE_NAME = 'T_PC_VEHICLE'
  7             AND COLUMN_NAME IN ('NETS_VEHICLE_ID'))
  8   ORDER BY INDEX_NAME, COLUMN_POSITION;

INDEX_NAME                     COLUMN_NAME               C
------------------------------ ------------------------- -
PK_PC_VEHICLE                  NETS_VEHICLE_ID           1

NETS_VEHICLE_ID对应的是PK_PC_VEHICLE，是主键索引，高选择率。
TASK_GROUP_ID结合status，只能使用IDX_TASK_GROUP_ID_STATUS，选择率肯定没有主键索引好。


现在大致情况我们都知道了。
通过分析谓词条件，可以走表T_PUB_ASSIST_APPLY的X_ASSITAPPLY_ASSI_STAT索引，表T_PUB_ASSIST_APPLY可以作为驱动表。
 通过分析关联条件，比较表T_PC_VEHICLE和表T_PUB_TASK关联字段的索引选择率，表T_PC_VEHICLE更适合作为和表T_PUB_ASSIST_APPLY关联的被驱动表。
Row resource1数据量很低，而被驱动表上又有高效的唯一性索引，非常适合用NESTED LOOP。
表T_PUB_ASSIST_APPLY和表T_PC_VEHICLE关联后的结果集再和T_PUB_TASK做NESTED LOOP。
我们来看下实际的执行计划如何：


|   0 | SELECT STATEMENT                   |                          |     1 |35 |    10   (0)|

|   1 |  SORT AGGREGATE                   |                          |     1 |35 |            |
|*  2 |   TABLE ACCESS BY INDEX ROWID   | T_PUB_TASK               |     1 |12 |     5   (0)|

|   3 |    NESTED LOOPS                        |                          |     1 |35 |    10   (0)|

|   4 |     NESTED LOOPS                       |                          |     1 |23 |     5   (0)|

|   5 |      TABLE ACCESS BY INDEX ROWID  | T_PUB_ASSIST_APPLY       |     1 |17 |     3   (0)|

|*  6 |       INDEX RANGE SCAN            | IX_ASSITAPPLY_ASSI_STAT  |     1 |   |     2   (0)|

|*  7 |       INDEX UNIQUE SCAN             | PK_PC_VEHICLE            |     1 | 6 |     2   (0)|

|   8 |     INLIST ITERATOR                     |                          |         |   |            |

|*  9 |       INDEX RANGE SCAN              | IDX_TASK_GROUP_ID_STATUS |     1 |   |     4   (0)|

可以看到，实际的执行计划的确是和我们预想的一样。

注：从Oracle的一个版本到另一个版本，优化器可能对同一语句生成不同的执行计划。在将来的Oracle 版本中，优化器可能会基于它可以用的更好、更理想的信息，作出更优的决策，从而导致为语句产生更优的执行计划。


什么是hint

Cbo已经是相当不错的优化器了，大部分情况下会选择正确的执行计划。但是优化器毕竟是程序，就算统计信息是最新最准确的，也不能保证生成的执行计划一定是好的，这时候就需要我们来人工干预。改变sql执行计划的方式有多种，除了改写sql外，还可以通过加hint来实现，这应该也是最简单的一种方法。
hints是oracle提供的一种机制，用来告诉优化器按照我们的告诉它的方式生成执行计划。我们可以用hints来实现：
1) 使用的优化器的类型
2) 基于代价的优化器的优化目标，是all_rows还是first_rows。
3) 表的访问路径，是全表扫描，还是索引扫描，还是直接利用rowid。
4) 表之间的连接类型
5) 表之间的连接顺序
6) 语句的并行程度

除了使用RULE提示外，使用其他的提示都会自动使用CBO。

如何使用hint
Hints只应用在它们所在sql语句块(statement block，由select、update、delete关键字标识)上，对其它SQL语句或语句的其它部分没有影响。如：对于使用union操作的2个sql语句，如果只在一个sql语句上有hints，则该hints不会影响另一个sql语句。
我们可以使用注释(comment)来为一个语句添加hints，一个语句块只能有一个注释，而且注释只能放在SELECT, UPDATE, or DELETE关键字的后面
使用hints的语法：
{DELETE|INSERT|SELECT|UPDATE} /*+ hint [text] [hint[text]]... */
多个hint之间需要用空格分开，如果没有指定正确的hint，oracle讲忽视该hint，没有任何错误提示。

优化器相关
ALL_ROWS -- 基于代价的优化器，以吞吐量为目标
FIRST_ROWS(n) -- 基于代价的优化器，以响应时间为目标
CHOOSE -- 根据是否有统计信息，选择不同的优化器
RULE -- 使用基于规则的优化器

连接类型相关
USE_NL /*+ USE_NL ( table [,table, ...] ) */
使用嵌套连接
USE_MERGE /*+ USE_MERGE ( table [,table, ...]) */
使用排序- -合并连接
USE_HASH /*+ USE_HASH ( table [,table, ...]) */
使用HASH连接
注意：如果表有alias(别名)，则上面的table指的是表的别名，而不是真实的表名

存取路径相关
FULL /*+ FULL ( table ) */
指定该表使用全表扫描
ROWID /*+ ROWID ( table ) */
指定对该表使用rowid存取方法，该提示用的较少
INDEX /*+ INDEX ( table [index]) */
使用该表上指定的索引对表进行索引扫描
INDEX_FFS /*+ INDEX_FFS ( table [index]) */
使用索引快速全扫描
NO_INDEX /*+ NO_INDEX ( table [index]) */
不使用该表上指定的索引进行存取，仍然可以使用其它的索引进行索引扫描

连接顺序相关
ORDERED /*+ ORDERED */
按from 子句中表的顺序从左到右的连接
STAR /*+ STAR */
指示优化器使用星型查询
LEADING /*+ LEADINGING(TAB1,TAB2,……)*/
指定表的连接顺序

使用hint并不总是能如愿，有时需要尝试使用不同的hint。


加hint可以解决偶尔出现的一些执行计划不好sql的性能问题，但是对于一个表相关的很多sql出现执行计划不好的情况时，不应该简单地通过加hint来解决，我们应该考虑是否这个表的统计信息过旧导致优化器选择了不正确的执行计划，这时收集最新的统计信息往往是更好的解决方案。当然，收集统计信息不应该直接在生产库上执行，而是应该在和生产一样的库中如cow库收集并做影响分析，确定没有问题后再通过版本下发导入到生产库中。如果没有cow库，就需要从生产最新的rman备份中恢复一个库出来。

1)stored outline简介
   有时候生产上sql的执行计划发生突变引发生产紧急问题，修改源码加hint在解决问题的时效上不允许的，这时候stored outline就有了用武之地。
可以通过做stored outline，无需更改sql源码，永久地为sql固定执行计划。同样引入了问题，如果数据分布是不均匀的，用stored outline固定后，就算之后发生硬解析，不管bind value是什么（在有直方图的情况下），执行计划也不会变。所以，我觉得stored outline适用于那种数据分布均匀的情况。还有一个问题，oracle的版本升级后，stored outline很可能会失效，如果dba没有做相应的措施，那么很可能在oracle版本升级后原先正确的执行计划会出现问题，所以stored outline的管理也是一件麻烦的事。在，stored outline可以作为临时解决生产问题的方法，但是开发一定要在后续的版本中修正sql问题而不是依赖于stored outline。
2）spm简介
 在Oracle 11g前，我们可以借助Stored Outline来固定sql的执行计划。在oracle 11g中，提供了SPM（SQL PLAN Managment），SPM是Oracle自我管理发展的新功能，自动去判断某个SQL的新的执行计划是否更加合理（成本更低），只有在新的执行计划比原来的执行计划更好的情况下，它才会被使用，从而有效的保护了执行计划的稳定性，进而保证了SQL语句的执行效率。
     Oracle提供了 DBMS_SPM来做相关的管理工作，常用方法有：
DBMS_SPM.ALTER_SQL_PLAN_BASELINE
DBMS_SPM.CREATE_STGTAB_BASELINE
DBMS_SPM.DROP_SQL_PLAN_BASELINE
DBMS_SPM.EVOLVE_SQL_PLAN_BASELINE
DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE

统计信息简介

从上章的hint中，我们可以看出统计信息是非常重要，它是cbo的基础，也是执行计划正确高效的保障。
优化器使用的统计信息，主要包括两类，其一是系统统计信息（System Statistics），用于反映系统中CPU的处理速度，以及从磁盘上读取数据块的速度；另一类就是表和索引的统计信息。对于系统统计信息，可能库的升级或者服务器的迁移，系统的统计信息如CPU成本、多块读成本等的改变会导致执行计划的改变，但是这个不在我们今天培训的范围中，我们讨论的是第二类统计信息。
统计信息是数据中表和索引信息的一些统计，这些信息包括：
表：行数、块数、行平均长度。
列：列中distinct值个数、null值的数量、数据分布。
索引：叶块数量、层级、聚簇因子。


可以通过以下视图来查询对象的统计信息：
DBA_TAB_STATISTICS
DBA_TAB_COL_STATISTICS
DBA_IND_STATISTICS

CBO根据统计信息来计算各种可能的执行计划的cost值，选择cost值最低的执行计划。

收集统计信息的命令有两种：
1）analyze
在oracle 8i以前是用analyze命令。现在基本已不使用这种方法来收集统计信息了（在收集表的行链接的行时还是需要用到这个命令）。
格式：
analyze table …
analyze index …

2）dbms_Stats
在oracle 8i以后用dbms_stats包， oracle建议使用dbms_stats来代替analyze，的确这个包也比analyze好用。

可以收集数据库、schema、表、索引统计：
dbms_stats.gather_database_stats
dbms_stats.gather_system_stats
dbms_stats.gather_schema_stats
dbms_stats.gather_table_stats
dbms_stats.gather_index_stats

你还可以设置表和列的统计信息：
dbms_stats.set_system_stats
dbms_stats.set_table_stats
dbms_stats.set_index_stats
dbms_stats.set_column_stats

锁定和解锁统计信息：
dbms_stats.lock_schema_stats
dbms_stats.lock_table_stats
dbms_stats.lock_partition_stats

也可以导出导入统计信息的：
dbms_stats.export_database_stats
dbms_stats.export_system_stats
dbms_stats.export_schema_stats
dbms_stats.export_table_stats
dbms_stats.export_index_stats
dbms_stats.export_column_stats
dbms_stats.import_database_stats
dbms_stats.import_system_stats
dbms_stats.import_schema_stats
dbms_stats.import_table_stats
dbms_stats.import_index_stats
dbms_stats.import_column_stats

当然不止这些方法，还有很多其他的方法，dbms_stats 包的功能是十分强大的。


动态采样（Dynamic Sampling）技术的最初提出是在Oracle 9i R2，在段（表，索引，分区）没有分析的情况下，为了使CBO优化器得到足够的信息以保证做出正确的执行计划而发明的一种技术，可以把它看做分析手段的一种补充。当段对象没有统计信息时（即没有做分析），动态采样技术可以通过直接从需要分析的对象上收集数据块（采样）来获得CBO需要的统计信息，如数据分布、列的distinct值等。
动态采样在某些情况下是不得已而为之的，如果我们能够收集统计信息，那么还是收集吧，因为这个比动态采样要来得精确得多。
当然，动态采样也有它适用的场景。比如：
对于临时表，数据的变化很频繁，每次的变化量也不一致，变化量差别很大，那么这种情况下每次收集统计是不现实的，这时候oracle的动态采样就可以帮上忙，以相对小的开销得到较优的执行计划。
同样是临时表，每次数据处理完毕后都会清理，但是每次的变化量是一定的，比如都是100w左右，那么这时候可以在数据导入完毕后，收集统计信息并锁定统计信息，效果往往比动态采样会更好。


使用动态采样的时候，使用sql trace可以看到执行计划中会出现如下标红提示：
已用时间:  00: 00: 00.02
执行计划
----------------------------------------------------------
Plan hash value: 1357081020

--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      | 44151 |  7631K|   196   (3)| 00:00:03 |
|*  1 |  TABLE ACCESS FULL| TEST | 44151 |  7631K|   196   (3)| 00:00:03 |
--------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("OBJECT_NAME"='TEST')

Note
-----
   - dynamic sampling used for this statement
当出现标红的字样时，表明执行计划是通过动态采样生成的。


构造直方图最主要的原因就是帮助优化器在表中数据严重偏斜时做出更好的规划。当表中的列的数据分布存在倾斜时——即列的不同值出现数量差异较大，而这个列出现在where子句的谓词中，如果在没有直方图的情况下，oracle对这个列的区分度取的是平均值，这样无法体现sql执行时实际bind值的占比情况，在适合走全表的情况下走了索引扫描，那么就不是一个好的执行计划。

直方图类型 :
频率直方图
Oracle中的频率直方图是按照累积某一列值的出现次数来生成数据分布描述的

高度均衡直方图
直方图的buckets数量的最大值为254个，当列的唯一值超过这个值时，Oracle会以height balanced的方式记录histograms，也就是按照buckets的值把所有的数据平分，如果bucket是50，就把所有的数据平分为50等份，再告诉我们处于每个边界的值

所以oracle引入了直方图。它可以描述列中数据的分布以及倾斜度。当sql发生硬解析时，优化器会依据传入的绑定变量值以及直方图信息来选择正确的执行计划，而不是一成不变的，这个过程叫做bind peeking。
但是同样引入了一个问题，在sql第一次执行时传入的bind值决定了执行计划，不管之后传入的bind值是怎样的，执行计划都不会变，除非发生硬解析，这样，当第一次传入的bind值和之后执行的bind值是在列的倾斜度的两端的数据时，这个执行计划对于这个特定的bind值就不是一个正确的执行计划，直方图依然没有解决问题。(在oracle 9i和10g中，cursor_sharing参数设置为similar可以为不同的bind值生成不同的执行计划，这听起来很不错，但是很不幸的是，它会导致子游标数过高的问题)。折衷的办法就是，分析数据分布，为不同的倾斜度的bind值（在一个范围内，而不是每一个的bind值）sql加hint固定。

由于直方图的种种问题，在的9i、10g库中是不建议自动收集直方图的信息的，对于已有的直方图，为避免影响，不做删除。
如何在收集统计信息时不收集直方图信息呢？在收集统计信息时，METHOD_OPT参数设置为“FOR ALL COLUMNS SIZE1”就不会收集直方图信息。
那么对于已有的直方图信息，在不重新收集统计信息的情况下如何删除呢？dbms_stats同样提供方法，使用dbms_stats.delete_column_stats可以删除列上的统计信息。
Oracle的bind peeking问题，直到11g才得到了解决。11g 的Adaptive Cursor Sharing in Oracle Database 11g Release 1新特性改善了这个情况，即使被bind peeking了，之后执行的时候11g的优化器会选择更优的执行计划。

看到这里，大家可能会问，如果库的统计信息策略是收集不启用，那么数据的变化量就算很大，统计信息也只是收集而不启用，这样会不会造成执行计划的效率变差呢？我觉得可以分两种情况来考虑：
1）数据分布发生了很大的改变
在数据库参数没有改变，且统计信息保持不变的情况下，sql的执行计划也是不变的，但是数据分布已经发生变化了，原先可能是正确的执行计划，现在可能已经是一个效率较差的执行计划了，这时候就需要考虑是否对这张表重新收集统计信息或者导入最新的统计信息，前提是需要做影响分析。
2）虽然数据量变化很大，但是数据分布改变不大
这种情况下，原先的执行计划还是正确的执行计划，就无需启用新的统计信息。


的统计信息收集策略
从oracle 10g开始，oracle会自动进行统计信息收集工作，看起来这个功能不错，遗憾的是，往往这个自动收集会带来很多问题，比如执行时间过长，在生产库自动收集统计信息导致生产执行计划突变等，所以在，除了11g的库以外（11g有强大的SPM），其他版本的数据库是不允许oracle自动收集统计信息的（9i本身就不会自动收集）。
现在的非11g库的统计信息收集工作是由DBA开发的统计信息收集脚步来实现的（11g库在今年也会使用这套脚步），一般原则下，所有的ddl变更，都是需要重新收集统计信息。对于dml变更，程序会判断数据的变化量，如果达到10%（这个标准和oracle的自动收集标准是一致的），就会自动备份当前统计信息，然后调用我们的给的规范收集统计信息，再根据当前库的收集策略是收集启用还是收集不启用来判断是否需要启用新的统计信息。


表的数据量大不代表性能就一定差，可能我们只是在数据量为1亿的表中查找几条数据，如果是在走索引的情况下，和在100W表的表中查询几条数据的效率几乎是没有区别的。这和索引的结构有关系，见下页的图。
这是一个常见的高度为3的B树索引，有根节点、子节点和叶节点，在这样的索引中，查询一条只需要4个IO，根节点一个IO，子节点一个IO，叶节点一个IO，根据得到的ROWID直接定位到表块又是一个IO。这种看的话，对于数据量是一亿或100万，所消耗的IO是一样的，不存在大表的查询慢的问题，对于小范围的索引扫描，也同样适用。关于索引的问题，有大师专门写了一本书，要讲的话需要单独做培训。
当然，查询如果需要用到全表扫描时，大表和小表的区别还是非常明显的。
OLTP
OLAP

相同的一个说法是走全表的一定是不好的。真的是这样吗？不尽然。
刚我们看到了索引的高效，在一百万甚至更大的表中查询一条记录，如果通过索引扫描，只需要4个IO即可搞定，那么索引应该是最优的选择啊。这个还是要看情况，对于OLTP系统中，可能我只要在大表中查询几条数据，这种情况索引的确适用，但是在一些跑批或olap系统中的统计sql，我可能需要查询表中大部分的数据，比如表中有1年的数据，我可能需要扫描其中半年的数据，这时候再用索引做扫描就不合适了（如果select后的字段就是索引中的字段，那么走INDEX FAST FULL SCAN而不需要访问表块则另当别论）。那么什么时候使用索引，什么时候使用全表扫描，有这样一个阀值吗？
一般我们认为，索引在查询表中某个阀值（一般这个阀值被认为在10%至20%之间）以下的数据量时是比较快的，这个时候走索引比全表扫描要更优，扫描的范围越小，性能也越好。但是当查询的结果集大于阀值时，全表扫描的性能就好于索引扫描了，我们也可以在MIS系统中经常看到全表扫描的场景。


这个阀值也只是大家的经验值，我们还需要考虑数据的分布问题，举一个极端的情况，需要查询的数据为整张表的1%，按经验，走索引会比全表好，如果这1%的数据分布在大部分的表块中呢？即使走了索引，还是需要读取大部分的表块，而且还是单块读（一次IO只能读取一个块），而全表扫描是多块读（一次IO读取多个块），全表扫描的效率反而优于索引扫描。
还有一种情况，对于在几十条数据的表中查询一条记录，按经验看，符合走索引扫描的法则，这时候的索引应该是一个blevel为0的索引，那么查询到数据需要2个IO。对于字段较少且字段长度较短的表，几十条数据在几个块中甚至就在一个块中，这时候走全表扫描只需要一个IO即可搞定，没有必要走索引。

相关知识点：
db file sequential read：
db文件顺序读取，一次IO只能读取一个块。索引扫描使用的就是db file sequential read，index fast full scan是个例外。
db file scattered read：
DB文件分散读取，一次IO可以读取多个块。全表扫描使用的多块读，读取的块数受db_file_multiblock_read_count的限制，同时也受到操作系统I/O的限制。

一般认为，驱动表的结果集比较小的情况使用nested loop会比较好，我觉得这是条件一，条件二是被驱动表是走索引唯一性扫描或较小范围的索引范围扫描。如果被驱动表很大的话，并且使用的范围扫描且这个范围扫描的范围很大的话，nested loop也可能不如hash join。


经常听到开发同事说，我的表很大，有几亿条数据，需要做分区，但是大表一定适合做分区吗？我觉得不是一概而论的。
首先我们来了解下分区表可以解决什么样的问题：
1）数据清理
经常会有定期清理数据的需求，大家普遍的做法是把需要清理的数据用delete来做清理，这种做法没有错，但delete操作本身会使用大量的undo段，delete操作产生的undo量是三张DML操作中最多的。所以大家会觉得这种操作非常耗时，如果是大数据量的删除，还需要分段提交以免undo段不够用。
这时候，表是分区表，且可以按照分区来清理数据时，比如我的表是按月分区的，要清理3个月前的数据，那么只需要简单地truncate或者drop无用的分区即可而不需要做delete，效率非常高，不会消耗很多的undo，产生的redo也非常少。需要注意的是，这种情况下，全局索引可能会变成无效，需要重建的。

2）分区扫描
经常会有这样的需求，一张大表存有一年的数据，而查询的时间范围是3个月，那么这种情况下，是不适合走索引的，会走全表扫描，扫描整张表12个月的数据，其实我们只要扫描3个月的数据即可，其余的9个月数据是没有必要扫描的。如果表按月来分区，那么oracle只会扫描这三个月对应的分区，并且可以开并行扫描，效率和之前的整张表的扫描差别还是非常大的。
Partition pruning （分区消除）

当然，我举的都是简单的例子，大家一眼就能看出来可以用分区表来提高性能的。实际的情况往往没有那么简单，这个就需要具体分析，其中分区键的选择以及索引的创建是非常重要的。

执行计划中的cost高低是执行计划优劣的依据

我发现很多开发同事在做sql调优时，把cost的高低作为执行计划好坏的一个判断标准。很遗憾的是，这个cost往往会误导大家。Cost是指cbo中这一步所耗费的资源，是cbo根据统计信息计算出来，cost的计算是非常复杂的算法，就算统计信息是最新的，生成的cost也是有可能不准确的，所以cost的高低不能成为判断执行计划优劣的依据。而是应该通过访问路径、连接方式等来判断。
Explain plan看到的Cost的值是一个估算值而不是实际值，同样，实际执行后看到的执行计划中的cost同样也是一个估算值。Oracle只有在实际执行sql后才能知道执行计划的优劣，下面介绍的性能调优工具也是需要实际执行sql才能判断执行计划的优劣。

总是使用高选择率的column作为复合索引的引导列
在创建复合索引前，我们要考虑多种因素，列的选择率高低，列在其他sql中出现的情况等。
如：
有列col1、col2，col1和col2的选择率都还可以，col1的选择率略高于col2，看到这里为止，col1应该更适合于做引导列。在其他sql中，col1不单独出现，而col2却有单独出现的情况，且在对应的sql中没有其他索引可以用，这时候col2做为复合索引的引导列会比较合适，这样对于那些col2单独出现的sql也可以使用到索引，而使用col1做为引导列的话，则不会。

索引必须定期重建
频繁dml（insert、update、delete）的表，对应的索引会出现碎片率上升的情况，很多同事认为索引碎片的上升会影响性能，需要定期重建，真是这样吗？我们需要从使用情况结合索引的结构来分析。
1）Index unique scan：
如果是索引唯一性扫描，对于一个blevel为2的索引，只需要4个IO即可得到结果（如果我们要的结果在索引中，那么只需要3个IO），除非因为大量的dml导致索引的blevel增加，增加1级blevel增加一个IO，不过blevel的增加是几何级的概念，这个可能性非常小。
2）index range scan
碎片率上升后，索引块中的数据会比较分散，所以在这种情况下，性能可能会有下降，这个程度和索引块中的行数、扫描扫描大小有关。
3）查询中大部分都是表块
如果sql查询中，大部分IO都是在查表块，那么重建索引对于性能提升用处也不大。

开发在写sql时不用了解数据的分布
了解了数据的分布，才可以写出正确的sql，最简单的就是直方图的问题。不光开发，开发dba和DA也同样需要了解。


创建临时表存放中间结果
如果中间结果是在一个sql中多次用到，可以用with as缓存在内容中来代替，如果是在package中多个sql用到，则可以创建。

应使用GTT（Global Temporary Table）来代替普通表作为临时数据存放的表。



