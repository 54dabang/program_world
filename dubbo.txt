第1章 如何设计一款重复的高性能分布式发号器1
1.1 可选方案及技术选型2
1.1.1 为什么不用UUID2
1.1.2 基于数据库的实现方案2
1.1.3 Snowflake开源项目3
1.1.4 小结4
1.2 分布式对发号器的基本需求4
1.3 架构设计与核心要点6
1.3.1 发布模式6
1.3.2 ID类型7
1.3.3 数据结构7
1.3.4 并发9
1.3.5 机器ID的分配9
1.3.6 时间同步
1.3.7 设计验证11
1.4 如何根据设计实现多场景的发号器11
1.4.1 项目结构12
1.4.2 服务接口的定义14
1.4.3 服务接口的实现15
1.4.4 ID元数据与长整型ID的互相转换22
1.4.5 时间操作25
1.4.6 机器ID的生成27
1.4.7 小结32
1.5 如何保证性能需求32
1.5.1 嵌入发布模式的压测结果33
1.5.2 中心服务器发布模式的压测结果33
1.5.3 REST发布模式（Netty实现）的压测结果33
1.5.4 REST发布模式（Spring Boot Tomcat实现）的压测结果34
1.5.5 性能测试总结34
1.6 如何让用户快速使用35
1.6.1 REST发布模式的使用指南35
1.6.2 服务化模式的使用指南38
1.6.3 嵌入发布模式的使用指南41
1.7 为用户提供API文档43
1.7.1 RESTful API文档44
1.7.2 Java API文档45
第2章 可灵活扩展的消息队列框架的设计与实现49
2.1 背景介绍50
2.2 项目目标50
2.2.1 简单易用50
2.2.2 高性能51
2.2.3 高稳定性51
2.3 架构难点51
2.3.1 线程模型51
2.3.2 异常处理53
2.3.3 优雅关机53
2.4 设计与实现54
2.4.1 项目结构54
2.4.2 项目的规划55
2.4.3 生产者的设计与实现57
2.4.4 消费者的设计与实现58
2.4.5 启动模块的设计与实现67
2.4.6 消息处理器的体系结构76
2.4.7 反射机制79
2.4.8 模板项目的设计80
2.5 使用指南82
2.5.1 安装步骤82
2.5.2 Java API83
2.5.3 与Spring环境集成84
2.5.4 对服务源码进行注解85
2.6 API简介87
2.6.1 Producer API87
2.6.2 Consumer API88
2.6.3 消息处理器88
2.6.4 消息处理器定义的注解90
2.7 消息处理机模板项目91
2.7.1 快速开发向导91
2.7.2 后台监控和管理92
第3章 轻量级的数据库分库分表架构与框架93
3.1 什么是分库分表94
3.1.1 使用数据库的三个阶段94
3.1.2 在什么情况下需要分库分表95
3.1.3 分库分表的典型实例96

3.2 三种分而治之的解决方案97
3.2.1 客户端分片97
3.2.2 代理分片0
3.2.3 支持事务的分布式数据库1
3.3 分库分表的架构设计2
3.3.1 整体的切分方式2
3.3.2 水平切分方式的路由过程和分片维度6
3.3.3 分片后的事务处理机制7
3.3.4 读写分离119
3.3.5 分库分表引起的问题119
3.4 流行代理分片框架Mycat的初体验123
3.4.1 安装Mycat123
3.4.2 配置Mycat124
3.4.3 配置数据库节点128
3.4.4 数据迁移129
3.4.5 Mycat支持的分片规则129
3.5 流行的客户端分片框架Sharding JDBC的初体验138
3.5.1 Sharding JDBC简介138
3.5.2 Sharding JDBC的功能139
3.5.3 Sharding JDBC的使用141
3.5.4 Sharding JDBC的使用限制152
3.6 自研客户端分片框架dbsplit的设计、实现与使用153
3.6.1 项目结构154
3.6.2 结构和执行流程155
3.6.3 切片下标命名策略159
3.6.4 SQL解析和组装167
3.6.5 SQL实用程序168
3.6.6 反射实用程序173
3.6.7 分片规则的配置177
3.6.8 支持分片的SplitJdbcTemplate和SimpleSplitJdbcTemplate接口API179
3.6.9 JdbcTemplate的扩展SimpleJdbcTemplate接口API184
3.6. 用于创建分库分表数据库的脚本工具187
3.6.11 使用dbsplit的一个简单示例192
3.6.12 使用dbsplit的线上真实示例展示199
第4章 缓存的本质和缓存使用的实践201
4.1 使用缓存的目的和问题202
4.2 自相似，CPU的缓存和架构的缓存203
4.2.1 CPU缓存的架构及性能205
4.2.2 CPU缓存的运行过程分析206
4.2.3 缓存行与伪共享208
4.2.4 从CPU的体系架构到分布式的缓存架构218
4.3 常用的分布式缓存解决方案221
4.3.1 常用的分布式缓存的对比221
4.3.2 Redis初体验225
4.4 分布式缓存的通用方法229
4.4.1 缓存编程的具体方法229
4.4.2 应用层访问缓存的模式233
4.4.3 分布式缓存分片的三种模式235
4.4.4 分布式缓存的迁移方案238
4.4.5 缓存穿透、缓存并发和缓存雪崩244
4.4.6 缓存对事务的支持246
4.5 分布式缓存的设计与案例248
4.5.1 缓存设计的核心要素248
4.5.2 缓存设计的实践250
4.5.3 关于常见的缓存线上问题的案例253
4.6 客户端缓存分片框架redic的设计与实现257
4.6.1 什么时候需要redic258
4.6.2 如何使用redic258
4.6.3 更多的配置258
4.6.4 项目结构260
4.6.5 结构261
4.6.6 设计与实现的过程261
第5章 大数据利器之Elasticsearch268
5.1 Lucene简介269
5.1.1 核心模块269
5.1.2 核心术语270
5.1.3 检索方式271
5.1.4 分段存储273
5.1.5 段合并策略275
5.1.6 Lucene相似度打分278
5.2 Elasticsearch简介286
5.2.1 核心概念286
5.2.2 3C和脑裂289
5.2.3 事务日志291
5.2.4 在集群中写索引294
5.2.5 集群中的查询流程295
5.3 Elasticsearch实战298
5.3.1 Elasticsearch的配置说明298
5.3.2 常用的接口300
5.4 性能调优305
5.4.1 写优化305
5.4.2 读优化308
5.4.3 堆大小的设置313
5.4.4 服务器配置的选择315
5.4.5 硬盘的选择和设置316
5.4.6 接入方式318
5.4.7 角色隔离和脑裂319

第7章 RPC服务的发展历程和对比分析377
7.1 什么是RPC服务378
7.2 RPC服务的原理379
7.2.1 Sokcet套接字379
7.2.2 RPC的调用过程380
7.3 在程序中使用RPC服务382

7.4 RPC服务的发展历程383
7.4.1 代RPC：以ONC RPC和DCE RPC为代表的函数式RPC384
7.4.2 第二代RPC：支持面对象的编程388
7.4.3 第三代RPC：SOA和微服务398
7.4.4 架构的演进402
7.5 主流的RPC框架403
7.5.1 Thrift403
7.5.2 ZeroC Ice4
7.5.3 gRPC418
7.5.4 Dubbo430
第8章 Dubbo实战及源码分析436
8.1 Dubbo的四种配置方式437
8.1.1 XML配置437
8.1.2 属性配置440
8.1.3 API配置441
8.1.4 注解配置443
8.2 服务的注册与发现446
8.2.1 注册中心446
8.2.2 服务暴露449
8.2.3 引用服务451
8.3 Dubbo通信协议及序列化探讨455
8.3.1 Dubbo支持的协议455
8.3.2 协议的配置方法456
8.3.3 多协议暴露服务457
8.3.4 Dubbo协议的使用注意事项458
8.3.5 Dubbo协议的约束459
8.4 Dubbo中高效的I/O线程模型459
8.4.1 对Dubbo中I/O模型的分析459
8.4.2 Dubbo中线程配置的相关参数460
8.4.3 在Dubbo线程方面踩过的坑461
8.4.4 对Dubbo中线程使用的建议462
8.5 集群的容错机制与负载均衡462
8.5.1 集群容错机制的原理462
8.5.2 集群容错模式的配置方法464
8.5.3 六种集群容错模式464
8.5.4 集群的负载均衡465
8.6 监控和运维实践467
8.6.1 日志适配467
8.6.2 监控管理后台467
8.6.3 服务降级473
8.6.4 优雅停机475
8.6.5 灰度发布475
8.7 Dubbo项目线上案例解析477
8.7.1 线上问题的通用解决方案477
8.7.2 耗时服务耗尽了线程池的案例480
8.7.3 容错重试机制引发服务雪崩的案例481
8.8 深入剖析Dubbo源码及其实现483
8.8.1 Dubbo的总体架构设计483
8.8.2 配置文件486
8.8.3 Dubbo的核心RPC488
8.8.4 Dubbo巧妙的URL总线设计491
8.8.5 Dubbo的扩展点加载SPI492
8.8.6 Dubbo服务暴露的过程493
8.8.7 服务引用502
8.8.8 集群容错和负载均衡503
8.8.9 集群容错504
8.8. 负载均衡509
第9章 高性能网络中间件512
9.1 TCP/UDP的核心原理及本质探索513
9.1.1 网络模型513
9.1.2 UDP、IP及其未解决的问题515
9.1.3 TCP详解519
9.1.4 是否可以用UDP代替TCP527
9.1.5 网络通信的不可靠性讨论529
9.2 网络测试实践530
9.2.1 网络测试的关键点530
9.2.2 那些必不可少的网络测试工具532
9.2.3 典型的测试报告539
9.3 高性能网络框架的设计与实现544
9.3.1 对代理功能的测试及分析545
9.3.2 网络中间件的使用介绍549
9.3.3 内存和缓存的优化551
9.3.4 快速解析流数据554

