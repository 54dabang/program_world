package com.lmax.disruptor;

import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

import com.lmax.disruptor.util.Util;

/**
 * Base class for the various sequencer types (single/multi).  Provides
 * common functionality like the management of gating sequences (add/remove) and
 * ownership of the current cursor.
 */
public abstract class AbstractSequencer implements Sequencer
{
    private static final AtomicReferenceFieldUpdater<AbstractSequencer, Sequence[]> SEQUENCE_UPDATER =
            AtomicReferenceFieldUpdater.newUpdater(AbstractSequencer.class, Sequence[].class, "gatingSequences");

    protected final int bufferSize;
    protected final WaitStrategy waitStrategy;
    protected final Sequence cursor = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
    protected volatile Sequence[] gatingSequences = new Sequence[0];

    /**
     * Create with the specified buffer size and wait strategy.
     *
     * @param bufferSize The total number of entries, must be a positive power of 2.
     * @param waitStrategy
     */
    public AbstractSequencer(int bufferSize, WaitStrategy waitStrategy)
    {
        if (bufferSize < 1)
        {
            throw new IllegalArgumentException("bufferSize must not be less than 1");
        }
        if (Integer.bitCount(bufferSize) != 1)
        {
            throw new IllegalArgumentException("bufferSize must be a power of 2");
        }

        this.bufferSize = bufferSize;
        this.waitStrategy = waitStrategy;
    }

    /**
     * @see Sequencer#getCursor()
     */
    @Override
    public final long getCursor()
    {
        return cursor.get();
    }

    /**
     * @see Sequencer#getBufferSize()
     */
    @Override
    public final int getBufferSize()
    {
        return bufferSize;
    }

    /**
     * @see Sequencer#addGatingSequences(Sequence...)
     */
    @Override
    public final void addGatingSequences(Sequence... gatingSequences)
    {
        SequenceGroups.addSequences(this, SEQUENCE_UPDATER, this, gatingSequences);
    }

    /**
     * @see Sequencer#removeGatingSequence(Sequence)
     */
    @Override
    public boolean removeGatingSequence(Sequence sequence)
    {
        return SequenceGroups.removeSequence(this, SEQUENCE_UPDATER, sequence);
    }

    /**
     * @see Sequencer#getMinimumSequence()
     */
    @Override
    public long getMinimumSequence()
    {
        return Util.getMinimumSequence(gatingSequences, cursor.get());
    }

    /**
     * @see Sequencer#newBarrier(Sequence...)
     */
    @Override
    public SequenceBarrier newBarrier(Sequence... sequencesToTrack)
    {
        return new ProcessingSequenceBarrier(this, waitStrategy, cursor, sequencesToTrack);
    }

    /**
     * Creates an event poller for this sequence that will use the supplied data provider and
     * gating sequences.
     *
     * @param dataProvider The data source for users of this event poller
     * @param gatingSequences Sequence to be gated on.
     * @return A poller that will gate on this ring buffer and the supplied sequences.
     */
    @Override
    public <T> EventPoller<T> newPoller(DataProvider<T> dataProvider, Sequence... gatingSequences)
    {
        return EventPoller.newInstance(dataProvider, this, new Sequence(), cursor, gatingSequences);
    }
}package geym.conc.ch2.sync;

public class Accounting implements Runnable{
	static Accounting instance=new Accounting();
	static int i=0;
	public synchronized static void increase(){
		i++;
	}
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			increase();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(instance);
		Thread t2=new Thread(instance);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.conc.ch2.sync;

public class AccountingSync implements Runnable{
	static AccountingSync instance=new AccountingSync();
	static int i=0;
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			synchronized(instance){
				i++;
			}
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(instance);
		Thread t2=new Thread(instance);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.conc.ch2.sync;

public class AccountingSync2 implements Runnable{
	static AccountingSync2 instance=new AccountingSync2();
	static int i=0;
	public synchronized void increase(){
		i++;
	}
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			increase();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(instance);
		Thread t2=new Thread(instance);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.conc.ch2.sync;

public class AccountingSyncBad implements Runnable{
	static int i=0;
	public synchronized void increase(){
		i++;
	}
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			increase();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(new AccountingSyncBad());
		Thread t2=new Thread(new AccountingSyncBad());
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.conc.ch2.sync;

public class AccountingSyncClass implements Runnable{
	static int i=0;
	public static synchronized void increase(){
		i++;
	}
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			increase();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(new AccountingSyncClass());
		Thread t2=new Thread(new AccountingSyncClass());
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.conc.ch2.sync;

public class AccountingVol implements Runnable{
	static AccountingVol instance=new AccountingVol();
	static volatile int i=0;
	public static void increase(){
		i++;
	}
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			increase();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(instance);
		Thread t2=new Thread(instance);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package com.lmax.disruptor;

/**
 * An aggregate collection of {@link EventHandler}s that get called in sequence for each event.
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 */
public final class AggregateEventHandler<T>
    implements EventHandler<T>, LifecycleAware
{
    private final EventHandler<T>[] eventHandlers;

    /**
     * Construct an aggregate collection of {@link EventHandler}s to be called in sequence.
     *
     * @param eventHandlers to be called in sequence.
     */
    public AggregateEventHandler(final EventHandler<T>... eventHandlers)
    {
        this.eventHandlers = eventHandlers;
    }

    @Override
    public void onEvent(final T event, final long sequence, final boolean endOfBatch)
        throws Exception
    {
        for (final EventHandler<T> eventHandler : eventHandlers)
        {
            eventHandler.onEvent(event, sequence, endOfBatch);
        }
    }

    @Override
    public void onStart()
    {
        for (final EventHandler<T> eventHandler : eventHandlers)
        {
            if (eventHandler instanceof LifecycleAware)
            {
                ((LifecycleAware)eventHandler).onStart();
            }
        }
    }

    @Override
    public void onShutdown()
    {
        for (final EventHandler<T> eventHandler : eventHandlers)
        {
            if (eventHandler instanceof LifecycleAware)
            {
                ((LifecycleAware)eventHandler).onShutdown();
            }
        }
    }
}

package geym.conc.ch5.aio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.concurrent.ExecutionException;

public class AIOClient {
    public static void main(String[] args) throws Exception {
        final AsynchronousSocketChannel client = AsynchronousSocketChannel.open();
        client.connect(new InetSocketAddress("localhost", 8000), null, new CompletionHandler<Void, Object>() {
            @Override
            public void completed(Void result, Object attachment) {
                client.write(ByteBuffer.wrap("Hello!".getBytes()), null, new CompletionHandler<Integer, Object>() {
                    @Override
                    public void completed(Integer result, Object attachment) {
                        try {
                            ByteBuffer buffer = ByteBuffer.allocate(1024);
                            client.read(buffer,buffer,new CompletionHandler<Integer, ByteBuffer>(){
                                @Override
                                public void completed(Integer result, ByteBuffer buffer) {
                                    buffer.flip();
                                    System.out.println(new String(buffer.array()));
                                    try {
                                        client.close();
                                    } catch (IOException e) {
                                        e.printStackTrace();
                                    }
                                }
                                @Override
                                public void failed(Throwable exc, ByteBuffer attachment) {
                                }
                            });
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                    @Override
                    public void failed(Throwable exc, Object attachment) {
                    }
                });
            }
            @Override
            public void failed(Throwable exc, Object attachment) {
            }
        });
        //由于主线程马上结束，这里等待上述处理全部完成
//        Thread.sleep(1000);
    }
}

package geym.conc.ch5.aio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class AIOEchoServer {
    public final static int PORT = 8000;
    private AsynchronousServerSocketChannel server;
    public AIOEchoServer() throws IOException {
        server = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(PORT));
    }

    public void start() throws InterruptedException, ExecutionException, TimeoutException {
        System.out.println("Server listen on " + PORT);
        //注册事件和事件完成后的处理器
        server.accept(null, new CompletionHandler<AsynchronousSocketChannel, Object>() {
            final ByteBuffer buffer = ByteBuffer.allocate(1024);
            public void completed(AsynchronousSocketChannel result, Object attachment) {
                System.out.println(Thread.currentThread().getName());
                Future<Integer> writeResult=null;
                try {
                    buffer.clear();
                    result.read(buffer).get(100, TimeUnit.SECONDS);
                    buffer.flip();
                    writeResult=result.write(buffer);
                } catch (InterruptedException | ExecutionException e) {
                    e.printStackTrace();
                } catch (TimeoutException e) {
                    e.printStackTrace();
                } finally {
                    try {
                        server.accept(null, this);
                        writeResult.get();
                        result.close();
                    } catch (Exception e) {
                        System.out.println(e.toString());
                    }
                }
            }

            @Override
            public void failed(Throwable exc, Object attachment) {
                System.out.println("failed: " + exc);
            }
        });
    }

    public static void main(String args[]) throws Exception {
        new AIOEchoServer().start();
        // 主线程可以继续自己的行为
        while (true) {
            Thread.sleep(1000);
        }
    }
}
package com.lmax.disruptor;

/**
 * Used to alert {@link EventProcessor}s waiting at a {@link SequenceBarrier} of status changes.
 * <P>
 * It does not fill in a stack trace for performance reasons.
 */
@SuppressWarnings("serial")
public final class AlertException extends Exception
{
    /** Pre-allocated exception to avoid garbage generation */
    public static final AlertException INSTANCE = new AlertException();

    /**
     * Private constructor so only a single instance exists.
     */
    private AlertException()
    {
    }

    /**
     * Overridden so the stack trace is not filled in for this exception for performance reasons.
     *
     * @return this instance.
     */
    @Override
    public Throwable fillInStackTrace()
    {
        return this;
    }
}

package geym.conc.ch2.notsafe;

import java.util.ArrayList;

public class ArrayListMultiThread {
    static ArrayList<Integer> al = new ArrayList<Integer>(10);
    public static class AddThread implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 1000000; i++) {
                al.add(i);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(new AddThread());
        Thread t2=new Thread(new AddThread());
        t1.start();
        t2.start();
        t1.join();t2.join();
        System.out.println(al.size());
    }
}
package geym.conc.ch4.atomic;

import java.util.concurrent.atomic.AtomicIntegerArray;

public class AtomicIntegerArrayDemo {
	static AtomicIntegerArray arr = new AtomicIntegerArray(10);
    public static class AddThread implements Runnable{
        public void run(){
           for(int k=0;k<10000;k++)
        	   arr.getAndIncrement(k%arr.length());
        }
    }
	public static void main(String[] args) throws InterruptedException {
        Thread[] ts=new Thread[10];
        for(int k=0;k<10;k++){
            ts[k]=new Thread(new AddThread());
        }
        for(int k=0;k<10;k++){ts[k].start();}
        for(int k=0;k<10;k++){ts[k].join();}
        System.out.println(arr);
	}
}
package geym.conc.ch4.atomic;

import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerDemo {
    static AtomicInteger i=new AtomicInteger();
    public static class AddThread implements Runnable{
        public void run(){
           for(int k=0;k<10000;k++)
               i.incrementAndGet();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] ts=new Thread[10];
        for(int k=0;k<10;k++){
            ts[k]=new Thread(new AddThread());
        }
        for(int k=0;k<10;k++){ts[k].start();}
        for(int k=0;k<10;k++){ts[k].join();}
        System.out.println(i);
    }
}
package geym.conc.ch4.atomic;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

/**
 * 1. AtomicIntegerFieldUpdater有访问权限
 * 2. 必须是非静态字段
 * 3. 必须有volatile
 * @author Geym
 *
 */
public class AtomicIntegerFieldUpdaterDemo {
    public static class Candidate{
        int id;
        volatile int score;
    }
    public final static AtomicIntegerFieldUpdater<Candidate> scoreUpdater
        = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, "score");
    //检查Updater是否工作正确
    public static AtomicInteger allScore=new AtomicInteger(0);
    public static void main(String[] args) throws InterruptedException {
        final Candidate stu=new Candidate();
        Thread[] t=new Thread[10000];
        for(int i = 0 ; i < 10000 ; i++) {
            t[i]=new Thread() {
                public void run() {
                    if(Math.random()>0.4){
                        scoreUpdater.incrementAndGet(stu);
                        allScore.incrementAndGet();
                    }
                }
            };
            t[i].start();
        }
        for(int i = 0 ; i < 10000 ; i++) {  t[i].join();}
        System.out.println("score="+stu.score);
        System.out.println("allScore="+allScore);
    }
}
package geym.conc.ch4.atomic;

import java.util.concurrent.atomic.AtomicReference;

public class AtomicReferenceDemo {
    static AtomicReference<Integer> money=new AtomicReference<Integer>();
    public static void main(String[] args) {
        money.set(19);
        //模拟多个线程同时更新后台数据库，为用户充值
        for(int i = 0 ; i < 3 ; i++) {
            new Thread() {
                public void run() {
                    while(true){
                        while(true){
                            Integer m=money.get();
                            if(m<20){
                                if(money.compareAndSet(m, m+20)){
                                    System.out.println("余额小于20元，充值成功，余额:"+money.get()+"元");
                                    break;
                                }
                            }else{
                                //System.out.println("余额大于20元，无需充值");
                                break ;
                            }
                        }
                    }
                }
            }.start();
        }

        //用户消费线程，模拟消费行为
        new Thread() {
            public void run() {
                for(int i=0;i<100;i++){
                    while(true){
                        Integer m=money.get();
                        if(m>10){
                            System.out.println("大于10元");
                            if(money.compareAndSet(m, m-10)){
                                System.out.println("成功消费10元，余额:"+money.get());
                                break;
                            }
                        }else{
                            System.out.println("没有足够的金额");
                            break;
                        }
                    }
                    try {Thread.sleep(100);} catch (InterruptedException e) {}
                }
            }
        }.start();
    }

}
package geym.conc.ch4.atomic;

import java.util.concurrent.atomic.AtomicStampedReference;

public class AtomicStampedReferenceDemo {
    static AtomicStampedReference<Integer> money=new AtomicStampedReference<Integer>(19,0);
    public static void main(String[] args) {
        //模拟多个线程同时更新后台数据库，为用户充值
        for(int i = 0 ; i < 3 ; i++) {
            final int timestamp=money.getStamp();
            new Thread() {
                public void run() {
                    while(true){
                        while(true){
                            Integer m=money.getReference();
                            if(m<20){
                                if(money.compareAndSet(m, m+20,timestamp,timestamp+1)){
                                    System.out.println("余额小于20元，充值成功，余额:"+money.getReference()+"元");
                                    break;
                                }
                            }else{
                                //System.out.println("余额大于20元，无需充值");
                                break ;
                            }
                        }
                    }
                }
            }.start();
        }

        //用户消费线程，模拟消费行为
        new Thread() {
            public void run() {
                for(int i=0;i<100;i++){
                    while(true){
                        int timestamp=money.getStamp();
                        Integer m=money.getReference();
                        if(m>10){
                            System.out.println("大于10元");
                            if(money.compareAndSet(m, m-10,timestamp,timestamp+1)){
                                System.out.println("成功消费10元，余额:"+money.getReference());
                                break;
                            }
                        }else{
                            System.out.println("没有足够的金额");
                            break;
                        }
                    }
                    try {Thread.sleep(100);} catch (InterruptedException e) {}
                }
            }
        }.start();
    }
}
package geym.conc.ch2.badlock;

public class BadAccountingSync2 implements Runnable{
	static int i=0;
	public synchronized void increase(){
		i++;
	}
	@Override
	public void run() {
		for(int j=0;j<10000;j++){
			increase();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(new BadAccountingSync2());
		Thread t2=new Thread(new BadAccountingSync2());
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.conc.ch2.sync.lockonint;

public class BadLockOnInteger implements Runnable{
    public static Integer i=0;
    static BadLockOnInteger instance=new BadLockOnInteger();
    @Override
    public void run() {
        for(int j=0;j<10000000;j++){
//            synchronized(i){
            synchronized(instance){
                i++;
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(instance);
        Thread t2=new Thread(instance);
        t1.start();t2.start();
        t1.join();t2.join();
        System.out.println(i);
    }
}package geym.conc.ch2.badlock;

public class BadLockOnInteger implements Runnable{
	public static Integer i=0;
	static BadLockOnInteger instance=new BadLockOnInteger();
	@Override
	public void run() {
		for(int j=0;j<1000000;j++){
			synchronized(i){
//			synchronized(instance){
				i++;
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(instance);
		Thread t2=new Thread(instance);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);

	}
}
package geym.conc.ch2.sync.lockonint;

public class BadLockOnInteger2 implements Runnable{
    public static Integer i=0;
    static BadLockOnInteger2 instance=new BadLockOnInteger2();
    @Override
    public void run() {
        for(int j=0;j<10000000;j++){
            synchronized(i){
//            synchronized(instance){
                i=Integer.valueOf(i.intValue()+1);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(instance);
        Thread t2=new Thread(instance);
        t1.start();t2.start();
        t1.join();t2.join();
        System.out.println(i);
    }
}package geym.conc.ch2.suspend;

public class BadSuspend {
	public static Object u = new Object();
	static ChangeObjectThread t1 = new ChangeObjectThread("t1");
	static ChangeObjectThread t2 = new ChangeObjectThread("t2");

	public static class ChangeObjectThread extends Thread {
		public ChangeObjectThread(String name){
			super.setName(name);
		}
		@Override
		public void run() {
			synchronized (u) {
				System.out.println("in "+getName());
				Thread.currentThread().suspend();
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		t1.start();
		Thread.sleep(100);
		t2.start();
		t1.resume();
		t2.resume();
		t1.join();
		t2.join();
	}
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.atomic.AtomicBoolean;


/**
 * Convenience class for handling the batching semantics of consuming entries from a {@link RingBuffer}
 * and delegating the available events to an {@link EventHandler}.
 *
 * If the {@link EventHandler} also implements {@link LifecycleAware} it will be notified just after the thread
 * is started and just before the thread is shutdown.
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 */
public final class BatchEventProcessor<T>
    implements EventProcessor
{
    private final AtomicBoolean running = new AtomicBoolean(false);
    private ExceptionHandler<? super T> exceptionHandler = new FatalExceptionHandler();
    private final DataProvider<T> dataProvider;
    private final SequenceBarrier sequenceBarrier;
    private final EventHandler<? super T> eventHandler;
    private final Sequence sequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
    private final TimeoutHandler timeoutHandler;

    /**
     * Construct a {@link EventProcessor} that will automatically track the progress by updating its sequence when
     * the {@link EventHandler#onEvent(Object, long, boolean)} method returns.
     *
     * @param dataProvider to which events are published.
     * @param sequenceBarrier on which it is waiting.
     * @param eventHandler is the delegate to which events are dispatched.
     */
    public BatchEventProcessor(final DataProvider<T> dataProvider,
                               final SequenceBarrier sequenceBarrier,
                               final EventHandler<? super T> eventHandler)
    {
        this.dataProvider = dataProvider;
        this.sequenceBarrier = sequenceBarrier;
        this.eventHandler = eventHandler;

        if (eventHandler instanceof SequenceReportingEventHandler)
        {
            ((SequenceReportingEventHandler<?>)eventHandler).setSequenceCallback(sequence);
        }

        timeoutHandler = (eventHandler instanceof TimeoutHandler) ? (TimeoutHandler) eventHandler : null;
    }

    @Override
    public Sequence getSequence()
    {
        return sequence;
    }

    @Override
    public void halt()
    {
        running.set(false);
        sequenceBarrier.alert();
    }

    @Override
    public boolean isRunning()
    {
        return running.get();
    }

    /**
     * Set a new {@link ExceptionHandler} for handling exceptions propagated out of the {@link BatchEventProcessor}
     *
     * @param exceptionHandler to replace the existing exceptionHandler.
     */
    public void setExceptionHandler(final ExceptionHandler<? super T> exceptionHandler)
    {
        if (null == exceptionHandler)
        {
            throw new NullPointerException();
        }

        this.exceptionHandler = exceptionHandler;
    }

    /**
     * It is ok to have another thread rerun this method after a halt().
     *
     * @throws IllegalStateException if this object instance is already running in a thread
     */
    @Override
    public void run()
    {
        if (!running.compareAndSet(false, true))
        {
            throw new IllegalStateException("Thread is already running");
        }
        sequenceBarrier.clearAlert();

        notifyStart();

        T event = null;
        long nextSequence = sequence.get() + 1L;
        try
        {
            while (true)
            {
                try
                {
                    final long availableSequence = sequenceBarrier.waitFor(nextSequence);

                    while (nextSequence <= availableSequence)
                    {
                        event = dataProvider.get(nextSequence);
                        eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);
                        nextSequence++;
                    }

                    sequence.set(availableSequence);
                }
                catch (final TimeoutException e)
                {
                    notifyTimeout(sequence.get());
                }
                catch (final AlertException ex)
                {
                    if (!running.get())
                    {
                        break;
                    }
                }
                catch (final Throwable ex)
                {
                    exceptionHandler.handleEventException(ex, nextSequence, event);
                    sequence.set(nextSequence);
                    nextSequence++;
                }
            }
        }
        finally
        {
            notifyShutdown();
            running.set(false);
        }
    }

    private void notifyTimeout(final long availableSequence)
    {
        try
        {
            if (timeoutHandler != null)
            {
                timeoutHandler.onTimeout(availableSequence);
            }
        }
        catch (Throwable e)
        {
            exceptionHandler.handleEventException(e, availableSequence, null);
        }
    }

    /**
     * Notifies the EventHandler when this processor is starting up
     */
    private void notifyStart()
    {
        if (eventHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware)eventHandler).onStart();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnStartException(ex);
            }
        }
    }

    /**
     * Notifies the EventHandler immediately prior to this processor shutting down
     */
    private void notifyShutdown()
    {
        if (eventHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware)eventHandler).onShutdown();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnShutdownException(ex);
            }
        }
    }
}package geym.conc.ch4.biased;

import java.util.List;
import java.util.Vector;

/**
 * -XX:BiasedLockingStartupDelay=0
 * @author Geym
 *
 */
public class Biased {
	public static List<Integer> numberList =new Vector<Integer>();
	public static void main(String[] args) throws InterruptedException {
		long begin=System.currentTimeMillis();
		int count=0;
		int startnum=0;
		while(count<10000000){
			numberList.add(startnum);
			startnum+=2;
			count++;
		}
		long end=System.currentTimeMillis();
		System.out.println(end-begin);
	}
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Blocking strategy that uses a lock and condition variable for {@link EventProcessor}s waiting on a barrier.
 *
 * This strategy can be used when throughput and low-latency are not as important as CPU resource.
 */
public final class BlockingWaitStrategy implements WaitStrategy
{
    private final Lock lock = new ReentrantLock();
    private final Condition processorNotifyCondition = lock.newCondition();

    @Override
    public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSequence, SequenceBarrier barrier)
        throws AlertException, InterruptedException
    {
        long availableSequence;
        if ((availableSequence = cursorSequence.get()) < sequence)
        {
            lock.lock();
            try
            {
                while ((availableSequence = cursorSequence.get()) < sequence)
                {
                    barrier.checkAlert();
                    processorNotifyCondition.await();
                }
            }
            finally
            {
                lock.unlock();
            }
        }

        while ((availableSequence = dependentSequence.get()) < sequence)
        {
            barrier.checkAlert();
        }

        return availableSequence;
    }

    @Override
    public void signalAllWhenBlocking()
    {
        lock.lock();
        try
        {
            processorNotifyCondition.signalAll();
        }
        finally
        {
            lock.unlock();
        }
    }
}
package geym.conc.ch5.sort;

import java.util.Arrays;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class BubbleSort {
//  static int[] arr = { 5, 52, 6, 3, 4, 10, 8, 100, 35, 78, 64, 31, 77, 90,
//          45, 53, 89, 78, 1 };
    static int[] arr = { 5, 52, 6, 3, 4};
    static ExecutorService pool = Executors.newFixedThreadPool(10);

    public static void bubbleSort(int[] arr) {
        for (int i = arr.length - 1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    /**
     * 奇偶换位排序
     *
     * @param arr
     */
    public static void oddEvenSort(int[] arr) {
        int exchFlag = 1, start = 0;
        while (exchFlag == 1 || start == 1) {
            exchFlag = 0;
            for (int i = start; i < arr.length - 1; i += 2) {
                if (arr[i] > arr[i + 1]) {
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                    exchFlag = 1;
                }
            }
            System.out.println(Arrays.toString(arr));
            if (start == 0)
                start = 1;
            else
                start = 0;
        }
    }

    static int exchFlag=1;
    static synchronized void setExchFlag(int v){
        exchFlag=v;
    }
    static synchronized int getExchFlag(){
        return exchFlag;
    }

    public static class OddEvenSortTask implements Runnable{
        int i;
        CountDownLatch latch;
        public OddEvenSortTask(int i,CountDownLatch latch){
            this.i=i;
            this.latch=latch;
        }
        @Override
        public void run() {
            if (arr[i] > arr[i + 1]) {
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                setExchFlag(1);
            }
            latch.countDown();
        }
    }
    public static void pOddEvenSort(int[] arr) throws InterruptedException {
        int start = 0;
        while (getExchFlag() == 1 || start == 1) {
            setExchFlag(0);
            //偶数的数组长度，当start为1时，只有len/2-1个线程
            CountDownLatch latch = new CountDownLatch(arr.length/2-(arr.length%2==0?start:0));
            for (int i = start; i < arr.length - 1; i += 2) {
                pool.submit(new OddEvenSortTask(i,latch));
            }
            //等待所有线程结束
            latch.await();
            if (start == 0)
                start = 1;
            else
                start = 0;
        }
    }
    public static void main(String[] args) throws InterruptedException {
//      pOddEvenSort(arr);
        oddEvenSort(arr);
        pool.shutdownNow();
        System.out.println(Arrays.toString(arr));
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;


/**
 * Busy Spin strategy that uses a busy spin loop for {@link com.lmax.disruptor.EventProcessor}s waiting on a barrier.
 *
 * This strategy will use CPU resource to avoid syscalls which can introduce latency jitter.  It is best
 * used when threads can be bound to specific CPU cores.
 */
public final class BusySpinWaitStrategy implements WaitStrategy
{
    @Override
    public long waitFor(final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
        throws AlertException, InterruptedException
    {
        long availableSequence;

        while ((availableSequence = dependentSequence.get()) < sequence)
        {
            barrier.checkAlert();
        }

        return availableSequence;
    }

    @Override
    public void signalAllWhenBlocking()
    {
    }
}

package geym.conc.ch2.notsafe;

public class CalcAve {

    public static void aveInt(){
        int v1=1073741827;
        int v2=1431655768;
        System.out.println("v1="+v1);
        System.out.println("v2="+v2);
        int ave=(v1+v2)/2;
        System.out.println("ave="+ave);
    }

    public static void aveInt2(){
        int v1=1073741827;
        int v2=1431655768;
        System.out.println("v1="+v1);
        System.out.println("v2="+v2);
        int ave= (v1 & v2) + ((v1 ^ v2) >> 1);
        System.out.println("ave="+ave);
    }

    public static void main(String[] args) {
        aveInt();
        aveInt2();
    }
}
package geym.conc.ch3.trace;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * submit吃掉异常
 * 1. 用Future.get()获得异常
 * 2. try-catch
 * @author Geym
 *
 */
public class CatchExceptionMain {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ThreadPoolExecutor pools=new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                0L, TimeUnit.SECONDS,
                new SynchronousQueue<Runnable>());

        for(int i=0;i<5;i++){
            pools.submit(new DivTask(100,i));
        }
    }
}
package geym.conc.ch3.trace;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * submit吃掉异常
 * 1. 用Future.get()获得异常
 * 2. try-catch
 * @author Geym
 *
 */
public class CatchExceptionMain2 {	public static void main(String[] args) throws InterruptedException, ExecutionException {
	ThreadPoolExecutor pools=new ThreadPoolExecutor(0, Integer.MAX_VALUE,
            0L, TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>());

	for(int i=0;i<5;i++){
		pools.execute(new DivTask(100,i));
	}
}}
package geym.conc.ch3.trace;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * submit吃掉异常
 * 1. 用Future.get()获得异常
 * 2. try-catch
 * @author Geym
 *
 */
public class CatchExceptionMain3 {	public static void main(String[] args) throws InterruptedException, ExecutionException {
	ThreadPoolExecutor pools=new ThreadPoolExecutor(0, Integer.MAX_VALUE,
            0L, TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>());

	for(int i=0;i<5;i++){
		Future re=pools.submit(new DivTask(100,i));
		re.get();
	}
}}
package geym.conc.ch6.completable;

import java.util.concurrent.CompletableFuture;

/**
 * 脱离线程池的使用，仅作为一个契约
 *
 * @author Geym
 *
 */
public class CFutureMain1 {
    public static class AskThread implements Runnable {
        CompletableFuture<Integer> re = null;

        public AskThread(CompletableFuture<Integer> re) {
            this.re = re;
        }

        @Override
        public void run() {
            int myRe = 0;
            try {
                myRe = re.get() * re.get();
            } catch (Exception e) {
            }
            System.out.println(myRe);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        final CompletableFuture<Integer> future = new CompletableFuture<>();
        new Thread(new AskThread(future)).start();
        // 模拟长时间其他调用
        Thread.sleep(1000);
        // 告知完成结果
        future.complete(60);
    }
}
package geym.conc.ch6.completable;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

/**
 * 完成普通future的工作
 *
 * 以下几个函数可以执行（创建）一个CompletableFuture任务
 * static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);
 * static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor);
 * static CompletableFuture<Void> runAsync(Runnable runnable);
 * static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor);
 * @author Geym
 *
 */
public class CFutureMain2 {
    public static Integer calc(Integer para) {
    	try {
    		// 模拟一个长时间的执行
			Thread.sleep(1000);
		} catch (InterruptedException e) {
		}
        return para*para;
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        final CompletableFuture<Integer> future =
                CompletableFuture.supplyAsync(() -> calc(50));
        System.out.println(future.get());
    }
}
package geym.conc.ch6.completable;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

/**
 * 完成普通future的工作
 *
 * 以下几个函数可以执行（创建）一个CompletableFuture任务
 * thenApply 转换
 * thenAccept 最后处理
 * @author Geym
 *
 */
public class CFutureMain3 {
    public static Integer calc(Integer para) {
    	try {
    		// 模拟一个长时间的执行
			Thread.sleep(1000);
		} catch (InterruptedException e) {
		}
        return para*para;
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
    	CompletableFuture<Void> fu=CompletableFuture.supplyAsync(() -> calc(50))
          .thenApply((i)->Integer.toString(i))
          .thenApply((str)->"\""+str+"\"")
          .thenAccept(System.out::println);
        fu.get();
    }
}
package geym.conc.ch6.completable;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

/**
 * 完成普通future的工作
 *
 * exceptionally 异常处理 发生异常进行处理，如果没有异常，则它返回原有的结果
 *
 * @author Geym
 *
 */
public class CFutureMain4 {

	public static Integer calc(Integer para) {
		return para / 0;
	}

	public static void main(String[] args) throws InterruptedException,ExecutionException {
		CompletableFuture<Void> fu = CompletableFuture
				.supplyAsync(() -> calc(50))
				.exceptionally(ex -> {
					System.out.println(ex.toString());
					return 0;
				})
				.thenApply((i) -> Integer.toString(i))
				.thenApply((str) -> "\"" + str + "\"")
				.thenAccept(System.out::println);
		fu.get();
	}

}
package geym.conc.ch6.completable;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

/**
 * 完成普通future的工作
 *
 * thenCompose
 *
 * @author Geym
 *
 */
public class CFutureMain5 {

    public static Integer calc(Integer para) {
        return para/2;
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture<Void> fu =
                CompletableFuture.supplyAsync(() -> calc(50))
                .thenCompose((i)->CompletableFuture.supplyAsync(() -> calc(i)))
                .thenApply((str)->"\"" + str + "\"").thenAccept(System.out::println);
        fu.get();
    }

}
package geym.conc.ch6.completable;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

/**
 * 完成普通future的工作
 *
 * thenCombine 合并结果
 *
 * @author Geym
 *
 */
public class CFutureMain6 {

	public static Integer calc(Integer para) {
		return para / 2;
	}

	public static void main(String[] args) throws InterruptedException,ExecutionException {
		CompletableFuture<Integer> intFuture = CompletableFuture.supplyAsync(() -> calc(50));
		CompletableFuture<Integer> intFuture2 = CompletableFuture.supplyAsync(() -> calc(25));

		CompletableFuture<Void> fu = intFuture.thenCombine(intFuture2, (i, j) -> (i + j))
				.thenApply((str) -> "\"" + str + "\"")
				.thenAccept(System.out::println);
		fu.get();
	}

}
package geym.conc.ch6.completable;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

public class CFutureMain7 {

    public static Integer calc(Integer para) {
        return para / 2;
    }

    public static void main(String[] args) {
        CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
            }
            return calc(50);

        }).orTimeout(1, TimeUnit.SECONDS).exceptionally(e -> {
            System.err.println(e);
            return 0;
        }).thenAccept(System.out::println);

        try

        {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
    }
}
package org.jmatrices.dbl.decomposition;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

/**
 * CholeskyDecomposition
 * <p>
 * It is a special case of LU decomposition applicable only if matrix to be decomposed is symmetric positive definite.
 * </p>
 * <p>
 * For a symmetric, positive definite matrix A, the Cholesky decomposition
 * is an lower triangular matrix L so that A = L*L'.
 * </p>
 * <p>
 * If the matrix is not symmetric or positive definite, the constructor
 * returns a partial decomposition and sets an internal flag that may
 * be queried by the isSPD() method.
 * </p>
 * <p><font color="red">
 * The code is basically JAMA code with modifications made to fit in the scheme of things.
 * </font></p>
 * <p>
 * http://ikpe1101.ikp.kfa-juelich.de/briefbook_data_analysis/node33.html
 * http://grids.ucs.indiana.edu/ptliupages/projects/HPJava/talks/beijing/hpspmd/HPJava/node15.html (pseudo code)
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 13.03.2004
 * Time: 01:04:45
 */
public class CholeskyDecomposition {

/* ------------------------
   Class variables
 * ------------------------ */

    /**
     * Array for internal storage of decomposition.
     *
     * @serial internal array storage.
     */
    private double[][] L;

    /**
     * Row and column dimension (square matrix).
     *
     * @serial matrix dimension.
     */
    private int n;

    /**
     * Symmetric and positive definite flag.
     *
     * @serial is symmetric and positive definite flag.
     */
    private boolean isspd;

    private Matrix hint;

/* ------------------------
   Constructor
 * ------------------------ */

    /**
     * Cholesky algorithm for symmetric and positive definite matrix.
     *
     * @param matrix Square, symmetric matrix.
     *            Structure to access L and isspd flag.
     */

    public CholeskyDecomposition(Matrix matrix) {
        hint = matrix;
        // Initialize.
        double[][] A = matrix.get();
        n = matrix.rows();
        L = new double[n][n];
        isspd = (matrix.cols() == n);
        // Main loop.
        for (int j = 0; j < n; j++) {
            double[] Lrowj = L[j];
            double d = 0.0;
            for (int k = 0; k < j; k++) {
                double[] Lrowk = L[k];
                double s = 0.0;
                for (int i = 0; i < k; i++) {
                    s += Lrowk[i] * Lrowj[i];
                }
                Lrowj[k] = s = (A[j][k] - s) / L[k][k];
                d = d + s * s;
                isspd = isspd & (A[k][j] == A[j][k]);
            }
            d = A[j][j] - d;
            isspd = isspd & (d > 0.0);
            L[j][j] = Math.sqrt(Math.max(d, 0.0));
            for (int k = j + 1; k < n; k++) {
                L[j][k] = 0.0;
            }
        }
    }

/* ------------------------
   Temporary, experimental code.
 * ------------------------ *\

   \** Right Triangular Cholesky Decomposition.
   <P>
   For a symmetric, positive definite matrix A, the Right Cholesky
   decomposition is an upper triangular matrix R so that A = R'*R.
   This constructor computes R with the Fortran inspired column oriented
   algorithm used in LINPACK and MATLAB.  In Java, we suspect a row oriented,
   lower triangular decomposition is faster.  We have temporarily included
   this constructor here until timing experiments confirm this suspicion.
   *\

   \** Array for internal storage of right triangular decomposition. **\
   private transient double[][] R;

   \** Cholesky algorithm for symmetric and positive definite matrix.
   @param  A           Square, symmetric matrix.
   @param  rightflag   Actual value ignored.
   @return             Structure to access R and isspd flag.
   *\

   public CholeskyDecomposition (Matrix Arg, int rightflag) {
      // Initialize.
      double[][] A = Arg.getArray();
      n = Arg.getColumnDimension();
      R = new double[n][n];
      isspd = (Arg.getColumnDimension() == n);
      // Main loop.
      for (int j = 0; j < n; j++) {
         double d = 0.0;
         for (int k = 0; k < j; k++) {
            double s = A[k][j];
            for (int i = 0; i < k; i++) {
               s = s - R[i][k]*R[i][j];
            }
            R[k][j] = s = s/R[k][k];
            d = d + s*s;
            isspd = isspd & (A[k][j] == A[j][k]);
         }
         d = A[j][j] - d;
         isspd = isspd & (d > 0.0);
         R[j][j] = Math.sqrt(Math.max(d,0.0));
         for (int k = j+1; k < n; k++) {
            R[k][j] = 0.0;
         }
      }
   }

   \** Return upper triangular factor.
   @return     R
   *\

   public Matrix getR () {
      return new Matrix(R,n,n);
   }

\* ------------------------
   End of temporary code.
 * ------------------------ */

/* ------------------------
   Public Methods
 * ------------------------ */

    /**
     * Is the matrix symmetric and positive definite?
     *
     * @return true if A is symmetric and positive definite.
     */

    public boolean isSPD() {
        return isspd;
    }

    /**
     * Return triangular factor.
     *
     * @return L
     */

    public Matrix getL() {
        return MatrixFactory.getMatrix(n, n, hint, L);
    }

    /**
     * Solve A*X = B
     *
     * @param B A Matrix with as many rows as A and any number of columns.
     * @return X so that L*L'*X = B
     * @throws IllegalArgumentException Matrix row dimensions must agree.
     * @throws RuntimeException         Matrix is not symmetric positive definite.
     */

    public Matrix solve(Matrix B) {
        if (B.rows() != n) {
            throw new IllegalArgumentException("Matrix row dimensions must agree.");
        }
        if (!isspd) {
            throw new RuntimeException("Matrix is not symmetric positive definite.");
        }

        // Copy right hand side.
        double[][] X = B.get();
        int nx = B.cols();

        // Solve L*Y = B;
        for (int k = 0; k < n; k++) {
            for (int i = k + 1; i < n; i++) {
                for (int j = 0; j < nx; j++) {
                    X[i][j] -= X[k][j] * L[i][k];
                }
            }
            for (int j = 0; j < nx; j++) {
                X[k][j] /= L[k][k];
            }
        }

        // Solve L'*X = Y;
        for (int k = n - 1; k >= 0; k--) {
            for (int j = 0; j < nx; j++) {
                X[k][j] /= L[k][k];
            }
            for (int i = 0; i < k; i++) {
                for (int j = 0; j < nx; j++) {
                    X[i][j] -= X[k][j] * L[k][i];
                }
            }
        }
        return MatrixFactory.getMatrix(n, nx, hint, X);
    }
}
package geym.conc.ch6.stamped;

import java.util.concurrent.atomic.AtomicReference;

public class CLHLock {
    private final AtomicReference<QNode> tail;
    private final ThreadLocal<QNode> myPred;
    private final ThreadLocal<QNode> myNode;

    public CLHLock() {
        tail = new AtomicReference<QNode>(new QNode());
        myNode = new ThreadLocal<QNode>() {
            protected QNode initialValue() {
                return new QNode();
            }
        };

        myPred = new ThreadLocal<QNode>();
    }

    public void lock() {
        QNode node = myNode.get();
        node.locked = true;
        QNode pred = tail.getAndSet(node);
        myPred.set(pred);
        while (pred.locked) {
        }
    }

    public void unlock() {
        QNode node = myNode.get();
        node.locked = false;
        myNode.set(myPred.get());
    }

    private static class QNode {
        volatile boolean locked;
    }
}
package geym.conc.ch5.simplefuture;

public class Client {
    public Data request(final String queryStr) {
        final FutureData future = new FutureData();
        // RealData的构建很慢
        new Thread() {
            public void run() {
                RealData realdata = new RealData(queryStr);
                future.setRealData(realdata);
            }
        }.start();
        return future;
    }
}
package geym.conc.ch3.ds;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class CollectionSync implements Runnable{
	static List<Integer> list=null;
	public void run(){
		for(int i=0;i<1000;i++){
			list.add(i);
		}
	}
	public static void main(String[] args) {
		list=Collections.synchronizedList(new ArrayList<Integer>());
//		list=new Vector<Integer>();
		CollectionSync cs=new CollectionSync();
		Thread t1=new Thread(cs);
		Thread t2=new Thread(cs);
		t1.start();
		t2.start();
	}
}
package org.jmatrices.dbl.rowcoltr;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.Matrix;

/**
 * ColumnTransformation
 * <p>
 * <font color="red">this is an open thought of trying to make column operations eleganter and perhaps faster </font>
 * Check out the "see also" section
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 20:48:58
 *
 * @see ColumnTransformer#applyColumnOperation(org.jmatrices.dbl.Matrix, org.jmatrices.dbl.rowcoltr.ColumnTransformation)
 */
public interface ColumnTransformation {
    public double apply(Matrix d);
}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jmatrices.dbl.rowcoltr;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

/**
 * ColumnTransformer captures the operations that can be carried out on columns of a matrix
 * <p>
 * Given a matrix of dimension mxn <strong> M -yields-> R</strong> ,where R is a row vector of dimension 1xn.
 * </p>
 * <p>
 * All operations on a matrix fitting this pattern can be found here!
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 20:46:52
 */
public final class ColumnTransformer {
    /**
     * <p/>
     * <font color="red">this is an open thought of trying to make column operations eleganter and perhaps faster </font>
     * Check out the "see also" section
     * <p/>
     *
     * @param m
     * @param co
     * @return
     * @see ColumnTransformation
     */
    public static Matrix applyColumnOperation(Matrix m, ColumnTransformation co) {
        throw new UnsupportedOperationException("to be implemented");
    }

    /**
     * Sums up all the columns and returns them as a row vector
     *
     * @param m Matrix
     * @return r(1xn) row vector with column sums
     */
    public static Matrix sum(Matrix m) {
        int rows_c = m.rows(), cols_c = m.cols();
        Matrix d;
        if (rows_c == 1) {
            return m;
        } else {
            d = MatrixFactory.getMatrix(1, cols_c,m);
            for (int col = 1; col <= cols_c; col++) {
                double sumCol = 0D;
                for (int row = 1; row <= rows_c; row++) {
                    sumCol += m.get(row, col);
                }
                d.set(1, col, sumCol);
            }
        }
        return d;
    }

    /**
     * Multiplies up all the elements in a column and returns them as a row vector
     *
     * @param m Matrix
     * @return r(1xn) row vector with column product
     */
    public static Matrix product(Matrix m) {
        int rows_c = m.rows(), cols_c = m.cols();
        Matrix d;
        if (rows_c == 1) {
            return m;
        } else {
            d = MatrixFactory.getMatrix(1, cols_c, m);
            for (int col = 1; col <= cols_c; col++) {
                double prodCol = 1D;
                for (int row = 1; row <= rows_c; row++) {
                    prodCol = prodCol * m.get(row, col);
                }
                d.set(1, col, prodCol);
            }
        }
        return d;
    }

    /**
     * Gets the means of  all the elements in a column and returns them as a row vector
     * <p>adjustment- calculates the mean by dividing the sum of all values by (n-1) instead of n,
     * which is the number of elements in the colum</p>
     *
     * @param m          Matrix
     * @param adjustment true or false
     * @return r(1xn) row vector with column means
     */
    public static Matrix mean(Matrix m, boolean adjustment) {
        int rows_c = m.rows(), cols_c = m.cols(), den = rows_c;
        Matrix d;
        if (adjustment)
            den = den - 1;
        if (rows_c == 1) {
            return m;
        } else {
            d = MatrixFactory.getMatrix(1, cols_c, m);
            for (int col = 1; col <= cols_c; col++) {
                double sumCol = 0D;
                for (int row = 1; row <= rows_c; row++) {
                    sumCol += m.get(row, col);
                }
                d.set(1, col, sumCol / den);
            }
        }
        return d;
    }

    /**
     * Gets the maximum element in a column and returns the selected as a row vector
     *
     * @param m Matrix
     * @return r(1xn) row vector with column's maximum values
     */
    public static Matrix max(Matrix m) {
        int rows_c = m.rows(), cols_c = m.cols();
        Matrix d;
        if (rows_c == 1) {
            return m;
        } else {
            d = MatrixFactory.getMatrix(1, cols_c, m);
            for (int col = 1; col <= cols_c; col++) {
                double max = 0D;
                boolean firstiter = true;
                for (int row = 1; row <= rows_c; row++) {
                    double tmp = m.get(row, col);
                    if (!firstiter) {
                        max = Math.max(tmp, max);
                    } else {
                        max = tmp;
                        firstiter = false;
                    }
                }
                d.set(1, col, max);
            }
        }
        return d;
    }

    /**
     * Gets the minimum element in a column and returns the selected as a row vector
     *
     * @param m Matrix
     * @return r(1xn) row vector with column's minimum values
     */
    public static Matrix min(Matrix m) {
        int rows_c = m.rows(), cols_c = m.cols(), den = rows_c;
        Matrix d;
        if (rows_c == 1) {
            return m;
        } else {
            d = MatrixFactory.getMatrix(1, cols_c, m);
            for (int col = 1; col <= cols_c; col++) {
                double min = 0D;
                boolean firstiter = true;
                for (int row = 1; row <= rows_c; row++) {
                    double tmp = m.get(row, col);
                    if (!firstiter) {
                        min = Math.min(tmp, min);
                    } else {
                        min = tmp;
                        firstiter = false;
                    }
                }
                d.set(1, col, min);
            }
        }
        return d;
    }

    private ColumnTransformer() {
    }
}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package geym.conc.ch6.map;

import java.util.concurrent.ConcurrentHashMap;

public class ComputeDemo {
    public static class HeavyObject {
        public HeavyObject() {
            System.out.println("HeavyObject created");
        }
    }

    public static void main(String[] args) {
        ConcurrentHashMap<String, HeavyObject> map = new ConcurrentHashMap<>();
        HeavyObject obj = getOrCreate(map, "1");
    }

    public static HeavyObject getOrCreate(ConcurrentHashMap<String, HeavyObject> map, String key) {
        return map.computeIfAbsent(key, k -> new HeavyObject());
    }

    // public static HeavyObject getOrCreate(ConcurrentHashMap<String, HeavyObject>
    // map, String key) {
    // HeavyObject value = map.get(key);
    // if (value == null) {
    // value = new HeavyObject();
    // map.put(key, value);
    // }
    // return value;
    // }
}

package geym.conc.ch3.collections;

import java.util.concurrent.ConcurrentLinkedQueue;

public class ConcurrentLinkedQueueDebug {
    public static void main(String[] args) {
        ConcurrentLinkedQueue<String> q=new ConcurrentLinkedQueue<String>();
        q.add("1");
        q.poll();
        q.add("3");
    }
}

package geym.conc.ch3.ds;

import java.util.Map;
import java.util.concurrent.ConcurrentSkipListMap;

public class ConcurrentSkipListMapDemo {
    public static void main(String[] args) {
        Map<Integer, Integer> map=new ConcurrentSkipListMap<Integer, Integer>();
        for(int i=0;i<30;i++){
            map.put(i,i);
        }
        for(Map.Entry<Integer, Integer> entry:map.entrySet()){
            System.out.println(entry.getKey());
        }
    }
}
package geym.conc.ch5.pc;

import java.text.MessageFormat;
import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

public class Consumer implements Runnable {
	private BlockingQueue<PCData> queue;
	private static final int SLEEPTIME = 1000;

	public Consumer(BlockingQueue<PCData> queue) {
		this.queue = queue;
	}

	public void run() {
		System.out.println("start Consumer id="
				+ Thread.currentThread().getId());
		Random r = new Random();

		try {
			while(true){
				PCData data = queue.take();
				if (null != data) {
					int re = data.getData() * data.getData();
					System.out.println(MessageFormat.format("{0}*{1}={2}",
							data.getData(), data.getData(), re));
					Thread.sleep(r.nextInt(SLEEPTIME));
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
			Thread.currentThread().interrupt();
		}
	}
}
package geym.conc.ch5.disruptor;

import com.lmax.disruptor.WorkHandler;

public class Consumer implements WorkHandler<PCData> {
	@Override
	public void onEvent(PCData event) throws Exception {
		System.out.println(Thread.currentThread().getId() + ":Event: --"
				+ event.get() * event.get() + "--");
	}
}
package com.lmax.disruptor.dsl;

import com.lmax.disruptor.Sequence;
import com.lmax.disruptor.SequenceBarrier;

import java.util.concurrent.Executor;

interface ConsumerInfo
{
    Sequence[] getSequences();

    SequenceBarrier getBarrier();

    boolean isEndOfChain();

    void start(Executor executor);

    void halt();

    void markAsUsedInBarrier();

    boolean isRunning();
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.dsl;

import com.lmax.disruptor.*;

import java.util.*;

/**
 * Provides a repository mechanism to associate {@link EventHandler}s with {@link EventProcessor}s
 *
 * @param <T> the type of the {@link EventHandler}
 */
class ConsumerRepository<T> implements Iterable<ConsumerInfo>
{
    private final Map<EventHandler<?>, EventProcessorInfo<T>> eventProcessorInfoByEventHandler = new IdentityHashMap<EventHandler<?>, EventProcessorInfo<T>>();
    private final Map<Sequence, ConsumerInfo> eventProcessorInfoBySequence = new IdentityHashMap<Sequence, ConsumerInfo>();
    private final Collection<ConsumerInfo> consumerInfos = new ArrayList<ConsumerInfo>();

    public void add(final EventProcessor eventprocessor,
                    final EventHandler<? super T> handler,
                    final SequenceBarrier barrier)
    {
        final EventProcessorInfo<T> consumerInfo = new EventProcessorInfo<T>(eventprocessor, handler, barrier);
        eventProcessorInfoByEventHandler.put(handler, consumerInfo);
        eventProcessorInfoBySequence.put(eventprocessor.getSequence(), consumerInfo);
        consumerInfos.add(consumerInfo);
    }

    public void add(final EventProcessor processor)
    {
        final EventProcessorInfo<T> consumerInfo = new EventProcessorInfo<T>(processor, null, null);
        eventProcessorInfoBySequence.put(processor.getSequence(), consumerInfo);
        consumerInfos.add(consumerInfo);
    }

    public void add(final WorkerPool<T> workerPool, final SequenceBarrier sequenceBarrier)
    {
        final WorkerPoolInfo<T> workerPoolInfo = new WorkerPoolInfo<T>(workerPool, sequenceBarrier);
        consumerInfos.add(workerPoolInfo);
        for (Sequence sequence : workerPool.getWorkerSequences())
        {
            eventProcessorInfoBySequence.put(sequence, workerPoolInfo);
        }
    }

    public Sequence[] getLastSequenceInChain(boolean includeStopped)
    {
        List<Sequence> lastSequence = new ArrayList<Sequence>();
        for (ConsumerInfo consumerInfo : consumerInfos)
        {
            if ((includeStopped || consumerInfo.isRunning()) && consumerInfo.isEndOfChain())
            {
                final Sequence[] sequences = consumerInfo.getSequences();
                Collections.addAll(lastSequence, sequences);
            }
        }

        return lastSequence.toArray(new Sequence[lastSequence.size()]);
    }

    public EventProcessor getEventProcessorFor(final EventHandler<T> handler)
    {
        final EventProcessorInfo<T> eventprocessorInfo = getEventProcessorInfo(handler);
        if (eventprocessorInfo == null)
        {
            throw new IllegalArgumentException("The event handler " + handler + " is not processing events.");
        }

        return eventprocessorInfo.getEventProcessor();
    }

    public Sequence getSequenceFor(final EventHandler<T> handler)
    {
        return getEventProcessorFor(handler).getSequence();
    }

    public void unMarkEventProcessorsAsEndOfChain(final Sequence... barrierEventProcessors)
    {
        for (Sequence barrierEventProcessor : barrierEventProcessors)
        {
            getEventProcessorInfo(barrierEventProcessor).markAsUsedInBarrier();
        }
    }

    @Override
    public Iterator<ConsumerInfo> iterator()
    {
        return consumerInfos.iterator();
    }

    public SequenceBarrier getBarrierFor(final EventHandler<T> handler)
    {
        final ConsumerInfo consumerInfo = getEventProcessorInfo(handler);
        return consumerInfo != null ? consumerInfo.getBarrier() : null;
    }

    private EventProcessorInfo<T> getEventProcessorInfo(final EventHandler<T> handler)
    {
        return eventProcessorInfoByEventHandler.get(handler);
    }

    private ConsumerInfo getEventProcessorInfo(final Sequence barrierEventProcessor)
    {
        return eventProcessorInfoBySequence.get(barrierEventProcessor);
    }
}
package geym.conc.ch3.synctrl;

import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 倒数计时器
 * @author Geym
 *
 */
public class CountDownLatchDemo implements Runnable {
    static final CountDownLatch end = new CountDownLatch(10);
    static final CountDownLatchDemo demo=new CountDownLatchDemo();
    @Override
    public void run() {
        try {
            //模拟检查任务
            Thread.sleep(new Random().nextInt(10)*1000);
            System.out.println("check complete");
            end.countDown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        ExecutorService exec = Executors.newFixedThreadPool(10);
        for(int i=0;i<10;i++){
            exec.submit(demo);
        }
        //等待检查
        end.await();
        //发射火箭
        System.out.println("Fire!");
        exec.shutdown();
    }
}
package geym.conc.ch3.fork;

import java.util.ArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;

public class CountTask extends RecursiveTask<Long>{
    private static final int THRESHOLD = 10000;
    private long start;
    private long end;

    public CountTask(long start,long end){
        this.start=start;
        this.end=end;
    }

    public Long compute(){
        long sum=0;
        boolean canCompute = (end-start)<THRESHOLD;
        if(canCompute){
            for(long i=start;i<=end;i++){
                sum +=i;
            }
        }else{
            //分成100个小任务
            long step=(start+end)/100;
            ArrayList<CountTask> subTasks=new ArrayList<CountTask>();
            long pos=start;
            for(int i=0;i<100;i++){
                long lastOne=pos+step;
                if(lastOne>end)lastOne=end;
                CountTask subTask=new CountTask(pos,lastOne);
                pos+=step+1;
                subTasks.add(subTask);
                subTask.fork();
            }
            for(CountTask  t:subTasks){
                sum+=t.join();
            }
        }
        return sum;
    }

    public static void main(String[]args){
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        CountTask task = new CountTask(0,200000000000L);
        ForkJoinTask<Long> result = forkJoinPool.submit(task);
        try{
            long res = result.get();
            System.out.println("sum="+res);
        }catch(InterruptedException e){
            e.printStackTrace();
        }catch(ExecutionException e){
            e.printStackTrace();
        }
    }
}package geym.conc.ch3.fork;

public class CountTaskOneThread {

    public static void main(String[] args) {
        long sum=0;
        for(long i=1;i<=2000000000L;i++){
            sum+=i;
        }
        System.out.println(sum);
    }

}
package geym.conc.ch2.create;

public class CreateThread {
	public static void main(String[] args) {
		Thread t1=new Thread();
		t1.start();
	}
}
package geym.conc.ch2.create;

public class CreateThread2 {
	public static void main(String[] args) {
		Thread t1=new Thread(){
			@Override
			public void run(){
				System.out.println("Hello, I am t1");
			}
		};
		t1.start();
	}
}
package geym.conc.ch2.create;

public class CreateThread3 implements Runnable {
	public static void main(String[] args) {
		Thread t1=new Thread(new CreateThread3());
		t1.start();
	}

	@Override
	public void run() {
		System.out.println("Oh, I am Runnable");
	}
}
/*
 * Copyright 2012 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Implementors of this interface must provide a single long value
 * that represents their current cursor value.  Used during dynamic
 * add/remove of Sequences from a
 * {@link SequenceGroups#addSequences(Object, java.util.concurrent.atomic.AtomicReferenceFieldUpdater, Cursored, Sequence...)}.
 */
public interface Cursored
{
    /**
     * Get the current cursor value.
     *
     * @return current cursor value
     */
    long getCursor();
}

package geym.conc.ch3.synctrl;

import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static class Soldier implements Runnable {
        private String soldier;
        private final CyclicBarrier cyclic;

        Soldier(CyclicBarrier cyclic, String soldierName) {
            this.cyclic = cyclic;
            this.soldier = soldierName;
        }

        public void run() {
            try {
                //等待所有士兵到齐
                cyclic.await();
                doWork();
                //等待所有士兵完成工作
                cyclic.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }

        void doWork() {
            try {
                Thread.sleep(Math.abs(new Random().nextInt()%10000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(soldier + ":任务完成");
        }
    }

    public static class BarrierRun implements Runnable {
        boolean flag;
        int N;
        public BarrierRun(boolean flag, int N) {
            this.flag = flag;
            this.N = N;
        }

        public void run() {
            if (flag) {
                System.out.println("司令:[士兵" + N + "个，任务完成！]");
            } else {
                System.out.println("司令:[士兵" + N + "个，集合完毕！]");
                flag = true;
            }
        }
    }

    public static void main(String args[]) throws InterruptedException {
        final int N = 10;
        Thread[] allSoldier=new Thread[N];
        boolean flag = false;
        CyclicBarrier cyclic = new CyclicBarrier(N, new BarrierRun(flag, N));
        //设置屏障点，主要是为了执行这个方法
        System.out.println("集合队伍！");
        for (int i = 0; i < N; ++i) {
            System.out.println("士兵 "+i+" 报道！");
            allSoldier[i]=new Thread(new Soldier(cyclic, "士兵 " + i));
            allSoldier[i].start();
        }
    }
}

package geym.conc.ch3.synctrl;


import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo2 {
    public static class Soldier implements Runnable {

        private String soldier;

        private final CyclicBarrier cyclic;

        Soldier(CyclicBarrier cyclic, String soldierName) {
            this.cyclic = cyclic;
            this.soldier = soldierName;
        }

        public void run() {
            try {
                //等待所有士兵到齐
                cyclic.await();
                doWork();
                //等待所有士兵完成工作
                cyclic.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }

        void doWork() {
            try {
                Thread.sleep(Math.abs(new Random().nextInt()%10000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(soldier + ":劳动完成");
        }
    }

    public static class BarrierRun implements Runnable {
        boolean flag;
        int N;
        public BarrierRun(boolean flag, int N) {
            this.flag = flag;
            this.N = N;
        }

        public void run() {
            if (flag) {
                System.out.println("司令:[士兵" + N + "个，任务完成！]");
            } else {
                System.out.println("司令:[士兵" + N + "个，集合完毕！]");
                flag = true;
            }
        }
    }

    public static void main(String args[]) throws InterruptedException {
        final int N = 10;
        Thread[] allSoldier=new Thread[N];
        boolean flag = false;
        CyclicBarrier cyclic = new CyclicBarrier(N, new BarrierRun(flag, N));
        //设置屏障点，主要是为了执行这个方法
        System.out.println("集合队伍！");
        for (int i = 0; i < N; ++i) {
            System.out.println("士兵 "+i+" 报道！");
            allSoldier[i]=new Thread(new Soldier(cyclic, "士兵 " + i));
            allSoldier[i].start();
            if(i==5){
                allSoldier[0].interrupt();
            }
        }
    }
}
package geym.conc.ch2.daemon;

public class DaemonDemo {
    public static class DaemonT extends Thread{
        public void run(){
            while(true){
                System.out.println("I am alive");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread t=new DaemonT();
        t.setDaemon(true);
        t.start();

        Thread.sleep(2000);
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.util;

import java.util.concurrent.ThreadFactory;

/**
 * Access to a ThreadFactory instance. All threads are created with setDaemon(true).
 */
public enum DaemonThreadFactory implements ThreadFactory
{
    INSTANCE;

    @Override
    public Thread newThread(final Runnable r)
    {
        Thread t = new Thread(r);
        t.setDaemon(true);
        return t;
    }
}
package geym.conc.ch5.simplefuture;

public interface Data {
    public String getResult();
}
/*
 * Copyright 2012 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

public interface DataProvider<T>
{
    T get(long sequence);
}
package geym.conc.ch4.deadlock;


public class DeadLock extends Thread {
  protected Object tool;
  static Object fork1 = new Object();
  static Object fork2 = new Object();

  public DeadLock(Object obj) {
    this.tool = obj;
    if (tool == fork1) {
      this.setName("哲学家A");
    }
    if (tool == fork2) {
      this.setName("哲学家B");
    }
  }

  @Override
  public void run() {
    if (tool == fork1) {
      synchronized (fork1) {
        try {
          Thread.sleep(500);
        } catch (Exception e) {
          e.printStackTrace();
        }
        synchronized (fork2) {
          System.out.println("哲学家A开始吃饭了");
        }
      }

    }
    if (tool == fork2) {
      synchronized (fork2) {
        try {
          Thread.sleep(500);
        } catch (Exception e) {
          e.printStackTrace();
        }
        synchronized (fork1) {
          System.out.println("哲学家B开始吃饭了");
        }
      }

    }
  }

  public static void main(String[] args) throws InterruptedException {
    DeadLock 哲学家A = new DeadLock(fork1);
    DeadLock 哲学家B = new DeadLock(fork2);
    哲学家A.start();
    哲学家B.start();
    Thread.sleep(1000);
  }
}
package geym.conc.ch4.deadlock;

import java.util.concurrent.locks.ReentrantLock;

public class DeadLockCar extends Thread{
	protected Object myDirect;
	static ReentrantLock south = new ReentrantLock();
	static ReentrantLock north = new ReentrantLock();
	static ReentrantLock west = new ReentrantLock();
	static ReentrantLock east = new ReentrantLock();

	public DeadLockCar(Object obj){
		this.myDirect=obj;
		if(myDirect==south){
			this.setName("south");
		}
		if(myDirect==north){
			this.setName("north");
		}
		if(myDirect==west){
			this.setName("west");
		}
		if(myDirect==east){
			this.setName("east");
		}
	}
	@Override
	public void run() {
		if (myDirect == south) {
			try {
				west.lockInterruptibly();
				try {
					Thread.sleep(500);
				} catch (Exception e) {
					e.printStackTrace();
				}
				south.lockInterruptibly();
				System.out.println("car to south has passed");
			} catch (InterruptedException e1) {
				System.out.println("car to south is killed");
			}finally{
				if(west.isHeldByCurrentThread())
					west.unlock();
				if(south.isHeldByCurrentThread())
					south.unlock();
			}

		}
		if (myDirect == north) {
			try {
				east.lockInterruptibly();
				try {
					Thread.sleep(500);
				} catch (Exception e) {
					e.printStackTrace();
				}
				north.lockInterruptibly();
				System.out.println("car to north has passed");
			} catch (InterruptedException e1) {
				System.out.println("car to north is killed");
			}finally{
				if(north.isHeldByCurrentThread())
					north.unlock();
				if(east.isHeldByCurrentThread())
					east.unlock();
			}

		}
		if (myDirect == west) {
			try {
				north.lockInterruptibly();
				try {
					Thread.sleep(500);
				} catch (Exception e) {
					e.printStackTrace();
				}
				west.lockInterruptibly();
				System.out.println("car to west has passed");
			} catch (InterruptedException e1) {
				System.out.println("car to west is killed");
			}finally{
				if(north.isHeldByCurrentThread())
					north.unlock();
				if(west.isHeldByCurrentThread())
					west.unlock();
			}

		}
		if (myDirect == east) {
			try {
				south.lockInterruptibly();
				try {
					Thread.sleep(500);
				} catch (Exception e) {
					e.printStackTrace();
				}
				east.lockInterruptibly();
				System.out.println("car to east has passed");
			} catch (InterruptedException e1) {
				System.out.println("car to east is killed");
			}finally{
				if(south.isHeldByCurrentThread())
					south.unlock();
				if(east.isHeldByCurrentThread())
					east.unlock();
			}

		}
	}

	public static void main(String[] args) throws InterruptedException {
		DeadLockCar car2south = new DeadLockCar(south);
		DeadLockCar car2north = new DeadLockCar(north);
		DeadLockCar car2west = new DeadLockCar(west);
		DeadLockCar car2east = new DeadLockCar(east);
		car2south.start();
		car2north.start();
		car2west.start();
		car2east.start();
		Thread.sleep(1000);
//		car2north.interrupt();
	}
}package geym.conc.ch6.stamped;

import java.util.concurrent.locks.StampedLock;

public class DebugPoint {
	private double x, y;
	private final StampedLock sl = new StampedLock();

	void move(double deltaX, double deltaY) { // an exclusively locked method
		long stamp = sl.writeLock();
		System.out.println("Thread:"+Thread.currentThread().getName()+" get the lock");
		try {
			Thread.sleep(500);
		} catch (InterruptedException e) {
		}
		try {
			x += deltaX;
			y += deltaY;
		} finally {
			sl.unlockWrite(stamp);
		}
	}

	double distanceFromOrigin() { // A read-only method
		long stamp = sl.tryOptimisticRead();
		double currentX = x, currentY = y;
		if (!sl.validate(stamp)) {
			stamp = sl.readLock();
			try {
				currentX = x;
				currentY = y;
			} finally {
				sl.unlockRead(stamp);
			}
		}
		return Math.sqrt(currentX * currentX + currentY * currentY);
	}

	void moveIfAtOrigin(double newX, double newY) { // upgrade
		// Could instead start with optimistic, not read mode
		long stamp = sl.readLock();
		try {
			while (x == 0.0 && y == 0.0) {
				long ws = sl.tryConvertToWriteLock(stamp);
				if (ws != 0L) {
					stamp = ws;
					x = newX;
					y = newY;
					break;
				} else {
					sl.unlockRead(stamp);
					stamp = sl.writeLock();
				}
			}
		} finally {
			sl.unlock(stamp);
		}
	}
}
package geym.conc.ch6.stamped;

public class DebugPointMain {
	static DebugPoint p = new DebugPoint();

	public static class WriteTask implements Runnable {
		@Override
		public void run() {
			p.move(Math.random(), Math.random());

		}
	}

	public static class ReadTask implements Runnable {
		@Override
		public void run() {
			p.distanceFromOrigin();
		}
	}

	public static void main(String[] args) {
		Thread writeThead=new Thread(new WriteTask());
		writeThead.start();
		for(int i=0;i<3;i++){
			Thread readThead=new Thread(new ReadTask());
			readThead.start();
		}

		for(int i=0;i<3;i++){
			Thread readThead=new Thread(new WriteTask());
			readThead.start();
		}


	}

}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.dsl;

import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import com.lmax.disruptor.BatchEventProcessor;
import com.lmax.disruptor.EventFactory;
import com.lmax.disruptor.EventHandler;
import com.lmax.disruptor.EventProcessor;
import com.lmax.disruptor.EventTranslator;
import com.lmax.disruptor.EventTranslatorOneArg;
import com.lmax.disruptor.ExceptionHandler;
import com.lmax.disruptor.RingBuffer;
import com.lmax.disruptor.Sequence;
import com.lmax.disruptor.SequenceBarrier;
import com.lmax.disruptor.TimeoutException;
import com.lmax.disruptor.WaitStrategy;
import com.lmax.disruptor.WorkHandler;
import com.lmax.disruptor.WorkerPool;
import com.lmax.disruptor.util.Util;

/**
 * A DSL-style API for setting up the disruptor pattern around a ring buffer
 * (aka the Builder pattern).
 *
 * <p>
 * A simple example of setting up the disruptor with two event handlers that
 * must process events in order:
 * </p>
 *
 * <pre>
 * <code>Disruptor&lt;MyEvent&gt; disruptor = new Disruptor&lt;MyEvent&gt;(MyEvent.FACTORY, 32, Executors.newCachedThreadPool());
 * EventHandler&lt;MyEvent&gt; handler1 = new EventHandler&lt;MyEvent&gt;() { ... };
 * EventHandler&lt;MyEvent&gt; handler2 = new EventHandler&lt;MyEvent&gt;() { ... };
 * disruptor.handleEventsWith(handler1);
 * disruptor.after(handler1).handleEventsWith(handler2);
 *
 * RingBuffer ringBuffer = disruptor.start();</code>
 * </pre>
 *
 * @param <T> the type of event used.
 */
public class Disruptor<T>
{
    private final RingBuffer<T> ringBuffer;
    private final Executor executor;
    private final ConsumerRepository<T> consumerRepository = new ConsumerRepository<T>();
    private final AtomicBoolean started = new AtomicBoolean(false);
    private ExceptionHandler<? super T> exceptionHandler;

    /**
     * Create a new Disruptor. Will default to {@link com.lmax.disruptor.BlockingWaitStrategy} and
     * {@link ProducerType}.MULTI
     *
     * @param eventFactory
     *            the factory to create events in the ring buffer.
     * @param ringBufferSize
     *            the size of the ring buffer.
     * @param executor
     *            an {@link Executor} to execute event processors.
     */
    public Disruptor(final EventFactory<T> eventFactory, final int ringBufferSize, final Executor executor)
    {
        this(RingBuffer.createMultiProducer(eventFactory, ringBufferSize), executor);
    }

    /**
     * Create a new Disruptor.
     *
     * @param eventFactory   the factory to create events in the ring buffer.
     * @param ringBufferSize the size of the ring buffer, must be power of 2.
     * @param executor       an {@link Executor} to execute event processors.
     * @param producerType   the claim strategy to use for the ring buffer.
     * @param waitStrategy   the wait strategy to use for the ring buffer.
     */
    public Disruptor(final EventFactory<T> eventFactory,
                     final int ringBufferSize,
                     final Executor executor,
                     final ProducerType producerType,
                     final WaitStrategy waitStrategy)
    {
        this(RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy),
             executor);
    }

    /**
     * Private constructor helper
     */
    private Disruptor(final RingBuffer<T> ringBuffer, final Executor executor)
    {
        this.ringBuffer = ringBuffer;
        this.executor = executor;
    }

    /**
     * <p>Set up event handlers to handle events from the ring buffer. These handlers will process events
     * as soon as they become available, in parallel.</p>
     *
     * <p>This method can be used as the start of a chain. For example if the handler <code>A</code> must
     * process events before handler <code>B</code>:</p>
     * <pre><code>dw.handleEventsWith(A).then(B);</code></pre>
     *
     * @param handlers the event handlers that will process events.
     * @return a {@link EventHandlerGroup} that can be used to chain dependencies.
     */
    @SuppressWarnings("varargs")
    public EventHandlerGroup<T> handleEventsWith(final EventHandler<? super T>... handlers)
    {
        return createEventProcessors(new Sequence[0], handlers);
    }

    /**
     * <p>Set up custom event processors to handle events from the ring buffer. The Disruptor will
     * automatically start these processors when {@link #start()} is called.</p>
     *
     * <p>This method can be used as the start of a chain. For example if the handler <code>A</code> must
     * process events before handler <code>B</code>:</p>
     * <pre><code>dw.handleEventsWith(A).then(B);</code></pre>
     *
     * <p>Since this is the start of the chain, the processor factories will always be passed an empty <code>Sequence</code>
     * array, so the factory isn't necessary in this case. This method is provided for consistency with
     * {@link EventHandlerGroup#handleEventsWith(EventProcessorFactory...)} and {@link EventHandlerGroup#then(EventProcessorFactory...)}
     * which do have barrier sequences to provide.</p>
     *
     * @param eventProcessorFactories the event processor factories to use to create the event processors that will process events.
     * @return a {@link EventHandlerGroup} that can be used to chain dependencies.
     */
    public EventHandlerGroup<T> handleEventsWith(final EventProcessorFactory<T>... eventProcessorFactories)
    {
        final Sequence[] barrierSequences = new Sequence[0];
        return createEventProcessors(barrierSequences, eventProcessorFactories);
    }

    /**
     * <p>Set up custom event processors to handle events from the ring buffer. The Disruptor will
     * automatically start this processors when {@link #start()} is called.</p>
     *
     * <p>This method can be used as the start of a chain. For example if the processor <code>A</code> must
     * process events before handler <code>B</code>:</p>
     * <pre><code>dw.handleEventsWith(A).then(B);</code></pre>
     *
     * @param processors the event processors that will process events.
     * @return a {@link EventHandlerGroup} that can be used to chain dependencies.
     */
    public EventHandlerGroup<T> handleEventsWith(final EventProcessor... processors)
    {
        for (final EventProcessor processor : processors)
        {
            consumerRepository.add(processor);
        }
        return new EventHandlerGroup<T>(this, consumerRepository, Util.getSequencesFor(processors));
    }


    /**
     * Set up a {@link WorkerPool} to distribute an event to one of a pool of work handler threads.
     * Each event will only be processed by one of the work handlers.
     * The Disruptor will automatically start this processors when {@link #start()} is called.
     *
     * @param workHandlers the work handlers that will process events.
     * @return a {@link EventHandlerGroup} that can be used to chain dependencies.
     */
    @SuppressWarnings("varargs")
    public EventHandlerGroup<T> handleEventsWithWorkerPool(final WorkHandler<T>... workHandlers)
    {
        return createWorkerPool(new Sequence[0], workHandlers);
    }

    /**
     * <p>Specify an exception handler to be used for any future event handlers.</p>
     *
     * <p>Note that only event handlers set up after calling this method will use the exception handler.</p>
     *
     * @param exceptionHandler the exception handler to use for any future {@link EventProcessor}.
     */
    public void handleExceptionsWith(final ExceptionHandler<? super T> exceptionHandler)
    {
        this.exceptionHandler = exceptionHandler;
    }

    /**
     * Override the default exception handler for a specific handler.
     * <pre>disruptorWizard.handleExceptionsIn(eventHandler).with(exceptionHandler);</pre>
     *
     * @param eventHandler the event handler to set a different exception handler for.
     * @return an ExceptionHandlerSetting dsl object - intended to be used by chaining the with method call.
     */
    public ExceptionHandlerSetting<T> handleExceptionsFor(final EventHandler<T> eventHandler)
    {
        return new ExceptionHandlerSetting<T>(eventHandler, consumerRepository);
    }

    /**
     * <p>Create a group of event handlers to be used as a dependency.
     * For example if the handler <code>A</code> must process events before handler <code>B</code>:</p>
     *
     * <pre><code>dw.after(A).handleEventsWith(B);</code></pre>
     *
     * @param handlers the event handlers, previously set up with {@link #handleEventsWith(com.lmax.disruptor.EventHandler[])},
     *                 that will form the barrier for subsequent handlers or processors.
     * @return an {@link EventHandlerGroup} that can be used to setup a dependency barrier over the specified event handlers.
     */
    @SuppressWarnings("varargs")
    public EventHandlerGroup<T> after(final EventHandler<T>... handlers)
    {
        final Sequence[] sequences = new Sequence[handlers.length];
        for (int i = 0, handlersLength = handlers.length; i < handlersLength; i++)
        {
            sequences[i] = consumerRepository.getSequenceFor(handlers[i]);
        }

        return new EventHandlerGroup<T>(this, consumerRepository, sequences);
    }

    /**
     * Create a group of event processors to be used as a dependency.
     *
     * @param processors the event processors, previously set up with {@link #handleEventsWith(com.lmax.disruptor.EventProcessor...)},
     *                   that will form the barrier for subsequent handlers or processors.
     * @return an {@link EventHandlerGroup} that can be used to setup a {@link SequenceBarrier} over the specified event processors.
     * @see #after(com.lmax.disruptor.EventHandler[])
     */
    public EventHandlerGroup<T> after(final EventProcessor... processors)
    {
        for (final EventProcessor processor : processors)
        {
            consumerRepository.add(processor);
        }

        return new EventHandlerGroup<T>(this, consumerRepository, Util.getSequencesFor(processors));
    }

    /**
     * Publish an event to the ring buffer.
     *
     * @param eventTranslator the translator that will load data into the event.
     */
    public void publishEvent(final EventTranslator<T> eventTranslator)
    {
        ringBuffer.publishEvent(eventTranslator);
    }

    /**
     * Publish an event to the ring buffer.
     *
     * @param eventTranslator the translator that will load data into the event.
     * @param arg A single argument to load into the event
     */
    public <A> void publishEvent(final EventTranslatorOneArg<T, A> eventTranslator, final A arg)
    {
        ringBuffer.publishEvent(eventTranslator, arg);
    }

    /**
     * Publish a batch of events to the ring buffer.
     *
     * @param eventTranslator the translator that will load data into the event.
     * @param arg An array single arguments to load into the events. One Per event.
     */
    public <A> void publishEvents(final EventTranslatorOneArg<T, A> eventTranslator, final A[] arg)
    {
        ringBuffer.publishEvents(eventTranslator, arg);
    }

    /**
     * <p>Starts the event processors and returns the fully configured ring buffer.</p>
     *
     * <p>The ring buffer is set up to prevent overwriting any entry that is yet to
     * be processed by the slowest event processor.</p>
     *
     * <p>This method must only be called once after all event processors have been added.</p>
     *
     * @return the configured ring buffer.
     */
    public RingBuffer<T> start()
    {
        final Sequence[] gatingSequences = consumerRepository.getLastSequenceInChain(true);
        ringBuffer.addGatingSequences(gatingSequences);

        checkOnlyStartedOnce();
        for (final ConsumerInfo consumerInfo : consumerRepository)
        {
            consumerInfo.start(executor);
        }

        return ringBuffer;
    }

    /**
     * Calls {@link com.lmax.disruptor.EventProcessor#halt()} on all of the event processors created via this disruptor.
     */
    public void halt()
    {
        for (final ConsumerInfo consumerInfo : consumerRepository)
        {
            consumerInfo.halt();
        }
    }

    /**
     * Waits until all events currently in the disruptor have been processed by all event processors
     * and then halts the processors.  It is critical that publishing to the ring buffer has stopped
     * before calling this method, otherwise it may never return.
     *
     * <p>This method will not shutdown the executor, nor will it await the final termination of the
     * processor threads.</p>
     */
    public void shutdown()
    {
        try
        {
            shutdown(-1, TimeUnit.MILLISECONDS);
        }
        catch (final TimeoutException e)
        {
            exceptionHandler.handleOnShutdownException(e);
        }
    }

    /**
     * <p>Waits until all events currently in the disruptor have been processed by all event processors
     * and then halts the processors.</p>
     *
     * <p>This method will not shutdown the executor, nor will it await the final termination of the
     * processor threads.</p>
     *
     * @param timeout  the amount of time to wait for all events to be processed. <code>-1</code> will give an infinite timeout
     * @param timeUnit the unit the timeOut is specified in
     */
    public void shutdown(final long timeout, final TimeUnit timeUnit) throws TimeoutException
    {
        final long timeOutAt = System.currentTimeMillis() + timeUnit.toMillis(timeout);
        while (hasBacklog())
        {
            if (timeout >= 0 && System.currentTimeMillis() > timeOutAt)
            {
                throw TimeoutException.INSTANCE;
            }
            // Busy spin
        }
        halt();
    }

    /**
     * The {@link RingBuffer} used by this Disruptor.  This is useful for creating custom
     * event processors if the behaviour of {@link BatchEventProcessor} is not suitable.
     *
     * @return the ring buffer used by this Disruptor.
     */
    public RingBuffer<T> getRingBuffer()
    {
        return ringBuffer;
    }

    /**
     * Get the value of the cursor indicating the published sequence.
     *
     * @return value of the cursor for events that have been published.
     */
    public long getCursor()
    {
        return ringBuffer.getCursor();
    }

    /**
     * The capacity of the data structure to hold entries.
     *
     * @return the size of the RingBuffer.
     * @see com.lmax.disruptor.Sequencer#getBufferSize()
     */
    public long getBufferSize()
    {
        return ringBuffer.getBufferSize();
    }

    /**
     * Get the event for a given sequence in the RingBuffer.
     *
     * @param sequence for the event.
     * @return event for the sequence.
     * @see RingBuffer#get(long)
     */
    public T get(final long sequence)
    {
        return ringBuffer.get(sequence);
    }

    /**
     * Get the {@link SequenceBarrier} used by a specific handler. Note that the {@link SequenceBarrier}
     * may be shared by multiple event handlers.
     *
     * @param handler the handler to get the barrier for.
     * @return the SequenceBarrier used by <i>handler</i>.
     */
    public SequenceBarrier getBarrierFor(final EventHandler<T> handler)
    {
        return consumerRepository.getBarrierFor(handler);
    }

    /**
     * Confirms if all messages have been consumed by all event processors
     */
    private boolean hasBacklog()
    {
        final long cursor = ringBuffer.getCursor();
        for (final Sequence consumer : consumerRepository.getLastSequenceInChain(false))
        {
            if (cursor > consumer.get())
            {
                return true;
            }
        }
        return false;
    }

    EventHandlerGroup<T> createEventProcessors(final Sequence[] barrierSequences,
                                               final EventHandler<? super T>[] eventHandlers)
    {
        checkNotStarted();

        final Sequence[] processorSequences = new Sequence[eventHandlers.length];
        final SequenceBarrier barrier = ringBuffer.newBarrier(barrierSequences);

        for (int i = 0, eventHandlersLength = eventHandlers.length; i < eventHandlersLength; i++)
        {
            final EventHandler<? super T> eventHandler = eventHandlers[i];

            final BatchEventProcessor<T> batchEventProcessor = new BatchEventProcessor<T>(ringBuffer, barrier, eventHandler);

            if (exceptionHandler != null)
            {
                batchEventProcessor.setExceptionHandler(exceptionHandler);
            }

            consumerRepository.add(batchEventProcessor, eventHandler, barrier);
            processorSequences[i] = batchEventProcessor.getSequence();
        }

        if (processorSequences.length > 0)
        {
            consumerRepository.unMarkEventProcessorsAsEndOfChain(barrierSequences);
        }

        return new EventHandlerGroup<T>(this, consumerRepository, processorSequences);
    }

    EventHandlerGroup<T> createEventProcessors(final Sequence[] barrierSequences, final EventProcessorFactory<T>[] processorFactories)
    {
        final EventProcessor[] eventProcessors = new EventProcessor[processorFactories.length];
        for (int i = 0; i < processorFactories.length; i++)
        {
            eventProcessors[i] = processorFactories[i].createEventProcessor(ringBuffer, barrierSequences);
        }
        return handleEventsWith(eventProcessors);
    }

    EventHandlerGroup<T> createWorkerPool(final Sequence[] barrierSequences, final WorkHandler<? super T>[] workHandlers)
    {
        final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier(barrierSequences);
        final WorkerPool<T> workerPool = new WorkerPool<T>(ringBuffer, sequenceBarrier, exceptionHandler, workHandlers);
        consumerRepository.add(workerPool, sequenceBarrier);
        return new EventHandlerGroup<T>(this, consumerRepository, workerPool.getWorkerSequences());
    }

    private void checkNotStarted()
    {
        if (started.get())
        {
            throw new IllegalStateException("All event handlers must be added before calling starts.");
        }
    }

    private void checkOnlyStartedOnce()
    {
        if (!started.compareAndSet(false, true))
        {
            throw new IllegalStateException("Disruptor.start() must only be called once.");
        }
    }
}
package geym.conc.ch5.pstream.demo;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class Div implements Runnable {
	public static BlockingQueue<Msg> bq = new LinkedBlockingQueue<Msg>();

	@Override
	public void run() {
		while (true) {
			try {
				Msg msg = bq.take();
				msg.i = msg.i / 2;
				System.out.println(msg.orgStr + "=" + msg.i);
			} catch (InterruptedException e) {
			}
		}
	}
}
package geym.conc.ch3.trace;

public class DivTask implements Runnable {
    int a,b;
    public DivTask(int a,int b){
        this.a=a;
        this.b=b;
    }
    @Override
    public void run() {
        double re=a/b;
        System.out.println(re);
    }
}

package geym.conc.ch5.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class EchoServer {
    public static void main(String args[]) {
        ServerSocket echoServer = null;
        BufferedReader is=null;
        PrintWriter os =null;
        Socket clientSocket = null;

        try {
            echoServer = new ServerSocket(8000);
        } catch (IOException e) {
            System.out.println(e);
        }

        while (true) {
            try {
                clientSocket = echoServer.accept();
                System.out.println(clientSocket.getRemoteSocketAddress() + " connect!");
                is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                os = new PrintWriter(clientSocket.getOutputStream(), true);
                // 从InputStream当中读取客户端所发送的数据
                String inputLine = null;
                while ((inputLine = is.readLine()) != null) {
                    os.println(inputLine);
                }
            } catch (IOException e) {
                System.out.println(e);
            }finally{
                System.out.println("close connection");
                try {
                    if(is!=null)is.close();
                    if(os!=null)os.close();
                    clientSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
package org.jmatrices.dbl.decomposition;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.measure.MatrixProperty;
import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

/**
 * EigenvalueDecomposition
 * <p>
 * If A is symmetric, then A = V*D*V' where the eigenvalue matrix D is
 * diagonal and the eigenvector matrix V is orthogonal.
 * I.e. A = V.times(D.times(V.transpose())) and
 * V.times(V.transpose()) equals the identity matrix.
 * </p>
 * <p>
 * If A is not symmetric, then the eigenvalue matrix D is block diagonal
 * with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
 * lambda + i*mu, in 2-by-2 blocks, [lambda, mu; -mu, lambda].  The
 * columns of V represent the eigenvectors in the sense that A*V = V*D,
 * i.e. A.times(V) equals V.times(D).  The matrix V may be badly
 * conditioned, or even singular, so the validity of the equation
 * A = V*D*inverse(V) depends upon V.cond().
 * </p>
 * <p><font color="red">
 * The code is basically JAMA code with modifications made to fit in the scheme of things.
 * </font></p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 13.03.2004
 * Time: 14:25:02
 */
public class EigenvalueDecomposition {

    /* ------------------------
   Class variables
 * ------------------------ */

    private Matrix hint;
    /**
     * Row and column dimension (square matrix).
     *
     * @serial matrix dimension.
     */
    private int n;

    /**
     * Symmetry flag.
     *
     * @serial internal symmetry flag.
     */
    private boolean issymmetric;

    /**
     * Arrays for internal storage of eigenvalues.
     *
     * @serial internal storage of eigenvalues.
     */
    private double[] d, e;

    /**
     * Array for internal storage of eigenvectors.
     *
     * @serial internal storage of eigenvectors.
     */
    private double[][] V;

    /**
     * Array for internal storage of nonsymmetric Hessenberg form.
     *
     * @serial internal storage of nonsymmetric Hessenberg form.
     */
    private double[][] H;

    /**
     * Working storage for nonsymmetric algorithm.
     *
     * @serial working storage for nonsymmetric algorithm.
     */
    private double[] ort;

/* ------------------------
   Private Methods
 * ------------------------ */

    // Symmetric Householder reduction to tridiagonal form.

    private void tred2() {

        //  This is derived from the Algol procedures tred2 by
        //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
        //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
        //  Fortran subroutine in EISPACK.

        for (int j = 0; j < n; j++) {
            d[j] = V[n - 1][j];
        }

        // Householder reduction to tridiagonal form.

        for (int i = n - 1; i > 0; i--) {

            // Scale to avoid under/overflow.

            double scale = 0.0;
            double h = 0.0;
            for (int k = 0; k < i; k++) {
                scale = scale + Math.abs(d[k]);
            }
            if (scale == 0.0) {
                e[i] = d[i - 1];
                for (int j = 0; j < i; j++) {
                    d[j] = V[i - 1][j];
                    V[i][j] = 0.0;
                    V[j][i] = 0.0;
                }
            } else {

                // Generate Householder vector.

                for (int k = 0; k < i; k++) {
                    d[k] /= scale;
                    h += d[k] * d[k];
                }
                double f = d[i - 1];
                double g = Math.sqrt(h);
                if (f > 0) {
                    g = -g;
                }
                e[i] = scale * g;
                h = h - f * g;
                d[i - 1] = f - g;
                for (int j = 0; j < i; j++) {
                    e[j] = 0.0;
                }

                // Apply similarity transformer to remaining columns.

                for (int j = 0; j < i; j++) {
                    f = d[j];
                    V[j][i] = f;
                    g = e[j] + V[j][j] * f;
                    for (int k = j + 1; k <= i - 1; k++) {
                        g += V[k][j] * d[k];
                        e[k] += V[k][j] * f;
                    }
                    e[j] = g;
                }
                f = 0.0;
                for (int j = 0; j < i; j++) {
                    e[j] /= h;
                    f += e[j] * d[j];
                }
                double hh = f / (h + h);
                for (int j = 0; j < i; j++) {
                    e[j] -= hh * d[j];
                }
                for (int j = 0; j < i; j++) {
                    f = d[j];
                    g = e[j];
                    for (int k = j; k <= i - 1; k++) {
                        V[k][j] -= (f * e[k] + g * d[k]);
                    }
                    d[j] = V[i - 1][j];
                    V[i][j] = 0.0;
                }
            }
            d[i] = h;
        }

        // Accumulate transformations.

        for (int i = 0; i < n - 1; i++) {
            V[n - 1][i] = V[i][i];
            V[i][i] = 1.0;
            double h = d[i + 1];
            if (h != 0.0) {
                for (int k = 0; k <= i; k++) {
                    d[k] = V[k][i + 1] / h;
                }
                for (int j = 0; j <= i; j++) {
                    double g = 0.0;
                    for (int k = 0; k <= i; k++) {
                        g += V[k][i + 1] * V[k][j];
                    }
                    for (int k = 0; k <= i; k++) {
                        V[k][j] -= g * d[k];
                    }
                }
            }
            for (int k = 0; k <= i; k++) {
                V[k][i + 1] = 0.0;
            }
        }
        for (int j = 0; j < n; j++) {
            d[j] = V[n - 1][j];
            V[n - 1][j] = 0.0;
        }
        V[n - 1][n - 1] = 1.0;
        e[0] = 0.0;
    }

    // Symmetric tridiagonal QL algorithm.

    private void tql2() {

        //  This is derived from the Algol procedures tql2, by
        //  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
        //  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
        //  Fortran subroutine in EISPACK.

        for (int i = 1; i < n; i++) {
            e[i - 1] = e[i];
        }
        e[n - 1] = 0.0;

        double f = 0.0;
        double tst1 = 0.0;
        double eps = Math.pow(2.0, -52.0);
        for (int l = 0; l < n; l++) {

            // Find small subdiagonal element

            tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
            int m = l;
            while (m < n) {
                if (Math.abs(e[m]) <= eps * tst1) {
                    break;
                }
                m++;
            }

            // If m == l, d[l] is an eigenvalue,
            // otherwise, iterate.

            if (m > l) {
                int iter = 0;
                do {
                    iter = iter + 1;  // (Could check iteration count here.)

                    // Compute implicit shift

                    double g = d[l];
                    double p = (d[l + 1] - g) / (2.0 * e[l]);
                    double r = Util.hypot(p, 1.0);
                    if (p < 0) {
                        r = -r;
                    }
                    d[l] = e[l] / (p + r);
                    d[l + 1] = e[l] * (p + r);
                    double dl1 = d[l + 1];
                    double h = g - d[l];
                    for (int i = l + 2; i < n; i++) {
                        d[i] -= h;
                    }
                    f = f + h;

                    // Implicit QL transformer.

                    p = d[m];
                    double c = 1.0;
                    double c2 = c;
                    double c3 = c;
                    double el1 = e[l + 1];
                    double s = 0.0;
                    double s2 = 0.0;
                    for (int i = m - 1; i >= l; i--) {
                        c3 = c2;
                        c2 = c;
                        s2 = s;
                        g = c * e[i];
                        h = c * p;
                        r = Util.hypot(p, e[i]);
                        e[i + 1] = s * r;
                        s = e[i] / r;
                        c = p / r;
                        p = c * d[i] - s * g;
                        d[i + 1] = h + s * (c * g + s * d[i]);

                        // Accumulate transformer.

                        for (int k = 0; k < n; k++) {
                            h = V[k][i + 1];
                            V[k][i + 1] = s * V[k][i] + c * h;
                            V[k][i] = c * V[k][i] - s * h;
                        }
                    }
                    p = -s * s2 * c3 * el1 * e[l] / dl1;
                    e[l] = s * p;
                    d[l] = c * p;

                    // Check for convergence.

                } while (Math.abs(e[l]) > eps * tst1);
            }
            d[l] = d[l] + f;
            e[l] = 0.0;
        }

        // Sort eigenvalues and corresponding vectors.

        for (int i = 0; i < n - 1; i++) {
            int k = i;
            double p = d[i];
            for (int j = i + 1; j < n; j++) {
                if (d[j] < p) {
                    k = j;
                    p = d[j];
                }
            }
            if (k != i) {
                d[k] = d[i];
                d[i] = p;
                for (int j = 0; j < n; j++) {
                    p = V[j][i];
                    V[j][i] = V[j][k];
                    V[j][k] = p;
                }
            }
        }
    }

    // Nonsymmetric reduction to Hessenberg form.

    private void orthes() {

        //  This is derived from the Algol procedures orthes and ortran,
        //  by Martin and Wilkinson, Handbook for Auto. Comp.,
        //  Vol.ii-Linear Algebra, and the corresponding
        //  Fortran subroutines in EISPACK.

        int low = 0;
        int high = n - 1;

        for (int m = low + 1; m <= high - 1; m++) {

            // Scale column.

            double scale = 0.0;
            for (int i = m; i <= high; i++) {
                scale = scale + Math.abs(H[i][m - 1]);
            }
            if (scale != 0.0) {

                // Compute Householder transformer.

                double h = 0.0;
                for (int i = high; i >= m; i--) {
                    ort[i] = H[i][m - 1] / scale;
                    h += ort[i] * ort[i];
                }
                double g = Math.sqrt(h);
                if (ort[m] > 0) {
                    g = -g;
                }
                h = h - ort[m] * g;
                ort[m] = ort[m] - g;

                // Apply Householder similarity transformer
                // H = (I-u*u'/h)*H*(I-u*u')/h)

                for (int j = m; j < n; j++) {
                    double f = 0.0;
                    for (int i = high; i >= m; i--) {
                        f += ort[i] * H[i][j];
                    }
                    f = f / h;
                    for (int i = m; i <= high; i++) {
                        H[i][j] -= f * ort[i];
                    }
                }

                for (int i = 0; i <= high; i++) {
                    double f = 0.0;
                    for (int j = high; j >= m; j--) {
                        f += ort[j] * H[i][j];
                    }
                    f = f / h;
                    for (int j = m; j <= high; j++) {
                        H[i][j] -= f * ort[j];
                    }
                }
                ort[m] = scale * ort[m];
                H[m][m - 1] = scale * g;
            }
        }

        // Accumulate transformations (Algol's ortran).

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                V[i][j] = (i == j ? 1.0 : 0.0);
            }
        }

        for (int m = high - 1; m >= low + 1; m--) {
            if (H[m][m - 1] != 0.0) {
                for (int i = m + 1; i <= high; i++) {
                    ort[i] = H[i][m - 1];
                }
                for (int j = m; j <= high; j++) {
                    double g = 0.0;
                    for (int i = m; i <= high; i++) {
                        g += ort[i] * V[i][j];
                    }
                    // Double division avoids possible underflow
                    g = (g / ort[m]) / H[m][m - 1];
                    for (int i = m; i <= high; i++) {
                        V[i][j] += g * ort[i];
                    }
                }
            }
        }
    }


    // Complex scalar division.

    private transient double cdivr, cdivi;

    private void cdiv(double xr, double xi, double yr, double yi) {
        double r, d;
        if (Math.abs(yr) > Math.abs(yi)) {
            r = yi / yr;
            d = yr + r * yi;
            cdivr = (xr + r * xi) / d;
            cdivi = (xi - r * xr) / d;
        } else {
            r = yr / yi;
            d = yi + r * yr;
            cdivr = (r * xr + xi) / d;
            cdivi = (r * xi - xr) / d;
        }
    }


    // Nonsymmetric reduction from Hessenberg to real Schur form.

    private void hqr2() {

        //  This is derived from the Algol procedure hqr2,
        //  by Martin and Wilkinson, Handbook for Auto. Comp.,
        //  Vol.ii-Linear Algebra, and the corresponding
        //  Fortran subroutine in EISPACK.

        // Initialize

        int nn = this.n;
        int n = nn - 1;
        int low = 0;
        int high = nn - 1;
        double eps = Math.pow(2.0, -52.0);
        double exshift = 0.0;
        double p = 0, q = 0, r = 0, s = 0, z = 0, t, w, x, y;

        // Store roots isolated by balanc and compute matrix norm

        double norm = 0.0;
        for (int i = 0; i < nn; i++) {
            if (i < low | i > high) {
                d[i] = H[i][i];
                e[i] = 0.0;
            }
            for (int j = Math.max(i - 1, 0); j < nn; j++) {
                norm = norm + Math.abs(H[i][j]);
            }
        }

        // Outer loop over eigenvalue index

        int iter = 0;
        while (n >= low) {

            // Look for single small sub-diagonal element

            int l = n;
            while (l > low) {
                s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);
                if (s == 0.0) {
                    s = norm;
                }
                if (Math.abs(H[l][l - 1]) < eps * s) {
                    break;
                }
                l--;
            }

            // Check for convergence
            // One root found

            if (l == n) {
                H[n][n] = H[n][n] + exshift;
                d[n] = H[n][n];
                e[n] = 0.0;
                n--;
                iter = 0;

                // Two roots found

            } else if (l == n - 1) {
                w = H[n][n - 1] * H[n - 1][n];
                p = (H[n - 1][n - 1] - H[n][n]) / 2.0;
                q = p * p + w;
                z = Math.sqrt(Math.abs(q));
                H[n][n] = H[n][n] + exshift;
                H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;
                x = H[n][n];

                // Real pair

                if (q >= 0) {
                    if (p >= 0) {
                        z = p + z;
                    } else {
                        z = p - z;
                    }
                    d[n - 1] = x + z;
                    d[n] = d[n - 1];
                    if (z != 0.0) {
                        d[n] = x - w / z;
                    }
                    e[n - 1] = 0.0;
                    e[n] = 0.0;
                    x = H[n][n - 1];
                    s = Math.abs(x) + Math.abs(z);
                    p = x / s;
                    q = z / s;
                    r = Math.sqrt(p * p + q * q);
                    p = p / r;
                    q = q / r;

                    // Row modification

                    for (int j = n - 1; j < nn; j++) {
                        z = H[n - 1][j];
                        H[n - 1][j] = q * z + p * H[n][j];
                        H[n][j] = q * H[n][j] - p * z;
                    }

                    // Column modification

                    for (int i = 0; i <= n; i++) {
                        z = H[i][n - 1];
                        H[i][n - 1] = q * z + p * H[i][n];
                        H[i][n] = q * H[i][n] - p * z;
                    }

                    // Accumulate transformations

                    for (int i = low; i <= high; i++) {
                        z = V[i][n - 1];
                        V[i][n - 1] = q * z + p * V[i][n];
                        V[i][n] = q * V[i][n] - p * z;
                    }

                    // Complex pair

                } else {
                    d[n - 1] = x + p;
                    d[n] = x + p;
                    e[n - 1] = z;
                    e[n] = -z;
                }
                n = n - 2;
                iter = 0;

                // No convergence yet

            } else {

                // Form shift

                x = H[n][n];
                y = 0.0;
                w = 0.0;
                if (l < n) {
                    y = H[n - 1][n - 1];
                    w = H[n][n - 1] * H[n - 1][n];
                }

                // Wilkinson's original ad hoc shift

                if (iter == 10) {
                    exshift += x;
                    for (int i = low; i <= n; i++) {
                        H[i][i] -= x;
                    }
                    s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);
                    x = y = 0.75 * s;
                    w = -0.4375 * s * s;
                }

                // MATLAB's new ad hoc shift

                if (iter == 30) {
                    s = (y - x) / 2.0;
                    s = s * s + w;
                    if (s > 0) {
                        s = Math.sqrt(s);
                        if (y < x) {
                            s = -s;
                        }
                        s = x - w / ((y - x) / 2.0 + s);
                        for (int i = low; i <= n; i++) {
                            H[i][i] -= s;
                        }
                        exshift += s;
                        x = y = w = 0.964;
                    }
                }

                iter = iter + 1;   // (Could check iteration count here.)

                // Look for two consecutive small sub-diagonal elements

                int m = n - 2;
                while (m >= l) {
                    z = H[m][m];
                    r = x - z;
                    s = y - z;
                    p = (r * s - w) / H[m + 1][m] + H[m][m + 1];
                    q = H[m + 1][m + 1] - z - r - s;
                    r = H[m + 2][m + 1];
                    s = Math.abs(p) + Math.abs(q) + Math.abs(r);
                    p = p / s;
                    q = q / s;
                    r = r / s;
                    if (m == l) {
                        break;
                    }
                    if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) <
                            eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) +
                            Math.abs(H[m + 1][m + 1])))) {
                        break;
                    }
                    m--;
                }

                for (int i = m + 2; i <= n; i++) {
                    H[i][i - 2] = 0.0;
                    if (i > m + 2) {
                        H[i][i - 3] = 0.0;
                    }
                }

                // Double QR step involving rows l:n and columns m:n

                for (int k = m; k <= n - 1; k++) {
                    boolean notlast = (k != n - 1);
                    if (k != m) {
                        p = H[k][k - 1];
                        q = H[k + 1][k - 1];
                        r = (notlast ? H[k + 2][k - 1] : 0.0);
                        x = Math.abs(p) + Math.abs(q) + Math.abs(r);
                        if (x != 0.0) {
                            p = p / x;
                            q = q / x;
                            r = r / x;
                        }
                    }
                    if (x == 0.0) {
                        break;
                    }
                    s = Math.sqrt(p * p + q * q + r * r);
                    if (p < 0) {
                        s = -s;
                    }
                    if (s != 0) {
                        if (k != m) {
                            H[k][k - 1] = -s * x;
                        } else if (l != m) {
                            H[k][k - 1] = -H[k][k - 1];
                        }
                        p = p + s;
                        x = p / s;
                        y = q / s;
                        z = r / s;
                        q = q / p;
                        r = r / p;

                        // Row modification

                        for (int j = k; j < nn; j++) {
                            p = H[k][j] + q * H[k + 1][j];
                            if (notlast) {
                                p = p + r * H[k + 2][j];
                                H[k + 2][j] = H[k + 2][j] - p * z;
                            }
                            H[k][j] = H[k][j] - p * x;
                            H[k + 1][j] = H[k + 1][j] - p * y;
                        }

                        // Column modification

                        for (int i = 0; i <= Math.min(n, k + 3); i++) {
                            p = x * H[i][k] + y * H[i][k + 1];
                            if (notlast) {
                                p = p + z * H[i][k + 2];
                                H[i][k + 2] = H[i][k + 2] - p * r;
                            }
                            H[i][k] = H[i][k] - p;
                            H[i][k + 1] = H[i][k + 1] - p * q;
                        }

                        // Accumulate transformations

                        for (int i = low; i <= high; i++) {
                            p = x * V[i][k] + y * V[i][k + 1];
                            if (notlast) {
                                p = p + z * V[i][k + 2];
                                V[i][k + 2] = V[i][k + 2] - p * r;
                            }
                            V[i][k] = V[i][k] - p;
                            V[i][k + 1] = V[i][k + 1] - p * q;
                        }
                    }  // (s != 0)
                }  // k loop
            }  // check convergence
        }  // while (n >= low)

        // Backsubstitute to find vectors of upper triangular form

        if (norm == 0.0) {
            return;
        }

        for (n = nn - 1; n >= 0; n--) {
            p = d[n];
            q = e[n];

            // Real vector

            if (q == 0) {
                int l = n;
                H[n][n] = 1.0;
                for (int i = n - 1; i >= 0; i--) {
                    w = H[i][i] - p;
                    r = 0.0;
                    for (int j = l; j <= n; j++) {
                        r = r + H[i][j] * H[j][n];
                    }
                    if (e[i] < 0.0) {
                        z = w;
                        s = r;
                    } else {
                        l = i;
                        if (e[i] == 0.0) {
                            if (w != 0.0) {
                                H[i][n] = -r / w;
                            } else {
                                H[i][n] = -r / (eps * norm);
                            }

                            // Solve real equations

                        } else {
                            x = H[i][i + 1];
                            y = H[i + 1][i];
                            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                            t = (x * s - z * r) / q;
                            H[i][n] = t;
                            if (Math.abs(x) > Math.abs(z)) {
                                H[i + 1][n] = (-r - w * t) / x;
                            } else {
                                H[i + 1][n] = (-s - y * t) / z;
                            }
                        }

                        // Overflow control

                        t = Math.abs(H[i][n]);
                        if ((eps * t) * t > 1) {
                            for (int j = i; j <= n; j++) {
                                H[j][n] = H[j][n] / t;
                            }
                        }
                    }
                }

                // Complex vector

            } else if (q < 0) {
                int l = n - 1;

                // Last vector component imaginary so matrix is triangular

                if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {
                    H[n - 1][n - 1] = q / H[n][n - 1];
                    H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
                } else {
                    cdiv(0.0, -H[n - 1][n], H[n - 1][n - 1] - p, q);
                    H[n - 1][n - 1] = cdivr;
                    H[n - 1][n] = cdivi;
                }
                H[n][n - 1] = 0.0;
                H[n][n] = 1.0;
                for (int i = n - 2; i >= 0; i--) {
                    double ra, sa, vr, vi;
                    ra = 0.0;
                    sa = 0.0;
                    for (int j = l; j <= n; j++) {
                        ra = ra + H[i][j] * H[j][n - 1];
                        sa = sa + H[i][j] * H[j][n];
                    }
                    w = H[i][i] - p;

                    if (e[i] < 0.0) {
                        z = w;
                        r = ra;
                        s = sa;
                    } else {
                        l = i;
                        if (e[i] == 0) {
                            cdiv(-ra, -sa, w, q);
                            H[i][n - 1] = cdivr;
                            H[i][n] = cdivi;
                        } else {

                            // Solve complex equations

                            x = H[i][i + 1];
                            y = H[i + 1][i];
                            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
                            vi = (d[i] - p) * 2.0 * q;
                            if (vr == 0.0 & vi == 0.0) {
                                vr = eps * norm * (Math.abs(w) + Math.abs(q) +
                                        Math.abs(x) + Math.abs(y) + Math.abs(z));
                            }
                            cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);
                            H[i][n - 1] = cdivr;
                            H[i][n] = cdivi;
                            if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {
                                H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;
                                H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
                            } else {
                                cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);
                                H[i + 1][n - 1] = cdivr;
                                H[i + 1][n] = cdivi;
                            }
                        }

                        // Overflow control

                        t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));
                        if ((eps * t) * t > 1) {
                            for (int j = i; j <= n; j++) {
                                H[j][n - 1] = H[j][n - 1] / t;
                                H[j][n] = H[j][n] / t;
                            }
                        }
                    }
                }
            }
        }

        // Vectors of isolated roots

        for (int i = 0; i < nn; i++) {
            if (i < low | i > high) {
                for (int j = i; j < nn; j++) {
                    V[i][j] = H[i][j];
                }
            }
        }

        // Back transformer to get eigenvectors of original matrix

        for (int j = nn - 1; j >= low; j--) {
            for (int i = low; i <= high; i++) {
                z = 0.0;
                for (int k = low; k <= Math.min(j, high); k++) {
                    z = z + V[i][k] * H[k][j];
                }
                V[i][j] = z;
            }
        }
    }


/* ------------------------
   Constructor
 * ------------------------ */

    /**
     * Check for symmetry, then construct the eigenvalue decomposition
     *
     * @param matrix Square matrix
     *            Structure to access D and V.
     */

    public EigenvalueDecomposition(Matrix matrix) {
        hint = matrix;
        double[][] A = matrix.get();
        n = matrix.cols();
        V = new double[n][n];
        d = new double[n];
        e = new double[n];

        /*issymmetric = true;
        for (int j = 0; (j < n) & issymmetric; j++) {
            for (int i = 0; (i < n) & issymmetric; i++) {
                issymmetric = (A[i][j] == A[j][i]);
            }
        } */

        //if (issymmetric) {
        if (MatrixProperty.isSymmetric(matrix)) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    V[i][j] = A[i][j];
                }
            }

            // Tridiagonalize.
            tred2();

            // Diagonalize.
            tql2();

        } else {
            H = new double[n][n];
            ort = new double[n];

            for (int j = 0; j < n; j++) {
                for (int i = 0; i < n; i++) {
                    H[i][j] = A[i][j];
                }
            }

            // Reduce to Hessenberg form.
            orthes();

            // Reduce Hessenberg to real Schur form.
            hqr2();
        }
    }

/* ------------------------
   Public Methods
 * ------------------------ */

    /**
     * Return the eigenvector matrix
     *
     * @return V
     */

    public Matrix getV() {
        return MatrixFactory.getMatrix(n, n, hint, V);
    }

    /**
     * Return the real parts of the eigenvalues
     * <p/>
     * todo a way to test eigen values is -> sum of eigenvalues = getTrace of the matrix and product of eigenvalues = detrminant of the matrix
     *
     * @return real(diag(D))
     */

    public double[] getRealEigenvalues() {
        return d;
    }

    /**
     * Return the imaginary parts of the eigenvalues
     *
     * @return imag(diag(D))
     */

    public double[] getImagEigenvalues() {
        return e;
    }

    /**
     * Return the block diagonal eigenvalue matrix
     *
     * @return D
     */

    public Matrix getD() {
        double[][] D = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                D[i][j] = 0.0;
            }
            D[i][i] = d[i];
            if (e[i] > 0) {
                D[i][i + 1] = e[i];
            } else if (e[i] < 0) {
                D[i][i - 1] = e[i];
            }
        }
        return MatrixFactory.getMatrix(n, n, hint,  D);
    }
}
package geym.conc.ch4.elelock;

import java.util.Vector;

public class EleLcok {

	public String[] createStrings(){
		Vector<String> v=new Vector<String>();
		for(int i=0;i<100;i++){
			v.add(Integer.toString(i));
		}
		return v.toArray(new String[]{});
	}

	public static void main(String[] args) {


	}

}
package org.jmatrices.dbl;

/**
 * EmptyMatrix
 * //todo is this concept worth thinking about? there must be a way to check for emptiness isEmpty()
 * //todo It breaks object encapsulation. We willhave to add another method in Matrix interface, isEmpty, to detect and deal with emptiness
 * //todo I would suggest throwing IllegalArgumentException where ever an empty matrix might result. As in MatrixTransformer.extractDiagonal
 * <p>Author: purangp</p>
 * Date: 29.04.2004
 * Time: 03:28:16
 */
class EmptyMatrix implements Matrix {
    private final int rows=0;
    private final int cols=0;
    /**
     * Gets the number of rows in the matrix
     * <p/>
     * Counts from 1
     *
     * @return number of rows in the matrix
     */
    public int rows() {
        return rows;
    }

    /**
     * Gets the number of columns in the matrix
     * <p/>
     * counts from 1
     *
     * @return number of columns in the matrix
     */
    public int cols() {
        return cols;
    }

    /**
     * Sets an element at the given position to a new value
     *
     * @param row   row in which the element occurs
     * @param col   column in which the element occurs
     * @param value the new value to be set
     */
    public void set(int row, int col, double value) {

    }

    /**
     * Gets the value of the element at the given row and column
     *
     * @param row row in which the element occurs
     * @param col column in which the element occurs
     * @return value of the element
     */
    public double get(int row, int col) {
        return Double.NaN;
    }

    /**
     * Gets the entire row as a matrix
     *
     * @param row row asked for
     * @return Matrix containing the row
     */
    public Matrix getRow(int row) {
        return new EmptyMatrix();
    }

    /**
     * Gets the entire column as a matrix
     *
     * @param col column asked for
     * @return Matrix containing the column
     */
    public Matrix getColumn(int col) {
        return new EmptyMatrix();
    }

    /**
     * Gets a <strong>copy</strong> of the elements as a 2D array.
     * <p/>
     * Copy signifies the fact that any modifications made on the copy will not affect the Source matrix!
     *
     * @return copy of all elements as a 2D array
     */
    public double[][] get() {
        return null;
    }

    /**
     * Get a submatrix.
     *
     * @param rowI Initial row index
     * @param colI Initial column index
     * @param rowF Final row index
     * @param colF Final column index
     * @return A(rowI:rowF,colI:colF)
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    public Matrix getSubMatrix(int rowI, int colI, int rowF, int colF) {
        return new EmptyMatrix();
    }

    /**
     * Get a submatrix.
     *
     * @param r Array of row indices.
     * @param c Array of column indices.
     * @return A(r(:),c(:))
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    public Matrix getSubMatrix(int[] r, int[] c) {
        return new EmptyMatrix();
    }

    /**
     * Get a submatrix.
     *
     * @param rowI Initial row index
     * @param rowF Final row index
     * @param c    Array of column indices.
     * @return A(i0:i1,c(:))
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    public Matrix getSubMatrix(int rowI, int rowF, int[] c) {
        return new EmptyMatrix();
    }

    /**
     * Get a submatrix.
     *
     * @param r    Array of row indices.
     * @param colI Initial column index
     * @param colF Final column index
     * @return A(r(:),j0:j1)
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    public Matrix getSubMatrix(int[] r, int colI, int colF) {
        return new EmptyMatrix();
    }

    /**
     * Returns a string representation of the object. In general, the
     * <code>toString</code> method returns a string that
     * "textually represents" this object. The result should
     * be a concise but informative representation that is easy for a
     * person to read.
     * It is recommended that all subclasses override this method.
     * <p/>
     * The <code>toString</code> method for class <code>Object</code>
     * returns a string consisting of the name of the class of which the
     * object is an instance, the at-sign character `<code>@</code>', and
     * the unsigned hexadecimal representation of the hash code of the
     * object. In other words, this method returns a string equal to the
     * value of:
     * <blockquote>
     * <pre>
     * getClass().getName() + '@' + Integer.toHexString(hashCode())
     * </pre></blockquote>
     *
     * @return a string representation of the object.
     */
    public String toString() {
        return "Empty Matrix!!";
    }

}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Called by the {@link RingBuffer} to pre-populate all the events to fill the RingBuffer.
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 */
public interface EventFactory<T>
{
    /*
     * Implementations should instantiate an event object, with all memory already allocated where possible.
     */
    T newInstance();
}/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Callback interface to be implemented for processing events as they become available in the {@link RingBuffer}
 *
 * @see BatchEventProcessor#setExceptionHandler(ExceptionHandler) if you want to handle exceptions propagated out of the handler.
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 */
public interface EventHandler<T>
{
    /**
     * Called when a publisher has published an event to the {@link RingBuffer}
     *
     * @param event published to the {@link RingBuffer}
     * @param sequence of the event being processed
     * @param endOfBatch flag to indicate if this is the last event in a batch from the {@link RingBuffer}
     * @throws Exception if the EventHandler would like the exception handled further up the chain.
     */
    void onEvent(T event, long sequence, boolean endOfBatch) throws Exception;
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.dsl;

import com.lmax.disruptor.EventHandler;
import com.lmax.disruptor.EventProcessor;
import com.lmax.disruptor.Sequence;
import com.lmax.disruptor.SequenceBarrier;
import com.lmax.disruptor.WorkHandler;

import java.util.Arrays;

/**
 * A group of {@link EventProcessor}s used as part of the {@link Disruptor}.
 *
 * @param <T> the type of entry used by the event processors.
 */
public class EventHandlerGroup<T>
{
    private final Disruptor<T> disruptor;
    private final ConsumerRepository<T> consumerRepository;
    private final Sequence[] sequences;

    EventHandlerGroup(final Disruptor<T> disruptor,
                      final ConsumerRepository<T> consumerRepository,
                      final Sequence[] sequences)
    {
        this.disruptor = disruptor;
        this.consumerRepository = consumerRepository;
        this.sequences = Arrays.copyOf(sequences, sequences.length);
    }

    /**
     * Create a new event handler group that combines the consumers in this group with <tt>otherHandlerGroup</tt>.
     *
     * @param otherHandlerGroup the event handler group to combine.
     * @return a new EventHandlerGroup combining the existing and new consumers into a single dependency group.
     */
    public EventHandlerGroup<T> and(final EventHandlerGroup<T> otherHandlerGroup)
    {
        final Sequence[] combinedSequences = new Sequence[this.sequences.length + otherHandlerGroup.sequences.length];
        System.arraycopy(this.sequences, 0, combinedSequences, 0, this.sequences.length);
        System.arraycopy(otherHandlerGroup.sequences, 0, combinedSequences, this.sequences.length, otherHandlerGroup.sequences.length);
        return new EventHandlerGroup<T>(disruptor, consumerRepository, combinedSequences);
    }

    /**
     * Create a new event handler group that combines the handlers in this group with <tt>processors</tt>.
     *
     * @param processors the processors to combine.
     * @return a new EventHandlerGroup combining the existing and new processors into a single dependency group.
     */
    public EventHandlerGroup<T> and(final EventProcessor... processors)
    {
        Sequence[] combinedSequences = new Sequence[sequences.length + processors.length];

        for (int i = 0; i < processors.length; i++)
        {
            consumerRepository.add(processors[i]);
            combinedSequences[i] = processors[i].getSequence();
        }
        System.arraycopy(sequences, 0, combinedSequences, processors.length, sequences.length);

        return new EventHandlerGroup<T>(disruptor, consumerRepository, combinedSequences);
    }

    /**
     * Set up batch handlers to consume events from the ring buffer. These handlers will only process events
     * after every {@link EventProcessor} in this group has processed the event.
     *
     * <p>This method is generally used as part of a chain. For example if the handler <code>A</code> must
     * process events before handler <code>B</code>:</p>
     *
     * <pre><code>dw.handleEventsWith(A).then(B);</code></pre>
     *
     * @param handlers the batch handlers that will process events.
     * @return a {@link EventHandlerGroup} that can be used to set up a event processor barrier over the created event processors.
     */
    public EventHandlerGroup<T> then(final EventHandler<? super T>... handlers)
    {
        return handleEventsWith(handlers);
    }

    /**
     * <p>Set up custom event processors to handle events from the ring buffer. The Disruptor will
     * automatically start these processors when {@link Disruptor#start()} is called.</p>
     *
     * <p>This method is generally used as part of a chain. For example if the handler <code>A</code> must
     * process events before handler <code>B</code>:</p>
     *
     * @param eventProcessorFactories the event processor factories to use to create the event processors that will process events.
     * @return a {@link EventHandlerGroup} that can be used to chain dependencies.
     */
    public EventHandlerGroup<T> then(final EventProcessorFactory<T>... eventProcessorFactories)
    {
        return handleEventsWith(eventProcessorFactories);
    }

    /**
     * Set up a worker pool to handle events from the ring buffer. The worker pool will only process events
     * after every {@link EventProcessor} in this group has processed the event. Each event will be processed
     * by one of the work handler instances.
     *
     * <p>This method is generally used as part of a chain. For example if the handler <code>A</code> must
     * process events before the worker pool with handlers <code>B, C</code>:</p>
     *
     * <pre><code>dw.handleEventsWith(A).thenHandleEventsWithWorkerPool(B, C);</code></pre>
     *
     * @param handlers the work handlers that will process events. Each work handler instance will provide an extra thread in the worker pool.
     * @return a {@link EventHandlerGroup} that can be used to set up a event processor barrier over the created event processors.
     */
    public EventHandlerGroup<T> thenHandleEventsWithWorkerPool(final WorkHandler<? super T>... handlers)
    {
        return handleEventsWithWorkerPool(handlers);
    }

    /**
     * Set up batch handlers to handle events from the ring buffer. These handlers will only process events
     * after every {@link EventProcessor} in this group has processed the event.
     *
     * <p>This method is generally used as part of a chain. For example if <code>A</code> must
     * process events before <code>B</code>:</p>
     *
     * <pre><code>dw.after(A).handleEventsWith(B);</code></pre>
     *
     * @param handlers the batch handlers that will process events.
     * @return a {@link EventHandlerGroup} that can be used to set up a event processor barrier over the created event processors.
     */
    public EventHandlerGroup<T> handleEventsWith(final EventHandler<? super T>... handlers)
    {
        return disruptor.createEventProcessors(sequences, handlers);
    }

    /**
     * <p>Set up custom event processors to handle events from the ring buffer. The Disruptor will
     * automatically start these processors when {@link Disruptor#start()} is called.</p>
     *
     * <p>This method is generally used as part of a chain. For example if <code>A</code> must
     * process events before <code>B</code>:</p>
     *
     * <pre><code>dw.after(A).handleEventsWith(B);</code></pre>
     *
     * @param eventProcessorFactories the event processor factories to use to create the event processors that will process events.
     * @return a {@link EventHandlerGroup} that can be used to chain dependencies.
     */
    public EventHandlerGroup<T> handleEventsWith(final EventProcessorFactory<T>... eventProcessorFactories)
    {
        return disruptor.createEventProcessors(sequences, eventProcessorFactories);
    }

    /**
     * Set up a worker pool to handle events from the ring buffer. The worker pool will only process events
     * after every {@link EventProcessor} in this group has processed the event. Each event will be processed
     * by one of the work handler instances.
     *
     * <p>This method is generally used as part of a chain. For example if the handler <code>A</code> must
     * process events before the worker pool with handlers <code>B, C</code>:</p>
     *
     * <pre><code>dw.after(A).handleEventsWithWorkerPool(B, C);</code></pre>
     *
     * @param handlers the work handlers that will process events. Each work handler instance will provide an extra thread in the worker pool.
     * @return a {@link EventHandlerGroup} that can be used to set up a event processor barrier over the created event processors.
     */
    public EventHandlerGroup<T> handleEventsWithWorkerPool(final WorkHandler<? super T>... handlers)
    {
        return disruptor.createWorkerPool(sequences, handlers);
    }

    /**
     * Create a dependency barrier for the processors in this group.
     * This allows custom event processors to have dependencies on
     * {@link com.lmax.disruptor.BatchEventProcessor}s created by the disruptor.
     *
     * @return a {@link SequenceBarrier} including all the processors in this group.
     */
    public SequenceBarrier asSequenceBarrier()
    {
        return disruptor.getRingBuffer().newBarrier(sequences);
    }
}
package com.lmax.disruptor;

/**
 * Experimental poll-based interface for the Disruptor.
 */
public class EventPoller<T>
{
    private final DataProvider<T> dataProvider;
    private final Sequencer sequencer;
    private final Sequence sequence;
    private final Sequence gatingSequence;

    public interface Handler<T>
    {
        boolean onEvent(T event, long sequence, boolean endOfBatch) throws Exception;
    }

    public enum PollState
    {
        PROCESSING, GATING, IDLE
    }

    public EventPoller(final DataProvider<T> dataProvider,
                       final Sequencer sequencer,
                       final Sequence sequence,
                       final Sequence gatingSequence)
    {
        this.dataProvider = dataProvider;
        this.sequencer = sequencer;
        this.sequence = sequence;
        this.gatingSequence = gatingSequence;
    }

    public PollState poll(final Handler<T> eventHandler) throws Exception
    {
        final long currentSequence = sequence.get();
        long nextSequence = currentSequence + 1;
        final long availableSequence = sequencer.getHighestPublishedSequence(nextSequence, gatingSequence.get());

        if (nextSequence <= availableSequence)
        {
            boolean processNextEvent;
            long processedSequence = currentSequence;

            try
            {
                do
                {
                    final T event = dataProvider.get(nextSequence);
                    processNextEvent = eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);
                    processedSequence = nextSequence;
                    nextSequence++;

                }
                while (nextSequence <= availableSequence & processNextEvent);
            }
            finally
            {
                sequence.set(processedSequence);
            }

            return PollState.PROCESSING;
        }
        else if (sequencer.getCursor() >= nextSequence)
        {
            return PollState.GATING;
        }
        else
        {
            return PollState.IDLE;
        }
    }

    public static <T> EventPoller<T> newInstance(final DataProvider<T> dataProvider,
                                                 final Sequencer sequencer,
                                                 final Sequence sequence,
                                                 final Sequence cursorSequence,
                                                 final Sequence...gatingSequences)
    {
        Sequence gatingSequence;
        if (gatingSequences.length == 0)
        {
            gatingSequence = cursorSequence;
        }
        else if (gatingSequences.length == 1)
        {
            gatingSequence = gatingSequences[0];
        }
        else
        {
            gatingSequence = new FixedSequenceGroup(gatingSequences);
        }

        return new EventPoller<T>(dataProvider, sequencer, sequence, gatingSequence);
    }

    public Sequence getSequence()
    {
        return sequence;
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * EventProcessors waitFor events to become available for consumption from the {@link RingBuffer}
 *
 * An EventProcessor will generally be associated with a Thread for execution.
 */
public interface EventProcessor extends Runnable
{
    /**
     * Get a reference to the {@link Sequence} being used by this {@link EventProcessor}.
     *
     * @return reference to the {@link Sequence} for this {@link EventProcessor}
     */
    Sequence getSequence();

    /**
     * Signal that this EventProcessor should stop when it has finished consuming at the next clean break.
     * It will call {@link SequenceBarrier#alert()} to notify the thread to check status.
     */
    void halt();

    boolean isRunning();
}
package com.lmax.disruptor.dsl;

import com.lmax.disruptor.EventProcessor;
import com.lmax.disruptor.RingBuffer;
import com.lmax.disruptor.Sequence;

/**
 * A factory interface to make it possible to include custom event processors in a chain:
 *
 * <pre><code>
 * disruptor.handleEventsWith(handler1).then((ringBuffer, barrierSequences) -&gt; new CustomEventProcessor(ringBuffer, barrierSequences));
 * </code></pre>
 */
public interface EventProcessorFactory<T>
{
    /**
     * Create a new event processor that gates on <code>barrierSequences</code>.
     *
     * @param barrierSequences the sequences to gate on
     * @return a new EventProcessor that gates on <code>barrierSequences</code> before processing events
     */
    EventProcessor createEventProcessor(RingBuffer<T> ringBuffer, Sequence[] barrierSequences);
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.dsl;

import com.lmax.disruptor.EventHandler;
import com.lmax.disruptor.EventProcessor;
import com.lmax.disruptor.Sequence;
import com.lmax.disruptor.SequenceBarrier;

import java.util.concurrent.Executor;

/**
 * <p>Wrapper class to tie together a particular event processing stage</p>
 *
 * <p>Tracks the event processor instance, the event handler instance, and sequence barrier which the stage is attached to.</p>
 *
 * @param T the type of the configured {@link EventHandler}
 */
class EventProcessorInfo<T> implements ConsumerInfo
{
    private final EventProcessor eventprocessor;
    private final EventHandler<? super T> handler;
    private final SequenceBarrier barrier;
    private boolean endOfChain = true;

    EventProcessorInfo(final EventProcessor eventprocessor, final EventHandler<? super T> handler, final SequenceBarrier barrier)
    {
        this.eventprocessor = eventprocessor;
        this.handler = handler;
        this.barrier = barrier;
    }

    public EventProcessor getEventProcessor()
    {
        return eventprocessor;
    }

    @Override
    public Sequence[] getSequences()
    {
        return new Sequence[] { eventprocessor.getSequence() };
    }

    public EventHandler<? super T> getHandler()
    {
        return handler;
    }

    @Override
    public SequenceBarrier getBarrier()
    {
        return barrier;
    }

    @Override
    public boolean isEndOfChain()
    {
        return endOfChain;
    }

    @Override
    public void start(final Executor executor)
    {
        executor.execute(eventprocessor);
    }

    @Override
    public void halt()
    {
        eventprocessor.halt();
    }

    /**
     *
     */
    @Override
    public void markAsUsedInBarrier()
    {
        endOfChain = false;
    }

    @Override
    public boolean isRunning()
    {
        return eventprocessor.isRunning();
    }
}
/*
 * Copyright 2013 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

public interface EventReleaseAware
{
    void setEventReleaser(EventReleaser eventReleaser);
}
/*
 * Copyright 2013 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

public interface EventReleaser
{
    void release();
}
package com.lmax.disruptor;

public interface EventSequencer<T> extends DataProvider<T>, Sequenced
{

}
package com.lmax.disruptor;

public interface EventSink<E>
{
    /**
     * Publishes an event to the ring buffer.  It handles
     * claiming the next sequence, getting the current (uninitialised)
     * event from the ring buffer and publishing the claimed sequence
     * after translation.
     *
     * @param translator The user specified translation for the event
     */
    void publishEvent(EventTranslator<E> translator);

    /**
     * Attempts to publish an event to the ring buffer.  It handles
     * claiming the next sequence, getting the current (uninitialised)
     * event from the ring buffer and publishing the claimed sequence
     * after translation.  Will return false if specified capacity
     * was not available.
     *
     * @param translator The user specified translation for the event
     * @return true if the value was published, false if there was insufficient
     * capacity.
     */
    boolean tryPublishEvent(EventTranslator<E> translator);

    /**
     * Allows one user supplied argument.
     *
     * @see #publishEvent(EventTranslator)
     * @param translator The user specified translation for the event
     * @param arg0 A user supplied argument.
     */
    <A> void publishEvent(EventTranslatorOneArg<E, A> translator, A arg0);

    /**
     * Allows one user supplied argument.
     *
     * @see #tryPublishEvent(EventTranslator)
     * @param translator The user specified translation for the event
     * @param arg0 A user supplied argument.
     * @return true if the value was published, false if there was insufficient
     * capacity.
     */
    <A> boolean tryPublishEvent(EventTranslatorOneArg<E, A> translator, A arg0);

    /**
     * Allows two user supplied arguments.
     *
     * @see #publishEvent(EventTranslator)
     * @param translator The user specified translation for the event
     * @param arg0 A user supplied argument.
     * @param arg1 A user supplied argument.
     */
    <A, B> void publishEvent(EventTranslatorTwoArg<E, A, B> translator, A arg0, B arg1);

    /**
     * Allows two user supplied arguments.
     *
     * @see #tryPublishEvent(EventTranslator)
     * @param translator The user specified translation for the event
     * @param arg0 A user supplied argument.
     * @param arg1 A user supplied argument.
     * @return true if the value was published, false if there was insufficient
     * capacity.
     */
    <A, B> boolean tryPublishEvent(EventTranslatorTwoArg<E, A, B> translator, A arg0, B arg1);

    /**
     * Allows three user supplied arguments
     *
     * @see #publishEvent(EventTranslator)
     * @param translator The user specified translation for the event
     * @param arg0 A user supplied argument.
     * @param arg1 A user supplied argument.
     * @param arg2 A user supplied argument.
     */
    <A, B, C> void publishEvent(EventTranslatorThreeArg<E, A, B, C> translator, A arg0, B arg1, C arg2);

    /**
     * Allows three user supplied arguments
     *
     * @see #publishEvent(EventTranslator)
     * @param translator The user specified translation for the event
     * @param arg0 A user supplied argument.
     * @param arg1 A user supplied argument.
     * @param arg2 A user supplied argument.
     * @return true if the value was published, false if there was insufficient
     * capacity.
     */
    <A, B, C> boolean tryPublishEvent(EventTranslatorThreeArg<E, A, B, C> translator, A arg0, B arg1, C arg2);

    /**
     * Allows a variable number of user supplied arguments
     *
     * @see #publishEvent(EventTranslator)
     * @param translator The user specified translation for the event
     * @param args User supplied arguments.
     */
    void publishEvent(EventTranslatorVararg<E> translator, Object... args);

    /**
     * Allows a variable number of user supplied arguments
     *
     * @see #publishEvent(EventTranslator)
     * @param translator The user specified translation for the event
     * @param args User supplied arguments.
     * @return true if the value was published, false if there was insufficient
     * capacity.
     */
    boolean tryPublishEvent(EventTranslatorVararg<E> translator, Object... args);

    /**
     * Publishes multiple events to the ring buffer.  It handles
     * claiming the next sequence, getting the current (uninitialised)
     * event from the ring buffer and publishing the claimed sequence
     * after translation.
     * <p>
     * With this call the data that is to be inserted into the ring
     * buffer will be a field (either explicitly or captured anonymously),
     * therefore this call will require an instance of the translator
     * for each value that is to be inserted into the ring buffer.
     *
     * @param translators The user specified translation for each event
     */
    void publishEvents(EventTranslator<E>[] translators);

    /**
     * Publishes multiple events to the ring buffer.  It handles
     * claiming the next sequence, getting the current (uninitialised)
     * event from the ring buffer and publishing the claimed sequence
     * after translation.
     * <p>
     * With this call the data that is to be inserted into the ring
     * buffer will be a field (either explicitly or captured anonymously),
     * therefore this call will require an instance of the translator
     * for each value that is to be inserted into the ring buffer.
     *
     * @param translators   The user specified translation for each event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The actual size of the batch
     */
    void publishEvents(EventTranslator<E>[] translators, int batchStartsAt, int batchSize);

    /**
     * Attempts to publish multiple events to the ring buffer.  It handles
     * claiming the next sequence, getting the current (uninitialised)
     * event from the ring buffer and publishing the claimed sequence
     * after translation.  Will return false if specified capacity
     * was not available.
     *
     * @param translators The user specified translation for the event
     * @return true if the value was published, false if there was insufficient
     *         capacity.
     */
    boolean tryPublishEvents(EventTranslator<E>[] translators);

    /**
     * Attempts to publish multiple events to the ring buffer.  It handles
     * claiming the next sequence, getting the current (uninitialised)
     * event from the ring buffer and publishing the claimed sequence
     * after translation.  Will return false if specified capacity
     * was not available.
     *
     * @param translators   The user specified translation for the event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The actual size of the batch
     * @return true if all the values were published, false if there was insufficient
     *         capacity.
     */
    boolean tryPublishEvents(EventTranslator<E>[] translators, int batchStartsAt, int batchSize);

    /**
     * Allows one user supplied argument per event.
     *
     * @param translator The user specified translation for the event
     * @param arg0       A user supplied argument.
     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])
     */
    <A> void publishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0);

    /**
     * Allows one user supplied argument per event.
     *
     * @param translator    The user specified translation for each event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The actual size of the batch
     * @param arg0          An array of user supplied arguments, one element per event.
     * @see #publishEvents(EventTranslator[])
     */
    <A> void publishEvents(EventTranslatorOneArg<E, A> translator, int batchStartsAt, int batchSize, A[] arg0);

    /**
     * Allows one user supplied argument.
     *
     * @param translator The user specified translation for each event
     * @param arg0       An array of user supplied arguments, one element per event.
     * @return true if the value was published, false if there was insufficient
     *         capacity.
     * @see #tryPublishEvents(com.lmax.disruptor.EventTranslator[])
     */
    <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0);

    /**
     * Allows one user supplied argument.
     *
     * @param translator    The user specified translation for each event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The actual size of the batch
     * @param arg0          An array of user supplied arguments, one element per event.
     * @return true if the value was published, false if there was insufficient
     *         capacity.
     * @see #tryPublishEvents(EventTranslator[])
     */
    <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, int batchStartsAt, int batchSize, A[] arg0);

    /**
     * Allows two user supplied arguments per event.
     *
     * @param translator The user specified translation for the event
     * @param arg0       An array of user supplied arguments, one element per event.
     * @param arg1       An array of user supplied arguments, one element per event.
     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])
     */
    <A, B> void publishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1);

    /**
     * Allows two user supplied arguments per event.
     *
     * @param translator    The user specified translation for the event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The actual size of the batch.
     * @param arg0          An array of user supplied arguments, one element per event.
     * @param arg1          An array of user supplied arguments, one element per event.
     * @see #publishEvents(EventTranslator[])
     */
    <A, B> void publishEvents(EventTranslatorTwoArg<E, A, B> translator, int batchStartsAt, int batchSize, A[] arg0,
                              B[] arg1);

    /**
     * Allows two user supplied arguments per event.
     *
     * @param translator The user specified translation for the event
     * @param arg0       An array of user supplied arguments, one element per event.
     * @param arg1       An array of user supplied arguments, one element per event.
     * @return true if the value was published, false if there was insufficient
     *         capacity.
     * @see #tryPublishEvents(com.lmax.disruptor.EventTranslator[])
     */
    <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1);

    /**
     * Allows two user supplied arguments per event.
     *
     * @param translator    The user specified translation for the event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The actual size of the batch.
     * @param arg0          An array of user supplied arguments, one element per event.
     * @param arg1          An array of user supplied arguments, one element per event.
     * @return true if the value was published, false if there was insufficient
     *         capacity.
     * @see #tryPublishEvents(EventTranslator[])
     */
    <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator, int batchStartsAt, int batchSize,
                                    A[] arg0, B[] arg1);

    /**
     * Allows three user supplied arguments per event.
     *
     * @param translator The user specified translation for the event
     * @param arg0       An array of user supplied arguments, one element per event.
     * @param arg1       An array of user supplied arguments, one element per event.
     * @param arg2       An array of user supplied arguments, one element per event.
     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])
     */
    <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2);

    /**
     * Allows three user supplied arguments per event.
     *
     * @param translator    The user specified translation for the event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The number of elements in the batch.
     * @param arg0          An array of user supplied arguments, one element per event.
     * @param arg1          An array of user supplied arguments, one element per event.
     * @param arg2          An array of user supplied arguments, one element per event.
     * @see #publishEvents(EventTranslator[])
     */
    <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, int batchStartsAt, int batchSize,
                                 A[] arg0, B[] arg1, C[] arg2);

    /**
     * Allows three user supplied arguments per event.
     *
     * @param translator The user specified translation for the event
     * @param arg0       An array of user supplied arguments, one element per event.
     * @param arg1       An array of user supplied arguments, one element per event.
     * @param arg2       An array of user supplied arguments, one element per event.
     * @return true if the value was published, false if there was insufficient
     *         capacity.
     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])
     */
    <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2);

    /**
     * Allows three user supplied arguments per event.
     *
     * @param translator    The user specified translation for the event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The actual size of the batch.
     * @param arg0          An array of user supplied arguments, one element per event.
     * @param arg1          An array of user supplied arguments, one element per event.
     * @param arg2          An array of user supplied arguments, one element per event.
     * @return true if the value was published, false if there was insufficient
     *         capacity.
     * @see #publishEvents(EventTranslator[])
     */
    <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> translator, int batchStartsAt,
                                       int batchSize, A[] arg0, B[] arg1, C[] arg2);

    /**
     * Allows a variable number of user supplied arguments per event.
     *
     * @param translator The user specified translation for the event
     * @param args       User supplied arguments, one Object[] per event.
     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])
     */
    void publishEvents(EventTranslatorVararg<E> translator, Object[]... args);

    /**
     * Allows a variable number of user supplied arguments per event.
     *
     * @param translator    The user specified translation for the event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The actual size of the batch
     * @param args          User supplied arguments, one Object[] per event.
     * @see #publishEvents(EventTranslator[])
     */
    void publishEvents(EventTranslatorVararg<E> translator, int batchStartsAt, int batchSize, Object[]... args);

    /**
     * Allows a variable number of user supplied arguments per event.
     *
     * @param translator The user specified translation for the event
     * @param args       User supplied arguments, one Object[] per event.
     * @return true if the value was published, false if there was insufficient
     *         capacity.
     * @see #publishEvents(com.lmax.disruptor.EventTranslator[])
     */
    boolean tryPublishEvents(EventTranslatorVararg<E> translator, Object[]... args);

    /**
     * Allows a variable number of user supplied arguments per event.
     *
     * @param translator    The user specified translation for the event
     * @param batchStartsAt The first element of the array which is within the batch.
     * @param batchSize     The actual size of the batch.
     * @param args          User supplied arguments, one Object[] per event.
     * @return true if the value was published, false if there was insufficient
     *         capacity.
     * @see #publishEvents(EventTranslator[])
     */
    boolean tryPublishEvents(EventTranslatorVararg<E> translator, int batchStartsAt, int batchSize, Object[]... args);

}/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * <p>Implementations translate (write) data representations into events claimed from the {@link RingBuffer}.</p>
 *
 * <p>When publishing to the RingBuffer, provide an EventTranslator. The RingBuffer will select the next available
 * event by sequence and provide it to the EventTranslator (which should update the event), before publishing
 * the sequence update.</p>
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 */
public interface EventTranslator<T>
{
    /**
     * Translate a data representation into fields set in given event
     *
     * @param event into which the data should be translated.
     * @param sequence that is assigned to event.
     */
    void translateTo(final T event, long sequence);
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Implementations translate another data representations into events claimed from the {@link RingBuffer}
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 * @see EventTranslator
 */
public interface EventTranslatorOneArg<T, A>
{
    /**
     * Translate a data representation into fields set in given event
     *
     * @param event into which the data should be translated.
     * @param sequence that is assigned to event.
     * @param arg0 The first user specified argument to the translator
     */
    void translateTo(final T event, long sequence, final A arg0);
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Implementations translate another data representations into events claimed from the {@link RingBuffer}
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 * @see EventTranslator
 */
public interface EventTranslatorThreeArg<T, A, B, C>
{
    /**
     * Translate a data representation into fields set in given event
     *
     * @param event into which the data should be translated.
     * @param sequence that is assigned to event.
     * @param arg0 The first user specified argument to the translator
     * @param arg1 The second user specified argument to the translator
     * @param arg2 The third user specified argument to the translator
     */
    void translateTo(final T event, long sequence, final A arg0, final B arg1, final C arg2);
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Implementations translate another data representations into events claimed from the {@link RingBuffer}
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 * @see EventTranslator
 */
public interface EventTranslatorTwoArg<T, A, B>
{
    /**
     * Translate a data representation into fields set in given event
     *
     * @param event into which the data should be translated.
     * @param sequence that is assigned to event.
     * @param arg0 The first user specified argument to the translator
     * @param arg1 The second user specified argument to the translator
     */
    void translateTo(final T event, long sequence, final A arg0, final B arg1);
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Implementations translate another data representations into events claimed from the {@link RingBuffer}
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 * @see EventTranslator
 */
public interface EventTranslatorVararg<T>
{
    /**
     * Translate a data representation into fields set in given event
     *
     * @param event into which the data should be translated.
     * @param sequence that is assigned to event.
     * @param args The array of user arguments.
     */
    void translateTo(final T event, long sequence, final Object...args);
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Callback handler for uncaught exceptions in the event processing cycle of the {@link BatchEventProcessor}
 */
public interface ExceptionHandler<T>
{
    /**
     * <p>Strategy for handling uncaught exceptions when processing an event.</p>
     *
     * <p>If the strategy wishes to terminate further processing by the {@link BatchEventProcessor}
     * then it should throw a {@link RuntimeException}.</p>
     *
     * @param ex the exception that propagated from the {@link EventHandler}.
     * @param sequence of the event which cause the exception.
     * @param event being processed when the exception occurred.  This can be null.
     */
    void handleEventException(Throwable ex, long sequence, T event);

    /**
     * Callback to notify of an exception during {@link LifecycleAware#onStart()}
     *
     * @param ex throw during the starting process.
     */
    void handleOnStartException(Throwable ex);

    /**
     * Callback to notify of an exception during {@link LifecycleAware#onShutdown()}
     *
     * @param ex throw during the shutdown process.
     */
    void handleOnShutdownException(Throwable ex);
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.dsl;

import com.lmax.disruptor.BatchEventProcessor;
import com.lmax.disruptor.EventHandler;
import com.lmax.disruptor.ExceptionHandler;

/**
 * A support class used as part of setting an exception handler for a specific event handler.
 * For example:
 * <pre><code>disruptorWizard.handleExceptionsIn(eventHandler).with(exceptionHandler);</code></pre>
 *
 * @param <T> the type of event being handled.
 */
public class ExceptionHandlerSetting<T>
{
    private final EventHandler<T> eventHandler;
    private final ConsumerRepository<T> consumerRepository;

    ExceptionHandlerSetting(final EventHandler<T> eventHandler,
                            final ConsumerRepository<T> consumerRepository)
    {
        this.eventHandler = eventHandler;
        this.consumerRepository = consumerRepository;
    }

    /**
     * Specify the {@link ExceptionHandler} to use with the event handler.
     *
     * @param exceptionHandler the exception handler to use.
     */
    public void with(ExceptionHandler<? super T> exceptionHandler)
    {
        ((BatchEventProcessor<T>) consumerRepository.getEventProcessorFor(eventHandler)).setExceptionHandler(exceptionHandler);
        consumerRepository.getBarrierFor(eventHandler).alert();
    }
}

package geym.conc.ch3.pool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ExtThreadPool {
    public static class MyTask implements Runnable {
        public String name;

        public MyTask(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            System.out.println("正在执行" + ":Thread ID:" + Thread.currentThread().getId()
                    + ",Task Name=" + name);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {

        ExecutorService es = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>()) {
            @Override
            protected void beforeExecute(Thread t, Runnable r) {
                System.out.println("准备执行：" + ((MyTask) r).name);
            }

            @Override
            protected void afterExecute(Runnable r, Throwable t) {
                System.out.println("执行完成：" + ((MyTask) r).name);
            }

            @Override
            protected void terminated() {
                System.out.println("线程池退出");
            }

        };
        for (int i = 0; i < 5; i++) {
            MyTask task = new MyTask("TASK-GEYM-" + i);
            es.execute(task);
            Thread.sleep(10);
        }
        es.shutdown();
    }
}
package geym.conc.ch3.synctrl;

import java.util.concurrent.locks.ReentrantLock;

public class FairLock implements Runnable {
    public static ReentrantLock fairLock = new ReentrantLock();

    @Override
    public void run() {
        while(true){
        try{
            fairLock.lock();
            System.out.println(Thread.currentThread().getName()+" 获得锁");
        }finally{
            fairLock.unlock();
        }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        FairLock r1 = new FairLock();
        Thread t1=new Thread(r1,"Thread_t1");
        Thread t2=new Thread(r1,"Thread_t2");
        t1.start();t2.start();
    }
}
package geym.conc.ch5.disruptor;

public final class FalseSharing implements Runnable {
    public final static int NUM_THREADS = 2; // change
    public final static long ITERATIONS = 500L * 1000L * 1000L;
    private final int arrayIndex;

    private static VolatileLong[] longs = new VolatileLong[NUM_THREADS];
    static {
        for (int i = 0; i < longs.length; i++) {
            longs[i] = new VolatileLong();
        }
    }

    public FalseSharing(final int arrayIndex) {
        this.arrayIndex = arrayIndex;
    }

    public static void main(final String[] args) throws Exception {
        final long start = System.currentTimeMillis();
        runTest();
        System.out.println("duration = " + (System.currentTimeMillis() - start));
    }

    private static void runTest() throws InterruptedException {
        Thread[] threads = new Thread[NUM_THREADS];

        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(new FalseSharing(i));
        }

        for (Thread t : threads) {
            t.start();
        }

        for (Thread t : threads) {
            t.join();
        }
    }

    public void run() {
        long i = ITERATIONS + 1;
        while (0 != --i) {
            longs[arrayIndex].value = i;
        }
    }

    //JDK 7 某些版本 和 JDK 8中 会把不用的数据优化 导致 这种优化手段失效
    // Unlock: -XX:-RestrictContended (JDK 8  option)
    //@sun.misc.Contended
    public final static class VolatileLong {
        public volatile long value = 0L;
        public long p1, p2, p3, p4, p5, p6,p7=8L; // comment out
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Convenience implementation of an exception handler that using standard JDK logging to log
 * the exception as {@link Level}.SEVERE and re-throw it wrapped in a {@link RuntimeException}
 */
public final class FatalExceptionHandler implements ExceptionHandler<Object>
{
    private static final Logger LOGGER = Logger.getLogger(FatalExceptionHandler.class.getName());
    private final Logger logger;

    public FatalExceptionHandler()
    {
        this.logger = LOGGER;
    }

    public FatalExceptionHandler(final Logger logger)
    {
        this.logger = logger;
    }

    @Override
    public void handleEventException(final Throwable ex, final long sequence, final Object event)
    {
        logger.log(Level.SEVERE, "Exception processing: " + sequence + " " + event, ex);

        throw new RuntimeException(ex);
    }

    @Override
    public void handleOnStartException(final Throwable ex)
    {
        logger.log(Level.SEVERE, "Exception during onStart()", ex);
    }

    @Override
    public void handleOnShutdownException(final Throwable ex)
    {
        logger.log(Level.SEVERE, "Exception during onShutdown()", ex);
    }
}
package geym.conc.remove.prime;


public class FindPrime implements Runnable {

    int myPrime;

    public FindPrime(int prime){
        this.myPrime=prime;
        FindPrimeMain.threadCount.incrementAndGet();
    }
    @Override
    public void run() {
       out:while(true){
           for(int i=myPrime+1;i<FindPrimeMain.COUNT;i++){
               if(PrimeUtil.isPrime(i)){
                   //submit
                   FindPrimeMain.pool.execute(new FindPrime(i));
                   break out;
               }
           }
       }
       int k=0;
       for(int i=myPrime;(k=i*myPrime)<FindPrimeMain.COUNT;i++){
           FindPrimeMain.bitset.set(k,false);
       }
       FindPrimeMain.threadCount.decrementAndGet();
    }
}
package geym.conc.remove.prime;

import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class FindPrimeMain {
    public static ThreadPoolExecutor pool=new ThreadPoolExecutor(0, Integer.MAX_VALUE,
            0L, TimeUnit.SECONDS,
            new SynchronousQueue<Runnable>());
    public static int COUNT=1000;
    public static SyncBitSet bitset=new SyncBitSet(COUNT);
    public static AtomicInteger threadCount=new AtomicInteger(0);

    public static void printPrime(){
        for(int i=0;i<COUNT;i++){
            if(bitset.get(i)){
                System.out.print(i+" ");
                if(i%20==0)System.out.println();
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        pool.execute(new FindPrime(2));
        while(threadCount.get()!=0){
            Thread.sleep(100);
        }
        printPrime();
    }

}
/*
 * Copyright 2012 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.Arrays;

import com.lmax.disruptor.util.Util;

/**
 * Hides a group of Sequences behind a single Sequence
 */
public final class FixedSequenceGroup extends Sequence
{
    private final Sequence[] sequences;

    /**
     * Constructor
     *
     * @param sequences the list of sequences to be tracked under this sequence group
     */
    public FixedSequenceGroup(Sequence[] sequences)
    {
        this.sequences = Arrays.copyOf(sequences, sequences.length);
    }

    /**
     * Get the minimum sequence value for the group.
     *
     * @return the minimum sequence value for the group.
     */
    @Override
    public long get()
    {
        return Util.getMinimumSequence(sequences);
    }

    @Override
    public String toString()
    {
        return Arrays.toString(sequences);
    }

    /**
     * Not supported.
     */
    @Override
    public void set(long value)
    {
        throw new UnsupportedOperationException();
    }

    /**
     * Not supported.
     */
    @Override
    public boolean compareAndSet(long expectedValue, long newValue)
    {
        throw new UnsupportedOperationException();
    }

    /**
     * Not supported.
     */
    @Override
    public long incrementAndGet()
    {
        throw new UnsupportedOperationException();
    }

    /**
     * Not supported.
     */
    @Override
    public long addAndGet(long increment)
    {
        throw new UnsupportedOperationException();
    }
}
package geym.conc.ch6.flow;
import java.util.Arrays;

import java.util.concurrent.Flow.*;
import java.util.concurrent.SubmissionPublisher;

public class FlowDemo
{
   public static void main(String[] args)
   {
      // Create a publisher.

      SubmissionPublisher<String> publisher = new SubmissionPublisher<>();

      // Create a subscriber and register it with the publisher.

      MySubscriber<String> subscriber = new MySubscriber<>();
      MySubscriber<String> subscriber2 = new MySubscriber<>();
      publisher.subscribe(subscriber);
      publisher.subscribe(subscriber2);

      // Publish several data items and then close the publisher.

      System.out.println("Publishing data items...");
      String[] items = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
      Arrays.asList(items).stream().forEach(i ->{
    	  publisher.submit(i);
    	  System.out.println(Thread.currentThread().getName()+" publish "+i);
      });
      publisher.close();

      try
      {
         synchronized("A")
         {
            "A".wait();
         }
      }
      catch (InterruptedException ie)
      {
      }
   }
}

class MySubscriber<T> implements Subscriber<T>
{
   private Subscription subscription;

   @Override
   public void onSubscribe(Subscription subscription)
   {
      this.subscription = subscription;
      subscription.request(1);
      System.out.println(Thread.currentThread().getName()+" onSubscribe");
   }

   @Override
   public void onNext(T item)
   {
      System.out.println(Thread.currentThread().getName()+" Received: " + item);
      subscription.request(1);
   }

   @Override
   public void onError(Throwable t)
   {
      t.printStackTrace();
      synchronized("A")
      {
         "A".notifyAll();
      }
   }

   @Override
   public void onComplete()
   {
      System.out.println("Done");
      synchronized("A")
      {
         "A".notifyAll();
      }
   }
}package geym.conc.ch6.flow;
import java.util.Arrays;
import java.util.concurrent.SubmissionPublisher;

public class FlowDemo2
{
   public static void main(String[] args)
   {
      // Create a publisher.

      SubmissionPublisher<String> publisher = new SubmissionPublisher<>();

      // Create a subscriber and register it with the publisher.

      MySubscriber<String> subscriber = new MySubscriber<>();
      MySubscriber<String> subscriber2 = new MySubscriber<>();

      TransformProcessor<String,String> toUpperCase = new TransformProcessor<>(String::toUpperCase);
      TransformProcessor<String,String> toLowverCase = new TransformProcessor<>(String::toLowerCase);

      publisher.subscribe(toUpperCase);
      publisher.subscribe(toLowverCase);

      toUpperCase.subscribe(subscriber);
      toLowverCase.subscribe(subscriber2);



      // Publish several data items and then close the publisher.

      System.out.println("Publishing data items...");
      String[] items = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
      Arrays.asList(items).stream().forEach(i ->{
    	  publisher.submit(i);
    	  System.out.println(Thread.currentThread().getName()+" publish "+i);
      });
      publisher.close();

      try
      {
         synchronized("A")
         {
            "A".wait();
         }
      }
      catch (InterruptedException ie)
      {
      }
   }
}

package geym.conc.ch5.guava.future;

import java.util.concurrent.Executors;

import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;

import geym.conc.ch5.future.RealData;

public class FutrueDemo {
    public static void main(String args[]) throws InterruptedException {
        ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));

        ListenableFuture<String> task = service.submit(new RealData("x"));

        task.addListener(() -> {
            System.out.print("异步处理成功:");
            try {
                System.out.println(task.get());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, MoreExecutors.directExecutor());

        System.out.println("main task done.....");
        Thread.sleep(3000);
    }
}
package geym.conc.ch5.guava.future;

import java.util.concurrent.Executors;

import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;

import geym.conc.ch5.future.RealData;

public class FutrueDemo2 {
	public static void main(String args[]) throws InterruptedException {
		ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
		ListenableFuture<String> task = service.submit(new RealData("x"));

		Futures.addCallback(task, new FutureCallback<String>() {
			public void onSuccess(String o) {
				System.out.println("异步处理成功,result=" + o);
			}

			public void onFailure(Throwable throwable) {
				System.out.println("异步处理失败,e=" + throwable);
			}
		}, MoreExecutors.newDirectExecutorService());

		System.out.println("main task done.....");
		Thread.sleep(3000);
	}
}
package geym.conc.ch5.simplefuture;

public class FutureData implements Data {
    protected RealData realdata = null;
    protected boolean isReady = false;
    public synchronized void setRealData(RealData realdata) {
        if (isReady) {
            return;
        }
        this.realdata = realdata;
        isReady = true;
        notifyAll();
    }
    public synchronized String getResult() {
        while (!isReady) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
        return realdata.result;
    }
}
package geym.conc.ch5.future;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;

public class FutureMain {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        //构造FutureTask
        FutureTask<String> future = new FutureTask<String>(new RealData("a"));
        ExecutorService executor = Executors.newFixedThreadPool(1);
        //执行FutureTask，相当于上例中的 client.request("a") 发送请求
        //在这里开启线程进行RealData的call()执行
        executor.submit(future);

        System.out.println("请求完毕");
        try {
        //这里依然可以做额外的数据操作，这里使用sleep代替其他业务逻辑的处理
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
        //相当于上例中得data.getContent()，取得call()方法的返回值
        //如果此时call()方法没有执行完成，则依然会等待
        System.out.println("数据 = " + future.get());
    }
}
package org.jmatrices.dbl.client;

/**
 * GaussSyntax  todo
 * <p>Author: purangp</p>
 * Date: 30.04.2004
 * Time: 14:52:28
 */
public class GaussSyntax {
}

package geym.conc.ch2.suspend;

public class GoodSuspend {
    public static Object u = new Object();

    public static class ChangeObjectThread extends Thread {
        volatile boolean suspendme = false;

        public void suspendMe() {
            suspendme = true;
        }

        public void resumeMe(){
            suspendme=false;
            synchronized (this){
                notify();
            }
        }
        @Override
        public void run() {
            while (true) {

                synchronized (this) {
                    while (suspendme)
                        try {
                            wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                }

                synchronized (u) {
                    System.out.println("in ChangeObjectThread");
                }
                Thread.yield();
            }
        }
    }

    public static class ReadObjectThread extends Thread {
        @Override
        public void run() {
            while (true) {
                synchronized (u) {
                    System.out.println("in ReadObjectThread");
                }
                Thread.yield();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ChangeObjectThread t1 = new ChangeObjectThread();
        ReadObjectThread t2 = new ReadObjectThread();
        t1.start();
        t2.start();
        Thread.sleep(1000);
        t1.suspendMe();
        System.out.println("suspend t1 2 sec");
        Thread.sleep(2000);
        System.out.println("resume t1");
        t1.resumeMe();
    }
}

package geym.conc.ch2.notsafe;

import java.util.HashMap;
import java.util.Map;

/**
 * use JDK 7
 * JDK 8不会死循环，只会数据不一致
 * @author Geym
 *
 */
public class HashMapMultiThread {

    static Map<String,String> map = new HashMap<String,String>();

    public static class AddThread implements Runnable {
        int start=0;
        public AddThread(int start){
            this.start=start;
        }
        @Override
        public void run() {
            for (int i = start; i < 100000; i+=2) {
                map.put(Integer.toString(i), Integer.toBinaryString(i));
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(new HashMapMultiThread.AddThread(0));
        Thread t2=new Thread(new HashMapMultiThread.AddThread(1));
        t1.start();
        t2.start();
        t1.join();t2.join();
        System.out.println(map.size());
    }
}
package org.jmatrices.dbl;

/**
 * HeavyMatrixImpl
 * <p>
 * todo perhaps it is better to implement it through delegation rather than extending LightMatrixImpl
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 10.03.2004
 * Time: 16:06:08
 */
class HeavyMatrixImpl extends LightMatrixImpl implements Matrix {

    private double[][] columnView;

    protected HeavyMatrixImpl() {

    }

    public HeavyMatrixImpl(int rows, int cols) {
        super(rows, cols);
        columnView = new double[cols][rows];
    }

    /**
     * @param i
     * @param j
     * @param value
     */
    public void set(int i, int j, double value) {
        super.set(i, j, value);
        columnView[j - 1][i - 1] = value;
    }

    public Matrix getRow(int i) {
        return getRowMatrix(cols, rowView[i - 1]);
    }

    //todo there is just one line different between this method and the method it overerides
    protected Matrix getRowMatrix(int cols, double[] elems) {
        if (elems.length != cols) throw new IllegalArgumentException("Length of elems and cols don't conform");
        Matrix hm = new HeavyMatrixImpl(1, cols);     //the only difference
        for (int elem = 0; elem < elems.length; elem++) {
            hm.set(1, elem + 1, elems[elem]);  //add 1 to elem as set expects index starting from 1,1
        }
        return hm;
    }

    public Matrix getColumn(int j) {
        return getColumnMatrix(rows, columnView[j - 1]);
    }

    //todo there is just one line different between this method and the method it overerides
    protected Matrix getColumnMatrix(int rows, double[] elems) {
        if (elems.length != rows) throw new IllegalArgumentException("Length of elems and cols don't conform");
        Matrix hm = new HeavyMatrixImpl(rows, 1); //the only difference
        for (int elem = 0; elem < elems.length; elem++) {
            hm.set(elem + 1, 1, elems[elem]);//add 1 to elem as set expects index starting from 1,1
        }
        return hm;
    }

    /**
     * Get a submatrix.
     *
     * @param rowI Initial row index
     * @param colI Initial column index
     * @param rowF Final row index
     * @param colF Final column index
     * @return A(rowI:rowF,colI:colF)
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */
    public Matrix getSubMatrix(int rowI, int colI, int rowF, int colF) {
        return getSubMatrix(new HeavyMatrixImpl(rowF - rowI + 1, colF - colI + 1), rowI, colI, rowF, colF);
    }

    /**
     * Get a submatrix.
     *
     * @param r Array of row indices.
     * @param c Array of column indices.
     * @return A(r(:),c(:))
     * @throws ArrayIndexOutOfBoundsException
     */

    public Matrix getSubMatrix(int[] r, int[] c) {
        return getSubMatrix(new HeavyMatrixImpl(r.length, c.length), r, c);
    }

    /**
     * Get a submatrix.
     *
     * @param rowI Initial row index
     * @param rowF Final row index
     * @param c    Array of column indices.
     * @return A(i0:i1,c(:))
     * @throws IllegalArgumentException
     * @throws ArrayIndexOutOfBoundsException
     */

    public Matrix getSubMatrix(int rowI, int rowF, int[] c) {
        return getSubMatrix(new HeavyMatrixImpl(rowF - rowI + 1, c.length), rowI, rowF, c);
    }

    /**
     * Get a submatrix.
     *
     * @param r    Array of row indices.
     * @param colI Initial column index
     * @param colF Final column index
     * @return A(r(:),j0:j1)
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    public Matrix getSubMatrix(int[] r, int colI, int colF) {
        return getSubMatrix(new HeavyMatrixImpl(r.length, colF - colI + 1), r, colI, colF);
    }

}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package geym.conc.ch5.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.LockSupport;

public class HeavySocketClient {
	private static ExecutorService  tp=Executors.newCachedThreadPool();
	private static final int sleep_time=1000*1000*1000;
	public static class EchoClient implements Runnable{
		public void run(){
	        Socket client = null;
	        PrintWriter writer = null;
	        BufferedReader reader = null;
	        try {
	            client = new Socket();
	            client.connect(new InetSocketAddress("localhost", 8000));
	            writer = new PrintWriter(client.getOutputStream(), true);
	            writer.print("H");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("e");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("l");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("l");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("o");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("!");
	            LockSupport.parkNanos(sleep_time);
	            writer.println();
	            writer.flush();

	            reader = new BufferedReader(new InputStreamReader(client.getInputStream()));
	            System.out.println("from server: " + reader.readLine());
	        } catch (UnknownHostException e) {
	            e.printStackTrace();
	        } catch (IOException e) {
	            e.printStackTrace();
	        } finally {
	            try {
					if (writer != null)
					    writer.close();
					if (reader != null)
					    reader.close();
					if (client != null)
					    client.close();
				} catch (IOException e) {
				}
	        }
		}
	}
    public static void main(String[] args) throws IOException {
    	EchoClient ec=new EchoClient();
    	for(int i=0;i<10;i++)
    		tp.execute(ec);
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.collections;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Arrays;

/**
 * <p>Histogram for tracking the frequency of observations of values below interval upper bounds.</p>
 *
 * <p>This class is useful for recording timings across a large number of observations
 * when high performance is required.<p>
 *
 * <p>The interval bounds are used to define the ranges of the histogram buckets. If provided bounds
 * are [10,20,30,40,50] then there will be five buckets, accessible by index 0-4. Any value
 * 0-10 will fall into the first interval bar, values 11-20 will fall into the
 * second bar, and so on.</p>
 */
public final class Histogram
{
    // tracks the upper intervals of each of the buckets/bars
    private final long[] upperBounds;
    // tracks the count of the corresponding bucket
    private final long[] counts;
    // minimum value so far observed
    private long minValue = Long.MAX_VALUE;
    // maximum value so far observed
    private long maxValue = 0L;

    /**
     * Create a new Histogram with a provided list of interval bounds.
     *
     * @param upperBounds of the intervals. Bounds must be provided in order least to greatest, and
     * lowest bound must be greater than or equal to 1.
     * @throws IllegalArgumentException if any of the upper bounds are less than or equal to zero
     * @throws IllegalArgumentException if the bounds are not in order, least to greatest
     */
    public Histogram(final long[] upperBounds)
    {
        validateBounds(upperBounds);

        this.upperBounds = Arrays.copyOf(upperBounds, upperBounds.length);
        this.counts = new long[upperBounds.length];
    }

    /**
     * Validates the input bounds; used by constructor only.
     */
    private void validateBounds(final long[] upperBounds)
    {
        long lastBound = -1L;
        if (upperBounds.length <= 0)
        {
            throw new IllegalArgumentException("Must provide at least one interval");
        }
        for (final long bound : upperBounds)
        {
            if (bound <= 0L)
            {
                throw new IllegalArgumentException("Bounds must be positive values");
            }

            if (bound <= lastBound)
            {
                throw new IllegalArgumentException("bound " + bound + " is not greater than " + lastBound);
            }

            lastBound = bound;
        }
    }

    /**
     * Size of the list of interval bars (ie: count of interval bars).
     *
     * @return size of the interval bar list.
     */
    public int getSize()
    {
        return upperBounds.length;
    }

    /**
     * Get the upper bound of an interval for an index.
     *
     * @param index of the upper bound.
     * @return the interval upper bound for the index.
     */
    public long getUpperBoundAt(final int index)
    {
        return upperBounds[index];
    }

    /**
     * Get the count of observations at a given index.
     *
     * @param index of the observations counter.
     * @return the count of observations at a given index.
     */
    public long getCountAt(final int index)
    {
        return counts[index];
    }

    /**
     * Add an observation to the histogram and increment the counter for the interval it matches.
     *
     * @param value for the observation to be added.
     * @return return true if in the range of intervals and successfully added observation; otherwise false.
     */
    public boolean addObservation(final long value)
    {
        int low = 0;
        int high = upperBounds.length - 1;

        // do a classic binary search to find the high value
        while (low < high)
        {
            int mid = low + ((high - low) >> 1);
            if (upperBounds[mid] < value)
            {
                low = mid + 1;
            }
            else
            {
                high = mid;
            }
        }

        // if the binary search found an eligible bucket, increment
        if (value <= upperBounds[high])
        {
            counts[high]++;
            trackRange(value);

            return true;
        }

        // otherwise value was not found
        return false;
    }

    /**
     * Track minimum and maximum observations
     *
     * @see getMin
     * @see getMax
     */
    private void trackRange(final long value)
    {
        if (value < minValue)
        {
            minValue = value;
        }

        if (value > maxValue)
        {
            maxValue = value;
        }
    }

    /**
     * <p>Add observations from another Histogram into this one.</p>
     *
     * <p>Histograms must have the same intervals.</p>
     *
     * @param histogram from which to add the observation counts.
     * @throws IllegalArgumentException if interval count or values do not match exactly
     */
    public void addObservations(final Histogram histogram)
    {
        // validate the intervals
        if (upperBounds.length != histogram.upperBounds.length)
        {
            throw new IllegalArgumentException("Histograms must have matching intervals");
        }

        for (int i = 0, size = upperBounds.length; i < size; i++)
        {
            if (upperBounds[i] != histogram.upperBounds[i])
            {
                throw new IllegalArgumentException("Histograms must have matching intervals");
            }
        }

        // increment all of the internal counts
        for (int i = 0, size = counts.length; i < size; i++)
        {
            counts[i] += histogram.counts[i];
        }

        // refresh the minimum and maximum observation ranges
        trackRange(histogram.minValue);
        trackRange(histogram.maxValue);
    }

    /**
     * Clear the list of interval counters
     */
    public void clear()
    {
        maxValue = 0L;
        minValue = Long.MAX_VALUE;

        for (int i = 0, size = counts.length; i < size; i++)
        {
            counts[i] = 0L;
        }
    }

    /**
     * Count total number of recorded observations.
     *
     * @return the total number of recorded observations.
     */
    public long getCount()
    {
        long count = 0L;

        for (int i = 0, size = counts.length; i < size; i++)
        {
            count += counts[i];
        }

        return count;
    }

    /**
     * Get the minimum observed value.
     *
     * @return the minimum value observed.
     */
    public long getMin()
    {
        return minValue;
    }

    /**
     * Get the maximum observed value.
     *
     * @return the maximum of the observed values;
     */
    public long getMax()
    {
        return maxValue;
    }

    /**
     * <p>Calculate the mean of all recorded observations.</p>
     *
     * <p>The mean is calculated by summing the mid points of each interval multiplied by the count
     * for that interval, then dividing by the total count of observations.  The max and min are
     * considered for adjusting the top and bottom bin when calculating the mid point, this
     * minimises skew if the observed values are very far away from the possible histogram values.</p>
     *
     * @return the mean of all recorded observations.
     */
    public BigDecimal getMean()
    {
        // early exit to avoid divide by zero later
        if (0L == getCount())
        {
            return BigDecimal.ZERO;
        }

        // precalculate the initial lower bound; needed in the loop
        long lowerBound = counts[0] > 0L ? minValue : 0L;
        // use BigDecimal to avoid precision errors
        BigDecimal total = BigDecimal.ZERO;

        // midpoint is calculated as the average between the lower and upper bound
        // (after taking into account the min & max values seen)
        // then, simply multiply midpoint by the count of values at the interval (intervalTotal)
        // and add to running total (total)
        for (int i = 0, size = upperBounds.length; i < size; i++)
        {
            if (0L != counts[i])
            {
                long upperBound = Math.min(upperBounds[i], maxValue);
                long midPoint = lowerBound + ((upperBound - lowerBound) / 2L);

                BigDecimal intervalTotal = new BigDecimal(midPoint).multiply(new BigDecimal(counts[i]));
                total = total.add(intervalTotal);
            }

            // and recalculate the lower bound for the next time around the loop
            lowerBound = Math.max(upperBounds[i] + 1L, minValue);
        }

        return total.divide(new BigDecimal(getCount()), 2, RoundingMode.HALF_UP);
    }

    /**
     * Calculate the upper bound within which 99% of observations fall.
     *
     * @return the upper bound for 99% of observations.
     */
    public long getTwoNinesUpperBound()
    {
        return getUpperBoundForFactor(0.99d);
    }

    /**
     * Calculate the upper bound within which 99.99% of observations fall.
     *
     * @return the upper bound for 99.99% of observations.
     */
    public long getFourNinesUpperBound()
    {
        return getUpperBoundForFactor(0.9999d);
    }

    /**
     * <p>Get the interval upper bound for a given factor of the observation population.</p>
     *
     * <p>Note this does not get the actual percentile measurement, it only gets the bucket</p>
     *
     * @param factor representing the size of the population.
     * @return the interval upper bound.
     * @throws IllegalArgumentException if factor &lt; 0.0 or factor &gt; 1.0
     */
    public long getUpperBoundForFactor(final double factor)
    {
        if (0.0d >= factor || factor >= 1.0d)
        {
            throw new IllegalArgumentException("factor must be >= 0.0 and <= 1.0");
        }

        final long totalCount = getCount();
        final long tailTotal = totalCount - Math.round(totalCount * factor);
        long tailCount = 0L;

        // reverse search the intervals ('tailCount' from end)
        for (int i = counts.length - 1; i >= 0; i--)
        {
            if (0L != counts[i])
            {
                tailCount += counts[i];
                if (tailCount >= tailTotal)
                {
                    return upperBounds[i];
                }
            }
        }

        return 0L;
    }

    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder();

        sb.append("Histogram{");

        sb.append("min=").append(getMin()).append(", ");
        sb.append("max=").append(getMax()).append(", ");
        sb.append("mean=").append(getMean()).append(", ");
        sb.append("99%=").append(getTwoNinesUpperBound()).append(", ");
        sb.append("99.99%=").append(getFourNinesUpperBound()).append(", ");

        sb.append('[');
        for (int i = 0, size = counts.length; i < size; i++)
        {
            sb.append(upperBounds[i]).append('=').append(counts[i]).append(", ");
        }

        if (counts.length > 0)
        {
            sb.setLength(sb.length() - 2);
        }
        sb.append(']');

        sb.append('}');

        return sb.toString();
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Convenience implementation of an exception handler that using standard JDK logging to log
 * the exception as {@link Level}.INFO
 */
public final class IgnoreExceptionHandler implements ExceptionHandler<Object>
{
    private static final Logger LOGGER = Logger.getLogger(IgnoreExceptionHandler.class.getName());
    private final Logger logger;

    public IgnoreExceptionHandler()
    {
        this.logger = LOGGER;
    }

    public IgnoreExceptionHandler(final Logger logger)
    {
        this.logger = logger;
    }

    @Override
    public void handleEventException(final Throwable ex, final long sequence, final Object event)
    {
        logger.log(Level.INFO, "Exception processing: " + sequence + " " + event, ex);
    }

    @Override
    public void handleOnStartException(final Throwable ex)
    {
        logger.log(Level.INFO, "Exception during onStart()", ex);
    }

    @Override
    public void handleOnShutdownException(final Throwable ex)
    {
        logger.log(Level.INFO, "Exception during onShutdown()", ex);
    }
}
package geym.conc.ch5.sort;

import java.util.Arrays;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 插入排序
 *
 * @author Administrator
 *
 */
public class InsertionSort {
//	static int[] arr = { 5, 52, 6, 3, 4, 10, 8, 100, 35, 78, 64, 31, 77, 90,
//			45, 53, 89, 78, 1 };
	static int[] arr = { 5, 52, 6, 3, 4};
	static ExecutorService pool = Executors.newFixedThreadPool(10);

	/**
	 *   j  i
	 *      key
	 *
	 */
	public static void insertSort(int[] arr) {
		int length = arr.length;
		int j, i, key;
		for (i = 1; i < length; i++) {
			//key为要准备插入的元素
			key = arr[i];
			j = i - 1;
			while (j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j--;
			}
			//找到合适的位置 插入key
			arr[j + 1] = key;
			System.out.println(Arrays.toString(arr));
		}
	}

	public static void shellSort(int[] arr) {
		// 计算出最大的h值
		int h = 1;
		while (h <= arr.length / 3) {
			h = h * 3 + 1;
		}
		while (h > 0) {
			System.out.println("h=" + h);
			for (int i = h; i < arr.length; i++) {
				if (arr[i] < arr[i - h]) {
					int tmp = arr[i];
					int j = i - h;
					while (j >= 0 && arr[j] > tmp) {
						arr[j + h] = arr[j];
						j -= h;
					}
					arr[j + h] = tmp;
				}
				System.out.println(Arrays.toString(arr));
			}
			System.out.println(Arrays.toString(arr));
			// 计算出下一个h值
			h = (h - 1) / 3;
		}
	}

	public static class ShellSortTask implements Runnable {
		int i = 0;
		int h = 0;
		CountDownLatch l;

		public ShellSortTask(int i, int h, CountDownLatch latch) {
			this.i = i;
			this.h = h;
			this.l = latch;
		}

		@Override
		public void run() {
			if (arr[i] < arr[i - h]) {
				int tmp = arr[i];
				int j = i - h;
				while (j >= 0 && arr[j] > tmp) {
					arr[j + h] = arr[j];
					j -= h;
				}
				arr[j + h] = tmp;
			}
			l.countDown();
		}
	}

	public static void pShellSort(int[] arr) throws InterruptedException {
		// 计算出最大的h值
		int h = 1;
		CountDownLatch latch = null;
		while (h <= arr.length / 3) {
			h = h * 3 + 1;
		}
		while (h > 0) {
			System.out.println("h=" + h);
			if (h >= 4)
				latch = new CountDownLatch(arr.length - h);
			for (int i = h; i < arr.length; i++) {
				// 控制线程数量
				if (h >= 4) {
					pool.execute(new ShellSortTask(i, h, latch));
				} else {
					if (arr[i] < arr[i - h]) {
						int tmp = arr[i];
						int j = i - h;
						while (j >= 0 && arr[j] > tmp) {
							arr[j + h] = arr[j];
							j -= h;
						}
						arr[j + h] = tmp;
					}
					// System.out.println(Arrays.toString(arr));
				}
			}
			// 等待线程排序完成，进入下一次排序
			latch.await();
			// 计算出下一个h值
			h = (h - 1) / 3;
		}
	}

	public static void main(String[] args) throws InterruptedException {
//		pShellSort(arr);
		insertSort(arr);
		pool.shutdownNow();
		System.out.println(Arrays.toString(arr));
	}
}
/*
 * Copyright 2012 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * <p>Exception thrown when the it is not possible to insert a value into
 * the ring buffer without it wrapping the consuming sequenes.  Used
 * specifically when claiming with the {@link RingBuffer#tryNext()} call.
 *
 * <p>For efficiency this exception will not have a stack trace.
 * @author mikeb01
 *
 */
@SuppressWarnings("serial")
public final class InsufficientCapacityException extends Exception
{
    public static final InsufficientCapacityException INSTANCE = new InsufficientCapacityException();

    private InsufficientCapacityException()
    {
        // Singleton
    }

    @Override
    public synchronized Throwable fillInStackTrace()
    {
        return this;
    }
}
package geym.conc.ch2.inter;

/**
 * sleep中断后 抛出异常被重置中断状态
 * 如果希望sleep后可以判断中断状态，则必须在sleep的异常处理中，在设置中断
 * @author Administrator
 *
 */
public class InterruputSleepThread {
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(){
            @Override
            public void run(){
                while(true){
                    if(Thread.currentThread().isInterrupted()){
                        System.out.println("Interruted!");
                        break;
                    }
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        System.out.println("Interruted When Sleep");
                        //设置中断状态
                        Thread.currentThread().interrupt();
                    }
                    Thread.yield();
                }
            }
        };
        t1.start();
        Thread.sleep(2000);
        t1.interrupt();
    }
}
package geym.conc.ch2.inter;

/**
 * 中断状态可以检测，并在应用上作出相应
 * 如果应用不相应中断，则T1永远不会退出
 * @author Administrator
 *
 */
public class InterruputThread {
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(){
            @Override
            public void run(){
                while(true){
                    if(Thread.currentThread().isInterrupted()){
                        System.out.println("Interruted!");
                        break;
                    }
                    Thread.yield();
                }
            }
        };
        t1.start();
        Thread.sleep(2000);
        t1.interrupt();
    }
}
package geym.conc.ch2.inter;

/**
 * 中断状态可以检测，并在应用上作出相应
 * 如果应用不相应中断，则T1永远不会退出
 * @author Administrator
 *
 */
public class InterruputThread2 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(){
            @Override
            public void run(){
                while(true){
                    Thread.yield();
                }
            }
        };
        t1.start();
        Thread.sleep(2000);
        t1.interrupt();
    }
}
package geym.conc.ch3.synctrl;

import java.util.concurrent.locks.ReentrantLock;

public class IntLock implements Runnable {
    public static ReentrantLock lock1 = new ReentrantLock();
    public static ReentrantLock lock2 = new ReentrantLock();
    int lock;
    /**
     * 控制加锁顺序，方便构造死锁
     * @param lock
     */
    public IntLock(int lock) {
        this.lock = lock;
    }

    @Override
    public void run() {
        try {
            if (lock == 1) {
                lock1.lockInterruptibly();
                try{
                    Thread.sleep(500);
                }catch(InterruptedException e){}
                lock2.lockInterruptibly();
            } else {
                lock2.lockInterruptibly();
                try{
                    Thread.sleep(500);
                }catch(InterruptedException e){}
                lock1.lockInterruptibly();
            }

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            if (lock1.isHeldByCurrentThread())
                lock1.unlock();
            if (lock2.isHeldByCurrentThread())
                lock2.unlock();
            System.out.println(Thread.currentThread().getId()+":线程退出");
        }
    }

    public static void main(String[] args) throws InterruptedException {
        IntLock r1 = new IntLock(1);
        IntLock r2 = new IntLock(2);
        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);
        t1.start();t2.start();
        Thread.sleep(1000);
        //中断其中一个线程
        t2.interrupt();
    }
}

package geym.conc.ch2.notsafe;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

/**
 * use JDK 7
 * JDK 8不会死循环，只会数据不一致
 * @author Geym
 *
 */
public class JDK8HashMapMultiThread {

    static Map<String,String> map = new HashMap<String,String>();
//    static Map map = new ConcurrentHashMap(10);

    public static class AddThread implements Runnable {
        int start=0;
        public AddThread(int start){
            this.start=start;
        }
        @Override
        public void run() {
            for (int i = start; i < 10000; i++) {
                map.put(Integer.toString(i), Integer.toString(i));
            }
        }
    }

    public static void test() throws Exception{
        Thread t1=new Thread(new JDK8HashMapMultiThread.AddThread(0));
        Thread t2=new Thread(new JDK8HashMapMultiThread.AddThread(1));
        t1.start();
        t2.start();
        t1.join();t2.join();
        System.out.println("map size="+map.size());
        System.out.println("table count="+getTableSize());
    }
    public static void main(String[] args) throws Exception {

        for(int i=0;i<100;i++){
            test();
            map = new HashMap<String,String>();
        }
    }

    public static int getTableSize() throws Exception{
        Field fTable=map.getClass().getDeclaredField("table");
        fTable.setAccessible(true);
        Object[] table=(Object[])fTable.get(map);
        int count=0;
        for(int i=0;i<table.length;i++){
           if(table[i]!=null)count++;
        }
        fTable.setAccessible(false);
        return count;
    }

}
package geym.conc.ch3.jmh;

import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
public class JMHSample_01_HelloWorld {
    @Benchmark
    public void wellHelloThere() {
        // this method was intentionally left blank.
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(JMHSample_01_HelloWorld.class.getSimpleName())
                .forks(1).build();
        new Runner(opt).run();
    }
}
package geym.conc.ch3.jmh;

import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
public class JMHSample_01_HelloWorld {
    @Benchmark
    public void wellHelloThere() {
        // this method was intentionally left blank.
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(JMHSample_01_HelloWorld.class.getSimpleName())
                .forks(1).build();
        new Runner(opt).run();
    }
}
package geym.conc.ch3.jmh;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

import java.util.concurrent.TimeUnit;

public class JMHSample_02_BenchmarkModes {

    @Benchmark
    @BenchmarkMode(Mode.Throughput)
    @OutputTimeUnit(TimeUnit.SECONDS)
    public void measureThroughput() throws InterruptedException {
        TimeUnit.MILLISECONDS.sleep(100);
    }

    /*
     * Mode.AverageTime measures the average execution time, and it does it in the
     * way similar to Mode.Throughput.
     *
     * Some might say it is the reciprocal throughput, and it really is. There are
     * workloads where measuring times is more convenient though.
     */

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public void measureAvgTime() throws InterruptedException {
        TimeUnit.MILLISECONDS.sleep(100);
    }

    /*
     * Mode.SampleTime samples the execution time. With this mode, we are still
     * running the method in a time-bound iteration, but instead of measuring the
     * total time, we measure the time spent in *some* of the benchmark method
     * calls.
     *
     * This allows us to infer the distributions, percentiles, etc.
     *
     * JMH also tries to auto-adjust sampling frequency: if the method is long
     * enough, you will end up capturing all the samples.
     */
    @Benchmark
    @BenchmarkMode(Mode.SampleTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public void measureSamples() throws InterruptedException {
        TimeUnit.MILLISECONDS.sleep(100);
    }

    /*
     * Mode.SingleShotTime measures the single method invocation time. As the
     * Javadoc suggests, we do only the single benchmark method invocation. The
     * iteration time is meaningless in this mode: as soon as benchmark method
     * stops, the iteration is over.
     *
     * This mode is useful to do cold startup tests, when you specifically do not
     * want to call the benchmark method continuously.
     */
    @Benchmark
    @BenchmarkMode(Mode.SingleShotTime)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public void measureSingleShot() throws InterruptedException {
        TimeUnit.MILLISECONDS.sleep(100);
    }

    /*
     * We can also ask for multiple benchmark modes at once. All the tests above can
     * be replaced with just a single test like this:
     */
    @Benchmark
    @BenchmarkMode({ Mode.Throughput, Mode.AverageTime, Mode.SampleTime, Mode.SingleShotTime })
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public void measureMultiple() throws InterruptedException {
        TimeUnit.MILLISECONDS.sleep(100);
    }

    /*
     * Or even...
     */

    @Benchmark
    @BenchmarkMode(Mode.All)
    @OutputTimeUnit(TimeUnit.MICROSECONDS)
    public void measureAll() throws InterruptedException {
        TimeUnit.MILLISECONDS.sleep(100);
    }

    /*
     * ============================== HOW TO RUN THIS TEST:
     * ====================================
     *
     * You are expected to see the different run modes for the same benchmark. Note
     * the units are different, scores are consistent with each other.
     *
     * You can run this test:
     *
     * a) Via the command line: $ mvn clean install $ java -jar
     * target/benchmarks.jar JMHSample_02 -f 1 (we requested a single fork; there
     * are also other options, see -h)
     *
     * b) Via the Java API: (see the JMH homepage for possible caveats when running
     * from IDE: http://openjdk.java.net/projects/code-tools/jmh/)
     */

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder().include(JMHSample_02_BenchmarkModes.class.getSimpleName()).forks(1).build();

        new Runner(opt).run();
    }

}package geym.conc.ch3.jmh;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

public class JMHSample_03_States {

    /*
     * Most of the time, you need to maintain some state while the benchmark is
     * running. Since JMH is heavily used to build concurrent benchmarks, we
     * opted for an explicit notion of state-bearing objects.
     *
     * Below are two state objects. Their class names are not essential, it
     * matters they are marked with @State. These objects will be instantiated
     * on demand, and reused during the entire benchmark trial.
     *
     * The important property is that state is always instantiated by one of
     * those benchmark threads which will then have the access to that state.
     * That means you can initialize the fields as if you do that in worker
     * threads (ThreadLocals are yours, etc).
     */

    @State(Scope.Benchmark)
    public static class BenchmarkState {
        volatile double x = Math.PI;
    }

    @State(Scope.Thread)
    public static class ThreadState {
        volatile double x = Math.PI;
    }

    /*
     * Benchmark methods can reference the states, and JMH will inject the
     * appropriate states while calling these methods. You can have no states at
     * all, or have only one state, or have multiple states referenced. This
     * makes building multi-threaded benchmark a breeze.
     *
     * For this exercise, we have two methods.
     */

    @Benchmark
    public void measureUnshared(ThreadState state) {
        // All benchmark threads will call in this method.
        //
        // However, since ThreadState is the Scope.Thread, each thread
        // will have it's own copy of the state, and this benchmark
        // will measure unshared case.
        state.x++;
    }

    @Benchmark
    public void measureShared(BenchmarkState state) {
        // All benchmark threads will call in this method.
        //
        // Since BenchmarkState is the Scope.Benchmark, all threads
        // will share the state instance, and we will end up measuring
        // shared case.
        state.x++;
    }

    /*
     * ============================== HOW TO RUN THIS TEST: ====================================
     *
     * You are expected to see the drastic difference in shared and unshared cases,
     * because you either contend for single memory location, or not. This effect
     * is more articulated on large machines.
     *
     * You can run this test:
     *
     * a) Via the command line:
     *    $ mvn clean install
     *    $ java -jar target/benchmarks.jar JMHSample_03 -t 4 -f 1
     *    (we requested 4 threads, single fork; there are also other options, see -h)
     *
     * b) Via the Java API:
     *    (see the JMH homepage for possible caveats when running from IDE:
     *      http://openjdk.java.net/projects/code-tools/jmh/)
     */

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(JMHSample_03_States.class.getSimpleName())
                .threads(4)
                .forks(1)
                .build();

        new Runner(opt).run();
    }

}package geym.conc.ch2.join;

public class JoinMain {
    public volatile static int i=0;
    public static class AddThread extends Thread{
        @Override
        public void run() {
            for(i=0;i<10000000;i++);
        }
    }
    public static void main(String[] args) throws InterruptedException {
        AddThread at=new AddThread();
        at.start();
        at.join();
        System.out.println(i);
    }
}
package geym.conc.ch5.singleton;

public class LazySingleton {
	private LazySingleton() {
		System.out.println("LazySingleton is create");
	}
	private static LazySingleton instance = null;
	public static synchronized LazySingleton getInstance() {
		if (instance == null)
			instance = new LazySingleton();
		return instance;
	}
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Implement this interface in your {@link EventHandler} to be notified when a thread for the
 * {@link BatchEventProcessor} starts and shuts down.
 */
public interface LifecycleAware
{
    /**
     * Called once on thread start before first event is available.
     */
    void onStart();

    /**
     * <p>Called once just before the thread is shutdown.</p>
     *
     * Sequence event processing will already have stopped before this method is called. No events will
     * be processed after this message.
     */
    void onShutdown();
}
package org.jmatrices.dbl;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.Locale;

/**
 * LightMatrixImpl
 * <p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 16:06:06
 */
class LightMatrixImpl implements Matrix {
    protected int rows, cols;
    protected double[][] rowView;

    protected LightMatrixImpl() {
    }

    public LightMatrixImpl(int rows, int cols) {
        if (rows < 1 || cols < 1)
            throw new IllegalArgumentException("Rows and/or Columns can't be less than 1");
        else {
            this.rows = rows;
            this.cols = cols;
            rowView = new double[rows][cols];
        }
    }

    /**
     * Counts from 1
     *
     * @return
     */
    public int rows() {
        return rows;
    }

    /**
     * counts from 1
     *
     * @return
     */
    public int cols() {
        return cols;
    }

    /**
     * @param row
     * @param col
     * @param value
     */
    public void set(int row, int col, double value) {
        rowView[row - 1][col - 1] = value;
    }

    /**
     * @param row
     * @param col
     * @return
     */
    public double get(int row, int col) {
        return rowView[row - 1][col - 1];
    }


    //todo should we return arrays or matrices?  we don't have to return arrays as get returns the rowView array perhaps we should move these to transformer package!!!
    //
    public Matrix getRow(int row) {
        return getRowMatrix(cols, rowView[row-1]);
    }

    protected Matrix getRowMatrix(int cols, double[] elems) {
        if (elems.length != cols) throw new IllegalArgumentException("Length of elems and cols don't conform");
        Matrix lm = new LightMatrixImpl(1, cols);
        for (int elem = 0; elem < elems.length; elem++) {
            lm.set(1, elem + 1, elems[elem]);  //add 1 to elem as set expects index starting from 1,1
        }
        return lm;
    }

    public Matrix getColumn(int j) {
        double[] column = new double[rows];
        for (int row = 0; row < rowView.length; row++) {
            for (int col = 0; col < rowView[row].length; col++) {
                if (col == j)
                    column[j] = rowView[row][col];
            }
        }
        return getColumnMatrix(rows, column);
    }

    protected Matrix getColumnMatrix(int rows, double[] elems) {
        if (elems.length != rows) throw new IllegalArgumentException("Length of elems and cols don't conform");
        Matrix lm = new LightMatrixImpl(rows, 1);
        for (int elem = 0; elem < elems.length; elem++) {
            lm.set(elem + 1, 1, elems[elem]);//add 1 to elem as set expects index starting from 1,1
        }
        return lm;
    }

    /**
     * @return
     */
    public double[][] get() {
        double[][] store = new double[rows][cols];
        for (int i = 0; i < rowView.length; i++) {
            for (int j = 0; j < rowView[i].length; j++) {
                store[i][j] = rowView[i][j];
            }
        }
        return store;
    }


    /**
     * Get a submatrix.
     *
     * @param rowI Initial row index
     * @param colI Initial column index
     * @param rowF Final row index
     * @param colF Final column index
     * @return A(rowI:rowF,colI:colF)
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */
    public Matrix getSubMatrix(int rowI, int colI, int rowF, int colF) {
        return getSubMatrix(new LightMatrixImpl(rowF - rowI + 1, colF - colI + 1), rowI, colI, rowF, colF);
    }

    //The reason we implement this way so as to allow each matrix implementation to use themeselves as the matrices
    //and yet we can share the code between
    protected Matrix getSubMatrix(Matrix m, int rowI, int colI, int rowF, int colF) {
        int rows_m = m.rows(), cols_m = m.cols();
        if (rows_m > rows() || cols_m > cols)
            throw new IllegalArgumentException("The submatrix being extracted violates dimension constraints");
        else {
            //for (int row = rowI, rowm = 1; row <= rowF; row++, rowm++) {
            for (int row = rowI; row <= rowF; row++) {
                //for (int col = colI, colm = 1; col <= colF; col++, colm++) {
                for (int col = colI; col <= colF; col++) {
                    //m.set(rowm,colm,get(row,col));
                    m.set(row - rowI + 1, col - colI + 1, get(row, col));
                }
            }
        }
        return m;
    }

    /**
     * Get a submatrix.
     *
     * @param r Array of row indices.
     * @param c Array of column indices.
     * @return A(r(:),c(:))
     * @throws ArrayIndexOutOfBoundsException
     */

    public Matrix getSubMatrix(int[] r, int[] c) {
        return getSubMatrix(new LightMatrixImpl(r.length, c.length), r, c);
    }

    protected Matrix getSubMatrix(Matrix m, int[] r, int[] c) {
        for (int row = 1; row <= r.length; row++) {
            for (int col = 1; col <= c.length; col++) {
                m.set(row, col, get(r[row - 1], c[col - 1]));
            }
        }
        return m;
    }


    /**
     * Get a submatrix.
     *
     * @param rowI Initial row index
     * @param rowF Final row index
     * @param c    Array of column indices.
     * @return A(i0:i1,c(:))
     * @throws IllegalArgumentException
     * @throws ArrayIndexOutOfBoundsException
     */

    public Matrix getSubMatrix(int rowI, int rowF, int[] c) {
        return getSubMatrix(new LightMatrixImpl(rowF - rowI + 1, c.length), rowI, rowF, c);
    }

    protected Matrix getSubMatrix(Matrix m, int rowI, int rowF, int[] c) {
        if (m.rows() > rows())
            throw new IllegalArgumentException("The submatrix being extracted violates dimension constraints");
        else {
            for (int row = rowI; row <= rowF; row++) {
                for (int col = 1; col <= c.length; col++) {
                    m.set(row - rowI + 1, col, get(row, c[col - 1]));
                }
            }
        }
        return m;
    }

    /**
     * Get a submatrix.
     *
     * @param r    Array of row indices.
     * @param colI Initial column index
     * @param colF Final column index
     * @return A(r(:),j0:j1)
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    public Matrix getSubMatrix(int[] r, int colI, int colF) {
        return getSubMatrix(new LightMatrixImpl(r.length, colF - colI + 1), r, colI, colF);
    }

    public Matrix getSubMatrix(Matrix m, int[] r, int colI, int colF) {
        if (m.cols() > cols())
            throw new IllegalArgumentException("The submatrix being extracted violates dimension constraints");
        else {
            for (int row = 1; row <= r.length; row++) {
                for (int col = colI; col <= colF; col++) {
                    m.set(row, col - colI + 1, get(r[row - 1], col));
                }
            }
        }
        return m;
    }

     public String toString() {
        //todo make this configurable!!
        DecimalFormat format = new DecimalFormat();
        format.setDecimalFormatSymbols(new DecimalFormatSymbols(Locale.US));
        format.setMinimumIntegerDigits(1);
        format.setMaximumFractionDigits(8);
        format.setMinimumFractionDigits(2);
        format.setGroupingUsed(false);
        StringBuffer matrix = new StringBuffer();
        for (int row = 1; row <= rows; row++) {
            for (int col = 1; col <= cols; col++) {
                matrix.append(format.format(this.get(row, col)) + " ");
                //matrix.append(Math.round(this.get(row, col)) + " ");
            }
            matrix.append("\n");
        }
        return matrix.toString();
    }
}

/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */package geym.conc.ch3.jmh;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Benchmark)
public class ListTest {

	CopyOnWriteArrayList smallCopyOnWriteList = new CopyOnWriteArrayList();
	ConcurrentLinkedQueue smallConcurrentList = new ConcurrentLinkedQueue();
	CopyOnWriteArrayList bigCopyOnWriteList = new CopyOnWriteArrayList();
	ConcurrentLinkedQueue bigConcurrentList = new ConcurrentLinkedQueue();

	@Setup
	public void setup() {
		for (int i = 0; i < 10; i++) {
			smallCopyOnWriteList.add(new Object());
			smallConcurrentList.add(new Object());
		}

		for (int i = 0; i < 1000; i++) {
			bigCopyOnWriteList.add(new Object());
			bigCopyOnWriteList.add(new Object());
		}
	}

	@Benchmark
	public void copyOnWriteGet() {
		smallCopyOnWriteList.get(0);
	}

	@Benchmark
	public void copyOnWriteSize() {
		smallCopyOnWriteList.size();
	}

	@Benchmark
	public void concurrentListGet() {
		smallConcurrentList.peek();
	}

	@Benchmark
	public void concurrentListSize() {
		smallConcurrentList.size();
	}

	@Benchmark
	public void smallCopyOnWriteWrite() {
		smallCopyOnWriteList.add(new Object());
		smallCopyOnWriteList.remove(0);
	}

	@Benchmark
	public void smallConcurrentListWrite() {
		smallConcurrentList.add(new Object());
		smallConcurrentList.remove(0);
	}

	@Benchmark
	public void bigCopyOnWriteWrite() {
		bigCopyOnWriteList.add(new Object());
		bigCopyOnWriteList.remove(0);
	}

	@Benchmark
	public void bigConcurrentListWrite() {
		bigConcurrentList.offer(new Object());
		bigConcurrentList.remove(0);
	}
	/*
	 *
	 * a) Via command-line: $ mvn clean install $ java -jar target/benchmarks.jar
	 * JMHSample_01
	 *
	 * JMH generates self-contained JARs, bundling JMH together with it. The runtime
	 * options for the JMH are available with "-h": $ java -jar
	 * target/benchmarks.jar -h
	 *
	 * b) Via the Java API: (see the JMH homepage for possible caveats when running
	 * from IDE: http://openjdk.java.net/projects/code-tools/jmh/)
	 */

	public static void main(String[] args) throws RunnerException {
		Options opt = new OptionsBuilder().include(ListTest.class.getSimpleName()).forks(1).warmupIterations(5)
				.measurementIterations(5).threads(5).build();
		new Runner(opt).run();
	}
}
package geym.conc.ch3.jmh;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Benchmark)
public class ListTest {

	CopyOnWriteArrayList smallCopyOnWriteList = new CopyOnWriteArrayList();
	ConcurrentLinkedQueue smallConcurrentList = new ConcurrentLinkedQueue();
	CopyOnWriteArrayList bigCopyOnWriteList = new CopyOnWriteArrayList();
	ConcurrentLinkedQueue bigConcurrentList = new ConcurrentLinkedQueue();

	@Setup
	public void setup() {
		for (int i = 0; i < 10; i++) {
			smallCopyOnWriteList.add(new Object());
			smallConcurrentList.add(new Object());
		}

		for (int i = 0; i < 1000; i++) {
			bigCopyOnWriteList.add(new Object());
			bigCopyOnWriteList.add(new Object());
		}
	}

	@Benchmark
	public void copyOnWriteGet() {
		smallCopyOnWriteList.get(0);
	}

	@Benchmark
	public void copyOnWriteSize() {
		smallCopyOnWriteList.size();
	}

	@Benchmark
	public void concurrentListGet() {
		smallConcurrentList.peek();
	}

	@Benchmark
	public void concurrentListSize() {
		smallConcurrentList.size();
	}

	@Benchmark
	public void smallCopyOnWriteWrite() {
		smallCopyOnWriteList.add(new Object());
		smallCopyOnWriteList.remove(0);
	}

	@Benchmark
	public void smallConcurrentListWrite() {
		smallConcurrentList.add(new Object());
		smallConcurrentList.remove(0);
	}

	@Benchmark
	public void bigCopyOnWriteWrite() {
		bigCopyOnWriteList.add(new Object());
		bigCopyOnWriteList.remove(0);
	}

	@Benchmark
	public void bigConcurrentListWrite() {
		bigConcurrentList.offer(new Object());
		bigConcurrentList.remove(0);
	}

	public static void main(String[] args) throws RunnerException {
		Options opt = new OptionsBuilder().include(ListTest.class.getSimpleName()).forks(1).warmupIterations(5)
				.measurementIterations(5).threads(4).build();
		new Runner(opt).run();
	}
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Variation of the {@link BlockingWaitStrategy} that attempts to elide conditional wake-ups when
 * the lock is uncontended.  Shows performance improvements on microbenchmarks.  However this
 * wait strategy should be considered experimental as I have not full proved the correctness of
 * the lock elision code.
 */
public final class LiteBlockingWaitStrategy implements WaitStrategy
{
    private final Lock lock = new ReentrantLock();
    private final Condition processorNotifyCondition = lock.newCondition();
    private final AtomicBoolean signalNeeded = new AtomicBoolean(false);

    @Override
    public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSequence, SequenceBarrier barrier)
        throws AlertException, InterruptedException
    {
        long availableSequence;
        if ((availableSequence = cursorSequence.get()) < sequence)
        {
            lock.lock();

            try
            {
                do
                {
                    signalNeeded.getAndSet(true);

                    if ((availableSequence = cursorSequence.get()) >= sequence)
                    {
                        break;
                    }

                    barrier.checkAlert();
                    processorNotifyCondition.await();
                }
                while ((availableSequence = cursorSequence.get()) < sequence);
            }
            finally
            {
                lock.unlock();
            }
        }

        while ((availableSequence = dependentSequence.get()) < sequence)
        {
            barrier.checkAlert();
        }

        return availableSequence;
    }

    @Override
    public void signalAllWhenBlocking()
    {
        if (signalNeeded.getAndSet(false))
        {
            lock.lock();
            try
            {
                processorNotifyCondition.signalAll();
            }
            finally
            {
                lock.unlock();
            }
        }
    }
}
package geym.conc.ch4.lockcoarsenn;

public class LockCoarsen {
	public static Object lock=new Object();
	public static final int CIRCLE=10000000;

	public static void main(String[] args) {


		long begintime=System.currentTimeMillis();
		for(int i=0;i<CIRCLE;i++){
			synchronized(lock){

			}
		}
		long endtime=System.currentTimeMillis();
		System.out.println("sync in loop:"+(endtime-begintime));

		long begintime1=System.currentTimeMillis();
		synchronized(lock){
			for(int i=0;i<CIRCLE;i++){

			}
		}
		long endtime1=System.currentTimeMillis();
		System.out.println("sync out loop:"+(endtime1-begintime1));

	}

}
package geym.conc.ch4.lockeli;


/**
 * -server -XX:+DoEscapeAnalysis -XX:-EliminateLocks -Xcomp -XX:-BackgroundCompilation -XX:BiasedLockingStartupDelay=0
 *
 * -server -XX:+DoEscapeAnalysis -XX:+EliminateLocks -Xcomp -XX:-BackgroundCompilation -XX:BiasedLockingStartupDelay=0
 */
public class LockEliminate {
	private static final int CIRCLE = 2000000;
	public static void main(String args[]) throws InterruptedException {
		long start = System.currentTimeMillis();
		for (int i = 0; i < CIRCLE; i++) {
			craeteStringBuffer("JVM", "Diagnosis");
		}
		long bufferCost = System.currentTimeMillis() - start;
		System.out.println("craeteStringBuffer: " + bufferCost + " ms");
	}

	public static String craeteStringBuffer(String s1, String s2) {
		StringBuffer sb = new StringBuffer();
		sb.append(s1);
		sb.append(s2);
		return sb.toString();
	}
}/*
 * Copyright (c) 2007 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * COME FROM org.amino.ds.lockfree
 */

package geym.conc.ch4.atomic;

import java.util.AbstractList;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

/**
 * It is a thread safe and lock-free vector.
 * This class implement algorithm from:<br>
 *
 * Lock-free Dynamically Resizable Arrays <br>
 *
 * Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup<br>
 * Texas A&M University College Station, TX 77843-3112<br>
 * {dechev, peter.pirkelbauer}@tamu.edu, bs@cs.tamu.edu
 *
 *
 * @author Zhi Gan
 *
 * @param <E> type of element in the vector
 *
 */
public class LockFreeVector<E> extends AbstractList<E> {
	private static final boolean debug = false;
	/**
	 * Size of the first bucket. sizeof(bucket[i+1])=2*sizeof(bucket[i])
	 */
	private static final int FIRST_BUCKET_SIZE = 8;

	/**
	 * number of buckets. 30 will allow 8*(2^30-1) elements
	 */
	private static final int N_BUCKET = 30;

	/**
	 * We will have at most N_BUCKET number of buckets. And we have
	 * sizeof(buckets.get(i))=FIRST_BUCKET_SIZE**(i+1)
	 */
	private final AtomicReferenceArray<AtomicReferenceArray<E>> buckets;

	/**
	 * @author ganzhi
	 *
	 * @param <E>
	 */
	static class WriteDescriptor<E> {
		public E oldV;
		public E newV;
		public AtomicReferenceArray<E> addr;
		public int addr_ind;

		/**
		 * Creating a new descriptor.
		 *
		 * @param addr Operation address
		 * @param addr_ind	Index of address
		 * @param oldV old operand
		 * @param newV new operand
		 */
		public WriteDescriptor(AtomicReferenceArray<E> addr, int addr_ind,
				E oldV, E newV) {
			this.addr = addr;
			this.addr_ind = addr_ind;
			this.oldV = oldV;
			this.newV = newV;
		}

		/**
		 * set newV.
		 */
		public void doIt() {
			addr.compareAndSet(addr_ind, oldV, newV);
		}
	}

	/**
	 * @author ganzhi
	 *
	 * @param <E>
	 */
	static class Descriptor<E> {
		public int size;
		volatile WriteDescriptor<E> writeop;

		/**
		 * Create a new descriptor.
		 *
		 * @param size Size of the vector
		 * @param writeop Executor write operation
		 */
		public Descriptor(int size, WriteDescriptor<E> writeop) {
			this.size = size;
			this.writeop = writeop;
		}

		/**
		 *
		 */
		public void completeWrite() {
			WriteDescriptor<E> tmpOp = writeop;
			if (tmpOp != null) {
				tmpOp.doIt();
				writeop = null; // this is safe since all write to writeop use
				// null as r_value.
			}
		}
	}

	private AtomicReference<Descriptor<E>> descriptor;
	private static final int zeroNumFirst = Integer
			.numberOfLeadingZeros(FIRST_BUCKET_SIZE);;

	/**
	 * Constructor.
	 */
	public LockFreeVector() {
		buckets = new AtomicReferenceArray<AtomicReferenceArray<E>>(N_BUCKET);
		buckets.set(0, new AtomicReferenceArray<E>(FIRST_BUCKET_SIZE));
		descriptor = new AtomicReference<Descriptor<E>>(new Descriptor<E>(0,
				null));
	}

	/**
	 * add e at the end of vector.
	 *
	 * @param e
	 *            element added
	 */
	public void push_back(E e) {
		Descriptor<E> desc;
		Descriptor<E> newd;
		do {
			desc = descriptor.get();
			desc.completeWrite();

			int pos = desc.size + FIRST_BUCKET_SIZE;
			int zeroNumPos = Integer.numberOfLeadingZeros(pos);
			int bucketInd = zeroNumFirst - zeroNumPos;
			if (buckets.get(bucketInd) == null) {
				int newLen = 2 * buckets.get(bucketInd - 1).length();
				if (debug)
					System.out.println("New Length is:" + newLen);
				buckets.compareAndSet(bucketInd, null,
						new AtomicReferenceArray<E>(newLen));
			}

			int idx = (0x80000000>>>zeroNumPos) ^ pos;
			newd = new Descriptor<E>(desc.size + 1, new WriteDescriptor<E>(
					buckets.get(bucketInd), idx, null, e));
		} while (!descriptor.compareAndSet(desc, newd));
		descriptor.get().completeWrite();
	}

	/**
	 * Remove the last element in the vector.
	 *
	 * @return element removed
	 */
	public E pop_back() {
		Descriptor<E> desc;
		Descriptor<E> newd;
		E elem;
		do {
			desc = descriptor.get();
			desc.completeWrite();

			int pos = desc.size + FIRST_BUCKET_SIZE - 1;
			int bucketInd = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
					- Integer.numberOfLeadingZeros(pos);
			int idx = Integer.highestOneBit(pos) ^ pos;
			elem = buckets.get(bucketInd).get(idx);
			newd = new Descriptor<E>(desc.size - 1, null);
		} while (!descriptor.compareAndSet(desc, newd));

		return elem;
	}

	/**
	 * Get element with the index.
	 *
	 * @param index
	 *            index
	 * @return element with the index
	 */
	@Override
	public E get(int index) {
		int pos = index + FIRST_BUCKET_SIZE;
		int zeroNumPos = Integer.numberOfLeadingZeros(pos);
		int bucketInd = zeroNumFirst - zeroNumPos;
		int idx = (0x80000000>>>zeroNumPos) ^ pos;
		return buckets.get(bucketInd).get(idx);
	}

	/**
	 * Set the element with index to e.
	 *
	 * @param index
	 *            index of element to be reset
	 * @param e
	 *            element to set
	 */
	/**
	  * {@inheritDoc}
	  */
	public E set(int index, E e) {
		int pos = index + FIRST_BUCKET_SIZE;
		int bucketInd = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
				- Integer.numberOfLeadingZeros(pos);
		int idx = Integer.highestOneBit(pos) ^ pos;
		AtomicReferenceArray<E> bucket = buckets.get(bucketInd);
		while (true) {
			E oldV = bucket.get(idx);
			if (bucket.compareAndSet(idx, oldV, e))
				return oldV;
		}
	}

	/**
	 * reserve more space.
	 *
	 * @param newSize
	 *            new size be reserved
	 */
	public void reserve(int newSize) {
		int size = descriptor.get().size;
		int pos = size + FIRST_BUCKET_SIZE - 1;
		int i = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
				- Integer.numberOfLeadingZeros(pos);
		if (i < 1)
			i = 1;

		int initialSize = buckets.get(i - 1).length();
		while (i < Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
				- Integer.numberOfLeadingZeros(newSize + FIRST_BUCKET_SIZE - 1)) {
			i++;
			initialSize *= FIRST_BUCKET_SIZE;
			buckets.compareAndSet(i, null, new AtomicReferenceArray<E>(
					initialSize));
		}
	}

	/**
	 * size of vector.
	 *
	 * @return size of vector
	 */
	public int size() {
		return descriptor.get().size;
	}

	/**
	  * {@inheritDoc}
	  */
	@Override
	public boolean add(E object) {
		push_back(object);
		return true;
	}
}
package geym.conc.ch3.ls;

import java.util.concurrent.locks.LockSupport;

public class LockSupportDemo {
	public static Object u = new Object();
	static ChangeObjectThread t1 = new ChangeObjectThread("t1");
	static ChangeObjectThread t2 = new ChangeObjectThread("t2");

	public static class ChangeObjectThread extends Thread {
		public ChangeObjectThread(String name){
			super.setName(name);
		}
		@Override
		public void run() {
			synchronized (u) {
				System.out.println("in "+getName());
				LockSupport.park(this);
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		t1.start();
		Thread.sleep(100);
		t2.start();
		LockSupport.unpark(t1);
		LockSupport.unpark(t2);
		t1.join();
		t2.join();
	}
}
package geym.conc.ch3.ls;

import java.util.concurrent.locks.LockSupport;

public class LockSupportIntDemo {
    public static Object u = new Object();
    static ChangeObjectThread t1 = new ChangeObjectThread("t1");
    static ChangeObjectThread t2 = new ChangeObjectThread("t2");

    public static class ChangeObjectThread extends Thread {
        public ChangeObjectThread(String name){
            super.setName(name);
        }
        @Override
        public void run() {
            synchronized (u) {
                System.out.println("in "+getName());
                LockSupport.park();
                if(Thread.interrupted()){
                    System.out.println(getName()+" 被中断了");
                }
            }
            System.out.println(getName()+"执行结束");
        }
    }

    public static void main(String[] args) throws InterruptedException {
        t1.start();
        Thread.sleep(100);
        t2.start();
        t1.interrupt();
        LockSupport.unpark(t2);
    }
}
package geym.conc.ch1;

public class Long2Binary {


	public static void main(String[] args) {
		System.out.println("+111="+String.format("%64s", Long.toBinaryString(111)).replaceAll(" ", "0"));
		System.out.println("-999="+String.format("%64s", Long.toBinaryString(-999)).replaceAll(" ", "0"));
		System.out.println("+333="+String.format("%64s", Long.toBinaryString(333)).replaceAll(" ", "0"));
		System.out.println("-444="+String.format("%64s", Long.toBinaryString(-444)).replaceAll(" ", "0"));

		System.out.println("+4294966852="+String.format("%64s", Long.toBinaryString(4294966852L)).replaceAll(" ", "0"));
		System.out.println("-4294967185="+Long.toBinaryString(-4294967185L));
	}

}

package geym.conc.ch6.atomic;

import java.util.Random;
import java.util.concurrent.atomic.LongAccumulator;

public class LongAccumulatorDemo {
    public static void main(String[] args) throws Exception {
        LongAccumulator accumulator = new LongAccumulator(Long::max, Long.MIN_VALUE);
        Thread[] ts = new Thread[1000];

        for (int i = 0; i < 1000; i++) {
            ts[i] = new Thread(() -> {
                Random random = new Random();
                long value = random.nextLong();
                accumulator.accumulate(value);
            });
            ts[i].start();
        }
        for (int i = 0; i < 1000; i++) {
            ts[i].join();
        }
        System.out.println(accumulator.longValue());
    }
}
package geym.conc.ch6.atomic;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

public class LongAdderDemo {
	private static final int MAX_THREADS = 3;				   //线程数
	private static final int TASK_COUNT = 3;				   //任务数
	private static final int TARGET_COUNT = 10000000;		   //目标总数

	private AtomicLong acount =new AtomicLong(0L);			//无锁的原子操作
	private LongAdder lacount=new LongAdder();
	private long count=0;

	static CountDownLatch cdlsync=new CountDownLatch(TASK_COUNT);
	static CountDownLatch cdlatomic=new CountDownLatch(TASK_COUNT);
	static CountDownLatch cdladdr=new CountDownLatch(TASK_COUNT);

	protected synchronized long inc(){							//有锁的加法
		return ++count;
	}

	protected synchronized long getCount(){						//有锁的操作
		return count;
	}

	public class SyncThread implements Runnable{
		protected String name;
		protected long starttime;
		LongAdderDemo out;
		public SyncThread(LongAdderDemo o,long starttime){
			out=o;
			this.starttime=starttime;
		}
		@Override
		public void run() {
			long v=out.getCount();
			while(v<TARGET_COUNT){						//在到达目标值前，不停循环
				v=out.inc();
			}
			long endtime=System.currentTimeMillis();
			System.out.println("SyncThread spend:"+(endtime-starttime)+"ms"+" v="+v);
			cdlsync.countDown();
		}
	}

	public void testSync() throws InterruptedException{
		ExecutorService exe=Executors.newFixedThreadPool(MAX_THREADS);
		long starttime=System.currentTimeMillis();
		SyncThread sync=new SyncThread(this,starttime);
		for(int i=0;i<TASK_COUNT;i++){
			exe.submit(sync); 								//提交线程开始计算
		}
		cdlsync.await();
		exe.shutdown();
	}
	public class AtomicThread implements Runnable{
		protected String name;
		protected long starttime;
		public AtomicThread(long starttime){
			this.starttime=starttime;
		}
		@Override
		public void run() {									//在到达目标值前，不停循环
			long v=acount.get();
			while(v<TARGET_COUNT){
				v=acount.incrementAndGet();					//无锁的加法
			}
			long endtime=System.currentTimeMillis();
			System.out.println("AtomicThread spend:"+(endtime-starttime)+"ms"+" v="+v);
			cdlatomic.countDown();
		}
	}

	public void testAtomic() throws InterruptedException{
		ExecutorService exe=Executors.newFixedThreadPool(MAX_THREADS);
		long starttime=System.currentTimeMillis();
		AtomicThread atomic=new AtomicThread(starttime);
		for(int i=0;i<TASK_COUNT;i++){
			exe.submit(atomic);								//提交线程开始计算
		}
		cdlatomic.await();
		exe.shutdown();
	}

	public class LongAddrThread implements Runnable{
		protected String name;
		protected long starttime;
		public LongAddrThread(long starttime){
			this.starttime=starttime;
		}
		@Override
		public void run() {
			long v=lacount.sum();
			while(v<TARGET_COUNT){
				lacount.increment();
				v=lacount.sum();
			}
			long endtime=System.currentTimeMillis();
			System.out.println("LongAdder spend:"+(endtime-starttime)+"ms"+" v="+v);
			cdladdr.countDown();
		}
	}

	public void testAtomicLong() throws InterruptedException{
		ExecutorService exe=Executors.newFixedThreadPool(MAX_THREADS);
		long starttime=System.currentTimeMillis();
		LongAddrThread atomic=new LongAddrThread(starttime);
		for(int i=0;i<TASK_COUNT;i++){
			exe.submit(atomic);								//提交线程开始计算
		}
		cdladdr.await();
		exe.shutdown();
	}

	public static void main(String args[]) throws InterruptedException{
		LongAdderDemo a=new LongAdderDemo();
		a.testSync();
		a.testAtomic();
		a.testAtomicLong();
	}
}
package org.jmatrices.dbl.decomposition;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

/**
 * LUDecomposition
 * <P>
 * For an m-by-n matrix A with m >= n, the LU decomposition is an m-by-n
 * unit lower triangular matrix L, an n-by-n upper triangular matrix U,
 * and a permutation vector piv of length m so that A(piv,:) = L*U.
 * If m < n, then L is m-by-m and U is m-by-n.
 * </p>
 * <P>
 * The LU decompostion with pivoting always exists, even if the matrix is
 * singular, so the constructor will never fail.  The primary use of the
 * LU decomposition is in the solution of square systems of simultaneous
 * linear equations.  This will fail if isNonsingular() returns false.
 * </p>
 * <p>
 * http://www.hku.hk/cc/sp2/software/hpf/Course/HTMLQuestionsnode65.html
 * http://csep10.phys.utk.edu/guidry/phys594/lectures/linear_algebra/lanotes/node3.html
 * </p>
 * <p><font color="red">
 * The code is basically JAMA code with modifications made to fit in the scheme of things.
 * </font></p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 08.03.2004
 * Time: 23:37:48
 */
public class LUDecomposition {
/* ------------------------
   Class variables
 * ------------------------ */

    /**
     * Array for internal storage of decomposition.
     *
     * @serial internal array storage.
     */
    private double[][] LU;

    /**
     * Row and column dimensions, and pivot sign.
     *
     * @serial column dimension.
     * @serial row dimension.
     * @serial pivot sign.
     */
    private int m, n, pivsign;

    /**
     * Internal storage of pivot vector.
     *
     * @serial pivot vector.
     */
    private int[] piv;

    private Matrix hint;

/* ------------------------
   Constructor
 * ------------------------ */
    /**
     * LU Decomposition
     *
     * @param a Rectangular matrix
     */
    public LUDecomposition(Matrix a) {   //renamed A to a
        hint = a;
        // Use a "left-looking", dot-product, Crout/Doolittle algorithm.

        LU = a.get();     //changed
        m = a.rows();
        n = a.cols();
        piv = new int[m];
        for (int i = 0; i < m; i++) {
            piv[i] = i + 1;    //changed so as to begin the indices from 1 and not 0
            //either we could do it here or we could have adjusted it later
        }
        pivsign = 1;
        double[] LUrowi;
        double[] LUcolj = new double[m];

        // Outer loop.

        for (int j = 0; j < n; j++) {

            // Make a copy of the j-th column to localize references.

            for (int i = 0; i < m; i++) {
                LUcolj[i] = LU[i][j];
            }

            // Apply previous transformations.

            for (int i = 0; i < m; i++) {
                LUrowi = LU[i];

                // Most of the time is spent in the following dot product.

                int kmax = Math.min(i, j);
                double s = 0.0;
                for (int k = 0; k < kmax; k++) {
                    s += LUrowi[k] * LUcolj[k];
                }

                LUrowi[j] = LUcolj[i] -= s;
            }

            // Find pivot and exchange if necessary.

            int p = j;
            for (int i = j + 1; i < m; i++) {
                if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
                    p = i;
                }
            }
            if (p != j) {
                for (int k = 0; k < n; k++) {
                    double t = LU[p][k];
                    LU[p][k] = LU[j][k];
                    LU[j][k] = t;
                }
                int k = piv[p];
                piv[p] = piv[j];
                piv[j] = k;
                pivsign = -pivsign;
            }

            // Compute multipliers.

            if (j < m & LU[j][j] != 0.0) {
                for (int i = j + 1; i < m; i++) {
                    LU[i][j] /= LU[j][j];
                }
            }
        }
    }

/* ------------------------
   Public Methods
 * ------------------------ */
    /**
     * Is the matrix nonsingular?
     *
     * @return true if U, and hence A, is nonsingular.
     */
    public boolean isNonsingular() {
        for (int j = 0; j < n; j++) {
            if (LU[j][j] == 0)
                return false;
        }
        return true;
    }

    //added this method
    public boolean isSingular() {
        return !isNonsingular();
    }

    /**
     * Return lower triangular factor
     *
     * @return L
     */
    public Matrix getL() {
        double[][] L = new double[m][n]; //changed
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > j) {
                    L[i][j] = LU[i][j];
                } else if (i == j) {
                    L[i][j] = 1.0;
                } else {
                    L[i][j] = 0.0;
                }
            }
        }
        return MatrixFactory.getMatrix(m, n, hint, L);     //changed
    }

    /**
     * Return upper triangular factor
     *
     * @return U
     */

    public Matrix getU() {
        double[][] U = new double[m][n]; //changed
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i <= j) {
                    U[i][j] = LU[i][j];
                } else {
                    U[i][j] = 0.0;
                }
            }
        }
        return MatrixFactory.getMatrix(m, n, hint, U);
    }

    /**
     * Return pivot permutation vector
     *
     * @return piv
     */

    public int[] getPivot() {
        int[] p = new int[m];
        for (int i = 0; i < m; i++) {
            p[i] = piv[i];
        }
        return p;
    }


    /**
     * Return pivot permutation vector as a one-dimensional double array
     *
     * @return (double) piv
     */

    public double[][] getDoublePivot() {       //changed to suit our needs
        double[][] vals = new double[m][1];
        for (int i = 0; i < m; i++) {
            vals[i][0] = (double) piv[i];
        }
        return vals;
    }


    /**
     * Return pivot permutation vector
     *
     * @return piv
     */

    public Matrix getPivotMatrix() {
        double[][] dblPivot = getDoublePivot();
        return MatrixFactory.getMatrix(dblPivot.length, 1, hint, dblPivot);
    }

    /**
     * Determinant
     *
     * @return det(A)
     * @throws IllegalArgumentException Matrix must be square
     */

    public double det() {
        if (m != n) {
            throw new IllegalArgumentException("Matrix must be square.");
        }
        double d = (double) pivsign;
        for (int j = 0; j < n; j++) {
            d *= LU[j][j];
        }
        return d;
    }

    /**
     * Solve A*X = B
     *
     * @param B A Matrix with as many rows as A and any number of columns.
     * @return X so that L*U*X = B(piv,:)
     * @throws IllegalArgumentException Matrix row dimensions must agree.
     * @throws RuntimeException         Matrix is singular.
     */

    public Matrix solve(Matrix B) {
        if (B.rows() != m) {
            throw new IllegalArgumentException("Matrix row dimensions must agree.");
        }
        if (!this.isNonsingular()) {
            throw new RuntimeException("Matrix is singular.");
        }

        // Copy right hand side with pivoting
        int nx = B.cols();
        Matrix Xmat = B.getSubMatrix(piv, 0 + 1, nx - 1 + 1);//changed to reflect indices from 1,1   //piv must have indices begining from 1
        //Matrix Xmat = B.getSubMatrix(getAdjustedPivot(),0+1,nx-1+1);//if we wouldn't have changed piv earlier we could have done that in a method named adjustedPivot .. I tested it and it was working!
        double[][] X = Xmat.get();

        // Solve L*Y = B(piv,:)
        for (int k = 0; k < n; k++) {
            for (int i = k + 1; i < n; i++) {
                for (int j = 0; j < nx; j++) {
                    X[i][j] -= X[k][j] * LU[i][k];
                }
            }
        }
        // Solve U*X = Y;
        for (int k = n - 1; k >= 0; k--) {
            for (int j = 0; j < nx; j++) {
                X[k][j] /= LU[k][k];
            }
            for (int i = 0; i < k; i++) {
                for (int j = 0; j < nx; j++) {
                    X[i][j] -= X[k][j] * LU[i][k];
                }
            }
        }
        return MatrixFactory.getMatrix(Xmat.rows(), Xmat.cols(), hint,  X);
    }



/* ------------------------
   Temporary, experimental code.
   ------------------------ *\

   \** LU Decomposition, computed by Gaussian elimination.
   <P>
   This constructor computes L and U with the "daxpy"-based elimination
   algorithm used in LINPACK and MATLAB.  In Java, we suspect the dot-product,
   Crout algorithm will be faster.  We have temporarily included this
   constructor until timing experiments confirm this suspicion.
   <P>
   @param  A             Rectangular matrix
   @param  linpackflag   Use Gaussian elimination.  Actual value ignored.
   @return               Structure to access L, U and piv.
   *\

   public LUDecomposition (Matrix A, int linpackflag) {
      // Initialize.
      LU = A.getArrayCopy();
      m = A.getRowDimension();
      n = A.getColumnDimension();
      piv = new int[m];
      for (int i = 0; i < m; i++) {
         piv[i] = i;
      }
      pivsign = 1;
      // Main loop.
      for (int k = 0; k < n; k++) {
         // Find pivot.
         int p = k;
         for (int i = k+1; i < m; i++) {
            if (Math.abs(LU[i][k]) > Math.abs(LU[p][k])) {
               p = i;
            }
         }
         // Exchange if necessary.
         if (p != k) {
            for (int j = 0; j < n; j++) {
               double t = LU[p][j]; LU[p][j] = LU[k][j]; LU[k][j] = t;
            }
            int t = piv[p]; piv[p] = piv[k]; piv[k] = t;
            pivsign = -pivsign;
         }
         // Compute multipliers and eliminate k-th column.
         if (LU[k][k] != 0.0) {
            for (int i = k+1; i < m; i++) {
               LU[i][k] /= LU[k][k];
               for (int j = k+1; j < n; j++) {
                  LU[i][j] -= LU[i][k]*LU[k][j];
               }
            }
         }
      }
   }

\* ------------------------
   End of temporary code.
 * ------------------------ */

}
package geym.conc.ch5.simplefuture;

public class Main {
    public static void main(String[] args) {
        Client client = new Client();

        Data data = client.request("a");
        System.out.println("请求完毕");
        try {
            //这里可以用一个sleep代替了对其它业务逻辑的处理
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
            //使用真实的数据
        System.out.println("数据 = " + data.getResult());
    }
}
package geym.conc.ch3.jmh;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Benchmark)
public class MapTest {

    static Map hashMap = new HashMap();
    static Map syncHashMap = Collections.synchronizedMap(new HashMap());
    static Map concurrentHashMap = new ConcurrentHashMap();

    @Setup
    public void setup() {
        for (int i = 0; i < 10000; i++) {
            hashMap.put(Integer.toString(i), Integer.toString(i));
            syncHashMap.put(Integer.toString(i), Integer.toString(i));
            concurrentHashMap.put(Integer.toString(i), Integer.toString(i));
        }

    }

    @Benchmark
    public void hashMapGet() {
        hashMap.get("4");
    }

    @Benchmark
    public void syncHashMapGet() {
        syncHashMap.get("4");
    }

    @Benchmark
    public void concurrentHashMapGet() {
        concurrentHashMap.get("4");
    }

    @Benchmark
    public void hashMapSize() {
        hashMap.size();
    }

    @Benchmark
    public void syncHashMapSize() {
        syncHashMap.size();
    }

    @Benchmark
    public void concurrentHashMapSize() {
        concurrentHashMap.size();
    }

    /*
     *
     * a) Via command-line: $ mvn clean install $ java -jar target/benchmarks.jar
     * JMHSample_01
     *
     * JMH generates self-contained JARs, bundling JMH together with it. The runtime
     * options for the JMH are available with "-h": $ java -jar
     * target/benchmarks.jar -h
     *
     * b) Via the Java API: (see the JMH homepage for possible caveats when running
     * from IDE: http://openjdk.java.net/projects/code-tools/jmh/)
     */

    public static void main(String[] args) throws RunnerException {
//        new Thread() {
//            public void run() {
//                while (true) {
//                    if (syncHashMap.size() > 1000) {
//                        syncHashMap.clear();
//                    }
//                    syncHashMap.put(Integer.toString(new Random().nextInt()), "");
//                    if (concurrentHashMap.size() > 1000) {
//                        concurrentHashMap.clear();
//                    }
//                    concurrentHashMap.put(Integer.toString(new Random().nextInt()), "");
//                }
//            }
//        }.start();
        Options opt = new OptionsBuilder().include(MapTest.class.getSimpleName()).forks(1).warmupIterations(5)
                .measurementIterations(5).threads(2).build();
        new Runner(opt).run();
    }
}
package geym.conc.ch3.jmh;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Benchmark)
public class MapTest {

    static Map hashMap = new HashMap();
    static Map syncHashMap = Collections.synchronizedMap(new HashMap());
    static Map concurrentHashMap = new ConcurrentHashMap();

    @Setup
    public void setup() {
        for (int i = 0; i < 10000; i++) {
            hashMap.put(Integer.toString(i), Integer.toString(i));
            syncHashMap.put(Integer.toString(i), Integer.toString(i));
            concurrentHashMap.put(Integer.toString(i), Integer.toString(i));
        }

    }

    @Benchmark
    public void hashMapGet() {
        hashMap.get("4");
    }

    @Benchmark
    public void syncHashMapGet() {
        syncHashMap.get("4");
    }

    @Benchmark
    public void concurrentHashMapGet() {
        concurrentHashMap.get("4");
    }

    @Benchmark
    public void hashMapSize() {
        hashMap.size();
    }

    @Benchmark
    public void syncHashMapSize() {
        syncHashMap.size();
    }

    @Benchmark
    public void concurrentHashMapSize() {
        concurrentHashMap.size();
    }

    /*
     *
     * a) Via command-line: $ mvn clean install $ java -jar target/benchmarks.jar
     * JMHSample_01
     *
     * JMH generates self-contained JARs, bundling JMH together with it. The runtime
     * options for the JMH are available with "-h": $ java -jar
     * target/benchmarks.jar -h
     *
     * b) Via the Java API: (see the JMH homepage for possible caveats when running
     * from IDE: http://openjdk.java.net/projects/code-tools/jmh/)
     */

    public static void main(String[] args) throws RunnerException {
//        new Thread() {
//            public void run() {
//                while (true) {
//                    if (syncHashMap.size() > 1000) {
//                        syncHashMap.clear();
//                    }
//                    syncHashMap.put(Integer.toString(new Random().nextInt()), "");
//                    if (concurrentHashMap.size() > 1000) {
//                        concurrentHashMap.clear();
//                    }
//                    concurrentHashMap.put(Integer.toString(new Random().nextInt()), "");
//                }
//            }
//        }.start();
        Options opt = new OptionsBuilder().include(MapTest.class.getSimpleName()).forks(1).warmupIterations(5)
                .measurementIterations(5).threads(2).build();
        new Runner(opt).run();
    }
}
package org.jmatrices.dbl.client;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.decomposition.*;
import org.jmatrices.dbl.measure.MatricesMeasure;
import org.jmatrices.dbl.measure.MatrixMeasure;
import org.jmatrices.dbl.operator.MatrixEBEOperation;
import org.jmatrices.dbl.operator.MatrixOperator;
import org.jmatrices.dbl.rowcoltr.ColumnTransformer;
import org.jmatrices.dbl.transformer.MatrixEBETransformation;
import org.jmatrices.dbl.transformer.MatrixEBETransformer;
import org.jmatrices.dbl.transformer.MatrixTransformer;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * MatlabSyntax
 * <p>Author: purangp</p>
 * Date: 30.04.2004
 * Time: 14:49:39
 */
public class MatlabSyntax {
    /**
     * Creation
     */
    public static Matrix create(String src) {
        return MatrixParser.parseMatlabMatrix(src);
    }

    public static Matrix rand(int rows, int cols) {
        return MatrixFactory.getRandomMatrix(rows, cols, null);
    }

    public static Matrix magic(int dim) {
        throw new UnsupportedOperationException("tobe implemented");
    }

    public static Matrix pascal(int dim) {
        throw new UnsupportedOperationException("tobe implemented");
    }

    public static Matrix zeros(int rows, int cols) {
        return MatrixFactory.getMatrix(rows, cols, null);
    }

    public static Matrix zeros(int dim) {
        return zeros(dim, dim);
    }

    public static Matrix ones(int rows, int cols) {
        return MatrixFactory.getMatrix(rows, cols, null, 1);
    }

    public static Matrix ones(int dim) {
        return ones(dim, dim);
    }

    public static Matrix eye(int rows, int cols) {
        if (rows == cols)
            return MatrixFactory.getIdentityMatrix(rows, null);
        boolean rowsAreBigger = (rows > cols);     //vertical concatenation
        if (rowsAreBigger)
            return MatrixOperator.verticalConcatenation(MatrixFactory.getIdentityMatrix(cols, null), MatrixFactory.getMatrix(rows - cols, cols, null));
        else
            return MatrixOperator.horizontalConcatenation(MatrixFactory.getIdentityMatrix(rows, null), MatrixFactory.getMatrix(rows, cols - rows, null));
    }

    /**
     * Operators
     */
    public static Matrix neg(Matrix a) {
        return MatrixTransformer.negate(a);
    }

    public static Matrix powElem(Matrix a, final double s) {
        return MatrixEBETransformer.ebeTransform(a, new MatrixEBETransformation() {
            public double transform(double element) {
                return Math.pow(element, s);
            }
        });
    }

    public static Matrix powElem(Matrix a, Matrix b) {
        return MatrixOperator.applyEBEOperation(a, b, new MatrixEBEOperation() {
            public double apply(double a, double b) {
                return Math.pow(a, b);
            }
        });
    }

    public static Matrix pow(Matrix a, int s) {
        return MatrixTransformer.pow(a, s);
    }

    public static Matrix add(Matrix a, Matrix b) {
        return MatrixOperator.add(a, b);
    }

    public static Matrix add(Matrix a, final double scalar) {
        return MatrixEBETransformer.ebeTransform(a, new MatrixEBETransformation() {
            public double transform(double element) {
                return element + scalar;
            }
        });
    }

    public static Matrix subtract(Matrix a, Matrix b) {
        return MatrixOperator.subtract(a, b);
    }

    public static Matrix subtract(Matrix a, final double scalar) {
        return MatrixEBETransformer.ebeTransform(a, new MatrixEBETransformation() {
            public double transform(double element) {
                return element - scalar;
            }
        });
    }

    public static Matrix subtract(final double scalar, Matrix a) {
        return MatrixEBETransformer.ebeTransform(a, new MatrixEBETransformation() {
            public double transform(double element) {
                return scalar - element;
            }
        });
    }

    public static double dotprod(Matrix a, Matrix b) {
        return MatricesMeasure.dotProduct(a, b);
    }

    public static Matrix multiply(Matrix a, Matrix b) {
        return MatrixOperator.multiply(a, b);
    }

    public static Matrix multiplyEBE(Matrix a, Matrix b) {
        return MatrixOperator.multiplyEBE(a, b);
    }

    public static Matrix multiply(Matrix a, final double scalar) {
        return MatrixEBETransformer.ebeTransform(a, new MatrixEBETransformation() {
            public double transform(double element) {
                return scalar * element;
            }
        });
    }

    public static Matrix kron(Matrix a, Matrix b) {
        return MatrixOperator.kroneckerProduct(a, b);
    }

    public static Matrix hdp(Matrix a, Matrix b) {
        return MatrixOperator.horizontalDirectProduct(a, b);
    }

    public static Matrix solve(Matrix a, Matrix b) {
        return MatrixOperator.solve(a, b);
    }

    public static Matrix divide(Matrix a, Matrix b) {
        return MatrixOperator.divideEBE(a, b);
    }

    public static Matrix divide(Matrix a, final double scalar) {
        return MatrixEBETransformer.ebeTransform(a, new MatrixEBETransformation() {
            public double transform(double element) {
                return element / scalar;
            }
        });
    }

    public static Matrix divide(final double scalar, Matrix a) {
        return MatrixEBETransformer.ebeTransform(a, new MatrixEBETransformation() {
            public double transform(double element) {
                return scalar / element;
            }
        });
    }

    public static Matrix t(Matrix m) {
        return MatrixTransformer.transpose(m);
    }

    public static Matrix inv(Matrix m) {
        return MatrixTransformer.inverse(m);
    }

    public static Matrix horzcat(Matrix a, Matrix b) {
        return MatrixOperator.horizontalConcatenation(a, b);
    }

    public static Matrix vertcat(Matrix a, Matrix b) {
        return MatrixOperator.verticalConcatenation(a, b);
    }

    public static Matrix blkdiag(ArrayList matrices) {
        Iterator iter = matrices.iterator();
        Matrix tmpMatrix = null;
        while (iter.hasNext()) {
            Matrix matrix = (Matrix) iter.next();
            int rows_m = matrix.rows(), cols_m = matrix.cols(), rows_tmp = 0, cols_tmp = 0;
            if (tmpMatrix != null) {
                rows_tmp = tmpMatrix.rows();
                cols_tmp = tmpMatrix.cols();
                Matrix rightMatrix = MatrixFactory.getMatrix(rows_tmp, cols_m, tmpMatrix, 0);
                Matrix leftMatrix = MatrixFactory.getMatrix(rows_m, cols_tmp, tmpMatrix, 0);
                Matrix upperMatrix = horzcat(tmpMatrix, rightMatrix);
                Matrix lowerMatrix = horzcat(leftMatrix, matrix);
                tmpMatrix = vertcat(upperMatrix, lowerMatrix);
            } else {
                tmpMatrix = matrix;
            }
        }
        return tmpMatrix;
    }

    /**
     * Methods
     */

    public static double rank(Matrix m) {
        return MatrixMeasure.getRank(m);
    }

    public static double det(Matrix m) {
        return MatrixMeasure.getDeterminant(m);
    }

    public static double trace(Matrix m) {
        return MatrixMeasure.getTrace(m);
    }

    public static double norm(Matrix m) {
        return MatrixMeasure.getNorm2(m);
    }

    public static double norm_1(Matrix m) {
        return MatrixMeasure.getNorm1(m);
    }

    public static double normInf(Matrix m) {
        return MatrixMeasure.getNormInfinity(m);
    }

    public static double normFro(Matrix m) {
        return MatrixMeasure.getNormFrobenius(m);
    }

    public static double cond(Matrix m) {
        return MatrixMeasure.getCondition(m);
    }

    public static Matrix diag(Matrix m) {
        return MatrixTransformer.diagonal(m);
    }

    public static Matrix diagEx(Matrix m, int offset) {
        return MatrixTransformer.extractDiagonal(m, offset);
    }

    public static Matrix diagEm(Matrix m, int offset) {
        return MatrixTransformer.embedDiagonal(m, offset);
    }

    public static int length(Matrix m) {
        return MatrixMeasure.length(m);
    }

    public static double sumElem(Matrix m) {
        return MatrixMeasure.getSum(m);
    }

    public static Matrix sumCol(Matrix m) {
        return ColumnTransformer.sum(m);
    }

    public static double prodElem(Matrix m) {
        return MatrixMeasure.getProduct(m);
    }

    public static Matrix prodCol(Matrix m) {
        return ColumnTransformer.product(m);
    }

    public static double maxElem(Matrix m) {
        return MatrixMeasure.getMax(m);
    }

    public static Matrix maxCol(Matrix m) {
        return ColumnTransformer.max(m);
    }

    public static double minElem(Matrix m) {
        return MatrixMeasure.getMin(m);
    }

    public static Matrix minCol(Matrix m) {
        return ColumnTransformer.min(m);
    }

    public static double meanElem(Matrix m) {
        return MatrixMeasure.getMean(m, false);
    }

    public static Matrix meanCol(Matrix m) {
        return ColumnTransformer.mean(m, false);
    }

    public static Matrix cumprod(Matrix m) {
        return MatrixTransformer.cumulativeColumnProduct(m);
    }

    public static Matrix cumsum(Matrix m) {
        return MatrixTransformer.cumulativeColumnSum(m);
    }

    public static Matrix triu(Matrix m, int offset) {
        return MatrixTransformer.extractUpperTriangular(m, offset);
    }

    public static Matrix tril(Matrix m, int offset) {
        return MatrixTransformer.extractLowerTriangular(m, offset);
    }

    /**
     * Deocompositions
     */
    public static Matrix[] lu(Matrix m) {
        Matrix[] result = new Matrix[3];
        LUDecomposition lu = new LUDecomposition(m);
        result[0] = lu.getL();
        result[1] = lu.getU();
        result[2] = lu.getPivotMatrix();
        return result;
    }

    public static Matrix[] qr(Matrix m) {
        Matrix[] result = new Matrix[3];
        QRDecomposition qr = new QRDecomposition(m);
        result[0] = qr.getQ();
        result[1] = qr.getR();
        result[2] = qr.getH();
        return result;
    }

    public static Matrix[] eig(Matrix m) {
        Matrix[] result = new Matrix[2];
        EigenvalueDecomposition eig = new EigenvalueDecomposition(m);
        result[0] = eig.getV();
        result[1] = eig.getD();
        return result;
    }

    public static Matrix[] chol(Matrix m) {
        Matrix[] result = new Matrix[2];
        CholeskyDecomposition chol = new CholeskyDecomposition(m);
        result[0] = chol.getL();
        Matrix p = MatrixFactory.getMatrix(1, 1, null);
        if (chol.isSPD())
            p.set(1, 1, 0);
        else
            p.set(1, 1, 1);
        result[1] = p;
        return result;
    }

    public static Matrix[] svd(Matrix m) {
        Matrix[] result = new Matrix[3];
        SingularValueDecomposition svd = new SingularValueDecomposition(m);
        result[0] = svd.getU();
        result[1] = svd.getS();
        result[2] = svd.getV();
        return result;
    }

    public static String help() {
        String str = "------------------------Legend for vars------------------------\n";
        str += "s (scalar) \t v,w (vectors) \t A,B (Matrices)\n";
        str +="------------------------Matrix creation------------------------\n";
        str +="\t[1,2,3;4,5,6]\t\tcreate(\"[1,2,3;4,5,6]\")\n";
        str +="\trand(2,3)\t\trand(2,3)\n";
        str +="\tzeros(4,5)\t\tzeros(4,5)\n";
        str +="\tones(4,5)\t\tones(4,5)\n";
        str +="\teye(3,4)\t\teye(3,4)\n";
        str +="\n";
        str +="------------------------Matrix operators------------------------\n";
        str +="\tA(1,2)\t\tA.get(1,2)\n";
        str +="\tA(1,2)=3.5\t\tA.set(1,2,3.5)\n";
        str +="\t[m,n] = size(A)\t\tm=A.rows(),n=A.cols()\n";
        str +="\tA(:,j)\t\tA.getColumn(j)\n";
        str +="\tA(i,:)\t\tA.getRow(i)\n";
        str +="\n";
        str +="\t-A\t\tneg(A)\n";
        str +="\tA+B\t\tadd(A,B)\n";
        str +="\ts+A\t\tadd(A,s)\n";
        str +="\n";
        str +="\tA-B\t\tsubtract(A,B)\n";
        str +="\tA-s\t\tsubtract(A,s)\n";
        str +="\ts-A\t\tsubtract(s,A)\n";
        str +="\n";
        str +="\tv*w\t\tdotprod(v,w)\n";
        str +="\tA*B\t\tmultiply(A,B)\n";
        str +="\tA.*B\t\tmultiplyEBE(A,B)\n";
        str +="\ts*A\t\tmultiply(A,s)\n";
        str +="\tkron(A,B)\t\tkron(A,B)\n";
        str +="\thorizontal direct product\t\thdp(A,B)\n";
        str +="\n";
        str +="\tA^s\t\tpow(A,s)\n";
        str +="\tA.^s\t\tpowElem(A,s)\n";
        str +="\tA.^B\t\tpowElem(A,B)\n";
        str +="\n";
        str +="\tA/B\t\tsolve(A,B)\n";
        str +="\n";
        str +="\tA./B\t\tdivide(A,B)\n";
        str +="\ts./B\t\tdivide(s,B)\n";
        str +="\tB./s\t\tdivide(B,s)\n";
        str +="\n";
        str +="\tA'\t\tt(A)\n";
        str +="\t\t\t\n";
        str +="\thorzcat(A,B)\t\thorzcat(A,B)\n";
        str +="\tvertcat(A,B)\t\tvertcat(A,B)\n";
        str +="\tblkdiag(A,B,C,...)\t\tblkdiag(list)\t list of matrices, ArrayList can be used\n";
        str +="\n";
        str +="------------------------Matrix functions------------------------\n";
        str +="\trank(A)\t\trank(A)\n";
        str +="\tdet(A)\t\tdet(A)\n";
        str +="\tinv(A)\t\tinv(A)\n";
        str +="\ttrace(A)\t\ttrace(A)\n";
        str +="\tnorm(A)\t\tnorm(A)\n";
        str +="\tnorm(A,1)\t\tnorm_1(A)\n";
        str +="\tnorm(A,inf)\t\tnormInf(A)\n";
        str +="\tnorm(A,'fro')\t\tnormFro(A)\n";
        str +="\tcond(A)\t\tcond(A)\n";
        str +="\tlength(A)\t\tlength(A)\n";
        str +="\n";
        str +="\tsum(v)\t\tsumElem(v)\n";
        str +="\tsum(A)\t\tsumCol(A)\n";
        str +="\tprod(v)\t\tprodElem(v)\n";
        str +="\tprod(A)\t\tprodCol(A)\n";
        str +="\tmax(v)\t\tmaxElem(v)\n";
        str +="\tmax(A)\t\tmaxCol(A)\n";
        str +="\tmin(v)\t\tminElem(v)\n";
        str +="\tmin(A)\t\tminCol(A)\n";
        str +="\tmean(v)\t\tmeanElem(v)\n";
        str +="\tmean(A)\t\tmeanCol(A)\n";
        str +="\n";
        str +="\tdiag(A)\t\tdiag(A)\t extracts the main diagonal from a SQUARE matrix\n";
        str +="\tdiag(v,offset)\t\tdiagEm(v,offset)\tputs the vector in a diagonal of a zeros matrix\n";
        str +="\tdiag(A,offset)\t\tdiagEx(A,offset) \t extracts the diagonal from the matrix and returns it as a column vector\n";
        str +="\n";
        str +="\tcumprod(A)\t\tcumprod(A)\n";
        str +="\tcumsum(A)\t\tcumsum(A)\n";
        str +="\n";
        str +="\ttriu(A,offset)\t\ttriu(A,offset)\n";
        str +="\ttril(A,offset)\t\ttril(A,offset)\n";
        str +="\n";
        str +="------------------------Matrix decompositions------------------------\n";
        str +="\t[L,U,P] = LU(A)\t\tMatrix[]=lu(A)\n";
        str +="\t[Q,R,H] = QR(A)\t\tMatrix[]=qr(A)\n";
        str +="\t[V,D]=eig(A)\t\tMatrix[]=eig(A)\n";
        str +="\t[L,P]=chol(A)\t\tMatrix[]=chol(A)\n";
        str +="\t[U,S,V] = SVD(A)\t\tMatrix[]=svd(A)\n";
        str +="\t\t\t\n";


        return str;

    }
   /*
    public static void main(String[] args) {
        //testEye();
        //testKron();
        //testHDP();
        //testNorms();
        help();
        testBlkDiag();
    }

    private static void testNorms() {
        Matrix v = create("[2,0,-1]");
        Matrix m = rand(3, 2);
        testNorms(v);
        testNorms(m);
    }

    private static void testNorms(Matrix m) {
        System.out.println("norm ->" + norm(m));
        System.out.println("norm 1 ->" + norm_1(m));
        System.out.println("norm Inf ->" + normInf(m));
        System.out.println("norm Forb ->" + normFro(m) + " [OR]" + Math.sqrt(ColumnTransformer.sum(diag(multiply(t(m), m))).get(1, 1)));
        System.out.println("--------------------------");
    }

    private static void testEye() {
        System.out.println(eye(3, 2));
        System.out.println("-----------");
        System.out.println(eye(2, 3));
    }

    private static void testBlkDiag() {
        ArrayList list = new ArrayList();
        list.add(create("[1,2;3,4]"));
        list.add(create("[4,5,6;7,8,9]"));
        list.add(create("[10,11,12,13;14,15,16,17;18,19,20,21]"));
        System.out.println(blkdiag(list));
    }

    private static void testKron() {
        Matrix a = create("[1,2;3,4]");
        Matrix b = create("[4,5,6;7,8,9]");

        System.out.println(kron(a, b));
    }

    private static void testHDP() {
        Matrix c = create("[1,2;3,4]");
        Matrix d = create("[5,6;7,8]");
        System.out.println(hdp(c, d));
    }
    */
}

package org.jmatrices.dbl.measure;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.operator.MatrixOperator;
import org.jmatrices.dbl.Matrix;

/**
 * MatricesMeasure provides methods applicable to two (or more) matrices
 * <p>
 * Given two matrices <strong> A,B -yields-> value</strong> ,where value is a number, boolean, or any other primitive type
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 12.03.2004
 * Time: 12:51:46
 */
public final class MatricesMeasure {
    /**
     * Compares elements of matrices to try and determine equality of matrices
     *
     * @param a Matrix
     * @param b Matrix
     * @return true iff element in a at a given position equals the element in b at the same position
     */
    public static boolean areEqual(Matrix a, Matrix b) {
        if (areSameDimension(a, b)) {
            for (int row = 1; row <= a.rows(); row++) {
                for (int col = 1; col <= a.cols(); col++) {
                    if (a.get(row, col) != b.get(row, col))
                        return false;
                }
            }
            return true;
        } else
            return false;
    }

    /**
     * Compares dimensions of the two matrices
     *
     * @param a Matrix
     * @param b Matrix
     * @return true if rows and columns, i.e. the dimensions of a and b are are equal
     */
    public static boolean areSameDimension(Matrix a, Matrix b) {
        return (a.rows() == b.rows() && a.cols() == b.cols());
    }

    /**
     * The dot or scalar product expects two vectors
     * <p/>
     * It basically does an element-by-element multiplication and sums the elements of the resulting matrix. So the two matrices need to be of the same dimensions
     * </p>
     *
     * @param a an mxn Matrix
     * @param b an mxn Matrix
     * @return
     */
    public static double dotProduct(Matrix a, Matrix b) {
        if (areSameDimension(a, b))
            return MatrixMeasure.getSum(MatrixOperator.multiplyEBE(a, b));
        else
            throw new IllegalArgumentException("Matrices don't conform");
    }


}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jmatrices.dbl;
/**
 * Matrix represents a <strong>structurally immutable</strong> matrix of numbers(double) with <strong>index begining at 1</strong>.
 * <p>
 * The only way to change the elements in a matrix is through {@link #set(int, int, double)}
 * </p><p>
 * A good convention to follow is to use <code>row=1;row<=rows();row++(col=1;col<=cols();coll++)</code>  as indices while looping over matrix elements.
 * </p><p>
 * And use the normal <code>i,j,k</code> etc. to iterate over arrays!
 * </p><p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 15:52:02
 */
public interface Matrix extends java.io.Serializable {
    /**
     * Gets the number of rows in the matrix
     * <p/>
     * Counts from 1
     *
     * @return number of rows in the matrix
     */
    int rows();

    /**
     * Gets the number of columns in the matrix
     * <p/>
     * counts from 1
     *
     * @return number of columns in the matrix
     */
    int cols();

    // GETS AND SETS
    /**
     * Sets an element at the given position to a new value
     *
     * @param row   row in which the element occurs
     * @param col   column in which the element occurs
     * @param value the new value to be set
     */
    void set(int row, int col, double value);

    /**
     * Gets the value of the element at the given row and column
     *
     * @param row row in which the element occurs
     * @param col column in which the element occurs
     * @return value of the element
     */
    double get(int row, int col);

    //todo should we return arrays or matrices?  we don't have to return arrays as get returns the store array perhaps we should move these to transformer package!!!
    /**
     * Gets the entire row as a matrix
     *
     * @param row row asked for
     * @return Matrix containing the row
     */
    Matrix getRow(int row);

    /**
     * Gets the entire column as a matrix
     *
     * @param col column asked for
     * @return Matrix containing the column
     */
    Matrix getColumn(int col);

    /**
     * Gets a <strong>copy</strong> of the elements as a 2D array.
     * <p/>
     * Copy signifies the fact that any modifications made on the copy will not affect the Source matrix!
     *
     * @return copy of all elements as a 2D array
     */
    double[][] get();

    //COPY

    //Matrix copy();
    //Matrix subMatrix(int initialRow, int initialCol, int finalRow, int finalCol);
    //Matrix subMatrix(int initialRow, int initialCol);

    /**
     * Get a submatrix.
     *
     * @param rowI Initial row index
     * @param colI Initial column index
     * @param rowF Final row index
     * @param colF Final column index
     * @return A(rowI:rowF,colI:colF)
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    public Matrix getSubMatrix(int rowI, int colI, int rowF, int colF);

    /**
     * Get a submatrix.
     *
     * @param r Array of row indices.
     * @param c Array of column indices.
     * @return A(r(:),c(:))
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    public Matrix getSubMatrix(int[] r, int[] c);

    /**
     * Get a submatrix.
     *
     * @param rowI Initial row index
     * @param rowF Final row index
     * @param c    Array of column indices.
     * @return A(i0:i1,c(:))
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    Matrix getSubMatrix(int rowI, int rowF, int[] c);

    /**
     * Get a submatrix.
     *
     * @param r    Array of row indices.
     * @param colI Initial column index
     * @param colF Final column index
     * @return A(r(:),j0:j1)
     * @throws ArrayIndexOutOfBoundsException Submatrix indices
     */

    Matrix getSubMatrix(int[] r, int colI, int colF);
}

/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */package org.jmatrices.dbl.transformer;

/**
 * MatrixConditionalEBETransformation
 * <p>
 * Encapsulates a conditional operation that can be performed on each element of a matrix
 * depending on their position
 * </p>
 * <p>
 * <strong>Usage:</strong>
 * <pre>
 * public static Matrix getScalarMatrix(int dim, final double scalar) {
 *       Matrix m = MatrixFactory.getMatrix(dim, dim);
 *       return MatrixEBETransformer.ebeTransform(m, new MatrixConditionalEBETransformation() {
 *           public double transformer(int row, int col, double element) {
 *               if (row == col)
 *                   return scalar;
 *               return
 *                       element;
 *           }
 *       });
 *   }
 * </pre>
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 12.03.2004
 * Time: 20:20:20
 */
public interface MatrixConditionalEBETransformation {
    /**
     * Transforms an elements value into another value
     *
     * @param row     row to which the element belongs
     * @param col     column to which the element belongs
     * @param element value of the element at row,col
     * @return transformed value
     */
    double transform(int row, int col, double element);
}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jmatrices.dbl.operator;

/**
 * MatrixEBEOperation
 * <p>
 * Encapsulates an operation that can be performed on elements at the same position in
 * two matrices.
 * </p>
 * <p>
 * <strong>Usage:</strong> from {@link MatrixOperator#add(org.jmatrices.dbl.Matrix, org.jmatrices.dbl.Matrix)}
 * <pre>
 * public static Matrix add(Matrix a, Matrix b) {
 *       return applyEBEOperation(a, b, new MatrixEBEOperation() {
 *           public double apply(double a, double b) {
 *               return a + b;
 *           }
 *       });
 *   }
 * </pre>
 * </p>
 * Check out the "See Also" list to find some more methods that use this method
 * <p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 19:17:46
 *
 * @see MatrixOperator
 * @see MatrixOperator#subtract(org.jmatrices.dbl.Matrix, org.jmatrices.dbl.Matrix)
 * @see MatrixOperator#multiplyEBE(org.jmatrices.dbl.Matrix, org.jmatrices.dbl.Matrix)
 * @see MatrixOperator#divideEBE(org.jmatrices.dbl.Matrix, org.jmatrices.dbl.Matrix)
 */
public interface MatrixEBEOperation {
    /**
     * Applies the operation to the elements
     * <p>
     * <font color="blue">
     * todo - perhaps we should provide row, col for better control!
     * </font>
     * </p>
     * @param a element of a matrix
     * @param b element of a matrix
     * @return result of application of an operation
     */
    double apply(double a, double b);
}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jmatrices.dbl.transformer;

/**
 * MatrixEBETransformation
 * <p>
 * Encapsulates an operation that can be performed on each element of a matrix
 * </p>
 * <p>
 * Meant for scalar ebe transformations or ebe function application.
 * </p>
 * <p>
 * <b>Examples:</b>  As annonymous classes ..
 * <pre>
 * private static Matrix scalarAddition(Matrix m, final double s) {
 *       return MatrixEBETransformer.ebeTransform(m, new MatrixEBETransformation() {
 *           public double transformer(double element) {
 *               return element + s; //could be +, *, -, /
 *           }
 *       });
 *   }
 * </pre>
 * <pre>
 * // unary minus or negation
 * new MatrixEBETransformation() {
 *      double transformer(double element) {
 *          return -element;
 *      }
 * };
 * </pre>
 * <pre>
 * //scalar multiplication
 * new MatrixEBETransformation() {
 *      double transformer(double element) {
 *          return 2 * element;
 *      }
 * };
 * </pre>
 * <pre>
 * // function application
 * new MatrixEBETransformation() {
 *      double transformer(double element) {
 *          return Math.sin(element);
 *      }
 * };
 * </pre>
 * </p>
 * <font color="red">
 * This interface may be dropped in the future in favour of the conditional one
 * as that one essentially allows for everything that this interface allows ..
 * or we might drop the MatrixConditionalEBETransformation,
 * replacing the method here with the one in MatrixConditionalEBETransformation
 * </font>
 * <p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 15:54:31
 *
 * @see MatrixEBETransformer
 */
public interface MatrixEBETransformation {
    /**
     * Transforms an elements value into another value
     *
     * @param element value of the element
     * @return transformed value
     */
    double transform(double element);


}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jmatrices.dbl.transformer;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

/**
 * MatrixEBETransformer is responsible for applying the <code>MatrixEBETransformation</code> to each element in a matrix
 * <p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 15:54:06
 *
 * @see MatrixEBETransformation
 * @see MatrixConditionalEBETransformation
 */
public final class MatrixEBETransformer {
    /**
     * Performs a ebeTransform on a matrix
     *
     * @param m     Matrix
     * @param mebet MatrixEBETransformation object responsible for the transformer
     * @return transformed matrix
     */
    public static Matrix ebeTransform(Matrix m, MatrixEBETransformation mebet) {
        int rows = m.rows(), cols = m.cols();
        Matrix transformed = MatrixFactory.getMatrix(rows, cols, m);
        for (int row = 1; row <= rows; row++) {
            for (int col = 1; col <= cols; col++) {
                transformed.set(row, col, mebet.transform(m.get(row, col)));
            }
        }
        return transformed;
    }

    /**
     * Performs a ebeTransform on a matrix
     *
     * @param m      Matrix to be transformed
     * @param mcebet MatrixConditionalEBETransformation object responsible for the transformer
     * @return transformed matrix
     */
    public static Matrix ebeTransform(Matrix m, MatrixConditionalEBETransformation mcebet) {
        int rows = m.rows(), cols = m.cols();
        Matrix transformed = MatrixFactory.getMatrix(rows, cols, m);
        for (int row = 1; row <= rows; row++) {
            for (int col = 1; col <= cols; col++) {
                transformed.set(row, col, mcebet.transform(row, col, m.get(row, col)));
            }
        }
        return transformed;
    }

    private MatrixEBETransformer() {
    }
}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jmatrices.dbl;

import org.jmatrices.dbl.transformer.MatrixConditionalEBETransformation;
import org.jmatrices.dbl.transformer.MatrixEBETransformation;
import org.jmatrices.dbl.transformer.MatrixEBETransformer;

import java.util.Iterator;
import java.util.List;

/**
 * MatrixFactory is one-stop shop for creating matrices.
 * <ol>
 * <li>Rectangular(Square, Vector) matrices, initialized to 0.0, scalar or array of values</li>
 * <li>Scalar Matrices including Identity matrix</li>
 * </ol>
 * <p/>
 * <font color="blue">
 * todo how to provide a mechanism to change implementations (from LightMatrixImpl to HeavyMatrixImpl), intelligent choice or user's choice?
 * <br/>todo consider deserialization of matrices from ascii, mathml, xml files.
 * <br/>todo serialization? through matrix interface ?
 * </font>
 * </p><p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 15:56:59
 */
public class MatrixFactory {
    /**
     * Please refer to the java doc of EmptyMatrix to see the reason for deprecation
     *
     * @return
     * @deprecated
     */
    public static Matrix getEmptyMatrix() {
        return new EmptyMatrix();
    }

    /**
     * Gets a matrix of the asked dimensions.
     * <p/>
     * All elements are set to 0.0
     *
     * @param rows number of rows in the matrix (> 1)
     * @param cols number of columns in the matrix (> 1)
     * @param hint acts as a hint for the right implementation to use
     * @return Matrix of the given dimensions
     */
    public static Matrix getMatrix(int rows, int cols, Matrix hint) {
        if (hint instanceof HeavyMatrixImpl)
            return new HeavyMatrixImpl(rows, cols);
        return new LightMatrixImpl(rows, cols);
    }

    /**
     * Gets a matrix of the asked dimensions, filled with random values
     * <p/>
     *
     * @param rows number of rows in the matrix (> 1)
     * @param cols number of columns in the matrix (> 1)
     * @param hint acts as a hint for the right implementation to use
     * @return Matrix of the given dimensions
     */
    public static Matrix getRandomMatrix(int rows, int cols, Matrix hint) {
        return MatrixEBETransformer.ebeTransform(getMatrix(rows, cols, hint), new MatrixEBETransformation() {
            public double transform(double element) {
                return Math.random();
            }
        });
    }

    public static Matrix getRandomIntMatrix(int rows, int cols, Matrix hint) {
        return MatrixEBETransformer.ebeTransform(getMatrix(rows, cols, hint), new MatrixEBETransformation() {
            public double transform(double element) {
                return (int)(Math.random()*100);
            }
        });
    }


    /**
     * Gets a matrix of the asked dimensions.
     * <p/>
     * All elements are set to scalar.
     *
     * @param rows   number of rows in the matrix (> 1)
     * @param cols   number of columns in the matrix (> 1)
     * @param hint   acts as a hint for the right implementation to use
     * @param scalar initial value of the elements
     * @return Matrix of the given dimensions and value
     */
    public static Matrix getMatrix(int rows, int cols, Matrix hint, double scalar) {
        return scalarAddition(getMatrix(rows, cols, hint), scalar);
    }

    /**
     * Gets a matrix of the asked dimensions.
     * <p/>
     * All elements are set to values in the passed array.
     *
     * @param rows   number of rows in the matrix (> 1)
     * @param cols   number of columns in the matrix (> 1)
     * @param hint   acts as a hint for the right implementation to use
     * @param values initial value of the elements
     * @return Matrix of the given dimensions and values
     */
    public static Matrix getMatrix(int rows, int cols, Matrix hint, double values[][]) {
        Matrix m = getMatrix(rows, cols, hint);
        return populateElements(m, values);
    }

    /**
     * Gets an Identity matrix
     *
     * @param dim  dimension of the square matrix
     * @param hint acts as a hint for the right implementation to use
     * @return Square matrix with the diagonal elements set to 1.
     */
    public static Matrix getIdentityMatrix(int dim, Matrix hint) {
        return getScalarMatrix(dim, hint, 1);
    }

    /**
     * Gets a scalar matrix.
     *
     * @param dim    dimension of the square matrix
     * @param hint   acts as a hint for the right implementation to use
     * @param scalar the value the main diagonal elements have to be set to
     * @return Square matrix with the diagonal elements set to scalar value.
     */
    public static Matrix getScalarMatrix(int dim, Matrix hint, final double scalar) {
        Matrix m = MatrixFactory.getMatrix(dim, dim, hint);
        return MatrixEBETransformer.ebeTransform(m, new MatrixConditionalEBETransformation() {
            public double transform(int row, int col, double element) {
                if (row == col)
                    return scalar;
                return
                        element;
            }
        });
    }

    /**
     * Gets a column vector with list values composing the vector's values.
     * <br/>
     * <b>Note:</b> will throw an <code>IllegalArgumentException</code> if <code>list.size()<=0</code>
     *
     * @param list list containing the <code>Double</code> values that will be used to compose the vector
     * @param hint acts as a hint for the right implementation to use
     * @return column vector
     */
    public static Matrix getMatrix(List list, Matrix hint) {
        if (list.size() <= 0)
            throw new IllegalArgumentException("Array list size should atleast be 1");
        // return MatrixFactory.getEmptyMatrix();
        Matrix cv = getMatrix(list.size(), 1, hint);
        Iterator iter = list.iterator();
        int row = 1;
        while (iter.hasNext()) {
            Double o = (Double) iter.next();
            cv.set(row, 1, o.doubleValue());
            row++;
        }
        return cv;
    }

    /**
     * PRIVATE MEMBERS
     */


    private MatrixFactory() {
    }

    /**
     * todo perhaps should be moved to transformer package and made public!
     *
     * @param m
     * @param s
     * @return
     */
    private static Matrix scalarAddition(Matrix m, final double s) {
        return MatrixEBETransformer.ebeTransform(m, new MatrixEBETransformation() {
            public double transform(double element) {
                return element + s; //could be +, *, -, /
            }
        });
    }

    private static Matrix populateElements(Matrix m, double[][] elems) {
        //todo - performance hit but better management of code - any better solution?!
        if (checkConformity(elems, m.rows(), m.cols())) {
            for (int i = 0; i < elems.length; i++) {
                for (int j = 0; j < elems[i].length; j++) {
                    m.set(i + 1, j + 1, elems[i][j]);
                }
            }
            return m;
        } else
            throw new IllegalArgumentException("Array to initialise doesn't conform with matrix dimensions");
    }


    private static boolean checkConformity(double[][] elems, int rows, int cols) {
        if (elems.length != rows) {
            return false;
        } else {
            for (int row = 0; row < elems.length; row++) {
                if (elems[row].length != cols) return false;
            }
        }
        return true;
    }

}


/**
 *  Jmatrices - Matrix Library
 Copyright (C) 2004  Piyush Purang

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library, see License.txt; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */package org.jmatrices.dbl.measure;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.decomposition.LUDecomposition;
import org.jmatrices.dbl.decomposition.SingularValueDecomposition;
import org.jmatrices.dbl.rowcoltr.ColumnTransformer;
import org.jmatrices.dbl.rowcoltr.RowTransformer;
import org.jmatrices.dbl.transformer.MatrixEBETransformation;
import org.jmatrices.dbl.transformer.MatrixEBETransformer;
import org.jmatrices.dbl.transformer.MatrixTransformer;


/**
 * MatrixMeasure provides important measures associated with a matrix
 * <p/>
 * Given a matrix <strong> M -yields-> value</strong> ,where value is a number.
 * </p>
 * <p/>
 * All operations on a matrix fitting this pattern can be found here!
 * </p>
 * <p/>
 * Author: purangp
 * </p>
 * Date: 08.03.2004
 * Time: 00:09:12
 */
public final class MatrixMeasure {
    //classical measures
    /**
     * Gets the getDeterminant of a non-singular square matrix.
     * <br/>todo is the observation about non-singularity true?
     *
     * @param m Matrix
     * @return detrminant
     */
    public static double getDeterminant(Matrix m) {
        return (new LUDecomposition(m)).det();
    }

    /**
     * Gets the trace of the matrix
     *
     * @param m Matrix
     * @return trace
     */
    public static double getTrace(Matrix m) {
        return ColumnTransformer.sum(MatrixTransformer.diagonal(m)).get(1, 1);
    }

    /**
     * Gets the rank of the matrix
     *
     * @param m Matrix
     * @return rank
     */
    public static int getRank(Matrix m) {
        return (new SingularValueDecomposition(m)).rank();
    }

    //todo do we really need get suffix? as we haven't used it any where else .. that doesn't seem very consistent!!!
    //reasons for .. because it is a gettable property of a matrix
    /**
     * Gets the maximum value occuring in the matrix
     *
     * @param m Matrix
     * @return maximum value
     */
    public static double getMax(Matrix m) {
        return (RowTransformer.max(ColumnTransformer.max(m))).get(1, 1);
    }

    /**
     * Gets the minimum value occuring in the matrix
     *
     * @param m Matrix
     * @return minimum value
     */
    public static double getMin(Matrix m) {
        return (RowTransformer.min(ColumnTransformer.min(m))).get(1, 1);
    }

    /**
     * Gets the sum of all values
     *
     * @param m Matrix
     * @return sum of all values
     */
    public static double getSum(Matrix m) {
        return (RowTransformer.sum(ColumnTransformer.sum(m))).get(1, 1);
    }

    /**
     * Gets the product of all values
     *
     * @param m Matrix
     * @return product of all values
     */
    public static double getProduct(Matrix m) {
        return (RowTransformer.product(ColumnTransformer.product(m))).get(1, 1);
    }

    /**
     * Gets the mean or average of all the values
     * <p>adjustment- calculates the mean by dividing the sum of all values by (n-1) instead of n,
     * which is the number of elements in the matrix</p>
     *
     * @param m          Matrix
     * @param adjustment true or false
     * @return adjusted or unadjusted mean of all values
     */
    public static double getMean(Matrix m, boolean adjustment) {
        double prod = m.rows() * m.cols();
        if (adjustment)
            return ((prod / (prod - 1)) * getMean(m, false));
        else
            return RowTransformer.mean(ColumnTransformer.mean(m, false), false).get(1, 1);
    }


    /**
     * Gets the maximum column sum
     *
     * @param m Matrix
     * @return maximum column sum
     */
    public static double getNorm1(Matrix m) {
        return RowTransformer.max(ColumnTransformer.sum(MatrixEBETransformer.ebeTransform(m, new MatrixEBETransformation() {
            public double transform(double element) {
                return Math.abs(element);
            }
        }))).get(1, 1);
    }

    /**
     * Gets the maximum singular value
     *
     * @param m Matrix
     * @return maximum singular value
     */
    public static double getNorm2(Matrix m) {
        return new SingularValueDecomposition(m).norm2();
    }


    /**
     * Gets the maximum row sum
     *
     * @param m Matrix
     * @return maximum row sum
     */
    public static double getNormInfinity(Matrix m) {
        return ColumnTransformer.max(RowTransformer.sum(MatrixEBETransformer.ebeTransform(m, new MatrixEBETransformation() {
            public double transform(double element) {
                return Math.abs(element);
            }
        }))).get(1, 1);
    }

    /**
     * Gets the sqrt of sum of squares of all elements.
     *
     * @param m Matrix
     * @return sqrt of sum of squares of all elements.
     */
    public static double getNormFrobenius(Matrix m) {
        return Math.sqrt(MatrixMeasure.getSum(MatrixEBETransformer.ebeTransform(m, new MatrixEBETransformation() {
            public double transform(double element) {
                return element * element;
            }
        })));
        //Math.sqrt(ColumnTransformer.sum(diag(multiply(t(m),m))).get(1,1))
    }

    /**
     * Gets the ratio of largest to smallest singular value.
     *
     * @param m Matrix
     * @return ratio of largest to smallest singular value.
     */
    public static double getCondition(Matrix m) {
        return new SingularValueDecomposition(m).cond();
    }


    /**
     * Gets the length of the matrix, which is treated to be the maximum dimension.
     *
     * @param m
     * @return Math.max(m.rows(),m.cols())
     */
    public static int length(Matrix m) {
        return Math.max(m.rows(), m.cols());
    }

    /**
     * Gets the breadth of the matrix, which is treated to be the minimum dimension.
     *
     * @param m
     * @return Math.min(m.rows(),m.cols())
     */
    public static int breadth(Matrix m) {
        return Math.min(m.rows(), m.cols());
    }

    /**
     * private constructor to disallow object creation or extensions
     */
    private MatrixMeasure() {
    }

}

/**
 *  Jmatrices - Matrix Library
 Copyright (C) 2004  Piyush Purang

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library, see License.txt; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package geym.conc.ch5.matrix;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.RecursiveTask;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.operator.MatrixOperator;

public class MatrixMulTask extends RecursiveTask<Matrix> {
    Matrix m1;
    Matrix m2;
    String pos;

    public MatrixMulTask(Matrix m1, Matrix m2, String pos) {
        this.m1 = m1;
        this.m2 = m2;
        this.pos = pos;
    }

    @Override
    protected Matrix compute() {
//        System.out.println(Thread.currentThread().getId()+":"+Thread.currentThread().getName() + " is start");
        if (m1.rows() <= PMatrixMul.granularity || m2.cols() <= PMatrixMul.granularity) {
            Matrix mRe = MatrixOperator.multiply(m1, m2);
            return mRe;
        } else {
            // 如果不是，那么继续分割矩阵
            int rows;
            rows = m1.rows();
            // 左乘的矩阵横向分割
            Matrix m11 = m1.getSubMatrix(1, 1, rows / 2, m1.cols());
            Matrix m12 = m1.getSubMatrix(rows / 2 + 1, 1, m1.rows(), m1.cols());
            // 右乘矩阵纵向分割
            Matrix m21 = m2.getSubMatrix(1, 1, m2.rows(), m2.cols() / 2);
            Matrix m22 = m2.getSubMatrix(1, m2.cols() / 2 + 1, m2.rows(), m2.cols());

            ArrayList<MatrixMulTask> subTasks = new ArrayList<MatrixMulTask>();
            MatrixMulTask tmp = null;
            tmp = new MatrixMulTask(m11, m21, "m1");
            subTasks.add(tmp);
            tmp = new MatrixMulTask(m11, m22, "m2");
            subTasks.add(tmp);
            tmp = new MatrixMulTask(m12, m21, "m3");
            subTasks.add(tmp);
            tmp = new MatrixMulTask(m12, m22, "m4");
            subTasks.add(tmp);
            for (MatrixMulTask t : subTasks) {
                t.fork();
            }
            Map<String, Matrix> matrixMap = new HashMap<String, Matrix>();
            for (MatrixMulTask t : subTasks) {
                matrixMap.put(t.pos, t.join());
            }
            Matrix tmp1 = MatrixOperator.horizontalConcatenation(matrixMap.get("m1"), matrixMap.get("m2"));
            Matrix tmp2 = MatrixOperator.horizontalConcatenation(matrixMap.get("m3"), matrixMap.get("m4"));
            Matrix reM = MatrixOperator.verticalConcatenation(tmp1, tmp2);
            return reM;
        }
    }
}
package org.jmatrices.dbl.operator;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.decomposition.LUDecomposition;
import org.jmatrices.dbl.decomposition.QRDecomposition;
import org.jmatrices.dbl.measure.MatrixProperty;
import org.jmatrices.dbl.transformer.MatrixEBETransformation;
import org.jmatrices.dbl.transformer.MatrixEBETransformer;

/**
 * MatrixOperator provides important operations that can be performed on two or more matrices
 * <p/>
 * Given two matrices <strong> A,B -yields-> C</strong> ,where C is another matrix.
 * </p>
 * <p/>
 * All operations on a matrix fitting this pattern can be found here!
 * </p>
 * <p/>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 18:09:51
 */
public final class MatrixOperator {
    /**
     * Applies element-by-element operation combining the elements of the two matrices
     * <br/>
     * <strong>Note:</strong> Matrix <code>a</code>'s underlying implementation is propogated in the resulting matrix
     * <br/>
     * <strong>Usage:</strong> from {@link MatrixOperator#add(org.jmatrices.dbl.Matrix, org.jmatrices.dbl.Matrix)}
     * <pre>
     * public static Matrix add(Matrix a, Matrix b) {
     *       return applyEBEOperation(a, b, new MatrixEBEOperation() {
     *           public double apply(double a, double b) {
     *               return a + b;
     *           }
     *       });
     *   }
     * </pre>
     * <strong>Hypothetical Usage:</strong>
     * <pre>
     * public static Matrix doSomeThing(Matrix a, Matrix b, final double n) {
     *       return applyEBEOperation(a, b, new MatrixEBEOperation() {
     *           public double apply(double a, double b) {
     *               return (a^2 + b^2)^n;
     *           }
     *       });
     *   }
     * </pre>
     *
     * @param a  Matrix
     * @param b  Matrix
     * @param mo Class
     * @return resultant Matrix
     */

    public static Matrix applyEBEOperation(Matrix a, Matrix b, MatrixEBEOperation mo) {
        int rows_a = a.rows(), cols_a = a.cols(), rows_b = b.rows(), cols_b = b.cols();
        Matrix c;
        if (rows_a != rows_b && cols_a != cols_b) {
            throw new IllegalArgumentException("Dimensions of a and b don't conform");
        } else {
            c = MatrixFactory.getMatrix(rows_a, cols_b, a);
            for (int row = 1; row <= rows_a; row++) {
                for (int col = 1; col <= cols_a; col++) {
                    c.set(row, col, mo.apply(a.get(row, col), b.get(row, col)));
                }
            }
        }
        return c;
    }

    /**
     * Solves the system of equations. Matrix x doesn't need to be square!
     * <p/>
     * Please pay attention to the dimensions of the two matrices!
     *
     * @param x The coefficient matrix
     * @param b The constant vector
     * @return The solution matrix or c = x / b
     */
    public static Matrix solve(Matrix x, Matrix b) {
        return (MatrixProperty.isSquare(x) ?
                new LUDecomposition(x).solve(b) :
                new QRDecomposition(x).solve(b));
    }

    /**
     * Matrix Addition
     * <p/>
     * Matrices must be of the same dimensions!
     *
     * @param a Matrix
     * @param b Matrix
     * @return c = a + b
     */
    public static Matrix add(Matrix a, Matrix b) {
        return applyEBEOperation(a, b, new MatrixEBEOperation() {
            public double apply(double a, double b) {
                return a + b;
            }
        });
    }

    /**
     * Matrix Subtraction
     * <p/>
     * Matrices must be of the same dimensions!
     *
     * @param a Matrix
     * @param b Matrix
     * @return c = a - b
     */
    public static Matrix subtract(Matrix a, Matrix b) {
        return applyEBEOperation(a, b, new MatrixEBEOperation() {
            public double apply(double a, double b) {
                return a - b;
            }
        });
    }

    /**
     * Matrix multiplication
     * <br/>
     * <strong>Note:</strong> Matrix <code>a</code>'s underlying implementation is propogated in the resulting matrix
     * <br/>
     * <p/>
     * Matrix dimensions must conform with the rules of matrix multiplication!
     *
     * @param a Matrix
     * @param b Matrix
     * @return c = a * b
     */
    public static Matrix multiply(Matrix a, Matrix b) {
        int rows_a = a.rows(), cols_a = a.cols(), rows_b = b.rows(), cols_b = b.cols();
        Matrix c;
        if (cols_a != rows_b) {
            throw new IllegalArgumentException("Dimensions of matrices don't conform for multiplication");
        } else {
            c = MatrixFactory.getMatrix(rows_a, cols_b, a);
            //pick a row in a
            for (int row_a = 1; row_a <= rows_a; row_a++) {

                //pick a col in b
                for (int col_b = 1; col_b <= cols_b; col_b++) {
                    //iterate over all cols in the selected row for a

                    for (int col_a = 1; col_a <= cols_a; col_a++) {
                        double tmp = 0D;
                        //iterate over all rows in the selected col for b
                        for (int row_b = 1; row_b <= rows_b; row_b++) {
                            double elem_a = a.get(row_a, row_b), elem_b = b.get(row_b, col_b);
                            tmp = tmp + elem_a * elem_b;
                        }
                        c.set(row_a, col_b, tmp);
                    }
                }
            }
        }
        return c;
    }

    /**
     * Element-by-elemnt Matrix Multiplication
     * <p/>
     * Matrices must be of the same dimensions!
     *
     * @param a Matrix
     * @param b Matrix
     * @return c = a .* b
     */
    public static Matrix multiplyEBE(Matrix a, Matrix b) {
        return applyEBEOperation(a, b, new MatrixEBEOperation() {
            public double apply(double a, double b) {
                return a * b;
            }
        });
    }

    /**
     * Element-by-elemnt Matrix division
     * <p/>
     * Matrices must be of the same dimensions!
     *
     * @param a Matrix
     * @param b Matrix
     * @return c = a ./ b
     */
    public static Matrix divideEBE(Matrix a, Matrix b) {
        return applyEBEOperation(a, b, new MatrixEBEOperation() {
            public double apply(double a, double b) {
                return a / b;
            }
        });
    }

    /**
     * Concatenates <code>a</code> and <code>b</code> horizontally with
     * <code>b</code>'s columns attached to the end of <code>a</code>
     * <p/>
     * rows of <code>a</code> must be equal to rows of <code>b</code>
     * <br/>
     * <strong>Note:</strong> Matrix <code>a</code>'s underlying implementation is propogated in the resulting matrix
     * <br/>
     *
     * @param a Matrix
     * @param b Matrix
     * @return c = a~b //gauss syntax
     */
    public static Matrix horizontalConcatenation(Matrix a, Matrix b) {
        int rows_a = a.rows(), cols_a = a.cols(), rows_b = b.rows(), cols_b = b.cols();
        Matrix c;
        if (rows_a != rows_b) {
            throw new IllegalArgumentException("Dimensions of a and b don't conform");
        } else {
            c = MatrixFactory.getMatrix(rows_a, cols_a + cols_b, a);
            for (int row = 1; row <= rows_a; row++) {
                for (int col_a = 1; col_a <= cols_a; col_a++) {
                    c.set(row, col_a, a.get(row, col_a));
                }
                for (int col_b = 1; col_b <= cols_b; col_b++) {
                    c.set(row, cols_a + col_b, b.get(row, col_b));
                }
            }
        }
        return c;
    }

    /**
     * Concatenates <code>a</code> and <code>b</code> vertically with
     * <code>b</code>'s rows following the <code>a</code>'s rows
     * <p/>
     * cols of <code>a</code> must be equal to colss of <code>b</code>
     * <br/>
     * <strong>Note:</strong> Matrix <code>a</code>'s underlying implementation is propogated in the resulting matrix
     * <br/>
     *
     * @param a Matrix
     * @param b Matrix
     * @return c = a|b //gauss syntax
     */
    public static Matrix verticalConcatenation(Matrix a, Matrix b) {
        int rows_a = a.rows(), cols_a = a.cols(), rows_b = b.rows(), cols_b = b.cols();
        Matrix c;
        if (cols_a != cols_b) {
            throw new IllegalArgumentException("Dimensions of a and b don't conform");
        } else {
            c = MatrixFactory.getMatrix(rows_a + rows_b, cols_a, a);
            for (int col = 1; col <= cols_a; col++) {
                for (int row_a = 1; row_a <= rows_a; row_a++) {
                    c.set(row_a, col, a.get(row_a, col));
                }
                for (int row_b = 1; row_b <= rows_b; row_b++) {
                    c.set(rows_a + row_b, col, b.get(row_b, col));
                }
            }
        }
        return c;
    }

    /**
     * Gets the Kronecker (tensor) product of the two matrices,
     * every element of <code>a</code> has been multiplied (scalar multilication)
     * by the matrix <code>b</code>
     * <pre>
     * a =
     * 1 2
     * 3 4
     *
     * b =
     * 4 5 6
     * 7 8 9
     *
     * kroneckerProduct(a, b)=
     * 4  5  6   8  10 12
     * 7  8  9   14 16 18
     * 12 15 18  16 20 24
     * 21 24 27  28 32 36
     * </pre>
     *
     * @param a
     * @param b
     * @return
     */
    public static Matrix kroneckerProduct(Matrix a, Matrix b) {
        /**
         * 1. pick first row
         * 2.      pick first column
         * 3.          scalar multiplication of a(1,1) with b.
         * 4.              assign to temp horizresult
         * 5. repeat for second element in the row
         * 6. do horizontal cocatenation with temp horizresult assign back to temp horizresult
         * 7. so on till all columns are exhausted.
         * 8. assign the resulting temp horizresult to  temp vertresult
         * 9. repeat creating temp horizresult for next row
         * 10. do vertical cocatenation with temp vertresult and assign back to temp vertresult
         * 11 exhaust all rows.
         */
        Matrix tmpVert = null;
        for (int row = 1; row <= a.rows(); row++) {
            Matrix horizVert = null;
            //columns in a row
            for (int col = 1; col <= a.cols(); col++) {
                final double scalar = a.get(row, col);
                if (horizVert == null)
                    horizVert = MatrixEBETransformer.ebeTransform(b, new MatrixEBETransformation() {
                        public double transform(double element) {
                            return scalar * element;
                        }
                    });
                else
                    horizVert = MatrixOperator.horizontalConcatenation(horizVert, MatrixEBETransformer.ebeTransform(b, new MatrixEBETransformation() {
                        public double transform(double element) {
                            return scalar * element;
                        }
                    }));
            }
            if (tmpVert == null)
                tmpVert = horizVert;
            else
                tmpVert = MatrixOperator.verticalConcatenation(tmpVert, horizVert);
        }
        return tmpVert;
    }

    /**
     * Gets the Horizontal Direct Product. <br/> <b>Note</b>  Both matrices must have the same number of rows.
     * <pre>
     * a =
     * 1 2
     * 3 4
     *
     * b =
     * 5 6
     * 7 8
     *
     * horizontalDirectProduct(a, b)=
     *  5  6 10 12
     * 21 24 28 32
     * </pre>
     *
     * @param a
     * @param b
     * @return
     */
    public static Matrix horizontalDirectProduct(Matrix a, Matrix b) {
        int rows_a = a.rows(), rows_b = b.rows();
        if(rows_a != rows_b)
            throw new IllegalArgumentException("Rows of a and b must be equal");
        else {
            Matrix tmpVert=null;
            for (int row=1; row<=rows_a; row++) {
                Matrix rowA = a.getRow(row), rowB = b.getRow(row);
                if (tmpVert == null)
                    tmpVert = MatrixOperator.kroneckerProduct(rowA,rowB);
                else
                    tmpVert = MatrixOperator.verticalConcatenation(tmpVert, MatrixOperator.kroneckerProduct(rowA,rowB));
            }
            return tmpVert;
        }
    }

    private MatrixOperator() {
    }
}


/**
 *  Jmatrices - Matrix Library
 Copyright (C) 2004  Piyush Purang

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library, see License.txt; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */package org.jmatrices.dbl.client;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * MatrixParser
 * <p>Author: purangp</p>
 * Date: 30.04.2004
 * Time: 15:02:25
 */
class MatrixParser {
    public static final MatrixStringParser matlabMatrixParser = new MatrixStringParser("\\[", "\\]", ";", ",");
    public static final MatrixStringParser gaussMatrixParser = new MatrixStringParser("\\{", "\\}", ",", "\\s");

    public static Matrix parseMatrix(String src, MatrixStringParser parser) {
        return parser.parse(src);
    }

    public static final Matrix parseMatlabMatrix(String src) {
        return parseMatrix(src, matlabMatrixParser);
    }

    public static final Matrix parseGaussMatrix(String src) {
        return parseMatrix(src, gaussMatrixParser);
    }


    static class MatrixStringParser {
        private String startString;
        private String endString;
        private String rowSeperator;
        private String elementSeperator;

        public MatrixStringParser(String startString, String endString, String rowSeperator, String elementSeperator) {
            this.startString = startString;
            this.endString = endString;
            this.rowSeperator = rowSeperator;
            this.elementSeperator = elementSeperator;
        }

        private Matrix parse(String src) {
            src = removeDuplicateWhitespace(src);
            double[][] values = divideIntoElements(divideIntoRows(discardStartEnd(src)));
            return MatrixFactory.getMatrix(values.length, values[0].length, null, values);
        }

        private String discardStartEnd(String src) {
            src = src.split(startString)[1];
            src = src.split(endString)[0];
            return src;
        }

        private String[] divideIntoRows(String src) {
            return src.split(rowSeperator);
        }

        private double[][] divideIntoElements(String[] rows) {
            double[][] values = new double[rows.length][];
            for (int row = 0; row < rows.length; row++) {
                values = divideIntoElements(values, row, removeDuplicateWhitespace(rows[row]));
            }
            return values;
        }

        private double[][] divideIntoElements(double[][] values, int row, String rowStr) {
            String[] strElements = rowStr.trim().split(elementSeperator);
            values[row] = new double[strElements.length];
            for (int element = 0; element < strElements.length; element++) {
                values[row][element] = Double.parseDouble(removeDuplicateWhitespace(strElements[element]));
            }
            return values;
        }

        private static String removeDuplicateWhitespace(String inputStr) {
            String patternStr = "\\s+";
            String replaceStr = " ";
            Pattern pattern = Pattern.compile(patternStr);
            Matcher matcher = pattern.matcher(inputStr);
            return matcher.replaceAll(replaceStr);
        }

    }

    public static void main(String[] args) {
        System.out.println(MatrixParser.parseMatlabMatrix("   [     -2,3.5,6;   7,8, 9.0; 10,-11,12    ]   "));
        System.out.println(MatrixParser.parseGaussMatrix("{ 2 -3.5 6 , 7 -8 9.0, 10 11 12}"));
    }


}
package org.jmatrices.dbl.decomposition;

/**
 * MatrixPartition
 *
 * <br/>
 * Author: purangp
 * <br/>
 * Date: 12.03.2004
 * Time: 14:08:50
 */
public class MatrixPartition {
    //also called matrix blocks?
    //see page 347 of Mathematics for Economics
}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jmatrices.dbl.transformer;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.Matrix;

/**
 * MatrixPermute
 * <p>
 * <font color="blue">
 * This is an open thought on a direction that we might take and that might ease
 * decompositions!!
 * </font>
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 12.03.2004
 * Time: 12:43:51
 */
public class MatrixPermute {
    public static Matrix swapRow(int row1, int row2) {
        return null;
    }

    public static Matrix swapColumn(int col1, int col2) {
        return null;
    }

    private MatrixPermute() {
    }
}

/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jmatrices.dbl.measure;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.decomposition.CholeskyDecomposition;
import org.jmatrices.dbl.decomposition.LUDecomposition;
import org.jmatrices.dbl.transformer.MatrixTransformer;
import org.jmatrices.dbl.Matrix;

/**
 * MatrixProperty
 * <p>
 * Given a matrix <strong> M -yields-> value</strong> ,where value is boolean (true or false).
 * </p>
 * <p>
 * All operations on a matrix fitting this pattern can be found here!
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 08.03.2004
 * Time: 23:15:14
 */
public final class MatrixProperty {

    /**
     * Determines whether or not a matrix is a Column Vector
     *
     * @param m
     * @return true iff m has only one column
     */
    public static boolean isColumnVector(Matrix m) {
        return m.cols() == 1;
    }

    /**
     * Determines whether or not a matrix is a Row Vector
     *
     * @param m
     * @return true iff m has only one row
     */
    public static boolean isRowVector(Matrix m) {
        return m.rows() == 1;
    }

     /**
     * Determines whether or not a matrix is a Row or a Column Vector
     *
     * @param m
     * @return true iff m has only one row
     */
    public static boolean isVector(Matrix m) {
        return (m.cols() ==1 || m.rows() == 1);
    }

    /**
     * Determines whether or not a matrix is a <strong>square</strong> matrix.
     *
     * @param m
     * @return true iff m has as many columns as it has rows
     */
    public static boolean isSquare(Matrix m) {
        return m.rows() == m.cols();
    }

    /**
     * Determines whether or not a matrix is <strong>Symmetric</strong>
     *
     * @param m
     * @return true iff A' = A
     */
    public static boolean isSymmetric(Matrix m) {
        return MatricesMeasure.areEqual(m, MatrixTransformer.transpose(m));
    }

    /**
     * Determines whether or not a matrix is <strong>SkewSymmetric</strong>
     *
     * @param m
     * @return true if A' = -A
     */
    public static boolean isSkewSymmetric(Matrix m) {
        return MatricesMeasure.areEqual(MatrixTransformer.transpose(m), MatrixTransformer.negate(m));
    }

    /**
     * Determines whether or not a matrix is <strong>Idempotent</strong>
     *
     * @param m
     * @return true if A = AA = AAA = AAAA...  or A = A<sup>2</sup> = A<sup>3</sup>= A<sup>4</sup> ..
     */
    public static boolean isIdempotent(Matrix m) {
        return MatricesMeasure.areEqual(m, MatrixTransformer.pow(m, 2));
    }

    //magic square - a square matrix of n rows and columns; the first n-squared integers are arranged in the cells of the matrix is such a way that the sum of any row or column or diagonal is the same
    /**
     * <font color="blue">todo implement</font>
     *
     * @param m
     * @return
     */
    public static boolean isMagicSquare(Matrix m) {
        throw new UnsupportedOperationException("to be implemented");
    }


    /**
     * Determines whether or not a square matrix is <strong>Singular</strong> i.e has no inverse.
     *
     * @param m Matrix
     * @return true iff A<sup>-1</sup> exists
     */
    public static boolean isSingular(Matrix m) {
        return new LUDecomposition(m).isSingular();
    }

    /**
     * Determines whether or not a square matrix is a <strong>Diagonal</strong>  matrix
     *
     * @param m Matrix
     * @return true iff a<sub>i</sub><sub>j</sub>=0 , for all i <> j
     * @see MatrixProperty#isScalar(org.jmatrices.dbl.Matrix)
     */
    public static boolean isDiagonal(Matrix m) {
        if (isSquare(m)) {
            for (int row = 1; row <= m.rows(); row++) {
                for (int col = 1; col <= m.cols(); col++) {
                    if (row != col && m.get(row, col) != 0)
                        return false;
                }
            }
            return true;
        } else
            return false;
    }

    /**
     * Determines whether or not a diagonal matrix is an <strong>Identity</strong> matrix
     *
     * @param m Matrix
     * @return true iff a<sub>i</sub><sub>j</sub>=0 , for all i <> j  and a<sub>i</sub><sub>j</sub>=1 , for all i = j
     */
    public static boolean isIdentity(Matrix m) {
        return isSquare(m) && MatricesMeasure.areEqual(m, MatrixFactory.getIdentityMatrix(m.rows(), null));
    }

    /**
     * Determines whether or not a diagonal matrix is an <strong>Unit</strong> matrix or an <strong>Identity</strong> matrix
     *
     * @param m Matrix
     * @return true iff a<sub>i</sub><sub>j</sub>=0 , for all i <> j  and a<sub>i</sub><sub>j</sub>=1 , for all i = j
     */
    public static boolean isUnit(Matrix m) {
        return isIdentity(m);
    }

    /**
     * Determines whether or not a matrix is upper triangular in form
     *
     * @param m
     * @return true if matrix is upper triangular in form
     */
    public static boolean isUpperTriangular(Matrix m) {
        return MatricesMeasure.areEqual(MatrixTransformer.extractUpperTriangular(m,0),m);
    }

    /**
     * Determines whether or not a matrix is lower triangular in form
     *
     * @param m
     * @return true if matrix is lower triangular in form
     */
    public static boolean isLowerTriangular(Matrix m) {
        return MatricesMeasure.areEqual(MatrixTransformer.extractLowerTriangular(m,0),m);
    }

    /**
     * Determines whether or not a square matrix is a <strong>Scalar</strong>  matrix
     * <p/>
     * scalar matrix - a diagonal matrix in which all of the diagonal elements are areEqual
     * </p>
     * //todo find a better way?
     *
     * @param m Matrix
     * @return true iff a<sub>i</sub><sub>j</sub>=0 , for all i <> j  and a<sub>i</sub><sub>j</sub>=c , for all i = j
     * @see MatrixProperty#isDiagonal(org.jmatrices.dbl.Matrix)
     */
    public static boolean isScalar(Matrix m) {
        //we could have done this in many ways ..
        double tmp = 0.0;
        boolean firstIter = true;
        if (isSquare(m)) {
            for (int row = 1; row <= m.rows(); row++) {
                for (int col = 1; col <= m.cols(); col++) {
                    if (row != col && m.get(row, col) != 0)
                        return false;
                    else if (row == col) {
                        if (firstIter) {
                            tmp = m.get(row, col);
                            firstIter = false;
                        } else {
                            if (tmp != m.get(row, col))
                                return false;
                        }
                    }
                }
            }
            return true;
        } else
            return false;
    }


    //Not sure but I hope it does what it says!
    public static boolean isSymetricPositiveDefinite(Matrix m) {
        return new CholeskyDecomposition(m).isSPD();
    }

    /**
     * <font color="blue">todo implement</font>
     *
     * @param m
     * @return
     */
    public static boolean isDefinitePositive(Matrix m) {
        throw new UnsupportedOperationException("to be implemented");
    }

    /**
     * <font color="blue">todo implement</font>
     *
     * @param m
     * @return
     */
    public static boolean isSemiDefinitePositive(Matrix m) {
        throw new UnsupportedOperationException("to be implemented");
    }

    /**
     * <font color="blue">todo implement</font>
     */
    public class MatrixBandwidth {
        //check
        //http://www.cs.ut.ee/~toomas_l/linalg/lin1/node13.html
    }

    private MatrixProperty() {
    }
}

/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */package org.jmatrices.dbl.transformer;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.measure.MatrixMeasure;
import org.jmatrices.dbl.measure.MatrixProperty;
import org.jmatrices.dbl.operator.MatrixOperator;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * MatrixTransformer is responsible for classical non element-by-element transformer of a matrix
 * <p/>
 * Captures classical transformations that aren't applicable in an element-by-element way (only exception is {@link #negate(org.jmatrices.dbl.Matrix)} )
 * <p/>
 * <p><font color="blue">
 * We might decide to remove this restriction and provide some important ebe transformations here
 * or we might move them(to be methods) and negate to {@link MatrixEBETransformer}
 * </font></p>
 * <p/>
 * Author: purangp
 * <br/>
 * Date: 07.03.2004
 * Time: 17:03:20
 *
 * @see MatrixEBETransformation
 * @see MatrixEBETransformer
 */
public final class MatrixTransformer {
    /**
     * Transforms the matrix by negating all the elements
     *
     * @param m Matrix
     * @return -a<sub>i</sub><sub>j</sub> for all i,j
     */
    public static Matrix negate(Matrix m) {
        return MatrixEBETransformer.ebeTransform(m, new MatrixEBETransformation() {
            public double transform(double element) {
                return -element;
            }
        });
    }

    /**
     * Transforms the matrix into it's transpose
     *
     * @param m
     * @return A'
     */
    public static Matrix transpose(Matrix m) {
        int rows = m.rows(), cols = m.cols();
        Matrix transposed = MatrixFactory.getMatrix(cols, rows, m);
        for (int row = 1; row <= rows; row++) {
            for (int col = 1; col <= cols; col++) {
                transposed.set(col, row, m.get(row, col));
            }
        }
        return transposed;
    }

    /**
     * Inverts the matrix
     *
     * @param m Matrix
     * @return A<sup>-1</sup>
     */
    public static Matrix inverse(Matrix m) {
        return MatrixOperator.solve(m, MatrixFactory.getIdentityMatrix(m.rows(), m));
    }

    /**
     * Column vector contatining the diagonal elements of the matrix
     * <pre>
     *    x=
     *  1 0 0
     *  0 1 0
     *  0 0 1
     *   then y = diagonal(x) is
     *  1
     *  1
     *  1
     * <pre>
     *
     * @param m
     * @return c(mx1) column vector containing the diagonal elements of the matrix
     */
    public static Matrix diagonal(Matrix m) {
        int rows = m.rows(), cols = m.cols();
        Matrix diagonal;
        if (rows == 1 && cols == 1) {
            return m;
        } else {
            diagonal = MatrixFactory.getMatrix(rows, 1, m);
            for (int row = 1; row <= rows; row++) {
                for (int col = 1; col <= cols; col++) {
                    if (row == col)
                        diagonal.set(row, 1, m.get(row, col));
                }
            }
        }
        return diagonal;
    }

    /**
     * Returns a matrix with diagonal (indicated by offset)
     * composed of the elements from the passed row or column vector <code>m</code>
     *
     * @param m a column or row Vector
     * @param offset the diagonal to be embeded (=0 will embed the elements as the main diagonal)
     * @return
     */
    public static Matrix embedDiagonal(Matrix m, int offset) {
        switch (m.rows()) {
            case 1:
                //if row matrix let us convert it into column matrix and let program execution fall through to the next case
                m = MatrixTransformer.transpose(m);
            default:
                //not a row matrix
                switch (m.cols()) {
                    //if it is column vector or was a row vector and now is a column vector
                    case 1:
                        int d = Math.abs(offset) + MatrixMeasure.length(m);
                        Matrix dm = MatrixFactory.getMatrix(d, d, m);
                        if (offset > 0) {
                            for (int row = 1; row <= MatrixMeasure.length(m); row++) {
                                dm.set(row, row + offset, m.get(row, 1));
                            }
                        } else {
                            for (int row = 1; row <= MatrixMeasure.length(m); row++) {
                                dm.set(row + Math.abs(offset), row, m.get(row, 1));
                            }
                        }
                        return dm;
                }
        }
        throw new IllegalArgumentException("Matrix m must be a row or column vector");

    }

    /**
     * Gets the elements of the indicated diagonal (offset) as a column vector
     * @param m
     * @param offset the diagonal to be extracted (=0 will extract the main diagonal)
     * @return Column vector of elements extracted from the indiacated diagonal
     */
    public static Matrix extractDiagonal(Matrix m, int offset) {
        if (MatrixProperty.isVector(m)) {
            throw new IllegalArgumentException("Matrix m can't be a Column or a Row Vector");
        } else {
            int length = MatrixMeasure.length(m);
            if (offset > 0) {
                System.out.println("offset > 0");
                //Matrix cv = MatrixFactory.getMatrix(length-offset,1);
                ArrayList list = new ArrayList(10);
                for (int row = 1; row <= length - offset; row++) {
                    //System.out.println("Trying to access" + row+","+ (row + offset));
                    if (row <= m.rows() && row + offset <= m.cols())  {
                       //System.out.println("Adding "+m.get(row, row + offset));
                       list.add(new Double(m.get(row, row + offset)));
                    }
                }
                return MatrixFactory.getMatrix(list,m);
            } else {
                if (length + offset < 1)
                    throw new IllegalArgumentException("Length of the matrix and offset combine to yield illegal matrix indices");
                    //return MatrixFactory.getEmptyMatrix();
                //Matrix cv = MatrixFactory.getMatrix(length + offset, 1);
                ArrayList list = new ArrayList(10);
                for (int row = 1; row <= length + offset; row++) {
                    //System.out.println("Trying to access" + (row + Math.abs(offset)) +","+ row);
                    if (row + Math.abs(offset) <= m.rows() && row <= m.cols()) {
                        //System.out.println("Adding "+m.get(row + Math.abs(offset), row));
                        list.add(new Double(m.get(row + Math.abs(offset), row)));
                    }
                }
                return MatrixFactory.getMatrix(list, m);
            }
        }
    }

    /**
     * Extracts the upper triangular matrix given an offset that indicates the relative diagonal
     * <br/>
     *
     * @param m
     * @param offset
     * @return
     */
    public static Matrix extractUpperTriangular(Matrix m, int offset) {
        int rows = m.rows(), cols = m.cols();
        Matrix ut = MatrixFactory.getMatrix(rows, cols,m);
        for (int row = 1; row <= MatrixMeasure.length(m) - Math.abs(offset); row++) {
            for (int col = row + Math.abs(offset); col <= MatrixMeasure.length(m); col++) {
                if (row <= rows && col <= cols)
                    ut.set(row, col, m.get(row, col));
            }
        }

        if (offset < 0) {
            for (int row = 1; row <= m.rows(); row++) {
                for (int col = Math.max(1, row + offset); col <= Math.min(MatrixMeasure.length(m), row - offset - 1); col++) {
                    if (row <= rows && col <= cols)
                        ut.set(row, col, m.get(row, col));
                }
            }

        }
        return ut;
    }

    /**
     * Extracts the lower triangular matrix given an offset that indicates the relative diagonal
     * <br/>
     *
     * @param m
     * @param offset
     * @return
     */
    public static Matrix extractLowerTriangular(Matrix m, int offset) {
        return MatrixOperator.subtract(m, MatrixTransformer.extractUpperTriangular(m, offset + 1));
    }

    /**
     * Multiplies the square matrix with itself multiple times.
     *
     * @param m is a square matrix
     * @param n if n>1 performs the operation else if (n<=0) returns a matrix composed of ones.
     * @return C = A<sup>n</sup>
     */
    public static Matrix pow(Matrix m, int n) {
        if (MatrixProperty.isSquare(m)) {
            if (n <= 0)
                return MatrixFactory.getMatrix(m.rows(), m.cols(), m, 1);
            Matrix result = m;
            for (int counter = 2; counter <= n; counter++) {  //if n==1 then just return m goon with the loop iff n >= 2
                result = MatrixOperator.multiply(m, result);
            }
            return result;
        } else
            throw new IllegalArgumentException("m must be a square matrix");
    }


    /**
     * //secondary diagonal - the diagonal of a square matrix running from the lower left entry to the upper right entry
     * <pre>
     * to implement it use ....
     * 1. first element is 0 and col
     * 2. second element is (0+1)or1 and col-1
     * 3. third element is   (1+1)or2 and col-2
     * 4. and so on till rows() and 0 is reached ..
     * </pre>
     *
     * @param m
     * @return
     */
    public static Matrix secondaryDiagonal(Matrix m) {
        throw new UnsupportedOperationException("to be implemented");
    }

    /**
     * <pre>
     * x =
     * 1 -3
     * 2  2
     * 3 -1
     *
     * y = cumulativeColumnProduct(x);
     * 1 -3
     * 2 -6
     * 6 6
     * </pre>
     *
     * @param m
     * @return
     */
    public static Matrix cumulativeColumnProduct(Matrix m) {
       Matrix result = MatrixFactory.getMatrix(m.rows(),m.cols(),m);
       for(int row=1; row<=m.rows();row++){
           for(int col=1; col<=m.cols(); col++){
               if(row==1)
                result.set(row,col,m.get(row,col));
               else
               result.set(row,col,result.get(row-1,col)*m.get(row,col));
           }
       }
        return result;
    }

    /**
     * <pre>
     * x =
     * 1 -3
     * 2  2
     * 3 -1
     *
     * y = cumulativeColumnSum(x);
     * 1 -3
     * 3 -1
     * 6 -2
     * </pre>
     *
     * @param m
     * @return
     */
    public static Matrix cumulativeColumnSum(Matrix m) {
       Matrix result = MatrixFactory.getMatrix(m.rows(),m.cols(),m);
       for(int row=1; row<=m.rows();row++){
           for(int col=1; col<=m.cols(); col++){
               if(row==1)
                result.set(row,col,m.get(row,col));
               else
               result.set(row,col,result.get(row-1,col)+m.get(row,col));
           }
       }
        return result;
    }

    private MatrixTransformer() {
    }

}


/**
 *  Jmatrices - Matrix Library
 Copyright (C) 2004  Piyush Purang

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library, see License.txt; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */package org.jmatrices.dbl;

/**
 * MatrixVector
 * <p>
 * <font color="blue">
 * todo - open thought!
 * </font>
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 10.03.2004
 * Time: 16:50:35
 */
public interface MatrixVector {
    int rows();

    int cols();

    double get(int row, int col);

    void set(int row, int col, double value);

    Vector getRowVector(int row);

    Vector getColumnVector(int col);
}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jmatrices.dbl;

import org.jmatrices.dbl.MatrixVector;

/**
 * MatrixVectorImpl
 * <p>
 * <font color="blue">
 * todo - open thought!
 * </font>
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 21:57:18
 */
public class MatrixVectorImpl implements MatrixVector {
    int cols, rows;

    Vector[] rowVectors;
    Vector[] columnVectors;

    public int rows() {
        return rows;
    }

    public int cols() {
        return cols;
    }

    public double get(int row, int col) {
        return 0;
    }

    public void set(int row, int col, double value) {
    }

    public Vector getRowVector(int row) {
        return null;
    }

    public Vector getColumnVector(int col) {
        return null;
    }


}

/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */ package geym.conc.ch3.pool;

import java.util.concurrent.Executor;

import com.google.common.util.concurrent.MoreExecutors;

public class MoreExecutorsDemo {
    public static void main(String[] args) {
        Executor exceutor = MoreExecutors.directExecutor();
        exceutor.execute(() -> System.out.println("I am running in " + Thread.currentThread().getName()));
    }
}
package geym.conc.ch3.pool;

import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

import com.google.common.util.concurrent.MoreExecutors;

public class MoreExecutorsDemo2 {
    public static void main(String[] args) {
        ThreadPoolExecutor exceutor = (ThreadPoolExecutor)Executors.newFixedThreadPool(2);
        MoreExecutors.getExitingExecutorService(exceutor);
        exceutor.execute(() -> System.out.println("I am running in " + Thread.currentThread().getName()));
    }
}
package geym.conc.ch5.pstream.demo;

public class Msg {
	public double i;
	public double j;
	public String orgStr=null;
}
package geym.conc.ch5.pstream.demo;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class Multiply implements Runnable {
	public static BlockingQueue<Msg> bq = new LinkedBlockingQueue<Msg>();

	@Override
	public void run() {
		while (true) {
			try {
				Msg msg = bq.take();
				msg.i = msg.i * msg.j;
				Div.bq.add(msg);
			} catch (InterruptedException e) {
			}
		}
	}
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.locks.LockSupport;

import sun.misc.Unsafe;

import com.lmax.disruptor.util.Util;


/**
 * <p>Coordinator for claiming sequences for access to a data structure while tracking dependent {@link Sequence}s.
 * Suitable for use for sequencing across multiple publisher threads.</p>
 *
 * <p> * <p>Note on {@link Sequencer#getCursor()}:  With this sequencer the cursor value is updated after the call
 * to {@link Sequencer#next()}, to determine the highest available sequence that can be read, then
 * {@link Sequencer#getHighestPublishedSequence(long, long)} should be used.
 */
public final class MultiProducerSequencer extends AbstractSequencer
{
    private static final Unsafe UNSAFE = Util.getUnsafe();
    private static final long BASE  = UNSAFE.arrayBaseOffset(int[].class);
    private static final long SCALE = UNSAFE.arrayIndexScale(int[].class);

    private final Sequence gatingSequenceCache = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);

    // availableBuffer tracks the state of each ringbuffer slot
    // see below for more details on the approach
    private final int[] availableBuffer;
    private final int indexMask;
    private final int indexShift;

    /**
     * Construct a Sequencer with the selected wait strategy and buffer size.
     *
     * @param bufferSize the size of the buffer that this will sequence over.
     * @param waitStrategy for those waiting on sequences.
     */
    public MultiProducerSequencer(int bufferSize, final WaitStrategy waitStrategy)
    {
        super(bufferSize, waitStrategy);
        availableBuffer = new int[bufferSize];
        indexMask = bufferSize - 1;
        indexShift = Util.log2(bufferSize);
        initialiseAvailableBuffer();
    }

    /**
     * @see Sequencer#hasAvailableCapacity(int)
     */
    @Override
    public boolean hasAvailableCapacity(final int requiredCapacity)
    {
        return hasAvailableCapacity(gatingSequences, requiredCapacity, cursor.get());
    }

    private boolean hasAvailableCapacity(Sequence[] gatingSequences, final int requiredCapacity, long cursorValue)
    {
        long wrapPoint = (cursorValue + requiredCapacity) - bufferSize;
        long cachedGatingSequence = gatingSequenceCache.get();

        if (wrapPoint > cachedGatingSequence || cachedGatingSequence > cursorValue)
        {
            long minSequence = Util.getMinimumSequence(gatingSequences, cursorValue);
            gatingSequenceCache.set(minSequence);

            if (wrapPoint > minSequence)
            {
                return false;
            }
        }

        return true;
    }

    /**
     * @see Sequencer#claim(long)
     */
    @Override
    public void claim(long sequence)
    {
        cursor.set(sequence);
    }

    /**
     * @see Sequencer#next()
     */
    @Override
    public long next()
    {
        return next(1);
    }

    /**
     * @see Sequencer#next(int)
     */
    @Override
    public long next(int n)
    {
        if (n < 1)
        {
            throw new IllegalArgumentException("n must be > 0");
        }

        long current;
        long next;

        do
        {
            current = cursor.get();
            next = current + n;

            long wrapPoint = next - bufferSize;
            long cachedGatingSequence = gatingSequenceCache.get();

            if (wrapPoint > cachedGatingSequence || cachedGatingSequence > current)
            {
                long gatingSequence = Util.getMinimumSequence(gatingSequences, current);

                if (wrapPoint > gatingSequence)
                {
                    LockSupport.parkNanos(1); // TODO, should we spin based on the wait strategy?
                    continue;
                }

                gatingSequenceCache.set(gatingSequence);
            }
            else if (cursor.compareAndSet(current, next))
            {
                break;
            }
        }
        while (true);

        return next;
    }

    /**
     * @see Sequencer#tryNext()
     */
    @Override
    public long tryNext() throws InsufficientCapacityException
    {
        return tryNext(1);
    }

    /**
     * @see Sequencer#tryNext(int)
     */
    @Override
    public long tryNext(int n) throws InsufficientCapacityException
    {
        if (n < 1)
        {
            throw new IllegalArgumentException("n must be > 0");
        }

        long current;
        long next;

        do
        {
            current = cursor.get();
            next = current + n;

            if (!hasAvailableCapacity(gatingSequences, n, current))
            {
                throw InsufficientCapacityException.INSTANCE;
            }
        }
        while (!cursor.compareAndSet(current, next));

        return next;
    }

    /**
     * @see Sequencer#remainingCapacity()
     */
    @Override
    public long remainingCapacity()
    {
        long consumed = Util.getMinimumSequence(gatingSequences, cursor.get());
        long produced = cursor.get();
        return getBufferSize() - (produced - consumed);
    }

    private void initialiseAvailableBuffer()
    {
        for (int i = availableBuffer.length - 1; i != 0; i--)
        {
            setAvailableBufferValue(i, -1);
        }

        setAvailableBufferValue(0, -1);
    }

    /**
     * @see Sequencer#publish(long)
     */
    @Override
    public void publish(final long sequence)
    {
        setAvailable(sequence);
        waitStrategy.signalAllWhenBlocking();
    }

    /**
     * @see Sequencer#publish(long, long)
     */
    @Override
    public void publish(long lo, long hi)
    {
        for (long l = lo; l <= hi; l++)
        {
            setAvailable(l);
        }
        waitStrategy.signalAllWhenBlocking();
    }

    /**
     * The below methods work on the availableBuffer flag.
     *
     * The prime reason is to avoid a shared sequence object between publisher threads.
     * (Keeping single pointers tracking start and end would require coordination
     * between the threads).
     *
     * --  Firstly we have the constraint that the delta between the cursor and minimum
     * gating sequence will never be larger than the buffer size (the code in
     * next/tryNext in the Sequence takes care of that).
     * -- Given that; take the sequence value and mask off the lower portion of the
     * sequence as the index into the buffer (indexMask). (aka modulo operator)
     * -- The upper portion of the sequence becomes the value to check for availability.
     * ie: it tells us how many times around the ring buffer we've been (aka division)
     * -- Because we can't wrap without the gating sequences moving forward (i.e. the
     * minimum gating sequence is effectively our last available position in the
     * buffer), when we have new data and successfully claimed a slot we can simply
     * write over the top.
     */
    private void setAvailable(final long sequence)
    {
        setAvailableBufferValue(calculateIndex(sequence), calculateAvailabilityFlag(sequence));
    }

    private void setAvailableBufferValue(int index, int flag)
    {
        long bufferAddress = (index * SCALE) + BASE;
        UNSAFE.putOrderedInt(availableBuffer, bufferAddress, flag);
    }

    /**
     * @see Sequencer#isAvailable(long)
     */
    @Override
    public boolean isAvailable(long sequence)
    {
        int index = calculateIndex(sequence);
        int flag = calculateAvailabilityFlag(sequence);
        long bufferAddress = (index * SCALE) + BASE;
        return UNSAFE.getIntVolatile(availableBuffer, bufferAddress) == flag;
    }

    @Override
    public long getHighestPublishedSequence(long lowerBound, long availableSequence)
    {
        for (long sequence = lowerBound; sequence <= availableSequence; sequence++)
        {
            if (!isAvailable(sequence))
            {
                return sequence - 1;
            }
        }

        return availableSequence;
    }

    private int calculateAvailabilityFlag(final long sequence)
    {
        return (int) (sequence >>> indexShift);
    }

    private int calculateIndex(final long sequence)
    {
        return ((int) sequence) & indexMask;
    }
}

package geym.conc.ch5.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultiThreadEchoServer {
    private static ExecutorService  tp=Executors.newCachedThreadPool();
    static class HandleMsg implements Runnable{
        Socket clientSocket;
        public HandleMsg(Socket clientSocket){
            this.clientSocket=clientSocket;
        }

        public void run(){
            BufferedReader is =null;
            PrintWriter os = null;
            try {

                is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                os = new PrintWriter(clientSocket.getOutputStream(), true);
                // 从InputStream当中读取客户端所发送的数据
                String inputLine = null;
                long b=System.currentTimeMillis();
                while ((inputLine = is.readLine()) != null) {
                    os.println(inputLine);
                }
                long e=System.currentTimeMillis();
                System.out.println("spend:"+(e-b)+"ms");
            } catch (IOException e) {
                e.printStackTrace();
            }finally{
                try {
                    if(is!=null)is.close();
                    if(os!=null)os.close();
                    clientSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    public static void main(String args[]) {
        ServerSocket echoServer = null;
        Socket clientSocket = null;
        try {
            echoServer = new ServerSocket(8000);
        } catch (IOException e) {
            System.out.println(e);
        }
        while (true) {
            try {
                clientSocket = echoServer.accept();
                System.out.println(clientSocket.getRemoteSocketAddress() + " connect!");
                tp.execute(new HandleMsg(clientSocket));
            } catch (IOException e) {
                System.out.println(e);
            }
        }
    }
}
package geym.conc.ch1;

/**
 * @author Administrator
 *
 */
public class MultiThreadLong {
	public volatile static long t=0;
	public static class ChangeT implements Runnable{
		private long to;
		public ChangeT(long to){
			this.to=to;
		}
		@Override
		public void run() {
			while(true){
			MultiThreadLong.t=to;
			Thread.yield();
			}
		}
	}
	public static class ReadT implements Runnable{
		@Override
		public void run() {
			while(true){
			 long tmp=MultiThreadLong.t;
			 if(tmp!=111L && tmp!=-999L && tmp!=333L && tmp!=-444L)
			     System.out.println(tmp);
			Thread.yield();
			}
		}
	}

	public static void main(String[] args) {
		new Thread(new ChangeT(111L)).start();
		new Thread(new ChangeT(-999L)).start();
		new Thread(new ChangeT(333L)).start();
		new Thread(new ChangeT(-444L)).start();
		new Thread(new ReadT()).start();
	}
}

package geym.conc.ch5.nio;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultiThreadNIOEchoServer {
	public static Map<Socket,Long> time_stat=new HashMap<Socket,Long>(10240);
    class EchoClient {
        private LinkedList<ByteBuffer> outq;

        EchoClient() {
            outq = new LinkedList<ByteBuffer>();
        }

        // Return the output queue.
        public LinkedList<ByteBuffer> getOutputQueue() {
            return outq;
        }

        // Enqueue a ByteBuffer on the output queue.
        public void enqueue(ByteBuffer bb) {
            outq.addFirst(bb);
        }
    }

    class HandleMsg implements Runnable{
        SelectionKey sk;
        ByteBuffer bb;
        public HandleMsg(SelectionKey sk,ByteBuffer bb){
            this.sk=sk;
            this.bb=bb;
        }
        @Override
        public void run() {
            EchoClient echoClient = (EchoClient) sk.attachment();
            echoClient.enqueue(bb);

            // We've enqueued data to be written to the client, we must
            // not set interest in OP_WRITE.
            sk.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
            //强迫selector立即返回
            selector.wakeup();
        }
    }

    private Selector selector;
    private ExecutorService  tp=Executors.newCachedThreadPool();
    /**
     * Accept a new client and set it up for reading.
     */
    private void doAccept(SelectionKey sk) {
        ServerSocketChannel server = (ServerSocketChannel) sk.channel();
        SocketChannel clientChannel;
        try {
            clientChannel = server.accept();
            clientChannel.configureBlocking(false);

            // Register this channel for reading.
            SelectionKey clientKey = clientChannel.register(selector, SelectionKey.OP_READ);
            // Allocate an EchoClient instance and attach it to this selection key.
            EchoClient echoClient = new EchoClient();
            clientKey.attach(echoClient);

            InetAddress clientAddress = clientChannel.socket().getInetAddress();
            System.out.println("Accepted connection from " + clientAddress.getHostAddress() + ".");
        } catch (Exception e) {
            System.out.println("Failed to accept new client.");
            e.printStackTrace();
        }
    }

    /**
     * Read from a client. Enqueue the data on the clients output
     * queue and set the selector to notify on OP_WRITE.
     */
    private void doRead(SelectionKey sk) {
        SocketChannel channel = (SocketChannel) sk.channel();
        ByteBuffer bb = ByteBuffer.allocate(8192);
        int len;

        try {
            len = channel.read(bb);
            if (len < 0) {
                disconnect(sk);
                return;
            }
        } catch (Exception e) {
            System.out.println("Failed to read from client.");
            e.printStackTrace();
            disconnect(sk);
            return;
        }

        // Flip the buffer.
        bb.flip();
        tp.execute(new HandleMsg(sk,bb));
    }

    /**
     * Called when a SelectionKey is ready for writing.
     */
    private void doWrite(SelectionKey sk) {
        SocketChannel channel = (SocketChannel) sk.channel();
        EchoClient echoClient = (EchoClient) sk.attachment();
        LinkedList<ByteBuffer> outq = echoClient.getOutputQueue();

        ByteBuffer bb = outq.getLast();
        try {
            int len = channel.write(bb);
            if (len == -1) {
                disconnect(sk);
                return;
            }

            if (bb.remaining() == 0) {
                // The buffer was completely written, remove it.
                outq.removeLast();
            }
        } catch (Exception e) {
            System.out.println("Failed to write to client.");
            e.printStackTrace();
            disconnect(sk);
        }

        // If there is no more data to be written, remove interest in
        // OP_WRITE.
        if (outq.size() == 0) {
            sk.interestOps(SelectionKey.OP_READ);
        }
    }

    private void disconnect(SelectionKey sk) {
        SocketChannel channel = (SocketChannel) sk.channel();

        InetAddress clientAddress = channel.socket().getInetAddress();
        System.out.println(clientAddress.getHostAddress() + " disconnected.");

        try {
            channel.close();
        } catch (Exception e) {
            System.out.println("Failed to close client socket channel.");
            e.printStackTrace();
        }
    }

    private void startServer() throws Exception {
        selector = SelectorProvider.provider().openSelector();

        // Create non-blocking server socket.
        ServerSocketChannel ssc = ServerSocketChannel.open();
        ssc.configureBlocking(false);

        // Bind the server socket to localhost.
//        InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(), 8000);
        InetSocketAddress isa = new InetSocketAddress(8000);
        ssc.socket().bind(isa);

        // Register the socket for select events.
        SelectionKey acceptKey = ssc.register(selector, SelectionKey.OP_ACCEPT);

        // Loop forever.
        for (;;) {
            selector.select();
            Set readyKeys = selector.selectedKeys();
            Iterator i = readyKeys.iterator();
            long e=0;
            while (i.hasNext()) {
                SelectionKey sk = (SelectionKey) i.next();
                i.remove();

                if (sk.isAcceptable()) {
                    doAccept(sk);
                }
                else if (sk.isValid() && sk.isReadable()) {
                	if(!time_stat.containsKey(((SocketChannel)sk.channel()).socket()))
                		time_stat.put(((SocketChannel)sk.channel()).socket(),
                			System.currentTimeMillis());
                    doRead(sk);
                }
                else if (sk.isValid() && sk.isWritable()) {
                    doWrite(sk);
                    e=System.currentTimeMillis();
                    long b=time_stat.remove(((SocketChannel)sk.channel()).socket());
                    System.out.println("spend:"+(e-b)+"ms");
                }
            }
        }
    }

    // Main entry point.
    public static void main(String[] args) {
        MultiThreadNIOEchoServer echoServer = new MultiThreadNIOEchoServer();
        try {
            echoServer.startServer();
        } catch (Exception e) {
            System.out.println("Exception caught, program exiting...");
            e.printStackTrace();
        }
    }
}
package geym.conc.ch2.vol;

/**
 * @author Administrator
 *
 */
public class MultiThreadVolatileLong {
	public static volatile long t=0;
	public static class ChangeT implements Runnable{
		private long to;
		public ChangeT(long to){
			this.to=to;
		}
		@Override
		public void run() {
			while(true){
			MultiThreadVolatileLong.t=to;
			Thread.yield();
			}
		}
	}
	public static class ReadT implements Runnable{
		@Override
		public void run() {
			while(true){
			 long tmp=MultiThreadVolatileLong.t;
			 if(tmp!=111L && tmp!=-999L && tmp!=333L && tmp!=-444L)
			     System.out.println(tmp);
			Thread.yield();
			}
		}
	}

	public static void main(String[] args) {
//		System.out.println(Long.toBinaryString(111L));
//		System.out.println(Long.toBinaryString(-999L));
//		System.out.println(Long.toBinaryString(333L));
//		System.out.println(Long.toBinaryString(-444L));
//		System.out.println(Long.toBinaryString(4294966297L));
//		System.out.println(Long.toBinaryString(-4294967185L));

		new Thread(new ChangeT(111L)).start();
		new Thread(new ChangeT(-999L)).start();
		new Thread(new ChangeT(333L)).start();
		new Thread(new ChangeT(-444L)).start();
		new Thread(new ReadT()).start();
	}
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.util;

/**
 * Holder class for a long value.
 */
public class MutableLong
{
    private long value = 0L;

    /**
     * Default constructor
     */
    public MutableLong()
    {
    }

    /**
     * Construct the holder with initial value.
     *
     * @param initialValue to be initially set.
     */
    public MutableLong(final long initialValue)
    {
        this.value = initialValue;
    }

    /**
     * Get the long value.
     *
     * @return the long value.
     */
    public long get()
    {
        return value;
    }

    /**
     * Set the long value.
     *
     * @param value to set.
     */
    public void set(final long value)
    {
        this.value = value;
    }

    /**
     * Increments the value
     */
    public void increment()
    {
        value++;
    }
}
package org.jmatrices.dbl;

/**
 * MuttableMatrix represents a matrix who's structure is muttable.
 * <br/>
 * This is a strict no no. The reason it exists is because we need it for better handling different implementations of
 * <p>Author: purangp</p>
 * Date: 29.04.2004
 * Time: 20:02:38
 */
interface MuttableMatrix extends Matrix{
    void setRows(int rows);
    void setCols(int cols);
}
package geym.conc.ch5.nio;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.Iterator;

public class NIOClient {
    private Selector selector;
    public void init(String ip, int port) throws IOException {
        SocketChannel channel = SocketChannel.open();
        channel.configureBlocking(false);
        this.selector = SelectorProvider.provider().openSelector();
        channel.connect(new InetSocketAddress(ip, port));
        channel.register(selector, SelectionKey.OP_CONNECT);
    }

    public void working() throws IOException {
        while (true) {
            if (!selector.isOpen())
                break;
            selector.select();
            Iterator<SelectionKey> ite = this.selector.selectedKeys().iterator();
            while (ite.hasNext()) {
                SelectionKey key = ite.next();
                ite.remove();
                // 连接事件发生
                if (key.isConnectable()) {
                    connect(key);
                } else if (key.isReadable()) {
                    read(key);
                }
            }
        }
    }

    /**
     * 处理读取服务端发来的信息 的事件
     *
     * @param key
     * @throws IOException
     */
    public void read(SelectionKey key) throws IOException {
        SocketChannel channel = (SocketChannel) key.channel();
        // 创建读取的缓冲区
        ByteBuffer buffer = ByteBuffer.allocate(100);
        channel.read(buffer);
        byte[] data = buffer.array();
        String msg = new String(data).trim();
        System.out.println("客户端收到信息：" + msg);
        channel.close();
        key.selector().close();
    }

    public void connect(SelectionKey key) throws IOException {
        SocketChannel channel = (SocketChannel) key.channel();
        // 如果正在连接，则完成连接
        if (channel.isConnectionPending()) {
            channel.finishConnect();
        }
        channel.configureBlocking(false);
        channel.write(ByteBuffer.wrap(new String("hello server!\r\n")
                .getBytes()));
        channel.register(this.selector, SelectionKey.OP_READ);
    }

    /**
     * 启动客户端测试
     *
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        NIOClient client = new NIOClient();
        client.init("localhost", 8000);
        client.working();
    }
}

package geym.conc.ch5.nio;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Set;

public class NIOEchoServer {
    class EchoClient {
        private LinkedList<ByteBuffer> outq;

        EchoClient() {
            outq = new LinkedList<ByteBuffer>();
        }

        // Return the output queue.
        public LinkedList<ByteBuffer> getOutputQueue() {
            return outq;
        }

        // Enqueue a ByteBuffer on the output queue.
        public void enqueue(ByteBuffer bb) {
            outq.addFirst(bb);
        }
    }

    private Selector selector;

    /**
     * Accept a new client and set it up for reading.
     */
    private void doAccept(SelectionKey sk) {
        ServerSocketChannel server = (ServerSocketChannel) sk.channel();
        SocketChannel clientChannel;
        try {
            clientChannel = server.accept();
            clientChannel.configureBlocking(false);

            // Register this channel for reading.
            SelectionKey clientKey = clientChannel.register(selector, SelectionKey.OP_READ);

            // Allocate an EchoClient instance and attach it to this selection key.
            EchoClient echoClient = new EchoClient();
            clientKey.attach(echoClient);

            InetAddress clientAddress = clientChannel.socket().getInetAddress();
            System.out.println("Accepted connection from " + clientAddress.getHostAddress() + ".");
        } catch (Exception e) {
            System.out.println("Failed to accept new client.");
            e.printStackTrace();
        }

    }

    /**
     * Read from a client. Enqueue the data on the clients output
     * queue and set the selector to notify on OP_WRITE.
     */
    private void doRead(SelectionKey sk) {
        SocketChannel channel = (SocketChannel) sk.channel();
        ByteBuffer bb = ByteBuffer.allocate(8192);
        int len;

        try {
            len = channel.read(bb);
            if (len < 0) {
                disconnect(sk);
                return;
            }
        } catch (Exception e) {
            System.out.println("Failed to read from client.");
            e.printStackTrace();
            disconnect(sk);
            return;
        }

        // Flip the buffer.
        bb.flip();


        EchoClient echoClient = (EchoClient) sk.attachment();
        echoClient.enqueue(bb);

        // We've enqueued data to be written to the client, we must
        // not set interest in OP_WRITE.
        sk.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    }

    /**
     * Called when a SelectionKey is ready for writing.
     */
    private void doWrite(SelectionKey sk) {
        SocketChannel channel = (SocketChannel) sk.channel();
        EchoClient echoClient = (EchoClient) sk.attachment();
        LinkedList<ByteBuffer> outq = echoClient.getOutputQueue();

        ByteBuffer bb = outq.getLast();
        try {
            int len = channel.write(bb);
            if (len == -1) {
                disconnect(sk);
                return;
            }

            if (bb.remaining() == 0) {
                // The buffer was completely written, remove it.
                outq.removeLast();
            }
        } catch (Exception e) {
            System.out.println("Failed to write to client.");
            e.printStackTrace();
            disconnect(sk);
        }

        // If there is no more data to be written, remove interest in
        // OP_WRITE.
        if (outq.size() == 0) {
            sk.interestOps(SelectionKey.OP_READ);
        }
    }

    private void disconnect(SelectionKey sk) {
        SocketChannel channel = (SocketChannel) sk.channel();

        InetAddress clientAddress = channel.socket().getInetAddress();
        System.out.println(clientAddress.getHostAddress() + " disconnected.");

        try {
            channel.close();
        } catch (Exception e) {
            System.out.println("Failed to close client socket channel.");
            e.printStackTrace();
        }
    }

    private void startServer() throws Exception {
        selector = SelectorProvider.provider().openSelector();

        // Create non-blocking server socket.
        ServerSocketChannel ssc = ServerSocketChannel.open();
        ssc.configureBlocking(false);

        // Bind the server socket to localhost.
//        InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(), 8000);
        InetSocketAddress isa = new InetSocketAddress(8000);
        ssc.socket().bind(isa);

        // Register the socket for select events.
        SelectionKey acceptKey = ssc.register(selector, SelectionKey.OP_ACCEPT);

        // Loop forever.
        for (;;) {
            selector.select();
            Set readyKeys = selector.selectedKeys();
            Iterator i = readyKeys.iterator();

            while (i.hasNext()) {
                SelectionKey sk = (SelectionKey) i.next();
                i.remove();

                if (sk.isAcceptable()) {
                    doAccept(sk);
                }
                if (sk.isValid() && sk.isReadable()) {
                    doRead(sk);
                }
                if (sk.isValid() && sk.isWritable()) {
                    doWrite(sk);
                }
            }
        }
    }

    // Main entry point.
    public static void main(String[] args) {
        NIOEchoServer echoServer = new NIOEchoServer();
        try {
            echoServer.startServer();
        } catch (Exception e) {
            System.out.println("Exception caught, program exiting...");
            e.printStackTrace();
        }
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.atomic.AtomicBoolean;

/**
 * No operation version of a {@link EventProcessor} that simply tracks a {@link Sequence}.
 *
 * This is useful in tests or for pre-filling a {@link RingBuffer} from a publisher.
 */
public final class NoOpEventProcessor implements EventProcessor
{
    private final SequencerFollowingSequence sequence;
    private final AtomicBoolean running = new AtomicBoolean(false);

    /**
     * Construct a {@link EventProcessor} that simply tracks a {@link Sequence} object.
     *
     * @param sequencer to track.
     */
    public NoOpEventProcessor(final RingBuffer<?> sequencer)
    {
        sequence = new SequencerFollowingSequence(sequencer);
    }

    @Override
    public Sequence getSequence()
    {
        return sequence;
    }

    @Override
    public void halt()
    {
        running.set(false);
    }

    @Override
    public boolean isRunning()
    {
        return running.get();
    }

    @Override
    public void run()
    {
        if (!running.compareAndSet(false, true))
        {
            throw new IllegalStateException("Thread is already running");
        }
    }

    /**
     * Sequence that follows (by wrapping) another sequence
     */
    private static final class SequencerFollowingSequence extends Sequence
    {
        private final RingBuffer<?> sequencer;

        private SequencerFollowingSequence(final RingBuffer<?> sequencer)
        {
            super(Sequencer.INITIAL_CURSOR_VALUE);
            this.sequencer = sequencer;
        }

        @Override
        public long get()
        {
            return sequencer.getCursor();
        }
    }
}
package geym.conc.ch2.vol;

/**
 * -server will never stop
 * @author geym
 *
 */
public class NoVisibility {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready);
            System.out.println(number);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new ReaderThread().start();
        Thread.sleep(1000);
        number = 42;
        ready = true;
        Thread.sleep(10000);
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.util;

/**
 * Cache line padded long variable to be used when false sharing maybe an issue.
 */
public final class PaddedLong extends MutableLong
{
    public volatile long p1, p2, p3, p4, p5, p6 = 7L;

    /**
     * Default constructor
     */
    public PaddedLong()
    {
    }

    /**
     * Construct with an initial value.
     *
     * @param initialValue for construction
     */
    public PaddedLong(final long initialValue)
    {
        super(initialValue);
    }

    public long sumPaddingToPreventOptimisation()
    {
        return p1 + p2 + p3 + p4 + p5 + p6;
    }
}
package geym.conc.ch6.pstream;

import java.util.Arrays;
import java.util.Random;

public class ParallelSort {

	public static void main(String args[]){
		Random r=new Random();
		int[] arr=new int[10000000];


		long b=System.currentTimeMillis();
		Arrays.setAll(arr, (i)->r.nextInt());
		Arrays.parallelSetAll(arr, (i)->r.nextInt());
		long e=System.currentTimeMillis();
		System.out.println("set spend time:"+(e-b)+"ms");

		b=System.currentTimeMillis();
	    Arrays.parallelSort(arr);
		Arrays.sort(arr);
	    e=System.currentTimeMillis();

	    System.out.println("sort spend time:"+(e-b)+"ms");

//	    for(int i=0;i<arr.length;i++){
//	    	System.out.print(arr[i]);
//	    	System.out.print('\t');
//		}
	}
}
package geym.conc.ch5.pc;

public final class PCData {
	private  final int intData;
	public PCData(int d){
		intData=d;
	}
	public PCData(String d){
		intData=Integer.valueOf(d);
	}
	public int getData(){
		return intData;
	}
	@Override
	public String toString(){
		return "data:"+intData;
	}
}
package geym.conc.ch5.disruptor;

public class PCData
{
    private long value;

    public void set(long value)
    {
        this.value = value;
    }
    public long get(){
    	return value;
    }
}
package geym.conc.ch5.disruptor;

import com.lmax.disruptor.EventFactory;

public class PCDataFactory implements EventFactory<PCData>
{
    public PCData newInstance()
    {
        return new PCData();
    }
}package geym.conc.ch5.disruptor;

import com.lmax.disruptor.EventHandler;

public class PCDataHandler implements EventHandler<PCData>
{
    public void onEvent(PCData event, long sequence, boolean endOfBatch)
    {
        System.out.println(Thread.currentThread().getId()+":Event: **" + event.get()*event.get()+"**");
    }
}package geym.conc.ch5.disruptor;

import com.lmax.disruptor.EventHandler;

public class PCDataHandler2 implements EventHandler<PCData>
{
    public void onEvent(PCData event, long sequence, boolean endOfBatch)
    {
        System.out.println(Thread.currentThread().getId()+":Event: " + event.get());
    }
}package geym.conc.ch5.pc;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class PCMain {
	public static void main(String[] args) throws InterruptedException {
        BlockingQueue<PCData> queue = new LinkedBlockingQueue<PCData>(10);
        Producer producer1 = new Producer(queue);
        Producer producer2 = new Producer(queue);
        Producer producer3 = new Producer(queue);
        Consumer consumer1 = new Consumer(queue);
        Consumer consumer2 = new Consumer(queue);
        Consumer consumer3 = new Consumer(queue);
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(producer1);
        service.execute(producer2);
        service.execute(producer3);
        service.execute(consumer1);
        service.execute(consumer2);
        service.execute(consumer3);
        Thread.sleep(10 * 1000);
        producer1.stop();
        producer2.stop();
        producer3.stop();
        Thread.sleep(3000);
        service.shutdown();
    }
}
package geym.conc.ch5.disruptor;

import java.nio.ByteBuffer;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import com.lmax.disruptor.BlockingWaitStrategy;
import com.lmax.disruptor.RingBuffer;
import com.lmax.disruptor.dsl.Disruptor;
import com.lmax.disruptor.dsl.ProducerType;

public class PCMain
{
    public static void main(String[] args) throws Exception
    {
        Executor executor = Executors.newCachedThreadPool();
        PCDataFactory factory = new PCDataFactory();
        // Specify the size of the ring buffer, must be power of 2.
        int bufferSize = 1024;
        Disruptor<PCData> disruptor = new Disruptor<PCData>(factory,
                bufferSize,
                executor,
                ProducerType.MULTI,
                new BlockingWaitStrategy()
                );
                // Connect the handler
//        disruptor.handleEventsWith(new LongEventHandler());
        disruptor.handleEventsWithWorkerPool(
        		new Consumer(),
        		new Consumer(),
        		new Consumer(),
        		new Consumer());
        disruptor.start();

        RingBuffer<PCData> ringBuffer = disruptor.getRingBuffer();
        Producer producer = new Producer(ringBuffer);
        ByteBuffer bb = ByteBuffer.allocate(8);
        for (long l = 0; true; l++)
        {
            bb.putLong(0, l);
            producer.pushData(bb);
            Thread.sleep(100);
            System.out.println("add data "+l);
        }
    }
}/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.TimeUnit;

/**
 * <p>Phased wait strategy for waiting {@link EventProcessor}s on a barrier.</p>
 *
 * <p>This strategy can be used when throughput and low-latency are not as important as CPU resource.
 * Spins, then yields, then waits using the configured fallback WaitStrategy.</p>
 */
public final class PhasedBackoffWaitStrategy implements WaitStrategy
{
    private static final int SPIN_TRIES = 10000;
    private final long spinTimeoutNanos;
    private final long yieldTimeoutNanos;
    private final WaitStrategy fallbackStrategy;

    public PhasedBackoffWaitStrategy(long spinTimeout,
                                     long yieldTimeout,
                                     TimeUnit units,
                                     WaitStrategy fallbackStrategy)
    {
        this.spinTimeoutNanos = units.toNanos(spinTimeout);
        this.yieldTimeoutNanos = spinTimeoutNanos + units.toNanos(yieldTimeout);
        this.fallbackStrategy = fallbackStrategy;
    }

    /**
     * Block with wait/notifyAll semantics
     */
    public static PhasedBackoffWaitStrategy withLock(long spinTimeout,
                                                     long yieldTimeout,
                                                     TimeUnit units)
    {
        return new PhasedBackoffWaitStrategy(spinTimeout, yieldTimeout,
                                             units, new BlockingWaitStrategy());
    }

    /**
     * Block with wait/notifyAll semantics
     */
    public static PhasedBackoffWaitStrategy withLiteLock(long spinTimeout,
                                                         long yieldTimeout,
                                                         TimeUnit units)
    {
        return new PhasedBackoffWaitStrategy(spinTimeout, yieldTimeout,
                                             units, new LiteBlockingWaitStrategy());
    }

    /**
     * Block by sleeping in a loop
     */
    public static PhasedBackoffWaitStrategy withSleep(long spinTimeout,
                                                      long yieldTimeout,
                                                      TimeUnit units)
    {
        return new PhasedBackoffWaitStrategy(spinTimeout, yieldTimeout,
                                             units, new SleepingWaitStrategy(0));
    }

    @Override
    public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, SequenceBarrier barrier)
        throws AlertException, InterruptedException, TimeoutException
    {
        long availableSequence;
        long startTime = 0;
        int counter = SPIN_TRIES;

        do
        {
            if ((availableSequence = dependentSequence.get()) >= sequence)
            {
                return availableSequence;
            }

            if (0 == --counter)
            {
                if (0 == startTime)
                {
                    startTime = System.nanoTime();
                }
                else
                {
                    long timeDelta = System.nanoTime() - startTime;
                    if (timeDelta > yieldTimeoutNanos)
                    {
                        return fallbackStrategy.waitFor(sequence, cursor, dependentSequence, barrier);
                    }
                    else if (timeDelta > spinTimeoutNanos)
                    {
                        Thread.yield();
                    }
                }
                counter = SPIN_TRIES;
            }
        }
        while (true);
    }

    @Override
    public void signalAllWhenBlocking()
    {
        fallbackStrategy.signalAllWhenBlocking();
    }
}
package geym.conc.ch5.pstream.demo;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class Plus implements Runnable {
	public static BlockingQueue<Msg> bq=new LinkedBlockingQueue<Msg>();
	@Override
	public void run() {
		while(true){
			try {
				Msg msg=bq.take();
				msg.j=msg.i+msg.j;
				Multiply.bq.add(msg);
			} catch (InterruptedException e) {
			}
		}
	}
}
package geym.conc.ch2.vol;

public class PlusV {
	static volatile int i=0;
	public static class PlusTask implements Runnable{
		@Override
		public void run() {
			for(int k=0;k<10000;k++)
				i++;
		}
	}

	public static void main(String[] args) throws InterruptedException {
		Thread[] threads=new Thread[10];
		for(int i=0;i<10;i++){
			threads[i]=new Thread(new PlusTask());
			threads[i].start();
		}
		for(int i=0;i<10;i++){
			threads[i].join();
		}

		System.out.println(i);
	}
}
package geym.conc.ch5.matrix;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.operator.MatrixOperator;

/**
 * A*B
    A=(A1,A2)T
    B=(B1,B2)

    A*B=(A1*B1  A1*B2)
        (A2*B1  A2*B2)
 *
 * @author Geym
 *
 */
public class PMatrixMul {
    public static final int granularity=3;
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        Matrix m1=MatrixFactory.getRandomIntMatrix(100, 100, null);
        Matrix m2=MatrixFactory.getRandomIntMatrix(100, 100, null);
        Matrix sr=MatrixOperator.multiply(m1, m2);
        MatrixMulTask task=new MatrixMulTask(m1,m2,null);
        ForkJoinTask<Matrix> result = forkJoinPool.submit(task);
        Matrix pr=result.get();
        //检查和串行计算结果是否一致 使用-ea开启断言
        assert sr.toString().equals(pr.toString());
//        System.out.println(pr);
    }
}
package geym.conc.ch5.matrix;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

/**
 * A*B
    A=(A1,A2)T
    B=(B1,B2)

    A*B=(A1*B1  A1*B2)
        (A2*B1  A2*B2)
 *
 * @author Geym
 *
 */
public class PMatrixMulOnly {
    public static final int granularity=3;
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        Matrix m1=MatrixFactory.getRandomIntMatrix(300, 300, null);
        Matrix m2=MatrixFactory.getRandomIntMatrix(300, 300, null);
        MatrixMulTask task=new MatrixMulTask(m1,m2,null);
        ForkJoinTask<Matrix> result = forkJoinPool.submit(task);
        Matrix pr=result.get();
        System.out.println(pr);
    }
}
package geym.conc.ch6.stamped;

import java.util.concurrent.locks.StampedLock;

public class Point {
	private double x, y;
	private final StampedLock sl = new StampedLock();

	void move(double deltaX, double deltaY) { // an exclusively locked method
		long stamp = sl.writeLock();
		try {
			x += deltaX;
			y += deltaY;
		} finally {
			sl.unlockWrite(stamp);
		}
	}

	double distanceFromOrigin() { // A read-only method
		long stamp = sl.tryOptimisticRead();
		double currentX = x, currentY = y;
		if (!sl.validate(stamp)) {
			stamp = sl.readLock();
			try {
				currentX = x;
				currentY = y;
			} finally {
				sl.unlockRead(stamp);
			}
		}
		return Math.sqrt(currentX * currentX + currentY * currentY);
	}

	void moveIfAtOrigin(double newX, double newY) { // upgrade
		// Could instead start with optimistic, not read mode
		long stamp = sl.readLock();
		try {
			while (x == 0.0 && y == 0.0) {
				long ws = sl.tryConvertToWriteLock(stamp);
				if (ws != 0L) {
					stamp = ws;
					x = newX;
					y = newY;
					break;
				} else {
					sl.unlockRead(stamp);
					stamp = sl.writeLock();
				}
			}
		} finally {
			sl.unlock(stamp);
		}
	}
}
package geym.conc.ch6.pstream;

import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;


public class PrimeMain {

	public static void main(String[] args) {
		long b=System.currentTimeMillis();
//		IntStream.range(1, 1000000).parallel().filter(PrimeUtil::isPrime).count();
		IntStream.range(1, 1000000).filter(PrimeUtil::isPrime).count();
		long e=System.currentTimeMillis();
		System.out.println("spend:"+(e-b)+"ms");
	}

}

package geym.conc.remove.prime;

public class PrimeUtil {
    public static boolean isPrime(int x) {
        boolean bo = true;
        int sqrt = (int) Math.sqrt(x);
        for (int i = 2; i < sqrt; i++) {
            if (x/i==0) {
                bo = false;
                break;
            }
        }
        return bo;
    }
}
package geym.conc.ch6.pstream;

public class PrimeUtil {
	public static boolean isPrime(int number) {
		int tmp = number;
		if (tmp < 2) {
			return false;
		}
		for (int i = 2; Math.sqrt(tmp) >= i; i++) {
			if (tmp % i == 0) {
				return false;
			}
		}
		return true;
	}
}
package geym.conc.ch2.priority;


public class PriorityDemo {
    public static class HightPriority extends Thread{
        static int count=0;
        public void run(){
            while(true){
                synchronized(PriorityDemo.class){
                    count++;
                    if(count>10000000){
                        System.out.println("HightPriority is complete");
                        break;
                    }
                }
            }
        }
    }
    public static class LowPriority extends Thread{
        static int count=0;
        public void run(){
            while(true){
                synchronized(PriorityDemo.class){
                    count++;
                    if(count>10000000){
                        System.out.println("LowPriority is complete");
                        break;
                    }
                }
            }
        }
    }

    /**
     * HightPriority先完成的次数多，但是 不保证
     *
     * @param args
     * @throws InterruptedException
     */
    public static void main(String[] args) throws InterruptedException {
        Thread high=new HightPriority();
        LowPriority low=new LowPriority();
        high.setPriority(Thread.MAX_PRIORITY);
        low.setPriority(Thread.MIN_PRIORITY);
        low.start();
        high.start();
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;


/**
 * {@link SequenceBarrier} handed out for gating {@link EventProcessor}s on a cursor sequence and optional dependent {@link EventProcessor}(s),
 * using the given WaitStrategy.
 */
final class ProcessingSequenceBarrier implements SequenceBarrier
{
    private final WaitStrategy waitStrategy;
    private final Sequence dependentSequence;
    private volatile boolean alerted = false;
    private final Sequence cursorSequence;
    private final Sequencer sequencer;

    public ProcessingSequenceBarrier(final Sequencer sequencer,
                                     final WaitStrategy waitStrategy,
                                     final Sequence cursorSequence,
                                     final Sequence[] dependentSequences)
    {
        this.sequencer = sequencer;
        this.waitStrategy = waitStrategy;
        this.cursorSequence = cursorSequence;
        if (0 == dependentSequences.length)
        {
            dependentSequence = cursorSequence;
        }
        else
        {
            dependentSequence = new FixedSequenceGroup(dependentSequences);
        }
    }

    @Override
    public long waitFor(final long sequence)
        throws AlertException, InterruptedException, TimeoutException
    {
        checkAlert();

        long availableSequence = waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this);

        if (availableSequence < sequence)
        {
            return availableSequence;
        }

        return sequencer.getHighestPublishedSequence(sequence, availableSequence);
    }

    @Override
    public long getCursor()
    {
        return dependentSequence.get();
    }

    @Override
    public boolean isAlerted()
    {
        return alerted;
    }

    @Override
    public void alert()
    {
        alerted = true;
        waitStrategy.signalAllWhenBlocking();
    }

    @Override
    public void clearAlert()
    {
        alerted = false;
    }

    @Override
    public void checkAlert() throws AlertException
    {
        if (alerted)
        {
            throw AlertException.INSTANCE;
        }
    }
}package geym.conc.ch5.pc;

import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class Producer implements Runnable {
	private volatile boolean isRunning = true;
	private BlockingQueue<PCData> queue;
	private static AtomicInteger count = new AtomicInteger();
	private static final int SLEEPTIME = 1000;

	public Producer(BlockingQueue<PCData> queue) {
		this.queue = queue;
	}

	public void run() {
		PCData data = null;
		Random r = new Random();

		System.out.println("start producer id="+Thread.currentThread().getId());
		try {
			while (isRunning) {
				Thread.sleep(r.nextInt(SLEEPTIME));
				data = new PCData(count.incrementAndGet());
				System.out.println(data+" is put into queue");
				if (!queue.offer(data, 2, TimeUnit.SECONDS)) {
					System.err.println("failed to put data：" + data);
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
			Thread.currentThread().interrupt();
		}
	}
	public void stop() {
		isRunning = false;
	}
}package geym.conc.ch5.disruptor;

import java.nio.ByteBuffer;

import com.lmax.disruptor.RingBuffer;

public class Producer
{
    private final RingBuffer<PCData> ringBuffer;

    public Producer(RingBuffer<PCData> ringBuffer)
    {
        this.ringBuffer = ringBuffer;
    }

    public void pushData(ByteBuffer bb)
    {
        long sequence = ringBuffer.next();  // Grab the next sequence
        try
        {
            PCData event = ringBuffer.get(sequence); // Get the entry in the Disruptor
                                                        // for the sequence
            event.set(bb.getLong(0));  // Fill with data
        }
        finally
        {
            ringBuffer.publish(sequence);
        }
    }
}/*
 * Copyright 2012 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.dsl;

/**
 * Defines producer types to support creation of RingBuffer with correct sequencer and publisher.
 */
public enum ProducerType
{
    /** Create a RingBuffer with a single event publisher to the RingBuffer */
    SINGLE,

    /** Create a RingBuffer supporting multiple event publishers to the one RingBuffer */
    MULTI
}
package geym.conc.ch6.pstream;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.IntStream;

public class PstreamMain {

	public static void main(String[] args) {
		List<Student> ss=new ArrayList<Student>();
		for(int i=1;i<1000000;i++){
			ss.add(new Student(Integer.toString(i),(int)(Math.random()*100)));
		}
		long b=System.currentTimeMillis();
//		double ave=ss.parallelStream().mapToInt(s->s.score).average().getAsDouble();
		double ave=ss.stream().mapToInt(s->s.score).average().getAsDouble();

		long e=System.currentTimeMillis();
		System.out.println("cal spend time:"+(e-b)+"ms");
		System.out.println(ave);
	}

}
package geym.conc.ch5.pstream.demo;
/**
 * 并行流解决数据相关性问题
 * (B+C)*B/2
 * P1:A＝B+C
 * P2:D＝A×B
 * P3:D=D/2
 * Output:D
 *
 * @param args
 */
public class PStreamMain {
    public static void main(String[] args) {
        new Thread(new Plus()).start();
        new Thread(new Multiply()).start();
        new Thread(new Div()).start();

        for (int i = 1; i <= 1000; i++) {
            for (int j = 1; j <= 1000; j++) {
                Msg msg = new Msg();
                msg.i = i;
                msg.j = j;
                msg.orgStr = "((" + i + "+" + j + ")*" + i + ")/2";
                Plus.bq.add(msg);
            }
        }
    }
}
package org.jmatrices.dbl.decomposition;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

/**
 * QRDecomposition
 * <P>
 * For an m-by-n matrix A with m >= n, the QR decomposition is an m-by-n
 * orthogonal matrix Q and an n-by-n upper triangular matrix R so that
 * A = Q*R.
 * </p>
 * <P>
 * The QR decompostion always exists, even if the matrix does not have
 * full rank, so the constructor will never fail.  The primary use of the
 * QR decomposition is in the least squares solution of nonsquare systems
 * of simultaneous linear equations.  This will fail if isFullRank()
 * returns false
 * </p>
 * <p><font color="red">
 * The code is basically JAMA code with modifications made to fit in the scheme of things.
 * </font></p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 13.03.2004
 * Time: 13:51:42
 */
public class QRDecomposition {

/* ------------------------
   Class variables
 * ------------------------ */

    /**
     * Array for internal storage of decomposition.
     *
     * @serial internal array storage.
     */
    private double[][] QR;

    /**
     * Row and column dimensions.
     *
     * @serial column dimension.
     * @serial row dimension.
     */
    private int m, n;

    /**
     * Array for internal storage of diagonal of R.
     *
     * @serial diagonal of R.
     */
    private double[] Rdiag;

    private Matrix hint;

/* ------------------------
   Constructor
 * ------------------------ */

    /**
     * QR Decomposition, computed by Householder reflections.
     *
     * @param matrix Rectangular matrix
     *          Structure to access R and the Householder vectors and compute Q.
     */

    public QRDecomposition(Matrix matrix) {
        hint = matrix;
        // Initialize.
        QR = matrix.get();        //changed
        m = matrix.rows(); //changed
        n = matrix.cols();  //changed
        Rdiag = new double[n];

        // Main loop.
        for (int k = 0; k < n; k++) {
            // Compute 2-norm of k-th column without under/overflow.
            double nrm = 0;
            for (int i = k; i < m; i++) {
                nrm = Util.hypot(nrm, QR[i][k]);
            }

            if (nrm != 0.0) {
                // Form k-th Householder vector.
                if (QR[k][k] < 0) {
                    nrm = -nrm;
                }
                for (int i = k; i < m; i++) {
                    QR[i][k] /= nrm;
                }
                QR[k][k] += 1.0;

                // Apply transformer to remaining columns.
                for (int j = k + 1; j < n; j++) {
                    double s = 0.0;
                    for (int i = k; i < m; i++) {
                        s += QR[i][k] * QR[i][j];
                    }
                    s = -s / QR[k][k];
                    for (int i = k; i < m; i++) {
                        QR[i][j] += s * QR[i][k];
                    }
                }
            }
            Rdiag[k] = -nrm;
        }
    }

/* ------------------------
   Public Methods
 * ------------------------ */

    /**
     * Is the matrix full rank?
     *
     * @return true if R, and hence A, has full rank.
     */

    public boolean isFullRank() {
        for (int j = 0; j < n; j++) {
            if (Rdiag[j] == 0)
                return false;
        }
        return true;
    }

    /**
     * Return the Householder vectors
     *
     * @return Lower trapezoidal matrix whose columns define the reflections
     */

    public Matrix getH() {
        double[][] H = new double[m][n];    //changed
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i >= j) {
                    H[i][j] = QR[i][j];
                } else {
                    H[i][j] = 0.0;
                }
            }
        }
        return MatrixFactory.getMatrix(m, n, hint, H);  //changed
    }

    /**
     * Return the upper triangular factor
     *
     * @return R
     */

    public Matrix getR() {
        double[][] R = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i < j) {
                    R[i][j] = QR[i][j];
                } else if (i == j) {
                    R[i][j] = Rdiag[i];
                } else {
                    R[i][j] = 0.0;
                }
            }
        }
        return MatrixFactory.getMatrix(n, n, hint, R); //changed
    }

    /**
     * Generate and return the (economy-sized) orthogonal factor
     *
     * @return Q
     */

    public Matrix getQ() {
        double[][] Q = new double[m][n];
        for (int k = n - 1; k >= 0; k--) {
            for (int i = 0; i < m; i++) {
                Q[i][k] = 0.0;
            }
            Q[k][k] = 1.0;
            for (int j = k; j < n; j++) {
                if (QR[k][k] != 0) {
                    double s = 0.0;
                    for (int i = k; i < m; i++) {
                        s += QR[i][k] * Q[i][j];
                    }
                    s = -s / QR[k][k];
                    for (int i = k; i < m; i++) {
                        Q[i][j] += s * QR[i][k];
                    }
                }
            }
        }
        return MatrixFactory.getMatrix(m, n, hint, Q);
    }

    /**
     * Least squares solution of A*X = B
     *
     * @param B A Matrix with as many rows as A and any number of columns.
     * @return X that minimizes the two norm of Q*R*X-B.
     * @throws IllegalArgumentException Matrix row dimensions must agree.
     * @throws RuntimeException         Matrix is rank deficient.
     */

    public Matrix solve(Matrix B) {
        if (B.rows() != m) {
            throw new IllegalArgumentException("Matrix row dimensions must agree.");
        }
        if (!this.isFullRank()) {
            throw new RuntimeException("Matrix is rank deficient.");
        }

        // Copy right hand side
        int nx = B.cols();
        double[][] X = B.get();        //changed

        // Compute Y = transpose(Q)*B
        for (int k = 0; k < n; k++) {
            for (int j = 0; j < nx; j++) {
                double s = 0.0;
                for (int i = k; i < m; i++) {
                    s += QR[i][k] * X[i][j];
                }
                s = -s / QR[k][k];
                for (int i = k; i < m; i++) {
                    X[i][j] += s * QR[i][k];
                }
            }
        }
        // Solve R*X = Y;
        for (int k = n - 1; k >= 0; k--) {
            for (int j = 0; j < nx; j++) {
                X[k][j] /= Rdiag[k];
            }
            for (int i = 0; i < k; i++) {
                for (int j = 0; j < nx; j++) {
                    X[i][j] -= X[k][j] * QR[i][k];
                }
            }
        }
        //return (new Matrix(X, n, nx).getMatrix(0, n - 1, 0, nx - 1));
        return MatrixFactory.getMatrix(B.rows(), B.cols(), hint, X).getSubMatrix(1, 1, n, nx); //changed  taking care of 1,1 (index start) and differences between getMatrix and getSubMatrix
    }
}
package geym.conc.ch5.sort;

import java.util.Arrays;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class QuickSort {
	// static int[] arr = { 5, 52, 6, 3, 4, 10, 8, 100, 35, 78, 64, 31, 77, 90,
	// 45, 53, 89, 78, 1 };
	static int[] arr = { 5, 52, 6, 3, 4 };
	static ExecutorService pool = Executors.newCachedThreadPool();

	public static void quickSort(int[] arr) {
		qsort(arr, 0, arr.length - 1);
	}

	public static void pQuickSort(int[] arr) throws InterruptedException {
		pQsort(arr, 0, arr.length - 1);
	}

	public static class QsortTask implements Runnable {
		int start, end;

		public QsortTask(int start, int end) {
			this.start = start;
			this.end = end;
		}

		@Override
		public void run() {
			try {
				pQsort(arr, start, end);
			} catch (InterruptedException e) {
			}
		}

	}

	/**
	 * 并行递归
	 *
	 * @param arr
	 * @param low
	 * @param high
	 * @throws InterruptedException
	 */
	private static void pQsort(int[] arr, int low, int high)
			throws InterruptedException {
		if (low < high) {
			int pivot = partition(arr, low, high);
			pool.submit(new QsortTask(low, pivot - 1));
			pool.submit(new QsortTask(pivot + 1, high));
		}
	}

	private static void qsort(int[] arr, int low, int high) {
		if (low < high) {
			int pivot = partition(arr, low, high);
			//System.out.println(Arrays.toString(arr)+":"+pivot);
			qsort(arr, low, pivot - 1);
			qsort(arr, pivot + 1, high);
		}
	}

	/**
	 *
	 * @param arr
	 * @param low
	 * @param high
	 * @return 枢轴的位置
	 */
	private static int partition(int[] arr, int low, int high) {
		int pivot = arr[low];
		while (low < high) {
			while (low < high && arr[high] >= pivot)
				--high;
			arr[low] = arr[high];
			while (low < high && arr[low] <= pivot)
				++low;
			arr[high] = arr[low];
		}
		arr[low] = pivot;
		return low;
	}

	public static void main(String[] args) throws InterruptedException {
		// pQuickSort(arr);
		arr=new int[100000];
		for(int i=0;i<arr.length;i++){
			arr[i]=(int)(Math.random()*10000);
		}
//		quickSort(arr);
		pQuickSort(arr);
		Thread.sleep(1000);
		pool.shutdown();
		System.out.println(Arrays.toString(arr));

	}

}
package geym.conc.ch3.ratelimit;

import com.google.common.util.concurrent.RateLimiter;

public class RateLimiterDemo {
	static RateLimiter limiter = RateLimiter.create(2);

	public static class Task implements Runnable {
		@Override
		public void run() {
			System.out.println(System.currentTimeMillis());
		}
	}

	public static void main(String args[]) throws InterruptedException {
		for (int i = 0; i < 50; i++) {
			limiter.acquire();
			new Thread(new Task()).start();
		}
	}
}
package geym.conc.ch3.ratelimit;

import com.google.common.util.concurrent.RateLimiter;

public class RateLimiterDemo2 {
	static RateLimiter limiter = RateLimiter.create(2);

	public static class Task implements Runnable {
		@Override
		public void run() {
			System.out.println(System.currentTimeMillis());
		}
	}

	public static void main(String args[]) throws InterruptedException {
		for (int i = 0; i < 50; i++) {
			if(!limiter.tryAcquire()) {
			    continue;
			}
			new Thread(new Task()).start();
		}
	}
}
package geym.conc.ch3.synctrl;

import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo {
	private static Lock lock=new ReentrantLock();
	private static ReentrantReadWriteLock readWriteLock=new ReentrantReadWriteLock();
	private static Lock readLock = readWriteLock.readLock();
	private static Lock writeLock = readWriteLock.writeLock();
	private int value;

	public Object handleRead(Lock lock) throws InterruptedException{
		try{
			lock.lock();				//模拟读操作
			Thread.sleep(1000);			//读操作的耗时越多，读写锁的优势就越明显
			return value;
		}finally{
		lock.unlock();
		}
	}

	public void handleWrite(Lock lock,int index) throws InterruptedException{
		try{
			lock.lock();				//模拟写操作
			Thread.sleep(1000);
			value=index;
		}finally{
		lock.unlock();
		}
	}

	public static void main(String[] args) {
		final ReadWriteLockDemo demo=new ReadWriteLockDemo();
		Runnable readRunnale=new Runnable() {
			@Override
			public void run() {
				try {
//					demo.handleRead(readLock);
					demo.handleRead(lock);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		};
		Runnable writeRunnale=new Runnable() {
			@Override
			public void run() {
				try {
//					demo.handleWrite(writeLock,new Random().nextInt());
					demo.handleWrite(lock,new Random().nextInt());
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		};

        for(int i=0;i<18;i++){
            new Thread(readRunnale).start();
        }

        for(int i=18;i<20;i++){
            new Thread(writeRunnale).start();
        }
	}
}
package geym.conc.ch5.simplefuture;

public class RealData implements Data {
    protected final String result;
    public RealData(String para) {
        //RealData的构造可能很慢，需要用户等待很久
        StringBuffer sb=new StringBuffer();
        for (int i = 0; i < 10; i++) {
            sb.append(para);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        result=sb.toString();
    }
    public String getResult() {
        return result;
    }
}
package geym.conc.ch5.future;

import java.util.concurrent.Callable;

public class RealData implements Callable<String> {
    private String para;
    public RealData(String para){
    	this.para=para;
    }
	@Override
	public String call() throws Exception {

    	StringBuffer sb=new StringBuffer();
        for (int i = 0; i < 10; i++) {
        	sb.append(para);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        return sb.toString();
	}
}
package geym.conc.ch6.map;

import java.util.concurrent.ConcurrentHashMap;

public class ReduceDemo {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        for (int i = 1; i <= 100; i++) {
            map.put(Integer.toString(i), i);
        }
        int count = map.reduceValues(2, (i, j) -> i + j);
        System.out.println(count);
    }
}
package geym.conc.ch3.synctrl;

import java.util.concurrent.locks.ReentrantLock;

public class ReenterLock implements Runnable{
	public static ReentrantLock lock=new ReentrantLock();
	public static int i=0;
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			lock.lock();
			lock.lock();
			try{
				i++;
			}finally{
				lock.unlock();
				lock.unlock();
			}
		}
	}
	public static void main(String[] args) throws InterruptedException {
		ReenterLock tl=new ReenterLock();
		Thread t1=new Thread(tl);
		Thread t2=new Thread(tl);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.conc.ch3.synctrl.cond;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ReenterLockCondition implements Runnable{
	public static ReentrantLock lock=new ReentrantLock();
	public static Condition condition = lock.newCondition();
	@Override
	public void run() {
		try {
			lock.lock();
			condition.await();
			System.out.println("Thread is going on");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}finally{
			lock.unlock();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		ReenterLockCondition tl=new ReenterLockCondition();
		Thread t1=new Thread(tl);
		t1.start();
		Thread.sleep(2000);
		//通知线程t1继续执行
		lock.lock();
		condition.signal();
//		lock.unlock();
	}
}
package geym.conc.ch3.pool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class RejectThreadPoolDemo {
	public static class MyTask implements Runnable {
		@Override
		public void run() {
			System.out.println(System.currentTimeMillis() + ":Thread ID:"
					+ Thread.currentThread().getId());
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		MyTask task = new MyTask();
		ExecutorService es = new ThreadPoolExecutor(5, 5,
                0L, TimeUnit.MILLISECONDS,
                new SynchronousQueue<Runnable>(),
                Executors.defaultThreadFactory(),
                new RejectedExecutionHandler(){
					@Override
					public void rejectedExecution(Runnable r,
							ThreadPoolExecutor executor) {
						System.out.println(r.toString()+" is discard");
					}
		});
		for (int i = 0; i < Integer.MAX_VALUE; i++) {
			es.submit(task);
			Thread.sleep(10);
		}
	}
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;


import sun.misc.Unsafe;

import com.lmax.disruptor.dsl.ProducerType;
import com.lmax.disruptor.util.Util;

abstract class RingBufferPad
{
    protected long p1, p2, p3, p4, p5, p6, p7;
}

abstract class RingBufferFields<E> extends RingBufferPad
{
    private static final int BUFFER_PAD;
    private static final long REF_ARRAY_BASE;
    private static final int REF_ELEMENT_SHIFT;
    private static final Unsafe UNSAFE = Util.getUnsafe();
    static
    {
        final int scale = UNSAFE.arrayIndexScale(Object[].class);
        if (4 == scale)
        {
            REF_ELEMENT_SHIFT = 2;
        }
        else if (8 == scale)
        {
            REF_ELEMENT_SHIFT = 3;
        }
        else
        {
            throw new IllegalStateException("Unknown pointer size");
        }
        BUFFER_PAD = 128 / scale;
        // Including the buffer pad in the array base offset
        REF_ARRAY_BASE = UNSAFE.arrayBaseOffset(Object[].class) + (BUFFER_PAD << REF_ELEMENT_SHIFT);
    }

    private final long indexMask;
    private final Object[] entries;
    protected final int bufferSize;
    protected final Sequencer sequencer;

    RingBufferFields(EventFactory<E> eventFactory,
                     Sequencer       sequencer)
    {
        this.sequencer  = sequencer;
        this.bufferSize = sequencer.getBufferSize();

        if (bufferSize < 1)
        {
            throw new IllegalArgumentException("bufferSize must not be less than 1");
        }
        if (Integer.bitCount(bufferSize) != 1)
        {
            throw new IllegalArgumentException("bufferSize must be a power of 2");
        }

        this.indexMask = bufferSize - 1;
        this.entries   = new Object[sequencer.getBufferSize() + 2 * BUFFER_PAD];
        fill(eventFactory);
    }

    private void fill(EventFactory<E> eventFactory)
    {
        for (int i = 0; i < bufferSize; i++)
        {
            entries[BUFFER_PAD + i] = eventFactory.newInstance();
        }
    }

    @SuppressWarnings("unchecked")
    protected final E elementAt(long sequence)
    {
        return (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence & indexMask) << REF_ELEMENT_SHIFT));
    }
}

/**
 * Ring based store of reusable entries containing the data representing
 * an event being exchanged between event producer and {@link EventProcessor}s.
 *
 * @param <E> implementation storing the data for sharing during exchange or parallel coordination of an event.
 */
public final class RingBuffer<E> extends RingBufferFields<E> implements Cursored, EventSequencer<E>, EventSink<E>
{
    public static final long INITIAL_CURSOR_VALUE = Sequence.INITIAL_VALUE;
    protected long p1, p2, p3, p4, p5, p6, p7;

    /**
     * Construct a RingBuffer with the full option set.
     *
     * @param eventFactory to newInstance entries for filling the RingBuffer
     * @param sequencer sequencer to handle the ordering of events moving through the RingBuffer.
     * @throws IllegalArgumentException if bufferSize is less than 1 or not a power of 2
     */
    RingBuffer(EventFactory<E> eventFactory,
               Sequencer       sequencer)
    {
        super(eventFactory, sequencer);
    }

    /**
     * Create a new multiple producer RingBuffer with the specified wait strategy.
     *
     * @see MultiProducerSequencer
     * @param factory used to create the events within the ring buffer.
     * @param bufferSize number of elements to create within the ring buffer.
     * @param waitStrategy used to determine how to wait for new elements to become available.
     * @throws IllegalArgumentException if bufferSize is less than 1 or not a power of 2
     */
    public static <E> RingBuffer<E> createMultiProducer(EventFactory<E> factory,
                                                        int             bufferSize,
                                                        WaitStrategy    waitStrategy)
    {
        MultiProducerSequencer sequencer = new MultiProducerSequencer(bufferSize, waitStrategy);

        return new RingBuffer<E>(factory, sequencer);
    }

    /**
     * Create a new multiple producer RingBuffer using the default wait strategy  {@link BlockingWaitStrategy}.
     *
     * @see MultiProducerSequencer
     * @param factory used to create the events within the ring buffer.
     * @param bufferSize number of elements to create within the ring buffer.
     * @throws IllegalArgumentException if <tt>bufferSize</tt> is less than 1 or not a power of 2
     */
    public static <E> RingBuffer<E> createMultiProducer(EventFactory<E> factory, int bufferSize)
    {
        return createMultiProducer(factory, bufferSize, new BlockingWaitStrategy());
    }

    /**
     * Create a new single producer RingBuffer with the specified wait strategy.
     *
     * @see SingleProducerSequencer
     * @param factory used to create the events within the ring buffer.
     * @param bufferSize number of elements to create within the ring buffer.
     * @param waitStrategy used to determine how to wait for new elements to become available.
     * @throws IllegalArgumentException if bufferSize is less than 1 or not a power of 2
     */
    public static <E> RingBuffer<E> createSingleProducer(EventFactory<E> factory,
                                                         int             bufferSize,
                                                         WaitStrategy    waitStrategy)
    {
        SingleProducerSequencer sequencer = new SingleProducerSequencer(bufferSize, waitStrategy);

        return new RingBuffer<E>(factory, sequencer);
    }

    /**
     * Create a new single producer RingBuffer using the default wait strategy  {@link BlockingWaitStrategy}.
     *
     * @see MultiProducerSequencer
     * @param factory used to create the events within the ring buffer.
     * @param bufferSize number of elements to create within the ring buffer.
     * @throws IllegalArgumentException if <tt>bufferSize</tt> is less than 1 or not a power of 2
     */
    public static <E> RingBuffer<E> createSingleProducer(EventFactory<E> factory, int bufferSize)
    {
        return createSingleProducer(factory, bufferSize, new BlockingWaitStrategy());
    }

    /**
     * Create a new Ring Buffer with the specified producer type (SINGLE or MULTI)
     *
     * @param producerType producer type to use {@link ProducerType}.
     * @param factory used to create events within the ring buffer.
     * @param bufferSize number of elements to create within the ring buffer.
     * @param waitStrategy used to determine how to wait for new elements to become available.
     * @throws IllegalArgumentException if bufferSize is less than 1 or not a power of 2
     */
    public static <E> RingBuffer<E> create(ProducerType    producerType,
                                           EventFactory<E> factory,
                                           int             bufferSize,
                                           WaitStrategy    waitStrategy)
    {
        switch (producerType)
        {
        case SINGLE:
            return createSingleProducer(factory, bufferSize, waitStrategy);
        case MULTI:
            return createMultiProducer(factory, bufferSize, waitStrategy);
        default:
            throw new IllegalStateException(producerType.toString());
        }
    }

    /**
     * <p>Get the event for a given sequence in the RingBuffer.</p>
     *
     * <p>This call has 2 uses.  Firstly use this call when publishing to a ring buffer.
     * After calling {@link RingBuffer#next()} use this call to get hold of the
     * preallocated event to fill with data before calling {@link RingBuffer#publish(long)}.</p>
     *
     * <p>Secondly use this call when consuming data from the ring buffer.  After calling
     * {@link SequenceBarrier#waitFor(long)} call this method with any value greater than
     * that your current consumer sequence and less than or equal to the value returned from
     * the {@link SequenceBarrier#waitFor(long)} method.</p>
     *
     * @param sequence for the event
     * @return the event for the given sequence
     */
    @Override
    public E get(long sequence)
    {
        return elementAt(sequence);
    }

    /**
     * Increment and return the next sequence for the ring buffer.  Calls of this
     * method should ensure that they always publish the sequence afterward.  E.g.
     * <pre>
     * long sequence = ringBuffer.next();
     * try {
     *     Event e = ringBuffer.get(sequence);
     *     // Do some work with the event.
     * } finally {
     *     ringBuffer.publish(sequence);
     * }
     * </pre>
     * @see RingBuffer#publish(long)
     * @see RingBuffer#get(long)
     * @return The next sequence to publish to.
     */
    @Override
    public long next()
    {
        return sequencer.next();
    }

    /**
     * The same functionality as {@link RingBuffer#next()}, but allows the caller to claim
     * the next n sequences.
     *
     * @see Sequencer#next(int)
     * @param n number of slots to claim
     * @return sequence number of the highest slot claimed
     */
    @Override
    public long next(int n)
    {
        return sequencer.next(n);
    }

    /**
     * <p>Increment and return the next sequence for the ring buffer.  Calls of this
     * method should ensure that they always publish the sequence afterward.  E.g.
     * <pre>
     * long sequence = ringBuffer.next();
     * try {
     *     Event e = ringBuffer.get(sequence);
     *     // Do some work with the event.
     * } finally {
     *     ringBuffer.publish(sequence);
     * }
     * </pre>
     * <p>This method will not block if there is not space available in the ring
     * buffer, instead it will throw an {@link InsufficientCapacityException}.
     *
     *
     * @see RingBuffer#publish(long)
     * @see RingBuffer#get(long)
     * @return The next sequence to publish to.
     * @throws InsufficientCapacityException if the necessary space in the ring buffer is not available
     */
    @Override
    public long tryNext() throws InsufficientCapacityException
    {
        return sequencer.tryNext();
    }

    /**
     * The same functionality as {@link RingBuffer#tryNext()}, but allows the caller to attempt
     * to claim the next n sequences.
     *
     * @param n number of slots to claim
     * @return sequence number of the highest slot claimed
     * @throws InsufficientCapacityException if the necessary space in the ring buffer is not available
     */
    @Override
    public long tryNext(int n) throws InsufficientCapacityException
    {
        return sequencer.tryNext(n);
    }

    /**
     * Resets the cursor to a specific value.  This can be applied at any time, but it is worth noting
     * that it can cause a data race and should only be used in controlled circumstances.  E.g. during
     * initialisation.
     *
     * @param sequence The sequence to reset too.
     * @throws IllegalStateException If any gating sequences have already been specified.
     */
    @Deprecated
    public void resetTo(long sequence)
    {
        sequencer.claim(sequence);
        sequencer.publish(sequence);
    }

    /**
     * Sets the cursor to a specific sequence and returns the preallocated entry that is stored there.  This
     * can cause a data race and should only be done in controlled circumstances, e.g. during initialisation.
     *
     * @param sequence The sequence to claim.
     * @return The preallocated event.
     */
    public E claimAndGetPreallocated(long sequence)
    {
        sequencer.claim(sequence);
        return get(sequence);
    }

    /**
     * Determines if a particular entry has been published.
     *
     * @param sequence The sequence to identify the entry.
     * @return If the value has been published or not.
     */
    public boolean isPublished(long sequence)
    {
        return sequencer.isAvailable(sequence);
    }

    /**
     * Add the specified gating sequences to this instance of the Disruptor.  They will
     * safely and atomically added to the list of gating sequences.
     *
     * @param gatingSequences The sequences to add.
     */
    public void addGatingSequences(Sequence... gatingSequences)
    {
        sequencer.addGatingSequences(gatingSequences);
    }

    /**
     * Get the minimum sequence value from all of the gating sequences
     * added to this ringBuffer.
     *
     * @return The minimum gating sequence or the cursor sequence if
     * no sequences have been added.
     */
    public long getMinimumGatingSequence()
    {
        return sequencer.getMinimumSequence();
    }

    /**
     * Remove the specified sequence from this ringBuffer.
     *
     * @param sequence to be removed.
     * @return <tt>true</tt> if this sequence was found, <tt>false</tt> otherwise.
     */
    public boolean removeGatingSequence(Sequence sequence)
    {
        return sequencer.removeGatingSequence(sequence);
    }

    /**
     * Create a new SequenceBarrier to be used by an EventProcessor to track which messages
     * are available to be read from the ring buffer given a list of sequences to track.
     *
     * @see SequenceBarrier
     * @param sequencesToTrack the additional sequences to track
     * @return A sequence barrier that will track the specified sequences.
     */
    public SequenceBarrier newBarrier(Sequence... sequencesToTrack)
    {
        return sequencer.newBarrier(sequencesToTrack);
    }

    /**
     * Creates an event poller for this ring buffer gated on the supplied sequences.
     *
     * @param gatingSequences
     * @return A poller that will gate on this ring buffer and the supplied sequences.
     */
    public EventPoller<E> newPoller(Sequence... gatingSequences)
    {
        return sequencer.newPoller(this, gatingSequences);
    }

    /**
     * Get the current cursor value for the ring buffer.  The actual value recieved
     * will depend on the type of {@link Sequencer} that is being used.
     *
     * @see MultiProducerSequencer
     * @see SingleProducerSequencer
     */
    @Override
    public long getCursor()
    {
        return sequencer.getCursor();
    }

    /**
     * The size of the buffer.
     */
    public int getBufferSize()
    {
        return bufferSize;
    }

    /**
     * Given specified <tt>requiredCapacity</tt> determines if that amount of space
     * is available.  Note, you can not assume that if this method returns <tt>true</tt>
     * that a call to {@link RingBuffer#next()} will not block.  Especially true if this
     * ring buffer is set up to handle multiple producers.
     *
     * @param requiredCapacity The capacity to check for.
     * @return <tt>true</tt> If the specified <tt>requiredCapacity</tt> is available
     * <tt>false</tt> if now.
     */
    public boolean hasAvailableCapacity(int requiredCapacity)
    {
        return sequencer.hasAvailableCapacity(requiredCapacity);
    }


    /**
     * @see com.lmax.disruptor.EventSink#publishEvent(com.lmax.disruptor.EventTranslator)
     */
    @Override
    public void publishEvent(EventTranslator<E> translator)
    {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvent(com.lmax.disruptor.EventTranslator)
     */
    @Override
    public boolean tryPublishEvent(EventTranslator<E> translator)
    {
        try
        {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvent(com.lmax.disruptor.EventTranslatorOneArg, Object)
     *      com.lmax.disruptor.EventSink#publishEvent(com.lmax.disruptor.EventTranslatorOneArg, A)
     */
    @Override
    public <A> void publishEvent(EventTranslatorOneArg<E, A> translator, A arg0)
    {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence, arg0);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvent(com.lmax.disruptor.EventTranslatorOneArg, Object)
     *      com.lmax.disruptor.EventSink#tryPublishEvent(com.lmax.disruptor.EventTranslatorOneArg, A)
     */
    @Override
    public <A> boolean tryPublishEvent(EventTranslatorOneArg<E, A> translator, A arg0)
    {
        try
        {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence, arg0);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvent(com.lmax.disruptor.EventTranslatorTwoArg, Object, Object)
     *      com.lmax.disruptor.EventSink#publishEvent(com.lmax.disruptor.EventTranslatorTwoArg, A, B)
     */
    @Override
    public <A, B> void publishEvent(EventTranslatorTwoArg<E, A, B> translator, A arg0, B arg1)
    {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence, arg0, arg1);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvent(com.lmax.disruptor.EventTranslatorTwoArg, Object, Object)
     *      com.lmax.disruptor.EventSink#tryPublishEvent(com.lmax.disruptor.EventTranslatorTwoArg, A, B)
     */
    @Override
    public <A, B> boolean tryPublishEvent(EventTranslatorTwoArg<E, A, B> translator, A arg0, B arg1)
    {
        try
        {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence, arg0, arg1);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvent(com.lmax.disruptor.EventTranslatorThreeArg, Object, Object, Object)
     *      com.lmax.disruptor.EventSink#publishEvent(com.lmax.disruptor.EventTranslatorThreeArg, A, B, C)
     */
    @Override
    public <A, B, C> void publishEvent(EventTranslatorThreeArg<E, A, B, C> translator, A arg0, B arg1, C arg2)
    {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence, arg0, arg1, arg2);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvent(com.lmax.disruptor.EventTranslatorThreeArg, Object, Object, Object)
     *      com.lmax.disruptor.EventSink#tryPublishEvent(com.lmax.disruptor.EventTranslatorThreeArg, A, B, C)
     */
    @Override
    public <A, B, C> boolean tryPublishEvent(EventTranslatorThreeArg<E, A, B, C> translator, A arg0, B arg1, C arg2)
    {
        try
        {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence, arg0, arg1, arg2);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvent(com.lmax.disruptor.EventTranslatorVararg, java.lang.Object...)
     */
    @Override
    public void publishEvent(EventTranslatorVararg<E> translator, Object...args)
    {
        final long sequence = sequencer.next();
        translateAndPublish(translator, sequence, args);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvent(com.lmax.disruptor.EventTranslatorVararg, java.lang.Object...)
     */
    @Override
    public boolean tryPublishEvent(EventTranslatorVararg<E> translator, Object...args)
    {
        try
        {
            final long sequence = sequencer.tryNext();
            translateAndPublish(translator, sequence, args);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }


    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslator[])
     */
    @Override
    public void publishEvents(EventTranslator<E>[] translators)
    {
        publishEvents(translators, 0, translators.length);
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslator[], int, int)
     */
    @Override
    public void publishEvents(EventTranslator<E>[] translators, int batchStartsAt, int batchSize)
    {
        checkBounds(translators, batchStartsAt, batchSize);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translators, batchStartsAt, batchSize, finalSequence);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslator[])
     */
    @Override
    public boolean tryPublishEvents(EventTranslator<E>[] translators)
    {
        return tryPublishEvents(translators, 0, translators.length);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslator[], int, int)
     */
    @Override
    public boolean tryPublishEvents(EventTranslator<E>[] translators, int batchStartsAt, int batchSize)
    {
        checkBounds(translators, batchStartsAt, batchSize);
        try
        {
            final long finalSequence = sequencer.tryNext(batchSize);
            translateAndPublishBatch(translators, batchStartsAt, batchSize, finalSequence);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorOneArg, Object[])
     *      com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorOneArg, A[])
     */
    @Override
    public <A> void publishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0)
    {
        publishEvents(translator, 0, arg0.length, arg0);
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorOneArg, int, int, Object[])
     *      com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorOneArg, int, int, A[])
     */
    @Override
    public <A> void publishEvents(EventTranslatorOneArg<E, A> translator, int batchStartsAt, int batchSize, A[] arg0)
    {
        checkBounds(arg0, batchStartsAt, batchSize);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translator, arg0, batchStartsAt, batchSize, finalSequence);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorOneArg, Object[])
     *      com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorOneArg, A[])
     */
    @Override
    public <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, A[] arg0)
    {
        return tryPublishEvents(translator, 0, arg0.length, arg0);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorOneArg, int, int, Object[])
     *      com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorOneArg, int, int, A[])
     */
    @Override
    public <A> boolean tryPublishEvents(EventTranslatorOneArg<E, A> translator, int batchStartsAt, int batchSize, A[] arg0)
    {
        checkBounds(arg0, batchStartsAt, batchSize);
        try
        {
            final long finalSequence = sequencer.tryNext(batchSize);
            translateAndPublishBatch(translator, arg0, batchStartsAt, batchSize, finalSequence);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorTwoArg, Object[], Object[])
     *      com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorTwoArg, A[], B[])
     */
    @Override
    public <A, B> void publishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1)
    {
        publishEvents(translator, 0, arg0.length, arg0, arg1);
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorTwoArg, int, int, Object[], Object[])
     *      com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorTwoArg, int, int, A[], B[])
     */
    @Override
    public <A, B> void publishEvents(EventTranslatorTwoArg<E, A, B> translator, int batchStartsAt, int batchSize, A[] arg0, B[] arg1)
    {
        checkBounds(arg0, arg1, batchStartsAt, batchSize);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translator, arg0, arg1, batchStartsAt, batchSize, finalSequence);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorTwoArg, Object[], Object[])
     *      com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorTwoArg, A[], B[])
     */
    @Override
    public <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator, A[] arg0, B[] arg1)
    {
        return tryPublishEvents(translator, 0, arg0.length, arg0, arg1);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorTwoArg, int, int, Object[], Object[])
     *      com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorTwoArg, int, int, A[], B[])
     */
    @Override
    public <A, B> boolean tryPublishEvents(EventTranslatorTwoArg<E, A, B> translator, int batchStartsAt, int batchSize, A[] arg0, B[] arg1)
    {
        checkBounds(arg0, arg1, batchStartsAt, batchSize);
        try
        {
            final long finalSequence = sequencer.tryNext(batchSize);
            translateAndPublishBatch(translator, arg0, arg1, batchStartsAt, batchSize, finalSequence);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorThreeArg, Object[], Object[], Object[])
     *      com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorThreeArg, A[], B[], C[])
     */
    @Override
    public <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2)
    {
        publishEvents(translator, 0, arg0.length, arg0, arg1, arg2);
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorThreeArg, int, int, Object[], Object[], Object[])
     *      com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorThreeArg, int, int, A[], B[], C[])
     */
    @Override
    public <A, B, C> void publishEvents(EventTranslatorThreeArg<E, A, B, C> translator, int batchStartsAt, int batchSize, A[] arg0, B[] arg1, C[] arg2)
    {
        checkBounds(arg0, arg1, arg2, batchStartsAt, batchSize);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translator, arg0, arg1, arg2, batchStartsAt, batchSize, finalSequence);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorThreeArg, Object[], Object[], Object[])
     *      com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorThreeArg, A[], B[], C[])
     */
    @Override
    public <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> translator, A[] arg0, B[] arg1, C[] arg2)
    {
        return tryPublishEvents(translator, 0, arg0.length, arg0, arg1, arg2);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorThreeArg, int, int, Object[], Object[], Object[])
     *      com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorThreeArg, int, int, A[], B[], C[])
     */
    @Override
    public <A, B, C> boolean tryPublishEvents(EventTranslatorThreeArg<E, A, B, C> translator, int batchStartsAt, int batchSize, A[] arg0, B[] arg1, C[] arg2)
    {
        checkBounds(arg0, arg1, arg2, batchStartsAt, batchSize);
        try
        {
            final long finalSequence = sequencer.tryNext(batchSize);
            translateAndPublishBatch(translator, arg0, arg1, arg2, batchStartsAt, batchSize, finalSequence);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorVararg, java.lang.Object[][])
     */
    @Override
    public void publishEvents(EventTranslatorVararg<E> translator, Object[]... args)
    {
        publishEvents(translator, 0, args.length, args);
    }

    /**
     * @see com.lmax.disruptor.EventSink#publishEvents(com.lmax.disruptor.EventTranslatorVararg, int, int, java.lang.Object[][])
     */
    @Override
    public void publishEvents(EventTranslatorVararg<E> translator, int batchStartsAt, int batchSize, Object[]... args)
    {
        checkBounds(batchStartsAt, batchSize, args);
        final long finalSequence = sequencer.next(batchSize);
        translateAndPublishBatch(translator, batchStartsAt, batchSize, finalSequence, args);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorVararg, java.lang.Object[][])
     */
    @Override
    public boolean tryPublishEvents(EventTranslatorVararg<E> translator, Object[]... args)
    {
        return tryPublishEvents(translator, 0, args.length, args);
    }

    /**
     * @see com.lmax.disruptor.EventSink#tryPublishEvents(com.lmax.disruptor.EventTranslatorVararg, int, int, java.lang.Object[][])
     */
    @Override
    public boolean tryPublishEvents(EventTranslatorVararg<E> translator, int batchStartsAt, int batchSize, Object[]... args)
    {
        checkBounds(args, batchStartsAt, batchSize);
        try
        {
            final long finalSequence = sequencer.tryNext(batchSize);
            translateAndPublishBatch(translator, batchStartsAt, batchSize, finalSequence, args);
            return true;
        }
        catch (InsufficientCapacityException e)
        {
            return false;
        }
    }

    /**
     * Publish the specified sequence.  This action marks this particular
     * message as being available to be read.
     *
     * @param sequence the sequence to publish.
     */
    @Override
    public void publish(long sequence)
    {
        sequencer.publish(sequence);
    }

    /**
     * Publish the specified sequences.  This action marks these particular
     * messages as being available to be read.
     *
     * @see Sequencer#next(int)
     * @param lo the lowest sequence number to be published
     * @param hi the highest sequence number to be published
     */
    @Override
    public void publish(long lo, long hi)
    {
        sequencer.publish(lo, hi);
    }

    /**
     * Get the remaining capacity for this ringBuffer.
     * @return The number of slots remaining.
     */
    public long remainingCapacity()
    {
        return sequencer.remainingCapacity();
    }

    private void checkBounds(final EventTranslator<E>[] translators, final int batchStartsAt, final int batchSize)
    {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(translators, batchStartsAt, batchSize);
    }

    private void checkBatchSizing(int batchStartsAt, int batchSize)
    {
        if(batchStartsAt < 0 || batchSize < 0)
        {
            throw new IllegalArgumentException("Both batchStartsAt and batchSize must be positive but got: batchStartsAt " + batchStartsAt + " and batchSize " + batchSize);
        }
        else if(batchSize > bufferSize)
        {
            throw new IllegalArgumentException("The ring buffer cannot accommodate " + batchSize + " it only has space for " + bufferSize + " entities.");
        }
    }

    private <A> void checkBounds(final A[] arg0, final int batchStartsAt, final int batchSize)
    {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(arg0, batchStartsAt, batchSize);
    }

    private <A, B> void checkBounds(final A[] arg0, final B[] arg1, final int batchStartsAt, final int batchSize)
    {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(arg0, batchStartsAt, batchSize);
        batchOverRuns(arg1, batchStartsAt, batchSize);
    }

    private <A, B, C> void checkBounds(final A[] arg0, final B[] arg1, final C[] arg2, final int batchStartsAt, final int batchSize)
    {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(arg0, batchStartsAt, batchSize);
        batchOverRuns(arg1, batchStartsAt, batchSize);
        batchOverRuns(arg2, batchStartsAt, batchSize);
    }

    private void checkBounds(final int batchStartsAt, final int batchSize, final Object[][] args)
    {
        checkBatchSizing(batchStartsAt, batchSize);
        batchOverRuns(args, batchStartsAt, batchSize);
    }

    private <A> void batchOverRuns(final A[] arg0, final int batchStartsAt, final int batchSize)
    {
        if(batchStartsAt + batchSize > arg0.length)
        {
            throw new IllegalArgumentException("A batchSize of: " + batchSize +
                                               " with batchStatsAt of: " + batchStartsAt +
                                               " will overrun the available number of arguments: " + (arg0.length - batchStartsAt));
        }
    }

    private void translateAndPublish(EventTranslator<E> translator, long sequence)
    {
        try
        {
            translator.translateTo(get(sequence), sequence);
        }
        finally
        {
            sequencer.publish(sequence);
        }
    }

    private <A> void translateAndPublish(EventTranslatorOneArg<E, A> translator, long sequence, A arg0)
    {
        try
        {
            translator.translateTo(get(sequence), sequence, arg0);
        }
        finally
        {
            sequencer.publish(sequence);
        }
    }

    private <A, B> void translateAndPublish(EventTranslatorTwoArg<E, A, B> translator, long sequence, A arg0, B arg1)
    {
        try
        {
            translator.translateTo(get(sequence), sequence, arg0, arg1);
        }
        finally
        {
            sequencer.publish(sequence);
        }
    }

    private <A, B, C> void translateAndPublish(EventTranslatorThreeArg<E, A, B, C> translator, long sequence,
                                               A arg0, B arg1, C arg2)
    {
        try
        {
            translator.translateTo(get(sequence), sequence, arg0, arg1, arg2);
        }
        finally
        {
            sequencer.publish(sequence);
        }
    }

    private void translateAndPublish(EventTranslatorVararg<E> translator, long sequence, Object...args)
    {
        try
        {
            translator.translateTo(get(sequence), sequence, args);
        }
        finally
        {
            sequencer.publish(sequence);
        }
    }

    private void translateAndPublishBatch(final EventTranslator<E>[] translators, int batchStartsAt,
                                          final int batchSize, final long finalSequence)
    {
        final long initialSequence = finalSequence - (batchSize - 1);
        try
        {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++)
            {
                final EventTranslator<E> translator = translators[i];
                translator.translateTo(get(sequence), sequence++);
            }
        }
        finally
        {
            sequencer.publish(initialSequence, finalSequence);
        }
    }

    private <A> void translateAndPublishBatch(final EventTranslatorOneArg<E, A> translator, final A[] arg0,
                                              int batchStartsAt, final int batchSize, final long finalSequence)
    {
        final long initialSequence = finalSequence - (batchSize - 1);
        try
        {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++)
            {
                translator.translateTo(get(sequence), sequence++, arg0[i]);
            }
        }
        finally
        {
            sequencer.publish(initialSequence, finalSequence);
        }
    }

    private <A, B> void translateAndPublishBatch(final EventTranslatorTwoArg<E, A, B> translator, final A[] arg0,
                                                 final B[] arg1, int batchStartsAt, int batchSize,
                                                 final long finalSequence)
    {
        final long initialSequence = finalSequence - (batchSize - 1);
        try
        {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++)
            {
                translator.translateTo(get(sequence), sequence++, arg0[i], arg1[i]);
            }
        }
        finally
        {
            sequencer.publish(initialSequence, finalSequence);
        }
    }

    private <A, B, C> void translateAndPublishBatch(final EventTranslatorThreeArg<E, A, B, C> translator,
                                                    final A[] arg0, final B[] arg1, final C[] arg2, int batchStartsAt,
                                                    final int batchSize, final long finalSequence)
    {
        final long initialSequence = finalSequence - (batchSize - 1);
        try
        {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++)
            {
                translator.translateTo(get(sequence), sequence++, arg0[i], arg1[i], arg2[i]);
            }
        }
        finally
        {
            sequencer.publish(initialSequence, finalSequence);
        }
    }

    private void translateAndPublishBatch(final EventTranslatorVararg<E> translator, int batchStartsAt,
                                          final int batchSize, final long finalSequence, final Object[][] args)
    {
        final long initialSequence = finalSequence - (batchSize - 1);
        try
        {
            long sequence = initialSequence;
            final int batchEndsAt = batchStartsAt + batchSize;
            for (int i = batchStartsAt; i < batchEndsAt; i++)
            {
                translator.translateTo(get(sequence), sequence++, args[i]);
            }
        }
        finally
        {
            sequencer.publish(initialSequence, finalSequence);
        }
    }
}

package geym.conc.ch4.tl;

import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class RndMultiThread {
    public static final int GEN_COUNT = 10000000;
    public static final int THREAD_COUNT = 4;
    static ExecutorService exe = Executors.newFixedThreadPool(THREAD_COUNT);
    public static Random rnd = new Random(123);

    public static ThreadLocal<Random> tRnd = new ThreadLocal<Random>() {
        @Override
        protected Random initialValue() {
            return new Random(123);
        }
    };

    public static class RndTask implements Callable<Long> {
        private int mode = 0;

        public RndTask(int mode) {
            this.mode = mode;
        }

        public Random getRandom() {
            if (mode == 0) {
                return rnd;
            } else if (mode == 1) {
                return tRnd.get();
            } else {
                return null;
            }
        }

        @Override
        public Long call() {
            long b = System.currentTimeMillis();
            for (long i = 0; i < GEN_COUNT; i++) {
                getRandom().nextInt();
            }
            long e = System.currentTimeMillis();
            System.out.println(Thread.currentThread().getName() + " spend " + (e - b) + "ms");
            return e - b;
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        Future<Long>[] futs = new Future[THREAD_COUNT];
        for (int i = 0; i < THREAD_COUNT; i++) {
            futs[i] = exe.submit(new RndTask(0));
        }
        long totaltime = 0;
        for (int i = 0; i < THREAD_COUNT; i++) {
            totaltime += futs[i].get();
        }
        System.out.println("多线程访问同一个Random实例:" + totaltime + "ms");

        //ThreadLocal的情况
        for (int i = 0; i < THREAD_COUNT; i++) {
            futs[i] = exe.submit(new RndTask(1));
        }
        totaltime = 0;
        for (int i = 0; i < THREAD_COUNT; i++) {
            totaltime += futs[i].get();
        }
        System.out.println("使用ThreadLocal包装Random实例:" + totaltime + "ms");
        exe.shutdown();
    }
}
package org.jmatrices.dbl.rowcoltr;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.transformer.MatrixTransformer;
import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

/**
 * RowTransformer  captures the operations that can be carried out on rows of a matrix
 * <p>
 * Given a matrix of dimension mxn <strong> M -yields-> C</strong> ,where C is a column vector of dimension mx1.
 * </p>
 * <p>
 * All operations on a matrix fitting this pattern can be found here!
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 20:37:21
 */
public final class RowTransformer {
    /**
     * Sums up all the rows and returns them as a column vector
     *
     * @param m Matrix
     * @return c(mx1) column vector with row sums
     */
    public static Matrix sum(Matrix m) {
        return MatrixTransformer.transpose(ColumnTransformer.sum(MatrixTransformer.transpose(m)));
    }

    /**
     * Multiplies up all the elements in a row and returns them as a column vector
     *
     * @param m Matrix
     * @return c(mx1) column vector with row products
     */
    public static Matrix product(Matrix m) {
        return MatrixTransformer.transpose(ColumnTransformer.product(MatrixTransformer.transpose(m)));
    }

    /**
     * Gets the means of  all the elements in a row and returns them as a column vector
     * <p>adjustment- calculates the mean by dividing the sum of all values by (n-1) instead of n,
     * which is the number of elements in the row</p>
     *
     * @param m          Matrix
     * @param adjustment true or false
     * @return c(mx1) column vector with row means
     */
    public static Matrix mean(Matrix m, boolean adjustment) {
        return MatrixTransformer.transpose(ColumnTransformer.mean(MatrixTransformer.transpose(m), adjustment));
    }

    /**
     * Gets the maximum element in a row and returns the selected ones as a column vector
     *
     * @param m Matrix
     * @return c(mx1) column vector with row's maximum values
     */
    public static Matrix max(Matrix m) {
        return MatrixTransformer.transpose(ColumnTransformer.max(MatrixTransformer.transpose(m)));
    }

    /**
     * Gets the minimum element in a column and returns the selected as a row vector
     *
     * @param m Matrix
     * @return c(mx1) column vector with rows's minimum values
     */
    public static Matrix min(Matrix m) {
        return MatrixTransformer.transpose(ColumnTransformer.min(MatrixTransformer.transpose(m)));
    }


    private RowTransformer() {
    }

}

/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package geym.conc.ch3.pool;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledExecutorServiceDemo {
    public static void main(String[] args) {
        ScheduledExecutorService ses=Executors.newScheduledThreadPool(10);
        //如果前面的任务没有完成，则调度也不会启动
        ses.scheduleWithFixedDelay(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                    System.out.println(System.currentTimeMillis()/1000);
//                    if(System.currentTimeMillis()%2==0){
//                    	System.out.println("exception");
//                    	throw new RuntimeException();
//                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, 0, 2, TimeUnit.SECONDS);

    }
}
package geym.conc.ch5.search;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 并发查找
 *
 * @author Administrator
 *
 */
public class Search {
	static int[] arr = { 5, 52, 6, 3, 4, 10, 8, 100, 35, 78, 64, 31, 77, 90,
			45, 53, 89, 78, 1,2 };
	static ExecutorService pool = Executors.newCachedThreadPool();
	static final int Thread_Num=2;
	static AtomicInteger result=new AtomicInteger(-1);

	public static void createArray(){
	    arr=new int[1000*1000*100];
	    Random r=new Random();
	    for(int i=0;i<arr.length;i++){
	        arr[i]=i;
	    }
	}
	/**
	 * [beginPos,endPos)
	 * @param searchValue
	 * @param beginPos  [
	 * @param endPos    )
	 * @return  -1: can't find
	 *          >=0:pos of find ele
	 */
	public static int search(int searchValue,int beginPos,int endPos){
		int i=0;
		for(i=beginPos;i<endPos;i++){
		    if(result.get()>=0){
		        return result.get();
		    }
			if(arr[i] == searchValue){
			    //如果设置失败，表示其它线程已经先找到了
			    if(!result.compareAndSet(-1, i)){
			        return result.get();
			    }
				return i;
			}
		}
		return -1;
	}

	public static class SearchTask implements Callable<Integer>{
		int begin,end,searchValue;
		public SearchTask(int searchValue,int begin,int end){
			this.begin=begin;
			this.end=end;
			this.searchValue=searchValue;
		}
		public Integer call(){
			int re= search(searchValue,begin,end);
			return re;
		}
	}

	public static int pSearch(int searchValue) throws InterruptedException, ExecutionException{
		int subArrSize=arr.length/Thread_Num+1;
		List<Future<Integer>> re=new ArrayList<Future<Integer>>();
		for(int i=0;i<arr.length;i+=subArrSize){
			int end = i+subArrSize;
			if(end>=arr.length)end=arr.length;
			re.add(pool.submit(new SearchTask(searchValue,i,end)));
		}
		for(Future<Integer> fu:re){
			if(fu.get()>=0)return fu.get();
		}
		return -1;
	}

	public static void main(String[] args) throws InterruptedException, ExecutionException {
//	    createArray();
		int pos=pSearch(2);
		pool.shutdownNow();
		System.out.println(pos);
	}
}
package geym.conc.ch6.map;

import java.util.concurrent.ConcurrentHashMap;

public class SearchDemo {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        for (int i = 1; i <= 100; i++) {
            map.put(Integer.toString(i), i);
        }
        int found = map.search(Long.MAX_VALUE, (str,i)->{
            if(i%2==0) {
                return i;
            }
            return null;
        });
        System.out.println(found);
    }
}
package geym.conc.ch3.synctrl;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class SemapDemo implements Runnable {
	final Semaphore semp = new Semaphore(5);

	@Override
	public void run() {
		try {
			semp.acquire();
			Thread.sleep(2000);
			System.out.println(Thread.currentThread().getId() + ":done!");
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			semp.release();
		}
	}

	public static void main(String[] args) {
		ExecutorService exec = Executors.newFixedThreadPool(20);
		final SemapDemo demo = new SemapDemo();
		for (int i = 0; i < 20; i++) {
			exec.submit(demo);
		}
	}
}
/*
 * Copyright 2012 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import sun.misc.Unsafe;

import com.lmax.disruptor.util.Util;


class LhsPadding
{
    protected long p1, p2, p3, p4, p5, p6, p7;
}

class Value extends LhsPadding
{
    protected volatile long value;
}

class RhsPadding extends Value
{
    protected long p9, p10, p11, p12, p13, p14, p15;
}

/**
 * <p>Concurrent sequence class used for tracking the progress of
 * the ring buffer and event processors.  Support a number
 * of concurrent operations including CAS and order writes.
 *
 * <p>Also attempts to be more efficient with regards to false
 * sharing by adding padding around the volatile field.
 */
public class Sequence extends RhsPadding
{
    static final long INITIAL_VALUE = -1L;
    private static final Unsafe UNSAFE;
    private static final long VALUE_OFFSET;

    static
    {
        UNSAFE = Util.getUnsafe();
        try
        {
            VALUE_OFFSET = UNSAFE.objectFieldOffset(Value.class.getDeclaredField("value"));
        }
        catch (final Exception e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * Create a sequence initialised to -1.
     */
    public Sequence()
    {
        this(INITIAL_VALUE);
    }

    /**
     * Create a sequence with a specified initial value.
     *
     * @param initialValue The initial value for this sequence.
     */
    public Sequence(final long initialValue)
    {
        UNSAFE.putOrderedLong(this, VALUE_OFFSET, initialValue);
    }

    /**
     * Perform a volatile read of this sequence's value.
     *
     * @return The current value of the sequence.
     */
    public long get()
    {
        return value;
    }

    /**
     * Perform an ordered write of this sequence.  The intent is
     * a Store/Store barrier between this write and any previous
     * store.
     *
     * @param value The new value for the sequence.
     */
    public void set(final long value)
    {
        UNSAFE.putOrderedLong(this, VALUE_OFFSET, value);
    }

    /**
     * Performs a volatile write of this sequence.  The intent is
     * a Store/Store barrier between this write and any previous
     * write and a Store/Load barrier between this write and any
     * subsequent volatile read.
     *
     * @param value The new value for the sequence.
     */
    public void setVolatile(final long value)
    {
        UNSAFE.putLongVolatile(this, VALUE_OFFSET, value);
    }

    /**
     * Perform a compare and set operation on the sequence.
     *
     * @param expectedValue The expected current value.
     * @param newValue The value to update to.
     * @return true if the operation succeeds, false otherwise.
     */
    public boolean compareAndSet(final long expectedValue, final long newValue)
    {
        return UNSAFE.compareAndSwapLong(this, VALUE_OFFSET, expectedValue, newValue);
    }

    /**
     * Atomically increment the sequence by one.
     *
     * @return The value after the increment
     */
    public long incrementAndGet()
    {
        return addAndGet(1L);
    }

    /**
     * Atomically add the supplied value.
     *
     * @param increment The value to add to the sequence.
     * @return The value after the increment.
     */
    public long addAndGet(final long increment)
    {
        long currentValue;
        long newValue;

        do
        {
            currentValue = get();
            newValue = currentValue + increment;
        }
        while (!compareAndSet(currentValue, newValue));

        return newValue;
    }

    @Override
    public String toString()
    {
        return Long.toString(get());
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;


/**
 * Coordination barrier for tracking the cursor for publishers and sequence of
 * dependent {@link EventProcessor}s for processing a data structure
 */
public interface SequenceBarrier
{
    /**
     * Wait for the given sequence to be available for consumption.
     *
     * @param sequence to wait for
     * @return the sequence up to which is available
     * @throws AlertException if a status change has occurred for the Disruptor
     * @throws InterruptedException if the thread needs awaking on a condition variable.
     * @throws TimeoutException
     */
    long waitFor(long sequence) throws AlertException, InterruptedException, TimeoutException;

    /**
     * Get the current cursor value that can be read.
     *
     * @return value of the cursor for entries that have been published.
     */
    long getCursor();

    /**
     * The current alert status for the barrier.
     *
     * @return true if in alert otherwise false.
     */
    boolean isAlerted();

    /**
     * Alert the {@link EventProcessor}s of a status change and stay in this status until cleared.
     */
    void alert();

    /**
     * Clear the current alert status.
     */
    void clearAlert();

    /**
     * Check if an alert has been raised and throw an {@link AlertException} if it has.
     *
     * @throws AlertException if alert has been raised.
     */
    void checkAlert() throws AlertException;
}
package com.lmax.disruptor;

public interface Sequenced
{
    /**
     * The capacity of the data structure to hold entries.
     *
     * @return the size of the RingBuffer.
     */
    int getBufferSize();

    /**
     * Has the buffer got capacity to allocate another sequence.  This is a concurrent
     * method so the response should only be taken as an indication of available capacity.
     * @param requiredCapacity in the buffer
     * @return true if the buffer has the capacity to allocate the next sequence otherwise false.
     */
    boolean hasAvailableCapacity(final int requiredCapacity);

    /**
     * Get the remaining capacity for this sequencer.
     * @return The number of slots remaining.
     */
    long remainingCapacity();

    /**
     * Claim the next event in sequence for publishing.
     * @return the claimed sequence value
     */
    long next();

    /**
     * Claim the next n events in sequence for publishing.  This is for batch event producing.  Using batch producing
     * requires a little care and some math.
     * <pre>
     * int n = 10;
     * long hi = sequencer.next(n);
     * long lo = hi - (n - 1);
     * for (long sequence = lo; sequence &lt;= hi; sequence++) {
     *     // Do work.
     * }
     * sequencer.publish(lo, hi);
     * </pre>
     *
     * @param n the number of sequences to claim
     * @return the highest claimed sequence value
     */
    long next(int n);

    /**
     * Attempt to claim the next event in sequence for publishing.  Will return the
     * number of the slot if there is at least <code>requiredCapacity</code> slots
     * available.
     * @return the claimed sequence value
     * @throws InsufficientCapacityException
     */
    long tryNext() throws InsufficientCapacityException;

    /**
     * Attempt to claim the next n events in sequence for publishing.  Will return the
     * highest numbered slot if there is at least <code>requiredCapacity</code> slots
     * available.  Have a look at {@link Sequencer#next()} for a description on how to
     * use this method.
     *
     * @param n the number of sequences to claim
     * @return the claimed sequence value
     * @throws InsufficientCapacityException
     */
    long tryNext(int n) throws InsufficientCapacityException;

    /**
     * Publishes a sequence. Call when the event has been filled.
     *
     * @param sequence
     */
    void publish(long sequence);

    /**
     * Batch publish sequences.  Called when all of the events have been filled.
     *
     * @param lo first sequence number to publish
     * @param hi last sequence number to publish
     */
    void publish(long lo, long hi);
}/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

import com.lmax.disruptor.util.Util;

/**
 * A {@link Sequence} group that can dynamically have {@link Sequence}s added and removed while being
 * thread safe.
 * <p>
 * The {@link SequenceGroup#get()} and {@link SequenceGroup#set(long)} methods are lock free and can be
 * concurrently be called with the {@link SequenceGroup#add(Sequence)} and {@link SequenceGroup#remove(Sequence)}.
 */
public final class SequenceGroup extends Sequence
{
    private static final AtomicReferenceFieldUpdater<SequenceGroup, Sequence[]> SEQUENCE_UPDATER =
            AtomicReferenceFieldUpdater.newUpdater(SequenceGroup.class, Sequence[].class, "sequences");
    private volatile Sequence[] sequences = new Sequence[0];

    /**
     * Default Constructor
     */
    public SequenceGroup()
    {
        super(-1);
    }

    /**
     * Get the minimum sequence value for the group.
     *
     * @return the minimum sequence value for the group.
     */
    @Override
    public long get()
    {
        return Util.getMinimumSequence(sequences);
    }

    /**
     * Set all {@link Sequence}s in the group to a given value.
     *
     * @param value to set the group of sequences to.
     */
    @Override
    public void set(final long value)
    {
        final Sequence[] sequences = this.sequences;
        for (int i = 0, size = sequences.length; i < size; i++)
        {
            sequences[i].set(value);
        }
    }

    /**
     * Add a {@link Sequence} into this aggregate.  This should only be used during
     * initialisation.  Use {@link SequenceGroup#addWhileRunning(Cursored, Sequence)}
     *
     * @see SequenceGroup#addWhileRunning(Cursored, Sequence)
     * @param sequence to be added to the aggregate.
     */
    public void add(final Sequence sequence)
    {
        Sequence[] oldSequences;
        Sequence[] newSequences;
        do
        {
            oldSequences = sequences;
            final int oldSize = oldSequences.length;
            newSequences = new Sequence[oldSize + 1];
            System.arraycopy(oldSequences, 0, newSequences, 0, oldSize);
            newSequences[oldSize] = sequence;
        }
        while (!SEQUENCE_UPDATER.compareAndSet(this, oldSequences, newSequences));
    }

    /**
     * Remove the first occurrence of the {@link Sequence} from this aggregate.
     *
     * @param sequence to be removed from this aggregate.
     * @return true if the sequence was removed otherwise false.
     */
    public boolean remove(final Sequence sequence)
    {
        return SequenceGroups.removeSequence(this, SEQUENCE_UPDATER, sequence);
    }

    /**
     * Get the size of the group.
     *
     * @return the size of the group.
     */
    public int size()
    {
        return sequences.length;
    }

    /**
     * Adds a sequence to the sequence group after threads have started to publish to
     * the Disruptor.  It will set the sequences to cursor value of the ringBuffer
     * just after adding them.  This should prevent any nasty rewind/wrapping effects.
     *
     * @param cursored The data structure that the owner of this sequence group will
     * be pulling it's events from.
     * @param sequence The sequence to add.
     */
    public void addWhileRunning(Cursored cursored, Sequence sequence)
    {
        SequenceGroups.addSequences(this, SEQUENCE_UPDATER, cursored, sequence);
    }
}
/*
 * Copyright 2012 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import static java.util.Arrays.copyOf;

import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

/**
 * Provides static methods for managing a {@link SequenceGroup} object.
 */
class SequenceGroups
{
    static <T> void addSequences(final T holder,
                                 final AtomicReferenceFieldUpdater<T, Sequence[]> updater,
                                 final Cursored cursor,
                                 final Sequence... sequencesToAdd)
    {
        long cursorSequence;
        Sequence[] updatedSequences;
        Sequence[] currentSequences;

        do
        {
            currentSequences = updater.get(holder);
            updatedSequences = copyOf(currentSequences, currentSequences.length + sequencesToAdd.length);
            cursorSequence = cursor.getCursor();

            int index = currentSequences.length;
            for (Sequence sequence : sequencesToAdd)
            {
                sequence.set(cursorSequence);
                updatedSequences[index++] = sequence;
            }
        }
        while (!updater.compareAndSet(holder, currentSequences, updatedSequences));

        cursorSequence = cursor.getCursor();
        for (Sequence sequence : sequencesToAdd)
        {
            sequence.set(cursorSequence);
        }
    }

    static <T> boolean removeSequence(final T holder,
                                      final AtomicReferenceFieldUpdater<T, Sequence[]> sequenceUpdater,
                                      final Sequence sequence)
    {
        int numToRemove;
        Sequence[] oldSequences;
        Sequence[] newSequences;

        do
        {
            oldSequences = sequenceUpdater.get(holder);

            numToRemove = countMatching(oldSequences, sequence);

            if (0 == numToRemove)
            {
                break;
            }

            final int oldSize = oldSequences.length;
            newSequences = new Sequence[oldSize - numToRemove];

            for (int i = 0, pos = 0; i < oldSize; i++)
            {
                final Sequence testSequence = oldSequences[i];
                if (sequence != testSequence)
                {
                    newSequences[pos++] = testSequence;
                }
            }
        }
        while (!sequenceUpdater.compareAndSet(holder, oldSequences, newSequences));

        return numToRemove != 0;
    }

    private static <T> int countMatching(T[] values, final T toMatch)
    {
        int numToRemove = 0;
        for (T value : values)
        {
            if (value == toMatch) // Specifically uses identity
            {
                numToRemove++;
            }
        }
        return numToRemove;
    }
}
/*
 * Copyright 2012 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Coordinates claiming sequences for access to a data structure while tracking dependent {@link Sequence}s
 */
public interface Sequencer extends Cursored, Sequenced
{
    /** Set to -1 as sequence starting point */
    long INITIAL_CURSOR_VALUE = -1L;

    /**
     * Claim a specific sequence.  Only used if initialising the ring buffer to
     * a specific value.
     *
     * @param sequence The sequence to initialise too.
     */
    void claim(long sequence);

    /**
     * Confirms if a sequence is published and the event is available for use; non-blocking.
     *
     * @param sequence of the buffer to check
     * @return true if the sequence is available for use, false if not
     */
    boolean isAvailable(long sequence);

    /**
     * Add the specified gating sequences to this instance of the Disruptor.  They will
     * safely and atomically added to the list of gating sequences.
     *
     * @param gatingSequences The sequences to add.
     */
    void addGatingSequences(Sequence... gatingSequences);

    /**
     * Remove the specified sequence from this sequencer.
     *
     * @param sequence to be removed.
     * @return <tt>true</tt> if this sequence was found, <tt>false</tt> otherwise.
     */
    boolean removeGatingSequence(Sequence sequence);

    /**
     * Create a new SequenceBarrier to be used by an EventProcessor to track which messages
     * are available to be read from the ring buffer given a list of sequences to track.
     *
     * @see SequenceBarrier
     * @param sequencesToTrack
     * @return A sequence barrier that will track the specified sequences.
     */
    SequenceBarrier newBarrier(Sequence... sequencesToTrack);

    /**
     * Get the minimum sequence value from all of the gating sequences
     * added to this ringBuffer.
     *
     * @return The minimum gating sequence or the cursor sequence if
     * no sequences have been added.
     */
    long getMinimumSequence();

    /**
     * Get the highest sequence number that can be safely read from the ring buffer.  Depending
     * on the implementation of the Sequencer this call may need to scan a number of values
     * in the Sequencer.  The scan will range from nextSequence to availableSequence.  If
     * there are no available values <code>&gt;= nextSequence</code> the return value will be
     * <code>nextSequence - 1</code>.  To work correctly a consumer should pass a value that
     * it 1 higher than the last sequence that was successfully processed.
     *
     * @param nextSequence The sequence to start scanning from.
     * @param availableSequence The sequence to scan to.
     * @return The highest value that can be safely read, will be at least <code>nextSequence - 1</code>.
     */
    long getHighestPublishedSequence(long nextSequence, long availableSequence);

    <T> EventPoller<T> newPoller(DataProvider<T> provider, Sequence...gatingSequences);
}/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Used by the {@link BatchEventProcessor} to set a callback allowing the {@link EventHandler} to notify
 * when it has finished consuming an event if this happens after the {@link EventHandler#onEvent(Object, long, boolean)} call.
 * <p>
 * Typically this would be used when the handler is performing some sort of batching operation such as writing to an IO
 * device; after the operation has completed, the implementation should call {@link Sequence#set} to update the
 * sequence and allow other processes that are dependent on this handler to progress.
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 */
public interface SequenceReportingEventHandler<T>
    extends EventHandler<T>
{
    /**
     * Call by the {@link BatchEventProcessor} to setup the callback.
     *
     * @param sequenceCallback callback on which to notify the {@link BatchEventProcessor} that the sequence has progressed.
     */
    void setSequenceCallback(final Sequence sequenceCallback);
}
package geym.conc.ch5.matrix;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.operator.MatrixOperator;



public class SerialsMatrixMul {

    public static void main(String[] args) {
        Matrix m1=MatrixFactory.getRandomIntMatrix(100, 100, null);
        Matrix m2=MatrixFactory.getRandomIntMatrix(100, 100, null);
        Matrix re=MatrixOperator.multiply(m1, m2);
        System.out.print(m1+"*\n"+m2+"=\n");
        System.out.println(re);
    }

}
package geym.conc.ch2.waitnotify;

import geym.conc.ch2.waitnotify.SimpleWNA.T1;

public class SimpleWN {
	final static Object object = new Object();
	public static class T1 extends Thread{
        public void run()
        {
            synchronized (object) {
                System.out.println(System.currentTimeMillis()+":T1 start! ");
                try {
                	System.out.println(System.currentTimeMillis()+":T1 wait for object ");
                    object.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(System.currentTimeMillis()+":T1 end!");
            }
        }
	}
	public static class T2 extends Thread{
        public void run()
        {
            synchronized (object) {
                System.out.println(System.currentTimeMillis()+":T2 start! notify one thread");
                object.notify();
                System.out.println(System.currentTimeMillis()+":T2 end!");
                try {
					Thread.sleep(2000);
				} catch (InterruptedException e) {
				}
            }
        }
	}
	public static void main(String[] args) {
        Thread t1 = new T1() ;
        Thread t2 = new T2() ;
//        Thread t1_1 = new T1() ;
//        t1_1.start();
        t1.start();
        t2.start();
	}
}
package geym.conc.ch2.waitnotify;

public class SimpleWNA {
	final static Object object = new Object();
	public static class T1 extends Thread{
        public void run()
        {
            synchronized (object) {
                System.out.println("T1 start! wait on object");
                try {
                    object.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("T1 end!");
            }
        }
	}
	public static class T2 extends Thread{
        public void run()
        {
            synchronized (object) {
                System.out.println("T2 start! notify all threads");
                object.notifyAll();
                System.out.println("T2 end!");
                try {
					Thread.sleep(2000);
				} catch (InterruptedException e) {
				}
            }
        }
	}
	public static void main(String[] args) throws InterruptedException {
        Thread t1 = new T1() ;
        Thread t1_1 = new T1() ;
        t1_1.start();
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new T2() ;
        t2.start();
	}
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.locks.LockSupport;

import com.lmax.disruptor.util.Util;

abstract class SingleProducerSequencerPad extends AbstractSequencer
{
    protected long p1, p2, p3, p4, p5, p6, p7;
    public SingleProducerSequencerPad(int bufferSize, WaitStrategy waitStrategy)
    {
        super(bufferSize, waitStrategy);
    }
}

abstract class SingleProducerSequencerFields extends SingleProducerSequencerPad
{
    public SingleProducerSequencerFields(int bufferSize, WaitStrategy waitStrategy)
    {
        super(bufferSize, waitStrategy);
    }

    /** Set to -1 as sequence starting point */
    protected long nextValue = Sequence.INITIAL_VALUE;
    protected long cachedValue = Sequence.INITIAL_VALUE;
}

/**
 * <p>Coordinator for claiming sequences for access to a data structure while tracking dependent {@link Sequence}s.
 * Not safe for use from multiple threads as it does not implement any barriers.</p>
 *
 * <p>Note on {@link Sequencer#getCursor()}:  With this sequencer the cursor value is updated after the call
 * to {@link Sequencer#publish(long)} is made.
 */

public final class SingleProducerSequencer extends SingleProducerSequencerFields
{
    protected long p1, p2, p3, p4, p5, p6, p7;

    /**
     * Construct a Sequencer with the selected wait strategy and buffer size.
     *
     * @param bufferSize the size of the buffer that this will sequence over.
     * @param waitStrategy for those waiting on sequences.
     */
    public SingleProducerSequencer(int bufferSize, final WaitStrategy waitStrategy)
    {
        super(bufferSize, waitStrategy);
    }

    /**
     * @see Sequencer#hasAvailableCapacity(int)
     */
    @Override
    public boolean hasAvailableCapacity(final int requiredCapacity)
    {
        long nextValue = this.nextValue;

        long wrapPoint = (nextValue + requiredCapacity) - bufferSize;
        long cachedGatingSequence = this.cachedValue;

        if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue)
        {
            long minSequence = Util.getMinimumSequence(gatingSequences, nextValue);
            this.cachedValue = minSequence;

            if (wrapPoint > minSequence)
            {
                return false;
            }
        }

        return true;
    }

    /**
     * @see Sequencer#next()
     */
    @Override
    public long next()
    {
        return next(1);
    }

    /**
     * @see Sequencer#next(int)
     */
    @Override
    public long next(int n)
    {
        if (n < 1)
        {
            throw new IllegalArgumentException("n must be > 0");
        }

        long nextValue = this.nextValue;

        long nextSequence = nextValue + n;
        long wrapPoint = nextSequence - bufferSize;
        long cachedGatingSequence = this.cachedValue;

        if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue)
        {
            long minSequence;
            while (wrapPoint > (minSequence = Util.getMinimumSequence(gatingSequences, nextValue)))
            {
                LockSupport.parkNanos(1L); // TODO: Use waitStrategy to spin?
            }

            this.cachedValue = minSequence;
        }

        this.nextValue = nextSequence;

        return nextSequence;
    }

    /**
     * @see Sequencer#tryNext()
     */
    @Override
    public long tryNext() throws InsufficientCapacityException
    {
        return tryNext(1);
    }

    /**
     * @see Sequencer#tryNext(int)
     */
    @Override
    public long tryNext(int n) throws InsufficientCapacityException
    {
        if (n < 1)
        {
            throw new IllegalArgumentException("n must be > 0");
        }

        if (!hasAvailableCapacity(n))
        {
            throw InsufficientCapacityException.INSTANCE;
        }

        long nextSequence = this.nextValue += n;

        return nextSequence;
    }

    /**
     * @see Sequencer#remainingCapacity()
     */
    @Override
    public long remainingCapacity()
    {
        long nextValue = this.nextValue;

        long consumed = Util.getMinimumSequence(gatingSequences, nextValue);
        long produced = nextValue;
        return getBufferSize() - (produced - consumed);
    }

    /**
     * @see Sequencer#claim(long)
     */
    @Override
    public void claim(long sequence)
    {
        this.nextValue = sequence;
    }

    /**
     * @see Sequencer#publish(long)
     */
    @Override
    public void publish(long sequence)
    {
        cursor.set(sequence);
        waitStrategy.signalAllWhenBlocking();
    }

    /**
     * @see Sequencer#publish(long, long)
     */
    @Override
    public void publish(long lo, long hi)
    {
        publish(hi);
    }

    /**
     * @see Sequencer#isAvailable(long)
     */
    @Override
    public boolean isAvailable(long sequence)
    {
        return sequence <= cursor.get();
    }

    @Override
    public long getHighestPublishedSequence(long lowerBound, long availableSequence)
    {
        return availableSequence;
    }
}
package geym.conc.ch5.singleton;

public class Singleton {
	public static int STATUS=1;
	private Singleton(){
		System.out.println("Singleton is create");
	}
	private static Singleton instance = new Singleton();
	public static Singleton getInstance() {
		return instance;
	}
}
package geym.conc.ch5.singleton;

public class Singleton2 {
	public static int STATUS=1;
	private Singleton2() {
		System.out.println("Singleton is create");
	}
	private static Singleton2 instance = new Singleton2();
	public static Singleton2 getInstance() {
		return instance;
	}
}
package geym.conc.ch5.singleton;

public class SingletonDemo {

	public static void main(String[] args) {
		System.out.println(StaticSingleton.getInstance());
	}

}
 package org.jmatrices.dbl.decomposition;

import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;
import org.jmatrices.dbl.Matrix;
import org.jmatrices.dbl.MatrixFactory;

/**
 * SingularValueDecomposition
 * <P>
 * For an m-by-n matrix A with m >= n, the singular value decomposition is
 * an m-by-n orthogonal matrix U, an n-by-n diagonal matrix S, and
 * an n-by-n orthogonal matrix V so that A = U*S*V'.
 * </p>
 * <P>
 * The singular values, sigma[k] = S[k][k], are ordered so that
 * sigma[0] >= sigma[1] >= ... >= sigma[n-1].
 * </p>
 * <P>
 * The singular value decompostion always exists, so the constructor will
 * never fail.  The matrix condition number and the effective numerical
 * rank can be computed from this decomposition.
 * </p>
 * <p>
 * http://kwon3d.com/theory/jkinem/svd.html
 * http://web.mit.edu/be.400/www/SVD/Singular_Value_Decomposition.htm
 * http://www.matheverywhere.com/mei/courseware/mgm/svdB/
 * http://www.netlib.org/lapack/lug/node53.html
 * http://www.mppmu.mpg.de/~schieck/svd.pdf
 * http://www.cs.ut.ee/~toomas_l/linalg/lin2/node14.html
 * </p>
 * <p>
 * A x X = B  <br/>
 * X = A<sup>-1</sup> x B <br/>
 * A = U x S x V<sup>T </sup> (Singular value decomposition of A)         <br/>
 * A-1 = V x S<sup>-1</sup> x U<sup>T</sup> (Generalized inverse or pseudoinverse of A)  <br/>
 * X = V x S<sup>-1</sup> x U<sup>T</sup> x B        <br/>
 * </p>
 * <p><font color="red">
 * The code is basically JAMA code with modifications made to fit in the scheme of things.
 * </font></p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 12.03.2004
 * Time: 23:09:45
 */
public class SingularValueDecomposition {
    /* ------------------------
   Class variables
 * ------------------------ */

    /**
     * Arrays for internal storage of U and V.
     *
     * @serial internal storage of U.
     * @serial internal storage of V.
     */
    private double[][] U, V;

    /**
     * Array for internal storage of singular values.
     *
     * @serial internal storage of singular values.
     */
    private double[] s;

    /**
     * Row and column dimensions.
     *
     * @serial row dimension.
     * @serial column dimension.
     */
    private int m, n;
    private Matrix hint;
/* ------------------------
   Constructor
 * ------------------------ */

    /**
     * Construct the singular value decomposition
     *
     * @param matrix Rectangular matrix
     */

    public SingularValueDecomposition(Matrix matrix) {
         hint = matrix;
        // Derived from LINPACK code.
        // Initialize.
        double[][] A = matrix.get();   //changed
        m = matrix.rows();          //changed
        n = matrix.cols();          //changed
        int nu = Math.min(m, n);

        s = new double[Math.min(m + 1, n)];
        U = new double[m][nu];
        V = new double[n][n];

        double[] e = new double[n];
        double[] work = new double[m];

        boolean wantu = true;
        boolean wantv = true;

        // Reduce A to bidiagonal form, storing the diagonal elements
        // in s and the super-diagonal elements in e.

        int nct = Math.min(m - 1, n);
        int nrt = Math.max(0, Math.min(n - 2, m));
        for (int k = 0; k < Math.max(nct, nrt); k++) {
            if (k < nct) {

                // Compute the transformer for the k-th column and
                // place the k-th diagonal in s[k].
                // Compute 2-norm of k-th column without under/overflow.
                s[k] = 0;
                for (int i = k; i < m; i++) {
                    s[k] = Util.hypot(s[k], A[i][k]); //changed
                }
                if (s[k] != 0.0) {
                    if (A[k][k] < 0.0) {
                        s[k] = -s[k];
                    }
                    for (int i = k; i < m; i++) {
                        A[i][k] /= s[k];
                    }
                    A[k][k] += 1.0;
                }
                s[k] = -s[k];
            }
            for (int j = k + 1; j < n; j++) {
                if ((k < nct) & (s[k] != 0.0)) {

                    // Apply the transformer.

                    double t = 0;
                    for (int i = k; i < m; i++) {
                        t += A[i][k] * A[i][j];
                    }
                    t = -t / A[k][k];
                    for (int i = k; i < m; i++) {
                        A[i][j] += t * A[i][k];
                    }
                }

                // Place the k-th row of A into e for the
                // subsequent calculation of the row transformer.

                e[j] = A[k][j];
            }
            if (wantu & (k < nct)) {

                // Place the transformer in U for subsequent back
                // multiplication.

                for (int i = k; i < m; i++) {
                    U[i][k] = A[i][k];
                }
            }
            if (k < nrt) {

                // Compute the k-th row transformer and place the
                // k-th super-diagonal in e[k].
                // Compute 2-norm without under/overflow.
                e[k] = 0;
                for (int i = k + 1; i < n; i++) {
                    e[k] = Util.hypot(e[k], e[i]); //changed
                }
                if (e[k] != 0.0) {
                    if (e[k + 1] < 0.0) {
                        e[k] = -e[k];
                    }
                    for (int i = k + 1; i < n; i++) {
                        e[i] /= e[k];
                    }
                    e[k + 1] += 1.0;
                }
                e[k] = -e[k];
                if ((k + 1 < m) & (e[k] != 0.0)) {

                    // Apply the transformer.

                    for (int i = k + 1; i < m; i++) {
                        work[i] = 0.0;
                    }
                    for (int j = k + 1; j < n; j++) {
                        for (int i = k + 1; i < m; i++) {
                            work[i] += e[j] * A[i][j];
                        }
                    }
                    for (int j = k + 1; j < n; j++) {
                        double t = -e[j] / e[k + 1];
                        for (int i = k + 1; i < m; i++) {
                            A[i][j] += t * work[i];
                        }
                    }
                }
                if (wantv) {

                    // Place the transformer in V for subsequent
                    // back multiplication.

                    for (int i = k + 1; i < n; i++) {
                        V[i][k] = e[i];
                    }
                }
            }
        }

        // Set up the final bidiagonal matrix or order p.

        int p = Math.min(n, m + 1);
        if (nct < n) {
            s[nct] = A[nct][nct];
        }
        if (m < p) {
            s[p - 1] = 0.0;
        }
        if (nrt + 1 < p) {
            e[nrt] = A[nrt][p - 1];
        }
        e[p - 1] = 0.0;

        // If required, generate U.

        if (wantu) {
            for (int j = nct; j < nu; j++) {
                for (int i = 0; i < m; i++) {
                    U[i][j] = 0.0;
                }
                U[j][j] = 1.0;
            }
            for (int k = nct - 1; k >= 0; k--) {
                if (s[k] != 0.0) {
                    for (int j = k + 1; j < nu; j++) {
                        double t = 0;
                        for (int i = k; i < m; i++) {
                            t += U[i][k] * U[i][j];
                        }
                        t = -t / U[k][k];
                        for (int i = k; i < m; i++) {
                            U[i][j] += t * U[i][k];
                        }
                    }
                    for (int i = k; i < m; i++) {
                        U[i][k] = -U[i][k];
                    }
                    U[k][k] = 1.0 + U[k][k];
                    for (int i = 0; i < k - 1; i++) {
                        U[i][k] = 0.0;
                    }
                } else {
                    for (int i = 0; i < m; i++) {
                        U[i][k] = 0.0;
                    }
                    U[k][k] = 1.0;
                }
            }
        }

        // If required, generate V.

        if (wantv) {
            for (int k = n - 1; k >= 0; k--) {
                if ((k < nrt) & (e[k] != 0.0)) {
                    for (int j = k + 1; j < nu; j++) {
                        double t = 0;
                        for (int i = k + 1; i < n; i++) {
                            t += V[i][k] * V[i][j];
                        }
                        t = -t / V[k + 1][k];
                        for (int i = k + 1; i < n; i++) {
                            V[i][j] += t * V[i][k];
                        }
                    }
                }
                for (int i = 0; i < n; i++) {
                    V[i][k] = 0.0;
                }
                V[k][k] = 1.0;
            }
        }

        // Main iteration loop for the singular values.
        int pp = p - 1;
        int iter = 0;
        double eps = Math.pow(2.0, -52.0);
        while (p > 0) {
            int k, kase;

            // Here is where a test for too many iterations would go.

            // This section of the program inspects for
            // negligible elements in the s and e arrays.  On
            // completion the variables kase and k are set as follows.

            // kase = 1     if s(p) and e[k-1] are negligible and k<p
            // kase = 2     if s(k) is negligible and k<p
            // kase = 3     if e[k-1] is negligible, k<p, and
            //              s(k), ..., s(p) are not negligible (qr step).
            // kase = 4     if e(p-1) is negligible (convergence).

            for (k = p - 2; k >= -1; k--) {
                if (k == -1) {
                    break;
                }
                if (Math.abs(e[k]) <= eps * (Math.abs(s[k]) + Math.abs(s[k + 1]))) {
                    e[k] = 0.0;
                    break;
                }
            }
            if (k == p - 2) {
                kase = 4;
            } else {
                int ks;
                for (ks = p - 1; ks >= k; ks--) {
                    if (ks == k) {
                        break;
                    }
                    double t = (ks != p ? Math.abs(e[ks]) : 0.) +
                            (ks != k + 1 ? Math.abs(e[ks - 1]) : 0.);
                    if (Math.abs(s[ks]) <= eps * t) {
                        s[ks] = 0.0;
                        break;
                    }
                }
                if (ks == k) {
                    kase = 3;
                } else if (ks == p - 1) {
                    kase = 1;
                } else {
                    kase = 2;
                    k = ks;
                }
            }
            k++;

            // Perform the task indicated by kase.

            switch (kase) {

                // Deflate negligible s(p).

                case 1:
                    {
                        double f = e[p - 2];
                        e[p - 2] = 0.0;
                        for (int j = p - 2; j >= k; j--) {
                            double t = Util.hypot(s[j], f);
                            double cs = s[j] / t;
                            double sn = f / t;
                            s[j] = t;
                            if (j != k) {
                                f = -sn * e[j - 1];
                                e[j - 1] = cs * e[j - 1];
                            }
                            if (wantv) {
                                for (int i = 0; i < n; i++) {
                                    t = cs * V[i][j] + sn * V[i][p - 1];
                                    V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];
                                    V[i][j] = t;
                                }
                            }
                        }
                    }
                    break;

                    // Split at negligible s(k).

                case 2:
                    {
                        double f = e[k - 1];
                        e[k - 1] = 0.0;
                        for (int j = k; j < p; j++) {
                            double t = Util.hypot(s[j], f);
                            double cs = s[j] / t;
                            double sn = f / t;
                            s[j] = t;
                            f = -sn * e[j];
                            e[j] = cs * e[j];
                            if (wantu) {
                                for (int i = 0; i < m; i++) {
                                    t = cs * U[i][j] + sn * U[i][k - 1];
                                    U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];
                                    U[i][j] = t;
                                }
                            }
                        }
                    }
                    break;

                    // Perform one qr step.

                case 3:
                    {
                        // Calculate the shift.
                        double scale = Math.max(Math.max(Math.max(Math.max(Math.abs(s[p - 1]), Math.abs(s[p - 2])), Math.abs(e[p - 2])),
                                Math.abs(s[k])), Math.abs(e[k]));
                        double sp = s[p - 1] / scale;
                        double spm1 = s[p - 2] / scale;
                        double epm1 = e[p - 2] / scale;
                        double sk = s[k] / scale;
                        double ek = e[k] / scale;
                        double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;
                        double c = (sp * epm1) * (sp * epm1);
                        double shift = 0.0;
                        if ((b != 0.0) | (c != 0.0)) {
                            shift = Math.sqrt(b * b + c);
                            if (b < 0.0) {
                                shift = -shift;
                            }
                            shift = c / (b + shift);
                        }
                        double f = (sk + sp) * (sk - sp) + shift;
                        double g = sk * ek;

                        // Chase zeros.

                        for (int j = k; j < p - 1; j++) {
                            double t = Util.hypot(f, g);   //changed
                            double cs = f / t;
                            double sn = g / t;
                            if (j != k) {
                                e[j - 1] = t;
                            }
                            f = cs * s[j] + sn * e[j];
                            e[j] = cs * e[j] - sn * s[j];
                            g = sn * s[j + 1];
                            s[j + 1] = cs * s[j + 1];
                            if (wantv) {
                                for (int i = 0; i < n; i++) {
                                    t = cs * V[i][j] + sn * V[i][j + 1];
                                    V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];
                                    V[i][j] = t;
                                }
                            }
                            t = Util.hypot(f, g);    //changed
                            cs = f / t;
                            sn = g / t;
                            s[j] = t;
                            f = cs * e[j] + sn * s[j + 1];
                            s[j + 1] = -sn * e[j] + cs * s[j + 1];
                            g = sn * e[j + 1];
                            e[j + 1] = cs * e[j + 1];
                            if (wantu && (j < m - 1)) {
                                for (int i = 0; i < m; i++) {
                                    t = cs * U[i][j] + sn * U[i][j + 1];
                                    U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];
                                    U[i][j] = t;
                                }
                            }
                        }
                        e[p - 2] = f;
                        iter = iter + 1;
                    }
                    break;

                    // Convergence.

                case 4:
                    {

                        // Make the singular values positive.

                        if (s[k] <= 0.0) {
                            s[k] = (s[k] < 0.0 ? -s[k] : 0.0);
                            if (wantv) {
                                for (int i = 0; i <= pp; i++) {
                                    V[i][k] = -V[i][k];
                                }
                            }
                        }

                        // Order the singular values.

                        while (k < pp) {
                            if (s[k] >= s[k + 1]) {
                                break;
                            }
                            double t = s[k];
                            s[k] = s[k + 1];
                            s[k + 1] = t;
                            if (wantv && (k < n - 1)) {
                                for (int i = 0; i < n; i++) {
                                    t = V[i][k + 1];
                                    V[i][k + 1] = V[i][k];
                                    V[i][k] = t;
                                }
                            }
                            if (wantu && (k < m - 1)) {
                                for (int i = 0; i < m; i++) {
                                    t = U[i][k + 1];
                                    U[i][k + 1] = U[i][k];
                                    U[i][k] = t;
                                }
                            }
                            k++;
                        }
                        iter = 0;
                        p--;
                    }
                    break;
            }
        }
    }



/* ------------------------
   Public Methods
 * ------------------------ */

    /**
     * Return the left singular vectors
     *
     * @return U
     */

    public Matrix getU() {
        //return new Matrix(U,m,Math.min(m+1,n));
        return MatrixFactory.getMatrix(m, Math.min(m + 1, n), hint, U);
    }

    /**
     * Return the right singular vectors
     *
     * @return V
     */

    public Matrix getV() {
        return MatrixFactory.getMatrix(n, n, hint, V);
    }

    /**
     * Return the one-dimensional array of singular values
     *
     * @return diagonal of S.
     */

    public double[] getSingularValues() {
        return s;
    }

    /**
     * Return the diagonal matrix of singular values
     *
     * @return S
     */

    public Matrix getS() {
        double[][] S = new double[m][n]; //changed n to m
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                S[i][j] = 0.0;
            }
            S[i][i] = this.s[i];
        }
        return MatrixFactory.getMatrix(m, n, hint, S);  //changed n to m
    }

    /**
     * Two norm
     *
     * @return max(S)
     */

    public double norm2() {
        return s[0];
    }

    /**
     * Two norm condition number
     *
     * @return max(S)/min(S)
     */

    public double cond() {
        return s[0] / s[Math.min(m, n) - 1];
    }

    /**
     * Effective numerical matrix rank
     *
     * @return Number of nonnegligible singular values.
     */

    public int rank() {
        double eps = Math.pow(2.0, -52.0);
        double tol = Math.max(m, n) * s[0] * eps;
        int r = 0;
        for (int i = 0; i < s.length; i++) {
            if (s[i] > tol) {
                r++;
            }
        }
        return r;
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.locks.LockSupport;

/**
 * Sleeping strategy that initially spins, then uses a Thread.yield(), and
 * eventually sleep (<code>LockSupport.parkNanos(1)</code>) for the minimum
 * number of nanos the OS and JVM will allow while the
 * {@link com.lmax.disruptor.EventProcessor}s are waiting on a barrier.
 *
 * This strategy is a good compromise between performance and CPU resource.
 * Latency spikes can occur after quiet periods.
 */
public final class SleepingWaitStrategy implements WaitStrategy
{
    private static final int DEFAULT_RETRIES = 200;

    private final int retries;

    public SleepingWaitStrategy()
    {
        this(DEFAULT_RETRIES);
    }

    public SleepingWaitStrategy(int retries)
    {
        this.retries = retries;
    }

    @Override
    public long waitFor(final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
        throws AlertException, InterruptedException
    {
        long availableSequence;
        int counter = retries;

        while ((availableSequence = dependentSequence.get()) < sequence)
        {
            counter = applyWaitMethod(barrier, counter);
        }

        return availableSequence;
    }

    @Override
    public void signalAllWhenBlocking()
    {
    }

    private int applyWaitMethod(final SequenceBarrier barrier, int counter)
        throws AlertException
    {
        barrier.checkAlert();

        if (counter > 100)
        {
            --counter;
        }
        else if (counter > 0)
        {
            --counter;
            Thread.yield();
        }
        else
        {
            LockSupport.parkNanos(1L);
        }

        return counter;
    }
}

package geym.conc.ch5.socket;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;

public class SocketClient {
    public static void main(String[] args) throws IOException {
        Socket client = null;
        PrintWriter writer = null;
        BufferedReader reader = null;
        try {
            client = new Socket();
            client.connect(new InetSocketAddress("localhost", 8000));
            writer = new PrintWriter(client.getOutputStream(), true);
            writer.println("Hello!");
            writer.flush();

            reader = new BufferedReader(new InputStreamReader(client.getInputStream()));
            System.out.println("from server: " + reader.readLine());
        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (writer != null)
                writer.close();
            if (reader != null)
                reader.close();
            if (client != null)
                client.close();
        }
    }
}
package geym.conc.ch6.stamped;

import java.util.concurrent.locks.LockSupport;
import java.util.concurrent.locks.StampedLock;

/**
 * @author Administrator
 *
 */
public class StampedLockCPUDemo {
    static Thread[] holdCpuThreads = new Thread[3];
    static final StampedLock lock = new StampedLock();
    public static void main(String[] args) throws InterruptedException {
        new Thread() {
            public void run() {
                long readLong = lock.writeLock();
                //LockSupport.parkNanos(600000000000L);
                LockSupport.parkNanos(15L*1000*1000*1000);
                lock.unlockWrite(readLong);
            }
        }.start();
        Thread.sleep(100);
        for (int i = 0; i < 3; ++i) {
            holdCpuThreads[i] = new Thread(new HoldCPUReadThread());
            holdCpuThreads[i].start();
        }
        Thread.sleep(10000);
        //线程中断后，会占用CPU
        for (int i = 0; i < 3; ++i) {
            holdCpuThreads[i].interrupt();
        }
    }

    private static class HoldCPUReadThread implements Runnable {
        public void run() {
            long lockr = lock.readLock();
            System.out.println(Thread.currentThread().getName()+ " 获得读锁");
            lock.unlockRead(lockr);
        }
    }
}
package geym.conc.ch6.stamped;

public class StampedLockDemo {
	static Point point=new Point();

	static class WritePoint implements Runnable{
		@Override
		public void run() {
			point.move(Math.random(), Math.random());
		}
	}
	static class ReadPoint implements Runnable{
		@Override
		public void run() {
			point.distanceFromOrigin();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(new WritePoint());
		Thread t2=new Thread(new ReadPoint());
		t1.start();
		Thread.sleep(100);
		t2.start();
	}

}
package geym.conc.ch5.singleton;

public class StaticSingleton {
	public static int STATUS;
	private StaticSingleton(){
		System.out.println("StaticSingleton is create");
	}
	private static class SingletonHolder {
		private static StaticSingleton instance = new StaticSingleton();
	}
	public static StaticSingleton getInstance() {
		return SingletonHolder.instance;
	}
}


package geym.conc.ch2.stop;

/**
 *
 * @author geym
 *
 */
public class StopThreadSafe {
    public static User u = new User();

    public static class User {
        private int id;

        private String name;

        public User() {
            id = 0;
            name = "0";
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        @Override
        public String toString() {
            return "User [id=" + id + ", name=" + name + "]";
        }
    }

    public static class ChangeObjectThread extends Thread {
        volatile boolean stopme = false;

        public void stopMe(){
            stopme = true;
        }
        @Override
        public void run() {
            while (true) {
                if (stopme){
                    System.out.println("exit by stop me");
                    break;
                }
                synchronized (u) {
                    int v = (int) (System.currentTimeMillis() / 1000);
                    u.setId(v);
                    //Oh, do sth. else
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    u.setName(String.valueOf(v));
                }
                Thread.yield();
            }
        }
    }

    public static class ReadObjectThread extends Thread {
        @Override
        public void run() {
            while (true) {
                synchronized (u) {
                    if (u.getId() != Integer.parseInt(u.getName())) {
                        System.out.println(u.toString());
                    }
                }
                Thread.yield();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new ReadObjectThread().start();
        while (true) {
            ChangeObjectThread t = new ChangeObjectThread();
            t.start();
            Thread.sleep(150);
            t.stopMe();
        }
    }
}

package geym.conc.ch2.stop;

/**
 *
 * @author geym
 *
 */
public class StopThreadSafe2 {
    public static User u = new User();

    public static class User {
        private int id;

        private String name;

        public User() {
            id = 0;
            name = "0";
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        @Override
        public String toString() {
            return "User [id=" + id + ", name=" + name + "]";
        }
    }

    public static class ChangeObjectThread extends Thread {

        @Override
        public void run() {
            while (true) {
                if (Thread.currentThread().isInterrupted()){
                    System.out.println("exit with interrupted");
                    break;
                }
                synchronized (u) {
                    int v = (int) (System.currentTimeMillis() / 1000);
                    u.setId(v);
                    //Oh, do sth. else
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        //重要，重置中断状态
                        Thread.currentThread().interrupt();
                    }
                    u.setName(String.valueOf(v));
                }
                Thread.yield();
            }
        }
    }

    public static class ReadObjectThread extends Thread {
        @Override
        public void run() {
            while (true) {
                synchronized (u) {
                    if (u.getId() != Integer.parseInt(u.getName())) {
                        System.out.println(u.toString());
                    }
                }
                Thread.yield();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new ReadObjectThread().start();
        while (true) {
            ChangeObjectThread t = new ChangeObjectThread();
            t.start();
            Thread.sleep(150);
            t.interrupt();
        }
    }
}
package geym.conc.ch2.stop;
/**
 *
 * @author geym
 *
 */
public class StopThreadUnsafe {
    public static User u=new User();
    public static class User{
        private int id;
        private String name;
        public User(){
            id=0;
            name="0";
        }
        public int getId() {
            return id;
        }
        public void setId(int id) {
            this.id = id;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        @Override
        public String toString() {
            return "User [id=" + id + ", name=" + name + "]";
        }
    }
    public static class ChangeObjectThread extends Thread{
        @Override
        public void run(){
            while(true){
                synchronized(u){
                    int v=(int)(System.currentTimeMillis()/1000);
                    u.setId(v);
                    //Oh, do sth. else
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    u.setName(String.valueOf(v));
                }
                Thread.yield();
            }
        }
    }

    public static class ReadObjectThread extends Thread{
        @Override
        public void run(){
            while(true){
                synchronized(u){
                    if(u.getId() != Integer.parseInt(u.getName())){
                        System.out.println(u.toString());
                    }
                }
                Thread.yield();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new ReadObjectThread().start();
        while(true){
            Thread t=new ChangeObjectThread();
            t.start();
            Thread.sleep(150);
            t.stop();
        }
    }
}
package geym.conc.ch6.pstream;

public class Student {
	public int score;
	public String id;
	public Student(String id,int score){
		this.id=id;
		this.score=score;
	}
}
package geym.conc.remove.prime;

import java.util.BitSet;

public class SyncBitSet {
    private BitSet bs=null;

    public SyncBitSet(int nbits){
        bs=new BitSet(nbits);
        //默认都是质数，剔除不是质数的
        bs.set(0, nbits,true);
    }

    public synchronized void set(int bitIndex, boolean value) {
        bs.set(bitIndex,value);
    }

    public synchronized void set(int fromIndex, int toIndex, boolean value){
        bs.set(fromIndex,toIndex,value);
    }

    public synchronized boolean get(int bitIndex){
        return bs.get(bitIndex);
    }
}
package geym.conc.ch3.collections;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;


public class SynHashMap {
//    public static Map m=Collections.synchronizedMap(new HashMap());
    public static Map m= new ConcurrentHashMap();

    public static void main(String[] args) {
        m.put("hello", "world");
    }
}
package geym.conc.ch3.collections;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

public class SynList {
	public static List<String> l=Collections.synchronizedList(new LinkedList<String>());
//    public static List<String> l=Collections.synchronizedList(new ArrayList<String>());
//    public static List<String> l=new Vector();
//    public static List<String> l=new CopyOnWriteArrayList<String>();

    public static void main(String[] args) {
        l.add("hello");
    }

}
package geym.conc.ch3.ds;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.Test;

public class TestCopyOnWriteArrayList {
	private static final int MAX_THREADS = 2000;
	private static final int TASK_COUNT = 4000;
	List list;

	public class AccessListThread implements Runnable{
		protected String name;
		java.util.Random rand=new java.util.Random();
		public AccessListThread(){
		}
		public AccessListThread(String name){
			this.name=name;
		}
		@Override
		public void run() {
			try {
				for(int i=0;i<500;i++)
					getList(rand.nextInt(1000));
				Thread.sleep(rand.nextInt(100));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public class CounterPoolExecutor extends ThreadPoolExecutor{
		private AtomicInteger count =new AtomicInteger(0);
		public long startTime=0;
		public String funcname="";
		public CounterPoolExecutor(int corePoolSize, int maximumPoolSize,
				long keepAliveTime, TimeUnit unit,
				BlockingQueue<Runnable> workQueue) {
			super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
		}

		protected void afterExecute(Runnable r, Throwable t) {
			int l=count.addAndGet(1);
			if(l==TASK_COUNT){
				System.out.println(funcname+" spend time:"+(System.currentTimeMillis()-startTime));

			}
		}
	}

	public Object getList(int index){
		return list.get(index);
	}

	public void initListCopyOnWriteContent(){
		List l=new ArrayList();
		for(int i=0;i<1000;i++)
			l.add(i);
		list=new CopyOnWriteArrayList(l);
	}

	public void initVector(){
		List l=new ArrayList();
		for(int i=0;i<1000;i++)
			l.add(i);
		list=new Vector(l);
	}

	public void initArrayList(){
		List l=new ArrayList();
		for(int i=0;i<1000;i++)
			l.add(i);
		list=Collections.synchronizedList(l);
	}

	//@Test
	public void testGetCopyOnWriteList() throws InterruptedException {
		initListCopyOnWriteContent();
		CounterPoolExecutor exe=new CounterPoolExecutor(MAX_THREADS, MAX_THREADS,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>());

		long starttime=System.currentTimeMillis();
		exe.startTime=starttime;
		exe.funcname="testGetCopyOnWriteList";
		for(int i=0;i<TASK_COUNT;i++)
			exe.submit(new AccessListThread());

		Thread.sleep(1000);
	}

	@Test
	public void testGetVector() throws InterruptedException {
		initVector();
		CounterPoolExecutor exe=new CounterPoolExecutor(MAX_THREADS, MAX_THREADS,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>());

		long starttime=System.currentTimeMillis();
		exe.startTime=starttime;
		exe.funcname="testGetVector";
		for(int i=0;i<TASK_COUNT;i++)
			exe.submit(new AccessListThread());

		Thread.sleep(1000);
	}

	//@Test
	public void testGetArrayList() throws InterruptedException {
		initArrayList();
		CounterPoolExecutor exe=new CounterPoolExecutor(MAX_THREADS, MAX_THREADS,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>());

		long starttime=System.currentTimeMillis();
		exe.startTime=starttime;
		exe.funcname="testGetArrayList";
		for(int i=0;i<TASK_COUNT;i++)
			exe.submit(new AccessListThread());

		Thread.sleep(1000);
	}
}
package org.jmatrices.dbl;

import org.jmatrices.dbl.decomposition.LUDecomposition;
import org.jmatrices.dbl.decomposition.SingularValueDecomposition;
import org.jmatrices.dbl.measure.MatrixMeasure;
import org.jmatrices.dbl.measure.MatrixProperty;
import org.jmatrices.dbl.operator.MatrixOperator;
import org.jmatrices.dbl.rowcoltr.ColumnTransformer;
import org.jmatrices.dbl.rowcoltr.RowTransformer;
import org.jmatrices.dbl.transformer.MatrixEBETransformation;
import org.jmatrices.dbl.transformer.MatrixEBETransformer;
import org.jmatrices.dbl.transformer.MatrixTransformer;

/**
 * TestMatrices
 * <p/>
 * <font color="blue">
 * todo - This is the reason why we need a Junit test suite!!
 * </font>
 * </p>
 * <p/>
 * Author: purangp
 * </p>
 * Date: 07.03.2004
 * Time: 16:49:52
 */
public class TestMatrices {

    public static void main(String[] args) {
        //TestMatrices.testTransformations();
        //TestMatrices.testTranspose();
        //TestMatrices.testMultiply();
        //TestMatrices.testConcatenation();
        //TestMatrices.testColumnOperators();
        //TestMatrices.testRowOperators();
        //TestMatrices.testMatrixMeasures();
        //TestMatrices.testDiagonalTrace();
        //TestMatrices.testHeavyMatrix();
        //TestMatrices.testGet();
        //TestMatrices.testPow();
        //TestMatrices.testIsSymetric();
        //TestMatrices.testIsIdempotent();
        //TestMatrices.testTrace();
        //TestMatrices.testSubmatrix();
        //TestMatrices.testLUDecomposition();
        //TestMatrices.testDeterminant();
        //TestMatrices.testIdentityMatrix();
        //TestMatrices.testSolve();
        //TestMatrices.testInverse();
        //TestMatrices.testSVD();
        //TestMatrices.testIsScalarMatrix();
        //TestMatrices.testExtractUpperTriangular();
        //TestMatrices.testExtractLowerTriangular();
        //TestMatrices.testPutDiagonal();
        //TestMatrices.testGetDiagonal();
        TestMatrices.testInstanceOfNull();
    }

    private static void testInstanceOfNull() {
        Matrix m = null;
        if (m instanceof LightMatrixImpl) {
            System.out.println("LightMatrixImpl");
        } else if (m instanceof HeavyMatrixImpl) {
            System.out.println("HeavyMatrixImpl");
        }
        System.out.println("Null");
    }

    private static void testGetDiagonal() {
        //Matrix[] m = {getMatrix55(), getMatrix35(), getMatrix53()};
        Matrix[] m = {getMatrix35()};
        for (int i = 0; i < m.length; i++) {
            Matrix matrix = m[i];
            int length = MatrixMeasure.length(matrix);
            for (int j = -length; j <= length; j++) {
                System.out.println("offset >> " + j);
                System.out.println(MatrixTransformer.extractDiagonal(matrix, j));

            }
        }
    }

    private static void testPutDiagonal() {
        Matrix[] m = {getMatrix11(), getMatrix15(), getMatrix51(), };
        for (int i = 0; i < m.length; i++) {
            Matrix matrix = m[i];
            int length = MatrixMeasure.length(matrix);
            for (int j = -length; j <= length; j++) {
                System.out.println("offset >> " + j);
                System.out.println(MatrixTransformer.embedDiagonal(matrix, j));
            }
        }
    }

    private static Matrix getMatrix11() {
        return MatrixFactory.getMatrix(1, 1, null, new double[][]{
            {1, },
        });
    }

    private static Matrix getMatrix51() {
        return MatrixFactory.getMatrix(5, 1, null, new double[][]{
            {1, },
            {1, },
            {1, },
            {1, },
            {1, },
        });
    }

    private static Matrix getMatrix15() {
        return MatrixFactory.getMatrix(1, 5, null, new double[][]{
            {1, 2, 3, 4, 5, },
        });
    }

    private static void testExtractUpperTriangular() {
        Matrix[] m = {getMatrix55(), getMatrix35(), getMatrix53()};
        for (int i = 0; i < m.length; i++) {
            Matrix matrix = m[i];
            int length = MatrixMeasure.length(matrix);
            for (int j = -length; j <= length; j++) {
                System.out.println("offset >> " + j);
                System.out.println(MatrixTransformer.extractUpperTriangular(matrix, j));
            }
        }
    }

    private static Matrix getMatrix55() {
        return MatrixFactory.getMatrix(5, 5, null, new double[][]{
            {1, 2, 3, 4, 5, },
            {1, 2, 3, 4, 5, },
            {1, 2, 3, 4, 5, },
            {1, 2, 3, 4, 5, },
            {1, 2, 3, 4, 5, },
        });
    }

    private static Matrix getMatrix35() {
        return MatrixFactory.getMatrix(3, 5, null, new double[][]{
            {1, 2, 3, 4, 5, },
            {1, 2, 3, 4, 5, },
            {1, 2, 3, 4, 5, },
        });
    }

    private static Matrix getMatrix53() {
        return MatrixFactory.getMatrix(5, 3, null, new double[][]{
            {1, 2, 3, },
            {1, 2, 3, },
            {1, 2, 3, },
            {1, 2, 3, },
            {1, 2, 3, },
        });
    }

    private static void testExtractLowerTriangular() {
        Matrix[] m = {getMatrix55(), getMatrix35(), getMatrix53()};
        for (int i = 0; i < m.length; i++) {
            Matrix matrix = m[i];
            int length = MatrixMeasure.length(matrix);
            for (int j = -length; j <= length; j++) {
                System.out.println("offset >> " + j);
                System.out.println(MatrixTransformer.extractLowerTriangular(matrix, j));
            }
        }
    }

    private static void testIsScalarMatrix() {
        System.out.println(MatrixProperty.isScalar(get22Scalar()));
        System.out.println(MatrixProperty.isScalar(get33NotScalar()));
    }

    private static Matrix get22Scalar() {
        double[][] elems = {{2, 0, },
                            {0, 2, }, };
        return MatrixFactory.getMatrix(2, 2, null, elems);
    }

    private static Matrix get33NotScalar() {
        double[][] elems = {{2, 0, 0, },
                            {0, 2, 0},
                            {0, 0, 0}, };
        return MatrixFactory.getMatrix(3, 3, null, elems);
    }

    /**
     * The results are mixed...
     * When we compare it with solutions given on the webpage http://web.mit.edu/be.400/www/SVD/Singular_Value_Decomposition.htm
     * Everything is fine except U's 3,2 and 4,2 values do not match and S's dimensions don't agree [played around with code to rectify the dimension of S]
     * <p/>
     * When we compare it with matlab nothing seems to agree except cond(), rank() and norm2();
     */


    private static void testSVD() {
        testSVD(new SingularValueDecomposition(get42SVD()));
        System.out.println("==========");
        testSVD(new SingularValueDecomposition(get22Cond()));
    }

    private static void testSVD(SingularValueDecomposition svd) {
        System.out.println(svd.getU());
        System.out.println(svd.getS());   //doesn't agree in dimensions with matlab
        System.out.println(svd.getV());
        System.out.println(svd.rank());  // 2 agrees with matlab
        System.out.println(svd.cond());   //14.9330 agrees with matlab solution
        System.out.println(svd.norm2());  //1.58 agrees with matlab solution

    }

    private static Matrix get22Cond() {
        double[][] elems = {{1.2969, 0.8648, },
                            {0.2161, 0.1414, }, };
        return MatrixFactory.getMatrix(2, 2, null, elems);
    }

    //the following matrix cortusey ..
    //http://web.mit.edu/be.400/www/SVD/Singular_Value_Decomposition.htm
    private static Matrix get42SVD() {
        double[][] elems = {{2, 4, },
                            {1, 3, },
                            {0, 0, },
                            {0, 0, }, };
        return MatrixFactory.getMatrix(4, 2, null, elems);
    }

    private static void testIdentityMatrix() {
        System.out.println(MatrixFactory.getIdentityMatrix(get33X().rows(), null));
    }

    private static void testSolve() {
        Matrix solution = MatrixOperator.solve(get33X(), get31B());
        System.out.println(solution);
        System.out.println(MatrixOperator.multiply(MatrixTransformer.inverse(get33X()), get31B()));
        System.out.println("");
    }

    private static void testInverse() {
        System.out.println("");
        System.out.println(MatrixTransformer.inverse(get33X()));
    }


    private static void testLUDecomposition() {
        LUDecomposition lu = new LUDecomposition(get33X());
        System.out.println(lu.getL());
        System.out.println(lu.getU());
        System.out.println(lu.isNonsingular());
        System.out.println(lu.getPivotMatrix());
    }

    private static Matrix get31B() {
        double[][] elems = {{14},
                            {3},
                            {8}, };
        return MatrixFactory.getMatrix(3, 1, null, elems);
    }

    private static Matrix get33X() {
        double[][] elems = {{1, 2, 3, },
                            {2, -1, 1, },
                            {3, 4, -1, }, };
        return MatrixFactory.getMatrix(3, 3, null, elems);
    }

    private static void testDeterminant() {
        System.out.println(MatrixMeasure.getDeterminant(getIdempotentMatrix()));
        System.out.println(MatrixMeasure.getDeterminant(get33X()));
        System.out.println(MatrixMeasure.getDeterminant(get55Matrix()));
        System.out.println(MatrixMeasure.getDeterminant(getSymetricMatrix()));
    }

    private static void testSubmatrix() {
        testSubmatrix(get55Matrix());
        System.out.println("@@@@@@@@@@@@@@@@@@@@HeavyMatrix@@@@@@@@@@@@@@@@@@@@@@@@@@@@@q");
        Matrix heavyMatrix = new HeavyMatrixImpl(5, 5);
        testSubmatrix(MatrixFactory.getMatrix(5, 5, null, get55Matrix().get()));
    }

    private static void testSubmatrix(Matrix matrix) {
        System.out.println("1,1 -> 5,5");
        System.out.println(matrix.getSubMatrix(1, 1, 5, 5));
        System.out.println("1,1 -> 1,1");
        System.out.println(matrix.getSubMatrix(1, 1, 1, 1));
        System.out.println("2,2 -> 5,5");
        System.out.println(matrix.getSubMatrix(2, 2, 5, 5));
        System.out.println("2,2 -> 4,5");
        System.out.println(matrix.getSubMatrix(2, 2, 4, 5));

        System.out.println("{1,3,4} -> {2,4,5}");
        System.out.println(matrix.getSubMatrix(new int[]{1, 3, 4}, new int[]{2, 4, 5}));

        System.out.println("1,1 -> {2,4}");
        System.out.println(matrix.getSubMatrix(1, 1, new int[]{2, 4}));

        System.out.println("2,3 -> {1,4,5}");
        System.out.println(matrix.getSubMatrix(2, 3, new int[]{1, 4, 5}));

        System.out.println("{1,3,5} -> 3,5");
        System.out.println(matrix.getSubMatrix(new int[]{1, 3, 5}, 3, 5));
    }


    private static Matrix get55Matrix() {
        double[][] elems = {{11, 12, 13, 14, 15, },
                            {21, 22, 23, 24, 25, },
                            {31, 32, 33, 34, 35, },
                            {41, 42, 43, 44, 45, },
                            {51, 52, 53, 54, 55, }, };
        return MatrixFactory.getMatrix(5, 5, null, elems);
    }

    private static Matrix get35Matrix() {
        double[][] elems = {{11, 12, 13, 14, 15, },
                            {21, 22, 23, 24, 25, },
                            {31, 32, 33, 34, 35, }, };
        return MatrixFactory.getMatrix(3, 5, null, elems);
    }

    private static Matrix get53Matrix() {
        double[][] elems = {{11, 12, 13, },
                            {21, 22, 23, },
                            {31, 32, 33, },
                            {41, 42, 43, },
                            {51, 52, 53, }};
        return MatrixFactory.getMatrix(5, 3, null, elems);
    }


    private static void testTrace() {
        // works on the fact that getTrace(AB) = getTrace(BA) where A mxn and B nxm matrices
        Matrix a = getIdempotentMatrix(), b = getSymetricMatrix();
        System.out.println(MatrixMeasure.getTrace(MatrixOperator.multiply(a, b)) == MatrixMeasure.getTrace(MatrixOperator.multiply(b, a)));
    }

    private static void testIsIdempotent() {
        System.out.println(MatrixProperty.isIdempotent(getIdempotentMatrix()));
    }

    private static Matrix getIdempotentMatrix() {
        double[][] elems = {{1 / 6, -1 / 3, 1 / 6, },
                            {-1 / 3, 2 / 3, -1 / 3, },
                            {1 / 6, -1 / 3, 1 / 6, }, };
        return MatrixFactory.getMatrix(3, 3, null, elems);
    }

    private static void testIsSymetric() {
        System.out.println(MatrixProperty.isSymmetric(getSymetricMatrix()));
    }

    private static Matrix getSymetricMatrix() {
        double[][] elems = {{1, 5, 6, },
                            {5, 2, 0, },
                            {6, 0, -4, }, };
        return MatrixFactory.getMatrix(3, 3, null, elems);
    }

    private static void testPow() {
        Matrix m = MatrixFactory.getMatrix(3, 3, null, 2);
        System.out.println(MatrixTransformer.pow(m, 0));
        System.out.println(MatrixTransformer.pow(m, 1));  //2
        System.out.println(MatrixTransformer.pow(m, 2));  //12
        System.out.println(MatrixTransformer.pow(m, 3));  //72
        //System.out.println(MatrixTransformer.pow(m,10));
    }

    private static void testGet() {
        Matrix m1 = MatrixFactory.getMatrix(3, 4, null);
        double[][] store = m1.get();
        store[0][0] = 1;
        System.out.println(m1);
        System.out.println(MatrixFactory.getMatrix(3, 4, null, store));

    }

    private static void testHeavyMatrix() {
        HeavyMatrixImpl hm = new HeavyMatrixImpl(3, 2);
        hm.set(1, 1, 1);
        hm.set(1, 2, 4);
        hm.set(2, 1, 2);
        hm.set(2, 2, 5);
        hm.set(3, 1, 3);
        hm.set(3, 2, 6);
        testHeavyMatrix(hm);


    }

    private static void testHeavyMatrix(HeavyMatrixImpl hm) {
        System.out.println(hm);
        Matrix row1 = hm.getRow(1);
        System.out.println(row1);
        System.out.println(hm.getColumn(1));
        System.out.println(hm.getRow(3));
        System.out.println(hm.getColumn(2));
    }

    private static void testTransformations() {
        testScalarTransformation();
        testFunctionTransformation();
    }

    private static void testScalarTransformation() {
        Matrix m = MatrixFactory.getMatrix(3, 3, null);
        int s = 3;

        final int sf = s;
        Matrix mi = MatrixEBETransformer.ebeTransform(m, new MatrixEBETransformation() {
            public double transform(double element) {
                return element + sf; //could be +, *, -, /
            }
        });
        System.out.println(mi);
    }

    private static void testFunctionTransformation() {
        Matrix m = MatrixFactory.getMatrix(3, 3, null);
        Matrix mi = MatrixEBETransformer.ebeTransform(m, new MatrixEBETransformation() {
            public double transform(double element) {
                return Math.cos(element);
            }
        });
        System.out.println(mi);
    }

    private static void testTranspose() {
        Matrix m = MatrixFactory.getMatrix(2, 3, null);
        System.out.println(m);
        System.out.println(MatrixTransformer.transpose(m));
    }

    private static void testMultiply() {
        Matrix a = MatrixFactory.getMatrix(3, 4, null);
        a.set(1, 1, 1);
        a.set(1, 4, 3);
        a.set(2, 1, 4);
        a.set(2, 2, 5);
        a.set(3, 3, 4);
        a.set(3, 4, 5);

        Matrix b = MatrixFactory.getMatrix(4, 3, null);
        b.set(1, 1, 3);
        b.set(4, 1, 7);
        b.set(4, 2, 8);
        b.set(4, 3, 9);

        System.out.println(MatrixOperator.multiply(a, b));

    }

    private static void testConcatenation() {
        Matrix a = MatrixFactory.getMatrix(3, 3, null);
        Matrix b = MatrixFactory.getMatrix(3, 4, null);
        System.out.println(MatrixOperator.horizontalConcatenation(a, b));

        Matrix c = MatrixFactory.getMatrix(3, 4, null);
        Matrix d = MatrixFactory.getMatrix(5, 4, null);
        System.out.println(MatrixOperator.verticalConcatenation(c, d));
    }

    private static void testColumnOperators() {
        Matrix a = MatrixFactory.getMatrix(3, 4, null);
        a.set(1, 1, 1);
        a.set(1, 4, 3);
        a.set(2, 1, 4);
        a.set(2, 2, 5);
        a.set(2, 4, -5);
        ;
        a.set(2, 3, -5);
        a.set(3, 3, 4);
        a.set(3, 4, 5);
        System.out.println(a);
        System.out.println(ColumnTransformer.sum(a));
        System.out.println(ColumnTransformer.product(a));

        System.out.println(ColumnTransformer.max(a));
        System.out.println(ColumnTransformer.min(a));

        System.out.println(ColumnTransformer.mean(a, false));

        System.out.println(ColumnTransformer.mean(a, true));
    }


    private static void testRowOperators() {
        Matrix a = MatrixFactory.getMatrix(3, 4, null);
        a.set(1, 1, 1);
        a.set(1, 4, 3);
        a.set(2, 1, 4);
        a.set(2, 2, 5);
        a.set(2, 4, -5);

        a.set(2, 3, -5);
        a.set(3, 3, 4);
        a.set(3, 4, 5);
                System.out.println(a);
        System.out.println(RowTransformer.sum(a));
        System.out.println(RowTransformer.product(a));

        System.out.println(RowTransformer.max(a));
        System.out.println(RowTransformer.min(a));

        System.out.println(RowTransformer.mean(a, false));

        System.out.println(RowTransformer.mean(a, true));


    }

    private static void testMatrixMeasures() {
        Matrix a = MatrixFactory.getMatrix(2, 2, null);
        a.set(1, 1, 2);
        a.set(1, 2, 3);
        a.set(2, 1, 2);
        a.set(2, 2, 3);
        ((LightMatrixImpl) a).toString();
        System.out.println(MatrixMeasure.getMax(a));
        System.out.println(MatrixMeasure.getMin(a));
        System.out.println(MatrixMeasure.getSum(a));
        System.out.println(MatrixMeasure.getProduct(a));
        System.out.println(MatrixMeasure.getMean(a, false));
        System.out.println(MatrixMeasure.getMean(a, true));
    }

    private static void testDiagonalTrace() {
        Matrix a = MatrixFactory.getMatrix(2, 3, null);
        a.set(1, 1, 1);
        a.set(1, 2, 0);
        a.set(1, 3, 1);
        a.set(2, 1, 0);
        a.set(2, 2, 1);
        a.set(2, 3, 1);
        System.out.println(a);
        System.out.println(MatrixTransformer.diagonal(a));
        System.out.println(MatrixMeasure.getTrace(a));
    }
}


/**
 *  Jmatrices - Matrix Library
 Copyright (C) 2004  Piyush Purang

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library, see License.txt; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */package geym.conc.ch3.ds;

import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.Test;

public class TestQueueList {
	private static final int MAX_THREADS = 2000;
	private static final int TASK_COUNT = 4000;
	Queue q;

	public class HandleQueueThread implements Runnable{
		protected String name;
		java.util.Random rand=new java.util.Random();
		public HandleQueueThread(){
		}
		public HandleQueueThread(String name){
			this.name=name;
		}
		@Override
		public void run() {
			try {
				for(int i=0;i<500;i++)
					handleQueue(rand.nextInt(1000));
				Thread.sleep(rand.nextInt(100));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public class CounterPoolExecutor extends ThreadPoolExecutor{
		private AtomicInteger count =new AtomicInteger(0);
		public long startTime=0;
		public String funcname="";
		public CounterPoolExecutor(int corePoolSize, int maximumPoolSize,
				long keepAliveTime, TimeUnit unit,
				BlockingQueue<Runnable> workQueue) {
			super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
		}

		protected void afterExecute(Runnable r, Throwable t) {
			int l=count.addAndGet(1);
			if(l==TASK_COUNT){
				System.out.println(funcname+" spend time:"+(System.currentTimeMillis()-startTime));
			}
		}
	}

	public Object handleQueue(int index){
		q.add(index);
		q.poll();
		return null;
	}

	public void initConcurrentLinkedQueue(){
		 q=new ConcurrentLinkedQueue();
		 for(int i=0;i<300;i++)
			 q.add(i);
	}

	public void initLinkedBlockingQueue(){
		q=new LinkedBlockingQueue();
		 for(int i=0;i<300;i++)
			 q.add(i);
	}

	public void initArrayListBlockingQueue(){
		q=new ArrayBlockingQueue(10000);
		 for(int i=0;i<300;i++)
			 q.add(i);
	}

	//@Test
	public void testAddConcurrentLinkedQueue() throws InterruptedException {
		initConcurrentLinkedQueue();
		CounterPoolExecutor exe=new CounterPoolExecutor(MAX_THREADS, MAX_THREADS,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>());

		long starttime=System.currentTimeMillis();
		exe.startTime=starttime;
		exe.funcname="testAddConcurrentLinkedQueue";
		for(int i=0;i<TASK_COUNT;i++)
			exe.submit(new HandleQueueThread());

		Thread.sleep(10000);
	}

	@Test
	public void testLinkedBlockingQueue() throws InterruptedException {
		initLinkedBlockingQueue();
		CounterPoolExecutor exe=new CounterPoolExecutor(MAX_THREADS, MAX_THREADS,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>());

		long starttime=System.currentTimeMillis();
		exe.startTime=starttime;
		exe.funcname="testLinkedBlockingQueue";
		for(int i=0;i<TASK_COUNT;i++)
			exe.submit(new HandleQueueThread());

		Thread.sleep(10000);
	}

	//@Test
	public void testinitArrayListBlockingQueue() throws InterruptedException {
		initArrayListBlockingQueue();
		CounterPoolExecutor exe=new CounterPoolExecutor(MAX_THREADS, MAX_THREADS,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>());

		long starttime=System.currentTimeMillis();
		exe.startTime=starttime;
		exe.funcname="testinitArrayListBlockingQueue";
		for(int i=0;i<TASK_COUNT;i++)
			exe.submit(new HandleQueueThread());

		Thread.sleep(10000);
	}
}
package geym.conc.ch3.readwritelock;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.junit.Test;


public class TestReadWriteLock {
	private static final int MAX_THREADS = 2000;
	private static final int TASK_COUNT = 4000;
	private static Lock lock=new ReentrantLock();
	private static ReentrantReadWriteLock readWriteLock=new ReentrantReadWriteLock();
	private static Lock readLock = readWriteLock.readLock();
	private static Lock writeLock = readWriteLock.writeLock();

	java.util.Random rand=new java.util.Random();

	private int value;

	public class ReadWriteThread implements Runnable{
		protected String name;

		public ReadWriteThread(){
		}
		public ReadWriteThread(String name){
			this.name=name;
		}
		@Override
		public void run() {
			try {
				handleRead();
				int v=rand.nextInt(100);
				if(v<10)
					handleWrite(v);
				Thread.sleep(rand.nextInt(100));
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public class ReadWriteThread2 implements Runnable{
		protected String name;

		public ReadWriteThread2(){
		}
		public ReadWriteThread2(String name){
			this.name=name;
		}
		@Override
		public void run() {
			try {
				handleRead2();
				int v=rand.nextInt(100);
				if(v<10)
					handleWrite2(v);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public class CounterPoolExecutor extends ThreadPoolExecutor{
		private AtomicInteger count =new AtomicInteger(0);
		public long startTime=0;
		public String funcname="";
		public CounterPoolExecutor(int corePoolSize, int maximumPoolSize,
				long keepAliveTime, TimeUnit unit,
				BlockingQueue<Runnable> workQueue) {
			super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
		}

		protected void afterExecute(Runnable r, Throwable t) {
			int l=count.addAndGet(1);
			if(l==TASK_COUNT){
				System.out.println(funcname+" spend time:"+(System.currentTimeMillis()-startTime));

			}
		}
	}

	public Object handleRead() throws InterruptedException{
		try{
			lock.lock();
			Thread.sleep(1);
			return value;
		}finally{
		lock.unlock();
		}
	}

	public void handleWrite(int index) throws InterruptedException{
		try{
			lock.lock();
			Thread.sleep(1);
			value=index;
		}finally{
		lock.unlock();
		}
	}

	public Object handleRead2() throws InterruptedException{
		try{
			readLock.lock();
			Thread.sleep(1);
			return value;
		}finally{
			readLock.unlock();
		}
	}

	public void handleWrite2(int index) throws InterruptedException{
		try{
			writeLock.lock();
			Thread.sleep(1);
			value=index;
		}finally{
			writeLock.unlock();
		}
	}

	@Test
	public void testLock() throws InterruptedException {

		CounterPoolExecutor exe=new CounterPoolExecutor(MAX_THREADS, MAX_THREADS,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>());

		long starttime=System.currentTimeMillis();
		exe.startTime=starttime;
		exe.funcname="testLock";
		for(int i=0;i<TASK_COUNT;i++)
			exe.submit(new ReadWriteThread());

		Thread.sleep(100000);
	}

	//@Test
	public void testLock2() throws InterruptedException {

		CounterPoolExecutor exe=new CounterPoolExecutor(MAX_THREADS, MAX_THREADS,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>());

		long starttime=System.currentTimeMillis();
		exe.startTime=starttime;
		exe.funcname="testLock2";
		for(int i=0;i<TASK_COUNT;i++)
			exe.submit(new ReadWriteThread2());

		Thread.sleep(100000);
	}

}
package geym.conc.ch3.pool.simple;

/**
 * 使用简单线程池和直接开启线程的差别
 * @author Administrator
 *
 */
public class TestThreadPool {
	public static class MyThread implements Runnable{
		protected String name;
		public MyThread(){
		}
		public MyThread(String name){
			this.name=name;
		}
		@Override
		public void run() {
			try {
				Thread.sleep(100);
				//System.out.print(name+" ");
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	public  static void main(String args[]) throws InterruptedException {
		long starttime=System.currentTimeMillis();
		for(int i=0;i<1000;i++){
			ThreadPool.getInstance().start(new MyThread("testThreadPool"+Integer.toString(i)));
		}

		long endtime=System.currentTimeMillis();
		System.out.println("testThreadPool"+": "+(endtime-starttime));
		System.out.println("getCreatedThreadsCount:"+ThreadPool.getInstance().getCreatedThreadsCount());
		Thread.sleep(1000);
	}


}
package geym.conc.ch3.pool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;


public class TFThreadPoolDemo {
	public static class MyTask implements Runnable {
		@Override
		public void run() {
			System.out.println(System.currentTimeMillis() + ":Thread ID:"
					+ Thread.currentThread().getId());
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		MyTask task = new MyTask();
		ExecutorService es = new ThreadPoolExecutor(5, 5,
                0L, TimeUnit.MILLISECONDS,
                new SynchronousQueue<Runnable>(),
                new ThreadFactory(){
					@Override
					public Thread newThread(Runnable r) {
						Thread t= new Thread(r);
						t.setDaemon(true);
						System.out.println("create "+t);
						return t;
					}
				}
               );
		for (int i = 0; i < 5; i++) {
			es.submit(task);
		}
		Thread.sleep(2000);
	}
}
package geym.conc.ch2.group;

public class ThreadGroupName implements Runnable {
	public static void main(String[] args) {
		ThreadGroup tg = new ThreadGroup("PrintGroup");
		Thread t1 = new Thread(tg, new ThreadGroupName(), "T1");
		Thread t2 = new Thread(tg, new ThreadGroupName(), "T2");
		t1.start();
		t2.start();
		System.out.println(tg.activeCount());
		tg.list();
	}

	@Override
	public void run() {
		String groupAndName = Thread.currentThread().getThreadGroup().getName()
				+ "-" + Thread.currentThread().getName();
		while (true) {
			System.out.println("I am " + groupAndName);
			try {
				Thread.sleep(3000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
package geym.conc.ch2.group;

public class ThreadGroupStop implements Runnable{
	public static void main(String[] args) throws InterruptedException {
		ThreadGroup tg=new ThreadGroup("PrintGroup");
		Thread t1=new Thread(tg,new ThreadGroupStop(),"T1");
		Thread t2=new Thread(tg,new ThreadGroupStop(),"T2");
		t1.start();
		t2.start();
		Thread.sleep(3000);
		tg.stop();
	}

	@Override
	public void run() {
		String groupAndName=Thread.currentThread().getThreadGroup().getName()
				+"-"+Thread.currentThread().getName();
		while(true){
			System.out.println("I am "+groupAndName);
			try {
				Thread.sleep(3000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
package geym.conc.ch4.tl;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadLocalDemo {
	private static final  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    public static class ParseDate implements Runnable{
    	int i=0;
    	public ParseDate(int i){this.i=i;}
		public void run() {
			try {
				Date t=sdf.parse("2015-03-29 19:29:"+i%60);
				System.out.println(i+":"+t);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
    }
	public static void main(String[] args) {
		ExecutorService es=Executors.newFixedThreadPool(10);
		for(int i=0;i<1000;i++){
			es.execute(new ParseDate(i));
		}
	}
}
package geym.conc.ch2.sync.lockonint;


public class ThreadLocalDemo implements Runnable {
	public static class User{
		public int id;
		public String strId;
		public User(int id, String strId) {
			super();
			this.id = id;
			this.strId = strId;
		}
	}
	public static final ThreadLocal<User> localvar= new ThreadLocal<User>();
	public static User u=new User(1,"1");
	@Override
	public void run() {
//		localvar.set(u);
		localvar.set(new User(1,"1"));
		for(int i=0;i<50000;i++){
			localvar.get().id=i;
			localvar.get().strId=Integer.toString(i);
			if(localvar.get().id!=Integer.parseInt(localvar.get().strId)){
				System.out.println("ID:"+localvar.get().id+" strId:"+localvar.get().strId);
			}
		}
	}

	public static void main(String[] args) {
		ThreadLocalDemo r=new ThreadLocalDemo();
		Thread t1=new Thread(r);
		Thread t2=new Thread(r);
		t1.start();
		t2.start();
	}
}
package geym.conc.ch4.tl;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadLocalDemo2 {
	static ThreadLocal<SimpleDateFormat> tl=new ThreadLocal<SimpleDateFormat>();
    public static class ParseDate implements Runnable{
    	int i=0;
    	public ParseDate(int i){this.i=i;}
		public void run() {
			try {
				if(tl.get()==null){
					tl.set(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
				}
				Date t=tl.get().parse("2015-03-29 19:29:"+i%60);
				System.out.println(i+":"+t);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
    }
	public static void main(String[] args) {
		ExecutorService es=Executors.newFixedThreadPool(10);
		for(int i=0;i<1000;i++){
			es.execute(new ParseDate(i));
		}

	}

}
package geym.conc.ch4.tl;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadLocalDemoBad {
	static ThreadLocal<SimpleDateFormat> tl=new ThreadLocal<SimpleDateFormat>();
	private static final  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    public static class ParseDate implements Runnable{
    	int i=0;
    	public ParseDate(int i){this.i=i;}
		public void run() {
			try {
				if(tl.get()==null){
					tl.set(sdf);
				}
				Date t=tl.get().parse("2015-03-29 19:29:"+i%60);
				System.out.println(i+":"+t);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
    }
	public static void main(String[] args) {
		ExecutorService es=Executors.newFixedThreadPool(10);
		for(int i=0;i<1000;i++){
			es.execute(new ParseDate(i));
		}

	}

}

package geym.conc.ch4.tl;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadLocalDemo_Gc {
    static volatile ThreadLocal<SimpleDateFormat> tl = new ThreadLocal<SimpleDateFormat>() {
        protected void finalize() throws Throwable {
            System.out.println(this.toString() + " is gc");
        }
    };
    static volatile CountDownLatch cd = new CountDownLatch(10000);
    public static class ParseDate implements Runnable {
        int i = 0;
        public ParseDate(int i) {
            this.i = i;
        }
        public void run() {
            try {
                if (tl.get() == null) {
                    tl.set(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss") {
                        protected void finalize() throws Throwable {
                            System.out.println(this.toString() + " is gc");
                        }
                    });
                    System.out.println(Thread.currentThread().getId() + ":create SimpleDateFormat");
                }
                Date t = tl.get().parse("2015-03-29 19:29:" + i % 60);
            } catch (ParseException e) {
                e.printStackTrace();
            } finally {
                cd.countDown();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ExecutorService es = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 10000; i++) {
            es.execute(new ParseDate(i));
        }
        cd.await();
        System.out.println("mission complete!!");
        tl = null;
        System.gc();
        System.out.println("first GC complete!!");
        //在设置ThreadLocal的时候，会清除ThreadLocalMap中的无效对象
        tl = new ThreadLocal<SimpleDateFormat>();
        cd = new CountDownLatch(10000);
        for (int i = 0; i < 10000; i++) {
            es.execute(new ParseDate(i));
        }
        cd.await();
        Thread.sleep(1000);

        System.gc();
        System.out.println("second GC complete!!");

    }
}
package geym.conc.ch3.pool.simple;

import java.util.List;
import java.util.Vector;

public class ThreadPool
{
    private static ThreadPool instance = null;

    private List<Worker> idleThreads;
    private int threadCounter;
    private boolean isShutDown = false;

    private ThreadPool()
    {
        this.idleThreads = new Vector(5);
        threadCounter = 0;
    }

    public int getCreatedThreadsCount() {
        return threadCounter;
    }


    public synchronized static ThreadPool getInstance() {
        if (instance == null)
            instance = new ThreadPool();
        return instance;
    }


    protected synchronized void repool(Worker repoolingThread)
    {
        if (!isShutDown)
        {
            idleThreads.add(repoolingThread);
        }
        else
        {
            repoolingThread.shutDown();//�ر��߳�
        }
    }


    public synchronized void shutdown()
    {
       isShutDown = true;
       for (int threadIndex = 0; threadIndex < idleThreads.size(); threadIndex++)
       {
             Worker idleThread = (Worker) idleThreads.get(threadIndex);
             idleThread.shutDown();
       }
    }

    public synchronized void start(Runnable target)
    {
        Worker thread = null;
        if (idleThreads.size() > 0)
        {
            int lastIndex = idleThreads.size() - 1;
            thread = (Worker) idleThreads.get(lastIndex);
            idleThreads.remove(lastIndex);
            thread.setTarget(target);
        }
        else
        {
            threadCounter++;
            thread = new Worker(target, "PThread #" + threadCounter, this);
            thread.start();
        }
    }
}package geym.conc.ch3.pool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolDemo {
	public static class MyTask implements Runnable {
		@Override
		public void run() {
			System.out.println(System.currentTimeMillis() + ":Thread ID:"
					+ Thread.currentThread().getId());
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public static void main(String[] args) {
		MyTask task = new MyTask();
		ExecutorService es = Executors.newFixedThreadPool(5);
		for (int i = 0; i < 10; i++) {
			es.submit(task);
		}
	}
}
package geym.conc.ch3.synctrl;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class TimeLock implements Runnable{
	public static ReentrantLock lock=new ReentrantLock();
	@Override
	public void run() {
		try {
			if(lock.tryLock(5, TimeUnit.SECONDS)){
				Thread.sleep(6000);
			}else{
				System.out.println("get lock failed");
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}finally{lock.unlock();}
	}
	public static void main(String[] args) {
		TimeLock tl=new TimeLock();
		Thread t1=new Thread(tl);
		Thread t2=new Thread(tl);
		t1.start();
		t2.start();
	}
}
package com.lmax.disruptor;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class TimeoutBlockingWaitStrategy implements WaitStrategy
{
    private final Lock lock = new ReentrantLock();
    private final Condition processorNotifyCondition = lock.newCondition();
    private final long timeoutInNanos;

    public TimeoutBlockingWaitStrategy(final long timeout, final TimeUnit units)
    {
        timeoutInNanos = units.toNanos(timeout);
    }

    @Override
    public long waitFor(final long sequence,
                        final Sequence cursorSequence,
                        final Sequence dependentSequence,
                        final SequenceBarrier barrier)
        throws AlertException, InterruptedException, TimeoutException
    {
        long nanos = timeoutInNanos;

        long availableSequence;
        if ((availableSequence = cursorSequence.get()) < sequence)
        {
            lock.lock();
            try
            {
                while ((availableSequence = cursorSequence.get()) < sequence)
                {
                    barrier.checkAlert();
                    nanos = processorNotifyCondition.awaitNanos(nanos);
                    if (nanos <= 0)
                    {
                        throw TimeoutException.INSTANCE;
                    }
                }
            }
            finally
            {
                lock.unlock();
            }
        }

        while ((availableSequence = dependentSequence.get()) < sequence)
        {
            barrier.checkAlert();
        }

        return availableSequence;
    }

    @Override
    public void signalAllWhenBlocking()
    {
        lock.lock();
        try
        {
            processorNotifyCondition.signalAll();
        }
        finally
        {
            lock.unlock();
        }
    }

}
package com.lmax.disruptor;

@SuppressWarnings("serial")
public final class TimeoutException extends Exception
{
    public static final TimeoutException INSTANCE = new TimeoutException();

    private TimeoutException()
    {
        // Singleton
    }

    @Override
    public synchronized Throwable fillInStackTrace()
    {
        return this;
    }
}
package com.lmax.disruptor;

public interface TimeoutHandler
{
    void onTimeout(long sequence) throws Exception;
}
package geym.conc.ch3.trace;

import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;


public class TraceMain {

	public static void main(String[] args) {
		ThreadPoolExecutor pools=new TraceThreadPoolExecutor(0, Integer.MAX_VALUE,
                0L, TimeUnit.SECONDS,
                new SynchronousQueue<Runnable>());
		for(int i=0;i<5;i++){
			pools.execute(new DivTask(100,i));
		}
	}

}
package geym.conc.ch3.trace;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class TraceThreadPoolExecutor extends ThreadPoolExecutor {
	public TraceThreadPoolExecutor(int corePoolSize, int maximumPoolSize,
			long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
		super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
	}

	@Override
	public void execute(Runnable task) {
		super.execute(wrap(task, clientTrace(), Thread.currentThread()
				.getName()));
	}

	@Override
	public Future<?> submit(Runnable task) {
		return super.submit(wrap(task, clientTrace(), Thread.currentThread()
				.getName()));
	}

	private Exception clientTrace() {
		return new Exception("Client stack trace");
	}

	private Runnable wrap(final Runnable task, final Exception clientStack,
			String clientThreadName) {
		return new Runnable() {
			@Override
			public void run() {
				try {
					task.run();
				} catch (Exception e) {
					clientStack.printStackTrace();
					throw e;
				}
			}
		};
	}
}
package geym.conc.ch6.flow;

import java.util.concurrent.Flow.Processor;
import java.util.concurrent.Flow.Subscription;
import java.util.concurrent.SubmissionPublisher;
import java.util.function.Function;

public class TransformProcessor<T, R> extends SubmissionPublisher<R> implements Processor<T, R> {
    private Function<? super T, ? extends R> function;
    private Subscription subscription;

    public TransformProcessor(Function<? super T, ? extends R> function) {
        super();
        this.function = function;
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
        subscription.request(1);
    }

    @Override
    public void onNext(T item) {
        submit(function.apply(item));
        subscription.request(1);
    }

    @Override
    public void onError(Throwable throwable) {
        throwable.printStackTrace();
    }

    @Override
    public void onComplete() {
        close();
    }

}
package geym.conc.ch3.synctrl;

import java.util.concurrent.locks.ReentrantLock;

public class TryLock implements Runnable {
	public static ReentrantLock lock1 = new ReentrantLock();
	public static ReentrantLock lock2 = new ReentrantLock();
	int lock;

	public TryLock(int lock) {
		this.lock = lock;
	}

	@Override
	public void run() {
		if (lock == 1) {
			while (true) {
				if (lock1.tryLock()) {
					try {
						try {
							Thread.sleep(500);
						} catch (InterruptedException e) {
						}
						if (lock2.tryLock()) {
							try {
								System.out.println(Thread.currentThread()
										.getId() + ":My Job done");
								return;
							} finally {
								lock2.unlock();
							}
						}
					} finally {
						lock1.unlock();
					}
				}
			}
		} else {
			while (true) {
				if (lock2.tryLock()) {
					try {
						try {
							Thread.sleep(500);
						} catch (InterruptedException e) {
						}
						if (lock1.tryLock()) {
							try {
								System.out.println(Thread.currentThread()
										.getId() + ":My Job done");
								return;
							} finally {
								lock1.unlock();
							}
						}
					} finally {
						lock2.unlock();
					}
				}
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		TryLock r1 = new TryLock(1);
		TryLock r2 = new TryLock(2);
		Thread t1 = new Thread(r1);
		Thread t2 = new Thread(r2);
		t1.start();
		t2.start();
	}
}
package geym.conc.ch8;

import java.util.ArrayList;

/**
 * 两个线程都过了数组大小检查，先后插入数据时 引起 out of bound
 * @author Geym
 *
 */
public class UnsafeArrayList {
    static ArrayList al=new ArrayList();
    static class AddTask implements Runnable{
        @Override
        public void run() {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {}
            for(int i=0;i<1000000;i++)
                al.add(new Object());
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(new AddTask(),"t1");
        Thread t2=new Thread(new AddTask(),"t2");
        t1.start();
        t2.start();
        Thread t3=new Thread(new Runnable(){
            @Override
            public void run() {
                while(true){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {}
                }
            }
        },"t3");
        t3.start();
    }
}
package org.jmatrices.dbl.decomposition;

/**
 * Util
 * <br/>
 * Author: purangp
 * <br/>
 * Date: 13.03.2004
 * Time: 13:54:46
 */
public class Util {
    public static double hypot(double a, double b) {
        double r;
        if (Math.abs(a) > Math.abs(b)) {
            r = b / a;
            r = Math.abs(a) * Math.sqrt(1 + r * r);
        } else if (b != 0) {
            r = a / b;
            r = Math.abs(b) * Math.sqrt(1 + r * r);
        } else {
            r = 0.0;
        }
        return r;
    }

    /**
     * Signum function
     * returns 1 if the <code>a</code>
     * is greater than zero, 0 if it equals zero and -1 if it is
     * less than zero.
     *
     * @param a
     * @return
     */
     public static int sign(int a) {
        if (a > 0)
            return 1;
        else if (a < 0)
            return -1;

        return 0;
    }

    public static int sign(double a) {
        if (a > 0)
            return 1;
        else if (a<0)
            return -1;

        return 0;
    }

    private Util() {
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor.util;

import java.lang.reflect.Field;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.security.AccessController;
import java.security.PrivilegedExceptionAction;

import sun.misc.Unsafe;

import com.lmax.disruptor.EventProcessor;
import com.lmax.disruptor.Sequence;

/**
 * Set of common functions used by the Disruptor
 */
public final class Util
{
    /**
     * Calculate the next power of 2, greater than or equal to x.<p>
     * From Hacker's Delight, Chapter 3, Harry S. Warren Jr.
     *
     * @param x Value to round up
     * @return The next power of 2 from x inclusive
     */
    public static int ceilingNextPowerOfTwo(final int x)
    {
        return 1 << (32 - Integer.numberOfLeadingZeros(x - 1));
    }

    /**
     * Get the minimum sequence from an array of {@link com.lmax.disruptor.Sequence}s.
     *
     * @param sequences to compare.
     * @return the minimum sequence found or Long.MAX_VALUE if the array is empty.
     */
    public static long getMinimumSequence(final Sequence[] sequences)
    {
        return getMinimumSequence(sequences, Long.MAX_VALUE);
    }

    /**
     * Get the minimum sequence from an array of {@link com.lmax.disruptor.Sequence}s.
     *
     * @param sequences to compare.
     * @param minimum an initial default minimum.  If the array is empty this value will be
     * returned.
     * @return the minimum sequence found or Long.MAX_VALUE if the array is empty.
     */
    public static long getMinimumSequence(final Sequence[] sequences, long minimum)
    {
        for (int i = 0, n = sequences.length; i < n; i++)
        {
            long value = sequences[i].get();
            minimum = Math.min(minimum, value);
        }

        return minimum;
    }

    /**
     * Get an array of {@link Sequence}s for the passed {@link EventProcessor}s
     *
     * @param processors for which to get the sequences
     * @return the array of {@link Sequence}s
     */
    public static Sequence[] getSequencesFor(final EventProcessor... processors)
    {
        Sequence[] sequences = new Sequence[processors.length];
        for (int i = 0; i < sequences.length; i++)
        {
            sequences[i] = processors[i].getSequence();
        }

        return sequences;
    }

    private static final Unsafe THE_UNSAFE;
    static
    {
        try
        {
            final PrivilegedExceptionAction<Unsafe> action = new PrivilegedExceptionAction<Unsafe>()
            {
                public Unsafe run() throws Exception
                {
                    Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
                    theUnsafe.setAccessible(true);
                    return (Unsafe) theUnsafe.get(null);
                }
            };

            THE_UNSAFE = AccessController.doPrivileged(action);
        }
        catch (Exception e)
        {
            throw new RuntimeException("Unable to load unsafe", e);
        }
    }

    /**
     * Get a handle on the Unsafe instance, used for accessing low-level concurrency
     * and memory constructs.
     * @return The Unsafe
     */
    public static Unsafe getUnsafe()
    {
        return THE_UNSAFE;
    }

    /**
     * Gets the address value for the memory that backs a direct byte buffer.
     * @param buffer
     * @return The system address for the buffers
     */
    public static long getAddressFromDirectByteBuffer(ByteBuffer buffer)
    {
        try
        {
            Field addressField = Buffer.class.getDeclaredField("address");
            addressField.setAccessible(true);
            return addressField.getLong(buffer);
        }
        catch (Exception e)
        {
            throw new RuntimeException("Unable to address field from ByteBuffer", e);
        }
    }


    /**
     * Calculate the log base 2 of the supplied integer, essentially reports the location
     * of the highest bit.
     *
     * @param i Value to calculate log2 for.
     * @return The log2 value
     */
    public static int log2(int i)
    {
        int r = 0;
        while ((i >>= 1) != 0)
        {
            ++r;
        }
        return r;
    }
}
package org.jmatrices.dbl;

/**
 * Vector
 * <p>
 * <font color="blue">
 * todo - open thought!
 * </font>
 * </p>
 * <p>
 * Author: purangp
 * </p>
 * Date: 10.03.2004
 * Time: 16:48:35
 */
public interface Vector {
    public int length();

    public double get(int i);

    public void set(int i, double value);
}


/**
 *  Jmatrices - Matrix Library
    Copyright (C) 2004  Piyush Purang

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library, see License.txt; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */ /*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;


/**
 * Strategy employed for making {@link EventProcessor}s wait on a cursor {@link Sequence}.
 */
public interface WaitStrategy
{
    /**
     * Wait for the given sequence to be available.  It is possible for this method to return a value
     * less than the sequence number supplied depending on the implementation of the WaitStrategy.  A common
     * use for this is to signal a timeout.  Any EventProcessor that is using a WaitStragegy to get notifications
     * about message becoming available should remember to handle this case.  The {@link BatchEventProcessor} explicitly
     * handles this case and will signal a timeout if required.
     *
     * @param sequence to be waited on.
     * @param cursor the main sequence from ringbuffer. Wait/notify strategies will
     *    need this as it's the only sequence that is also notified upon update.
     * @param dependentSequence on which to wait.
     * @param barrier the processor is waiting on.
     * @return the sequence that is available which may be greater than the requested sequence.
     * @throws AlertException if the status of the Disruptor has changed.
     * @throws InterruptedException if the thread is interrupted.
     * @throws TimeoutException
     */
    long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, SequenceBarrier barrier)
        throws AlertException, InterruptedException, TimeoutException;

    /**
     * Implementations should signal the waiting {@link EventProcessor}s that the cursor has advanced.
     */
    void signalAllWhenBlocking();
}
package geym.conc.ch3.pool.simple;

public class Worker extends Thread
{
    //线程池
    private ThreadPool pool;
    //任务
    private Runnable target;
    private boolean isShutDown = false;
    private boolean isIdle = false;

    public Worker(Runnable target, String name, ThreadPool pool)
    {
        super(name);
        this.pool = pool;
        this.target = target;
    }

    public Runnable getTarget()
    {
        return target;
    }

    public boolean isIdle()
    {
        return isIdle;
    }
    public void run()
    {
        while (!isShutDown)
        {
            isIdle = false;
            if (target != null)
            {
                // 运行任务
                target.run();
            }
            //任务结束了
            isIdle = true;
            try
            {
                //该任务结束后，不关闭线程，而是放入线程池空闲队列
                pool.repool(this);
                synchronized (this)
                {
                    //线程空闲，等待新的任务到来
                    wait();
                }
            }
            catch (InterruptedException ie)
            {
            }
            isIdle = false;
        }
    }


    public synchronized void setTarget(java.lang.Runnable newTarget)
    {
        target = newTarget;
        //设置了任务之后，通知run方法，开始执行这个任务
        notifyAll();
    }

    public synchronized void shutDown()
    {
        isShutDown = true;
        notifyAll();
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import com.lmax.disruptor.util.Util;

import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * WorkerPool contains a pool of {@link WorkProcessor}s that will consume sequences so jobs can be farmed out across a pool of workers.
 * Each of the {@link WorkProcessor}s manage and calls a {@link WorkHandler} to process the events.
 *
 * @param <T> event to be processed by a pool of workers
 */
public final class WorkerPool<T>
{
    private final AtomicBoolean started = new AtomicBoolean(false);
    private final Sequence workSequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
    private final RingBuffer<T> ringBuffer;
    // WorkProcessors are created to wrap each of the provided WorkHandlers
    private final WorkProcessor<?>[] workProcessors;

    /**
     * Create a worker pool to enable an array of {@link WorkHandler}s to consume published sequences.
     *
     * This option requires a pre-configured {@link RingBuffer} which must have {@link RingBuffer#addGatingSequences(Sequence...)}
     * called before the work pool is started.
     *
     * @param ringBuffer of events to be consumed.
     * @param sequenceBarrier on which the workers will depend.
     * @param exceptionHandler to callback when an error occurs which is not handled by the {@link WorkHandler}s.
     * @param workHandlers to distribute the work load across.
     */
    public WorkerPool(final RingBuffer<T> ringBuffer,
                      final SequenceBarrier sequenceBarrier,
                      final ExceptionHandler<? super T> exceptionHandler,
                      final WorkHandler<? super T>... workHandlers)
    {
        this.ringBuffer = ringBuffer;
        final int numWorkers = workHandlers.length;
        workProcessors = new WorkProcessor[numWorkers];

        for (int i = 0; i < numWorkers; i++)
        {
            workProcessors[i] = new WorkProcessor<T>(ringBuffer,
                                                     sequenceBarrier,
                                                     workHandlers[i],
                                                     exceptionHandler,
                                                     workSequence);
        }
    }

    /**
     * Construct a work pool with an internal {@link RingBuffer} for convenience.
     *
     * This option does not require {@link RingBuffer#addGatingSequences(Sequence...)} to be called before the work pool is started.
     *
     * @param eventFactory for filling the {@link RingBuffer}
     * @param exceptionHandler to callback when an error occurs which is not handled by the {@link WorkHandler}s.
     * @param workHandlers to distribute the work load across.
     */
    public WorkerPool(final EventFactory<T> eventFactory,
                      final ExceptionHandler<? super T> exceptionHandler,
                      final WorkHandler<? super T>... workHandlers)
    {
        ringBuffer = RingBuffer.createMultiProducer(eventFactory, 1024, new BlockingWaitStrategy());
        final SequenceBarrier barrier = ringBuffer.newBarrier();
        final int numWorkers = workHandlers.length;
        workProcessors = new WorkProcessor[numWorkers];

        for (int i = 0; i < numWorkers; i++)
        {
            workProcessors[i] = new WorkProcessor<T>(ringBuffer,
                                                     barrier,
                                                     workHandlers[i],
                                                     exceptionHandler,
                                                     workSequence);
        }

        ringBuffer.addGatingSequences(getWorkerSequences());
    }

    /**
     * Get an array of {@link Sequence}s representing the progress of the workers.
     *
     * @return an array of {@link Sequence}s representing the progress of the workers.
     */
    public Sequence[] getWorkerSequences()
    {
        final Sequence[] sequences = new Sequence[workProcessors.length + 1];
        for (int i = 0, size = workProcessors.length; i < size; i++)
        {
            sequences[i] = workProcessors[i].getSequence();
        }
        sequences[sequences.length - 1] = workSequence;

        return sequences;
    }

    /**
     * Start the worker pool processing events in sequence.
     *
     * @param executor providing threads for running the workers.
     * @return the {@link RingBuffer} used for the work queue.
     * @throws IllegalStateException if the pool has already been started and not halted yet
     */
    public RingBuffer<T> start(final Executor executor)
    {
        if (!started.compareAndSet(false, true))
        {
            throw new IllegalStateException("WorkerPool has already been started and cannot be restarted until halted.");
        }

        final long cursor = ringBuffer.getCursor();
        workSequence.set(cursor);

        for (WorkProcessor<?> processor : workProcessors)
        {
            processor.getSequence().set(cursor);
            executor.execute(processor);
        }

        return ringBuffer;
    }

    /**
     * Wait for the {@link RingBuffer} to drain of published events then halt the workers.
     */
    public void drainAndHalt()
    {
        Sequence[] workerSequences = getWorkerSequences();
        while (ringBuffer.getCursor() > Util.getMinimumSequence(workerSequences))
        {
            Thread.yield();
        }

        for (WorkProcessor<?> processor : workProcessors)
        {
            processor.halt();
        }

        started.set(false);
    }

    /**
     * Halt all workers immediately at the end of their current cycle.
     */
    public void halt()
    {
        for (WorkProcessor<?> processor : workProcessors)
        {
            processor.halt();
        }

        started.set(false);
    }

    public boolean isRunning()
    {
        return started.get();
    }
}
package com.lmax.disruptor.dsl;

import com.lmax.disruptor.*;

import java.util.concurrent.Executor;

class WorkerPoolInfo<T> implements ConsumerInfo
{
    private final WorkerPool<T> workerPool;
    private final SequenceBarrier sequenceBarrier;
    private boolean endOfChain = true;

    public WorkerPoolInfo(final WorkerPool<T> workerPool, final SequenceBarrier sequenceBarrier)
    {
        this.workerPool = workerPool;
        this.sequenceBarrier = sequenceBarrier;
    }

    @Override
    public Sequence[] getSequences()
    {
        return workerPool.getWorkerSequences();
    }

    @Override
    public SequenceBarrier getBarrier()
    {
        return sequenceBarrier;
    }

    @Override
    public boolean isEndOfChain()
    {
        return endOfChain;
    }

    @Override
    public void start(final Executor executor)
    {
        workerPool.start(executor);
    }

    @Override
    public void halt()
    {
        workerPool.halt();
    }

    @Override
    public void markAsUsedInBarrier()
    {
        endOfChain = false;
    }

    @Override
    public boolean isRunning()
    {
        return workerPool.isRunning();
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

/**
 * Callback interface to be implemented for processing units of work as they become available in the {@link RingBuffer}.
 *
 * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
 * @see WorkerPool
 */
public interface WorkHandler<T>
{
    /**
     * Callback to indicate a unit of work needs to be processed.
     *
     * @param event published to the {@link RingBuffer}
     * @throws Exception if the {@link WorkHandler} would like the exception handled further up the chain.
     */
    void onEvent(T event) throws Exception;
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;

import java.util.concurrent.atomic.AtomicBoolean;

/**
 * <p>A {@link WorkProcessor} wraps a single {@link WorkHandler}, effectively consuming the sequence
 * and ensuring appropriate barriers.</p>
 *
 * <p>Generally, this will be used as part of a {@link WorkerPool}.</p>
 *
 * @param <T> event implementation storing the details for the work to processed.
 */
public final class WorkProcessor<T>
    implements EventProcessor
{
    private final AtomicBoolean running = new AtomicBoolean(false);
    private final Sequence sequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
    private final RingBuffer<T> ringBuffer;
    private final SequenceBarrier sequenceBarrier;
    private final WorkHandler<? super T> workHandler;
    private final ExceptionHandler<? super T> exceptionHandler;
    private final Sequence workSequence;

    private final EventReleaser eventReleaser = new EventReleaser()
    {
        @Override
        public void release()
        {
            sequence.set(Long.MAX_VALUE);
        }
    };

    /**
     * Construct a {@link WorkProcessor}.
     *
     * @param ringBuffer to which events are published.
     * @param sequenceBarrier on which it is waiting.
     * @param workHandler is the delegate to which events are dispatched.
     * @param exceptionHandler to be called back when an error occurs
     * @param workSequence from which to claim the next event to be worked on.  It should always be initialised
     * as {@link Sequencer#INITIAL_CURSOR_VALUE}
     */
    public WorkProcessor(final RingBuffer<T> ringBuffer,
                         final SequenceBarrier sequenceBarrier,
                         final WorkHandler<? super T> workHandler,
                         final ExceptionHandler<? super T> exceptionHandler,
                         final Sequence workSequence)
    {
        this.ringBuffer = ringBuffer;
        this.sequenceBarrier = sequenceBarrier;
        this.workHandler = workHandler;
        this.exceptionHandler = exceptionHandler;
        this.workSequence = workSequence;

        if (this.workHandler instanceof EventReleaseAware)
        {
            ((EventReleaseAware)this.workHandler).setEventReleaser(eventReleaser);
        }
    }

    @Override
    public Sequence getSequence()
    {
        return sequence;
    }

    @Override
    public void halt()
    {
        running.set(false);
        sequenceBarrier.alert();
    }

    @Override
    public boolean isRunning()
    {
        return running.get();
    }

    /**
     * It is ok to have another thread re-run this method after a halt().
     *
     * @throws IllegalStateException if this processor is already running
     */
    @Override
    public void run()
    {
        if (!running.compareAndSet(false, true))
        {
            throw new IllegalStateException("Thread is already running");
        }
        sequenceBarrier.clearAlert();

        notifyStart();

        boolean processedSequence = true;
        long cachedAvailableSequence = Long.MIN_VALUE;
        long nextSequence = sequence.get();
        T event = null;
        while (true)
        {
            try
            {
                // if previous sequence was processed - fetch the next sequence and set
                // that we have successfully processed the previous sequence
                // typically, this will be true
                // this prevents the sequence getting too far forward if an exception
                // is thrown from the WorkHandler
                if (processedSequence)
                {
                    processedSequence = false;
                    do
                    {
                        nextSequence = workSequence.get() + 1L;
                        sequence.set(nextSequence - 1L);
                    }
                    while (!workSequence.compareAndSet(nextSequence - 1L, nextSequence));
                }

                if (cachedAvailableSequence >= nextSequence)
                {
                    event = ringBuffer.get(nextSequence);
                    workHandler.onEvent(event);
                    processedSequence = true;
                }
                else
                {
                    cachedAvailableSequence = sequenceBarrier.waitFor(nextSequence);
                }
            }
            catch (final AlertException ex)
            {
                if (!running.get())
                {
                    break;
                }
            }
            catch (final Throwable ex)
            {
                // handle, mark as processed, unless the exception handler threw an exception
                exceptionHandler.handleEventException(ex, nextSequence, event);
                processedSequence = true;
            }
        }

        notifyShutdown();

        running.set(false);
    }

    private void notifyStart()
    {
        if (workHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware)workHandler).onStart();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnStartException(ex);
            }
        }
    }

    private void notifyShutdown()
    {
        if (workHandler instanceof LifecycleAware)
        {
            try
            {
                ((LifecycleAware)workHandler).onShutdown();
            }
            catch (final Throwable ex)
            {
                exceptionHandler.handleOnShutdownException(ex);
            }
        }
    }
}
/*
 * Copyright 2011 LMAX Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.lmax.disruptor;


/**
 * Yielding strategy that uses a Thread.yield() for {@link com.lmax.disruptor.EventProcessor}s waiting on a barrier
 * after an initially spinning.
 *
 * This strategy is a good compromise between performance and CPU resource without incurring significant latency spikes.
 */
public final class YieldingWaitStrategy implements WaitStrategy
{
    private static final int SPIN_TRIES = 100;

    @Override
    public long waitFor(final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
        throws AlertException, InterruptedException
    {
        long availableSequence;
        int counter = SPIN_TRIES;

        while ((availableSequence = dependentSequence.get()) < sequence)
        {
            counter = applyWaitMethod(barrier, counter);
        }

        return availableSequence;
    }

    @Override
    public void signalAllWhenBlocking()
    {
    }

    private int applyWaitMethod(final SequenceBarrier barrier, int counter)
        throws AlertException
    {
        barrier.checkAlert();

        if (0 == counter)
        {
            Thread.yield();
        }
        else
        {
            --counter;
        }

        return counter;
    }
}
package geym.conc.ch2.stop;

public class YieldThread {
	volatile static int i=0;
	volatile static int j=0;
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(){
			@Override
			public void run(){
				while(true){
				    i++;
				    Thread.yield();
				}
			}
		};
		Thread t2=new Thread(){
			@Override
			public void run(){
				while(true){
					j++;
					Thread.yield();
				}
			}
		};
		t1.start();
		t2.start();
		Thread.sleep(2000);
		System.out.println("i="+i);
		System.out.println("j="+j);
		t1.stop();
		t2.stop();
	}
}


package geym.ch2.sync;

public class AccountingSync implements Runnable{
	static AccountingSync instance=new AccountingSync();
	static int i=0;
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			synchronized(instance){
				i++;
			}
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(instance);
		Thread t2=new Thread(instance);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.ch2.sync;


public class AccountingSync2 implements Runnable{
	static AccountingSync2 instance=new AccountingSync2();
	static int i=0;
	public synchronized void increase(){
		i++;
	}
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			increase();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(instance);
		Thread t2=new Thread(instance);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.ch2.sync;


public class AccountingSyncBad implements Runnable{
	static int i=0;
	public synchronized void increase(){
		i++;
	}
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			increase();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(new AccountingSyncBad());
		Thread t2=new Thread(new AccountingSyncBad());
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
package geym.ch2.sync;


public class AccountingSyncClass implements Runnable{
	static int i=0;
	public static synchronized void increase(){
		i++;
	}
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			increase();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		Thread t1=new Thread(new AccountingSyncClass());
		Thread t2=new Thread(new AccountingSyncClass());
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}

package geym.ch8;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class AIOEchoServer {
    public final static int PORT = 8000;
    private AsynchronousServerSocketChannel server;
    public AIOEchoServer() throws IOException {
        server = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(PORT));
    }

    public void start() throws InterruptedException, ExecutionException, TimeoutException {
        System.out.println("Server listen on " + PORT);
        //注册事件和事件完成后的处理器
        server.accept(null, new CompletionHandler<AsynchronousSocketChannel, Object>() {
            final ByteBuffer buffer = ByteBuffer.allocate(1024);
            public void completed(AsynchronousSocketChannel result, Object attachment) {
                System.out.println(Thread.currentThread().getName());
                Future<Integer> writeResult=null;
                try {
                    buffer.clear();
                    result.read(buffer).get(100, TimeUnit.SECONDS);
                    buffer.flip();
                    writeResult=result.write(buffer);
                } catch (InterruptedException | ExecutionException e) {
                    e.printStackTrace();
                } catch (TimeoutException e) {
                    e.printStackTrace();
                } finally {
                    try {
                        server.accept(null, this);
                        writeResult.get();
                        result.close();
                    } catch (Exception e) {
                        System.out.println(e.toString());
                    }
                }
            }

            @Override
            public void failed(Throwable exc, Object attachment) {
                System.out.println("failed: " + exc);
            }
        });
    }

    public static void main(String args[]) throws Exception {
        new AIOEchoServer().start();
        // 主线程可以继续自己的行为
        while (true) {
            Thread.sleep(1000);
        }
    }
}
package geym.ch4;

import java.util.concurrent.atomic.AtomicIntegerArray;

public class AtomicIntegerArrayDemo {
	static AtomicIntegerArray arr = new AtomicIntegerArray(10);
    public static class AddThread implements Runnable{
        public void run(){
           for(int k=0;k<100000;k++)
        	   arr.getAndIncrement(k%arr.length());
        }
    }
	public static void main(String[] args) throws InterruptedException {
        Thread[] ts=new Thread[10];
        for(int k=0;k<10;k++){
            ts[k]=new Thread(new AddThread());
        }
        for(int k=0;k<10;k++){ts[k].start();}
        for(int k=0;k<10;k++){ts[k].join();}
        System.out.println(arr);
	}
}
package geym.ch4;

import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerDemo {
    static AtomicInteger i=new AtomicInteger();
    public static class AddThread implements Runnable{
        public void run(){
           for(int k=0;k<10000;k++)
               i.incrementAndGet();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread[] ts=new Thread[10];
        for(int k=0;k<10;k++){
            ts[k]=new Thread(new AddThread());
        }
        for(int k=0;k<10;k++){ts[k].start();}
        for(int k=0;k<10;k++){ts[k].join();}
        System.out.println(i);
    }
}
package geym.ch4;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

public class AtomicIntegerFieldUpdaterDemo {
    public static class Candidate{
        int id;
        volatile int score;
    }
    public final static AtomicIntegerFieldUpdater<Candidate> scoreUpdater
        = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, "score");
    //检查Updater是否工作正确
    public static AtomicInteger allScore=new AtomicInteger(0);
    public static void main(String[] args) throws InterruptedException {
        final Candidate stu=new Candidate();
        Thread[] t=new Thread[10000];
        for(int i = 0 ; i < 10000 ; i++) {
            t[i]=new Thread() {
                public void run() {
                    if(Math.random()>0.4){
                        scoreUpdater.incrementAndGet(stu);
                        allScore.incrementAndGet();
                    }
                }
            };
            t[i].start();
        }
        for(int i = 0 ; i < 10000 ; i++) {  t[i].join();}
        System.out.println("score="+stu.score);
        System.out.println("allScore="+allScore);
    }
}

package geym.ch4;

import java.util.concurrent.atomic.AtomicReference;

public class AtomicReferenceTest {
    public final static AtomicReference<String> atomicStr = new AtomicReference<String>("abc");

    public static void main(String []args) {
        for(int i = 0 ; i < 10 ; i++) {
            final int num = i;
            new Thread() {
                public void run() {
                    try {
                        Thread.sleep(Math.abs((int)(Math.random() * 100)));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if(atomicStr.compareAndSet("abc", "def")) {
                        System.out.println("Thread:"+Thread.currentThread().getId()+" Change value to "+atomicStr);
                    } else{
                    	System.out.println("Thread:"+Thread.currentThread().getId()+" FAILED");
                    }
                }
            }.start();
        }
    }
}
package geym.ch4;

import java.util.concurrent.atomic.AtomicStampedReference;

public class AtomicStampedReferenceDemo {
	static AtomicStampedReference<Integer> money = new AtomicStampedReference<Integer>(19, 0);

	public static void main(String[] args) {
		// 模拟多个线程同时更新后台数据库，为用户充值
		for (int i = 0; i < 3; i++) {
			final int timestamp = money.getStamp();
			new Thread() {
				public void run() {
					while (true) {
						while (true) {
							Integer m = money.getReference();
							if (m < 20) {
								if (money.compareAndSet(m, m + 20, timestamp, timestamp + 1)) {
									System.out.println("余额小于20元，充值成功，余额:"
											+ money.getReference()+ "元");
									break;
								}
							} else {
								// System.out.println("余额大于20元，无需充值");
								break;
							}
						}
					}
				}
			}.start();
		}

		// 用户消费线程，模拟消费行为
		new Thread() {
			public void run() {
				for (int i = 0; i < 100; i++) {
					while (true) {
						int timestamp = money.getStamp();
						Integer m = money.getReference();
						if (m > 10) {
							System.out.println("大于10元");
							if (money.compareAndSet(m, m - 10, timestamp, timestamp + 1)) {
								System.out.println("成功消费10元，余额:" + money.getReference());
								break;
							}
						} else {
							System.out.println("没有足够的金额");
							break;
						}
					}
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
					}
				}
			}
		}.start();
	}
}
package geym.ch2;

public class BadSuspend {
	public static Object u = new Object();
	static ChangeObjectThread t1 = new ChangeObjectThread("t1");
	static ChangeObjectThread t2 = new ChangeObjectThread("t2");

	public static class ChangeObjectThread extends Thread {
		public ChangeObjectThread(String name){
			super.setName(name);
		}
		@Override
		public void run() {
			synchronized (u) {
				System.out.println("in "+getName());
				Thread.currentThread().suspend();
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		t1.start();
		Thread.sleep(100);
		t2.start();
		t1.resume();
		t2.resume();
		t1.join();
		t2.join();
	}
}
package geym.ch5;

import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapDemo {
public static void main(String[] args) {
    ConcurrentHashMap map=new ConcurrentHashMap();
    map.put("a", "aa");
}
}
package geym.ch5;

import java.util.Random;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CountDownLatchDemo implements Runnable {
    static final CountDownLatch end = new CountDownLatch(10);
    static final CountDownLatchDemo demo=new CountDownLatchDemo();
    @Override
    public void run() {
        try {
            //模拟检查任务
            Thread.sleep(new Random().nextInt(10)*1000);
            System.out.println("check complete");
            end.countDown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        ExecutorService exec = Executors.newFixedThreadPool(10);
        for(int i=0;i<10;i++){
            exec.submit(demo);
        }
        //等待检查
        end.await();
        //发射火箭
        System.out.println("Fire!");
        exec.shutdown();
    }
}

package geym.ch6.fork;

import java.util.ArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;

public class CountTask extends RecursiveTask<Long>{
    private static final int THRESHOLD = 10000;
    private long start;
    private long end;

    public CountTask(long start,long end){
        this.start=start;
        this.end=end;
    }

    public Long compute(){
        long sum=0;
        boolean canCompute = (end-start)<THRESHOLD;
        if(canCompute){
            for(long i=start;i<=end;i++){
                sum +=i;
            }
        }else{
            //分成100个小任务
            long step=(start+end)/100;
            ArrayList<CountTask> subTasks=new ArrayList<CountTask>();
            long pos=start;
            for(int i=0;i<100;i++){
                long lastOne=pos+step;
                if(lastOne>end)lastOne=end;
                CountTask subTask=new CountTask(pos,lastOne);
                pos+=step+1;
                subTasks.add(subTask);
                subTask.fork();
            }
            for(CountTask  t:subTasks){
                sum+=t.join();
            }
        }
        return sum;
    }

    public static void main(String[]args){
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        CountTask task = new CountTask(0,20000L);
        ForkJoinTask<Long> result = forkJoinPool.submit(task);
        try{
            long res = result.get();
            System.out.println("sum="+res);
        }catch(InterruptedException e){
            e.printStackTrace();
        }catch(ExecutionException e){
            e.printStackTrace();
        }
    }
}package geym.ch6.fork;

public class CountTaskOneThread {

    public static void main(String[] args) {
        long sum=0;
        for(long i=1;i<=2000000000L;i++){
            sum+=i;
        }
        System.out.println(sum);
    }

}
package geym.ch5;

import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierDemo {
    public static class Soldier implements Runnable {
        private String soldier;
        private final CyclicBarrier cyclic;

        Soldier(CyclicBarrier cyclic, String soldierName) {
            this.cyclic = cyclic;
            this.soldier = soldierName;
        }

        public void run() {
            try {
                //等待所有士兵到齐
                cyclic.await();
                doWork();
                //等待所有士兵完成工作
                cyclic.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }

        void doWork() {
            try {
                Thread.sleep(Math.abs(new Random().nextInt()%10000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(soldier + ":任务完成");
        }
    }

    public static class BarrierRun implements Runnable {
        boolean flag;
        int N;
        public BarrierRun(boolean flag, int N) {
            this.flag = flag;
            this.N = N;
        }

        public void run() {
            if (flag) {
                System.out.println("司令:[士兵" + N + "个，任务完成！]");
            } else {
                System.out.println("司令:[士兵" + N + "个，集合完毕！]");
                flag = true;
            }
        }
    }

    public static void main(String args[]) throws InterruptedException {
        final int N = 10;
        Thread[] allSoldier=new Thread[N];
        boolean flag = false;
        CyclicBarrier cyclic = new CyclicBarrier(N, new BarrierRun(flag, N));
        //设置屏障点，主要是为了执行这个方法
        System.out.println("集合队伍！");
        for (int i = 0; i < N; ++i) {
            System.out.println("士兵 "+i+" 报道！");
            allSoldier[i]=new Thread(new Soldier(cyclic, "士兵 " + i));
            allSoldier[i].start();
            if(i==5){
             	allSoldier[0].interrupt();
             }
        }
    }
}

package geym.ch2;

public class DaemonDemo {
    public static class DaemonT extends Thread{
        public void run(){
            while(true){
                System.out.println("I am alive");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread t=new DaemonT();
        t.setDaemon(true);
        t.start();

//        Thread.sleep(2000);
    }
}
package geym.ch10;

import java.util.concurrent.locks.ReentrantLock;

public class DeadLockCar extends Thread{
	protected Object myDirect;
	static ReentrantLock south = new ReentrantLock();
	static ReentrantLock north = new ReentrantLock();
	static ReentrantLock west = new ReentrantLock();
	static ReentrantLock east = new ReentrantLock();

	public DeadLockCar(Object obj){
		this.myDirect=obj;
		if(myDirect==south){
			this.setName("south");
		}
		if(myDirect==north){
			this.setName("north");
		}
		if(myDirect==west){
			this.setName("west");
		}
		if(myDirect==east){
			this.setName("east");
		}
	}
	@Override
	public void run() {
		if (myDirect == south) {
			try {
				west.lockInterruptibly();
				try {
					Thread.sleep(500);
				} catch (Exception e) {
					e.printStackTrace();
				}
				south.lockInterruptibly();
				System.out.println("car to south has passed");
			} catch (InterruptedException e1) {
				System.out.println("car to south is killed");
			}finally{
				if(west.isHeldByCurrentThread())
					west.unlock();
				if(south.isHeldByCurrentThread())
					south.unlock();
			}

		}
		if (myDirect == north) {
			try {
				east.lockInterruptibly();
				try {
					Thread.sleep(500);
				} catch (Exception e) {
					e.printStackTrace();
				}
				north.lockInterruptibly();
				System.out.println("car to north has passed");
			} catch (InterruptedException e1) {
				System.out.println("car to north is killed");
			}finally{
				if(north.isHeldByCurrentThread())
					north.unlock();
				if(east.isHeldByCurrentThread())
					east.unlock();
			}

		}
		if (myDirect == west) {
			try {
				north.lockInterruptibly();
				try {
					Thread.sleep(500);
				} catch (Exception e) {
					e.printStackTrace();
				}
				west.lockInterruptibly();
				System.out.println("car to west has passed");
			} catch (InterruptedException e1) {
				System.out.println("car to west is killed");
			}finally{
				if(north.isHeldByCurrentThread())
					north.unlock();
				if(west.isHeldByCurrentThread())
					west.unlock();
			}

		}
		if (myDirect == east) {
			try {
				south.lockInterruptibly();
				try {
					Thread.sleep(500);
				} catch (Exception e) {
					e.printStackTrace();
				}
				east.lockInterruptibly();
				System.out.println("car to east has passed");
			} catch (InterruptedException e1) {
				System.out.println("car to east is killed");
			}finally{
				if(south.isHeldByCurrentThread())
					south.unlock();
				if(east.isHeldByCurrentThread())
					east.unlock();
			}

		}
	}

	public static void main(String[] args) throws InterruptedException {
		DeadLockCar car2south = new DeadLockCar(south);
		DeadLockCar car2north = new DeadLockCar(north);
		DeadLockCar car2west = new DeadLockCar(west);
		DeadLockCar car2east = new DeadLockCar(east);
		car2south.start();
		car2north.start();
		car2west.start();
		car2east.start();
		Thread.sleep(1000);
//		car2north.interrupt();
	}
}package geym.ch5.deadlock;

import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class DeadlockChecker {
	private final static ThreadMXBean mbean = ManagementFactory.getThreadMXBean();
	final static Runnable deadlockCheck = new Runnable() {
		@Override
		public void run() {
			while (true) {
				long[] deadlockedThreadIds = mbean.findDeadlockedThreads();
				if (deadlockedThreadIds != null) {
					ThreadInfo[] threadInfos = mbean.getThreadInfo(deadlockedThreadIds);
					for (Thread t : Thread.getAllStackTraces().keySet()) {
						for (int i = 0; i < threadInfos.length; i++) {
							if (t.getId() == threadInfos[i].getThreadId()) {
								t.interrupt();
							}
						}
					}
				}
				try {
					Thread.sleep(5000);
				} catch (InterruptedException e) {
				}
			}
		}
	};

	public static void check() {
		Thread t = new Thread(deadlockCheck);
		t.setDaemon(true);
		t.start();
	}
}

package geym.ch6;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ExtThreadPool {
    public static class MyTask implements Runnable {
        public String name;

        public MyTask(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            System.out.println("正在执行" + ":Thread ID:" + Thread.currentThread().getId()
                    + ",Task Name=" + name);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {

        ExecutorService es = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>()) {
            @Override
            protected void beforeExecute(Thread t, Runnable r) {
                System.out.println("准备执行：" + ((MyTask) r).name);
            }

            @Override
            protected void afterExecute(Runnable r, Throwable t) {
                System.out.println("执行完成：" + ((MyTask) r).name);
            }

            @Override
            protected void terminated() {
                System.out.println("线程池退出");
            }

        };
        for (int i = 0; i < 5; i++) {
            MyTask task = new MyTask("TASK-GEYM-" + i);
            es.execute(task);
            Thread.sleep(10);
        }
        es.shutdown();
    }
}
package geym.ch7;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;

public class FutureMain {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        //构造FutureTask
        FutureTask<String> future = new FutureTask<String>(new RealData("a"));
        ExecutorService executor = Executors.newFixedThreadPool(1);
        //执行FutureTask，相当于上例中的 client.request("a") 发送请求
        //在这里开启线程进行RealData的call()执行
        executor.submit(future);

        System.out.println("请求完毕");
        try {
        //这里依然可以做额外的数据操作，这里使用sleep代替其他业务逻辑的处理
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
        //相当于data.getResult ()，取得call()方法的返回值
        //如果此时call()方法没有执行完成，则依然会等待
        System.out.println("数据 = " + future.get());
    }
}
package geym.ch7;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class FutureMain2 {
    public static void main(String[] args) throws InterruptedException, ExecutionException {

        ExecutorService executor = Executors.newFixedThreadPool(1);
        //执行FutureTask，相当于上例中的 client.request("a") 发送请求
        //在这里开启线程进行RealData的call()执行
        Future<String> future=executor.submit(new RealData("a"));

        System.out.println("请求完毕");
        try {
        //这里依然可以做额外的数据操作，这里使用sleep代替其他业务逻辑的处理
            Thread.sleep(2000);
        } catch (InterruptedException e) {
        }
        //相当于data.getResult ()，取得call()方法的返回值
        //如果此时call()方法没有执行完成，则依然会等待
        System.out.println("数据 = " + future.get());
    }
}

package geym.ch8;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.LockSupport;

public class HeavySocketClient {
	private static ExecutorService  tp=Executors.newCachedThreadPool();
	private static final int sleep_time=1000*1000*1000;
	public static class EchoClient implements Runnable{
		public void run(){
	        Socket client = null;
	        PrintWriter writer = null;
	        BufferedReader reader = null;
	        try {
	            client = new Socket();
	            client.connect(new InetSocketAddress("localhost", 8000));
	            writer = new PrintWriter(client.getOutputStream(), true);
	            writer.print("H");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("e");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("l");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("l");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("o");
	            LockSupport.parkNanos(sleep_time);
	            writer.print("!");
	            LockSupport.parkNanos(sleep_time);
	            writer.println();
	            writer.flush();

	            reader = new BufferedReader(new InputStreamReader(client.getInputStream()));
	            System.out.println("from server: " + reader.readLine());
	        } catch (UnknownHostException e) {
	            e.printStackTrace();
	        } catch (IOException e) {
	            e.printStackTrace();
	        } finally {
	            try {
					if (writer != null)
					    writer.close();
					if (reader != null)
					    reader.close();
					if (client != null)
					    client.close();
				} catch (IOException e) {
				}
	        }
		}
	}
    public static void main(String[] args) throws IOException {
    	EchoClient ec=new EchoClient();
    	for(int i=0;i<10;i++)
    		tp.execute(ec);
    }
}
package geym.ch9;

public class IntegerLock {
	static Integer i=0;
	public static class AddThread extends Thread{
		public void run(){
			for(int k=0;k<100000;k++){
				synchronized(i){
					i++;
				}
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		AddThread t1=new AddThread();
		AddThread t2=new AddThread();
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}
/*
 * Copyright (c) 2007 IBM Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * COME FROM org.amino.ds.lockfree
 */

package geym.ch4;

import java.util.AbstractList;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;

/**
 * It is a thread safe and lock-free vector.
 * This class implement algorithm from:<br>
 *
 * Lock-free Dynamically Resizable Arrays <br>
 *
 * Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup<br>
 * Texas A&M University College Station, TX 77843-3112<br>
 * {dechev, peter.pirkelbauer}@tamu.edu, bs@cs.tamu.edu
 *
 *
 * @author Zhi Gan
 *
 * @param <E> type of element in the vector
 *
 */
public class LockFreeVector<E> extends AbstractList<E> {
	private static final boolean debug = false;
	/**
	 * Size of the first bucket. sizeof(bucket[i+1])=2*sizeof(bucket[i])
	 */
	private static final int FIRST_BUCKET_SIZE = 8;

	/**
	 * number of buckets. 30 will allow 8*(2^30-1) elements
	 */
	private static final int N_BUCKET = 30;

	/**
	 * We will have at most N_BUCKET number of buckets. And we have
	 * sizeof(buckets.get(i))=FIRST_BUCKET_SIZE**(i+1)
	 */
	private final AtomicReferenceArray<AtomicReferenceArray<E>> buckets;

	/**
	 * @author ganzhi
	 *
	 * @param <E>
	 */
	static class WriteDescriptor<E> {
		public E oldV;
		public E newV;
		public AtomicReferenceArray<E> addr;
		public int addr_ind;

		/**
		 * Creating a new descriptor.
		 *
		 * @param addr Operation address
		 * @param addr_ind	Index of address
		 * @param oldV old operand
		 * @param newV new operand
		 */
		public WriteDescriptor(AtomicReferenceArray<E> addr, int addr_ind,
				E oldV, E newV) {
			this.addr = addr;
			this.addr_ind = addr_ind;
			this.oldV = oldV;
			this.newV = newV;
		}

		/**
		 * set newV.
		 */
		public void doIt() {
			addr.compareAndSet(addr_ind, oldV, newV);
		}
	}

	/**
	 * @author ganzhi
	 *
	 * @param <E>
	 */
	static class Descriptor<E> {
		public int size;
		volatile WriteDescriptor<E> writeop;

		/**
		 * Create a new descriptor.
		 *
		 * @param size Size of the vector
		 * @param writeop Executor write operation
		 */
		public Descriptor(int size, WriteDescriptor<E> writeop) {
			this.size = size;
			this.writeop = writeop;
		}

		/**
		 *
		 */
		public void completeWrite() {
			WriteDescriptor<E> tmpOp = writeop;
			if (tmpOp != null) {
				tmpOp.doIt();
				writeop = null; // this is safe since all write to writeop use
				// null as r_value.
			}
		}
	}

	private AtomicReference<Descriptor<E>> descriptor;
	private static final int zeroNumFirst = Integer
			.numberOfLeadingZeros(FIRST_BUCKET_SIZE);;

	/**
	 * Constructor.
	 */
	public LockFreeVector() {
		buckets = new AtomicReferenceArray<AtomicReferenceArray<E>>(N_BUCKET);
		buckets.set(0, new AtomicReferenceArray<E>(FIRST_BUCKET_SIZE));
		descriptor = new AtomicReference<Descriptor<E>>(new Descriptor<E>(0,
				null));
	}

	/**
	 * add e at the end of vector.
	 *
	 * @param e
	 *            element added
	 */
	public void push_back(E e) {
		Descriptor<E> desc;
		Descriptor<E> newd;
		do {
			desc = descriptor.get();
			desc.completeWrite();

			int pos = desc.size + FIRST_BUCKET_SIZE;
			int zeroNumPos = Integer.numberOfLeadingZeros(pos);
			int bucketInd = zeroNumFirst - zeroNumPos;
			if (buckets.get(bucketInd) == null) {
				int newLen = 2 * buckets.get(bucketInd - 1).length();
				if (debug)
					System.out.println("New Length is:" + newLen);
				buckets.compareAndSet(bucketInd, null,
						new AtomicReferenceArray<E>(newLen));
			}

			int idx = (0x80000000>>>zeroNumPos) ^ pos;
			newd = new Descriptor<E>(desc.size + 1, new WriteDescriptor<E>(
					buckets.get(bucketInd), idx, null, e));
		} while (!descriptor.compareAndSet(desc, newd));
		descriptor.get().completeWrite();
	}

	/**
	 * Remove the last element in the vector.
	 *
	 * @return element removed
	 */
	public E pop_back() {
		Descriptor<E> desc;
		Descriptor<E> newd;
		E elem;
		do {
			desc = descriptor.get();
			desc.completeWrite();

			int pos = desc.size + FIRST_BUCKET_SIZE - 1;
			int bucketInd = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
					- Integer.numberOfLeadingZeros(pos);
			int idx = Integer.highestOneBit(pos) ^ pos;
			elem = buckets.get(bucketInd).get(idx);
			newd = new Descriptor<E>(desc.size - 1, null);
		} while (!descriptor.compareAndSet(desc, newd));

		return elem;
	}

	/**
	 * Get element with the index.
	 *
	 * @param index
	 *            index
	 * @return element with the index
	 */
	@Override
	public E get(int index) {
		int pos = index + FIRST_BUCKET_SIZE;
		int zeroNumPos = Integer.numberOfLeadingZeros(pos);
		int bucketInd = zeroNumFirst - zeroNumPos;
		int idx = (0x80000000>>>zeroNumPos) ^ pos;
		return buckets.get(bucketInd).get(idx);
	}

	/**
	 * Set the element with index to e.
	 *
	 * @param index
	 *            index of element to be reset
	 * @param e
	 *            element to set
	 */
	/**
	  * {@inheritDoc}
	  */
	public E set(int index, E e) {
		int pos = index + FIRST_BUCKET_SIZE;
		int bucketInd = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
				- Integer.numberOfLeadingZeros(pos);
		int idx = Integer.highestOneBit(pos) ^ pos;
		AtomicReferenceArray<E> bucket = buckets.get(bucketInd);
		while (true) {
			E oldV = bucket.get(idx);
			if (bucket.compareAndSet(idx, oldV, e))
				return oldV;
		}
	}

	/**
	 * reserve more space.
	 *
	 * @param newSize
	 *            new size be reserved
	 */
	public void reserve(int newSize) {
		int size = descriptor.get().size;
		int pos = size + FIRST_BUCKET_SIZE - 1;
		int i = Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
				- Integer.numberOfLeadingZeros(pos);
		if (i < 1)
			i = 1;

		int initialSize = buckets.get(i - 1).length();
		while (i < Integer.numberOfLeadingZeros(FIRST_BUCKET_SIZE)
				- Integer.numberOfLeadingZeros(newSize + FIRST_BUCKET_SIZE - 1)) {
			i++;
			initialSize *= FIRST_BUCKET_SIZE;
			buckets.compareAndSet(i, null, new AtomicReferenceArray<E>(
					initialSize));
		}
	}

	/**
	 * size of vector.
	 *
	 * @return size of vector
	 */
	public int size() {
		return descriptor.get().size;
	}

	/**
	  * {@inheritDoc}
	  */
	@Override
	public boolean add(E object) {
		push_back(object);
		return true;
	}
}
package geym.ch5;

import java.util.concurrent.locks.LockSupport;

public class LockSupportDemo {
	public static Object u = new Object();
	static ChangeObjectThread t1 = new ChangeObjectThread("t1");
	static ChangeObjectThread t2 = new ChangeObjectThread("t2");

	public static class ChangeObjectThread extends Thread {
		public ChangeObjectThread(String name){
			super.setName(name);
		}
		@Override
		public void run() {
			synchronized (u) {
				System.out.println("in "+getName());
				LockSupport.park();
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		t1.start();
		Thread.sleep(100);
		t2.start();
		LockSupport.unpark(t1);
		LockSupport.unpark(t2);
		t1.join();
		t2.join();
	}
}
package geym.ch10;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAdder;

public class LongAdderDemo {
	private static final int MAX_THREADS = 3;				   //线程数
	private static final int TASK_COUNT = 3;				   //任务数
	private static final int TARGET_COUNT = 10000000;		   //目标总数

	private AtomicLong acount =new AtomicLong(0L);			//无锁的原子操作
	private LongAdder lacount=new LongAdder();
	private long count=0;

	static CountDownLatch cdlsync=new CountDownLatch(TASK_COUNT);
	static CountDownLatch cdlatomic=new CountDownLatch(TASK_COUNT);
	static CountDownLatch cdladdr=new CountDownLatch(TASK_COUNT);

	protected synchronized long inc(){							//有锁的加法
		return ++count;
	}

	protected synchronized long getCount(){						//有锁的操作
		return count;
	}

	public class SyncThread implements Runnable{
		protected String name;
		protected long starttime;
		LongAdderDemo out;
		public SyncThread(LongAdderDemo o,long starttime){
			out=o;
			this.starttime=starttime;
		}
		@Override
		public void run() {
			long v=out.getCount();
			while(v<TARGET_COUNT){						//在到达目标值前，不停循环
				v=out.inc();
			}
			long endtime=System.currentTimeMillis();
			System.out.println("SyncThread spend:"+(endtime-starttime)+"ms"+" v="+v);
			cdlsync.countDown();
		}
	}

	public void testSync() throws InterruptedException{
		ExecutorService exe=Executors.newFixedThreadPool(MAX_THREADS);
		long starttime=System.currentTimeMillis();
		SyncThread sync=new SyncThread(this,starttime);
		for(int i=0;i<TASK_COUNT;i++){
			exe.submit(sync); 								//提交线程开始计算
		}
		cdlsync.await();
		exe.shutdown();
	}
	public class AtomicThread implements Runnable{
		protected String name;
		protected long starttime;
		public AtomicThread(long starttime){
			this.starttime=starttime;
		}
		@Override
		public void run() {									//在到达目标值前，不停循环
			long v=acount.get();
			while(v<TARGET_COUNT){
				v=acount.incrementAndGet();					//无锁的加法
			}
			long endtime=System.currentTimeMillis();
			System.out.println("AtomicThread spend:"+(endtime-starttime)+"ms"+" v="+v);
			cdlatomic.countDown();
		}
	}

	public void testAtomic() throws InterruptedException{
		ExecutorService exe=Executors.newFixedThreadPool(MAX_THREADS);
		long starttime=System.currentTimeMillis();
		AtomicThread atomic=new AtomicThread(starttime);
		for(int i=0;i<TASK_COUNT;i++){
			exe.submit(atomic);								//提交线程开始计算
		}
		cdlatomic.await();
		exe.shutdown();
	}

	public class LongAddrThread implements Runnable{
		protected String name;
		protected long starttime;
		public LongAddrThread(long starttime){
			this.starttime=starttime;
		}
		@Override
		public void run() {
			long v=lacount.sum();
			while(v<TARGET_COUNT){
				lacount.increment();
				v=lacount.sum();
			}
			long endtime=System.currentTimeMillis();
			System.out.println("LongAdder spend:"+(endtime-starttime)+"ms"+" v="+v);
			cdladdr.countDown();
		}
	}

	public void testAtomicLong() throws InterruptedException{
		ExecutorService exe=Executors.newFixedThreadPool(MAX_THREADS);
		long starttime=System.currentTimeMillis();
		LongAddrThread atomic=new LongAddrThread(starttime);
		for(int i=0;i<TASK_COUNT;i++){
			exe.submit(atomic);								//提交线程开始计算
		}
		cdladdr.await();
		exe.shutdown();
	}

	public static void main(String args[]) throws InterruptedException{
		LongAdderDemo a=new LongAdderDemo();
		a.testSync();
		a.testAtomic();
		a.testAtomicLong();
	}
}
package geym.ch8;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultiThreadEchoServer {
    private static ExecutorService  tp=Executors.newCachedThreadPool();
    static class HandleMsg implements Runnable{
        Socket clientSocket;
        public HandleMsg(Socket clientSocket){
            this.clientSocket=clientSocket;
        }

        public void run(){
            BufferedReader is =null;
            PrintWriter os = null;
            try {

        is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                os = new PrintWriter(clientSocket.getOutputStream(), true);
                // 从InputStream当中读取客户端所发送的数据
                String inputLine = null;
                long b=System.currentTimeMillis();
                while ((inputLine = is.readLine()) != null) {
                    os.println(inputLine);
                }
                long e=System.currentTimeMillis();
                System.out.println("spend:"+(e-b)+"ms");
            } catch (IOException e) {
                e.printStackTrace();
            }finally{
                try {
                    if(is!=null)is.close();
                    if(os!=null)os.close();
                    clientSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    public static void main(String args[]) {
        ServerSocket echoServer = null;
        Socket clientSocket = null;
        try {
            echoServer = new ServerSocket(8000);
        } catch (IOException e) {
            System.out.println(e);
        }
        while (true) {
            try {
                clientSocket = echoServer.accept();
                System.out.println(clientSocket.getRemoteSocketAddress() + " connect!");
                tp.execute(new HandleMsg(clientSocket));
            } catch (IOException e) {
                System.out.println(e);
            }
        }
    }
}


package geym.ch8;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultiThreadNIOEchoServer {
	public static Map<Socket,Long> geym_time_stat=new HashMap<Socket,Long>(10240);
    class EchoClient {
        private LinkedList<ByteBuffer> outq;

        EchoClient() {
            outq = new LinkedList<ByteBuffer>();
        }

        // Return the output queue.
        public LinkedList<ByteBuffer> getOutputQueue() {
            return outq;
        }

        // Enqueue a ByteBuffer on the output queue.
        public void enqueue(ByteBuffer bb) {
            outq.addFirst(bb);
        }
    }

    class HandleMsg implements Runnable{
        SelectionKey sk;
        ByteBuffer bb;
        public HandleMsg(SelectionKey sk,ByteBuffer bb){
            this.sk=sk;
            this.bb=bb;
        }
        @Override
        public void run() {
            EchoClient echoClient = (EchoClient) sk.attachment();
            echoClient.enqueue(bb);

            // We've enqueued data to be written to the client, we must
            // not set interest in OP_WRITE.
            sk.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
            //强迫selector立即返回
            selector.wakeup();
        }
    }

    private Selector selector;
    private ExecutorService  tp=Executors.newCachedThreadPool();
    /**
     * Accept a new client and set it up for reading.
     */
    private void doAccept(SelectionKey sk) {
        ServerSocketChannel server = (ServerSocketChannel) sk.channel();
        SocketChannel clientChannel;
        try {
            clientChannel = server.accept();
            clientChannel.configureBlocking(false);

            // Register this channel for reading.
            SelectionKey clientKey = clientChannel.register(selector, SelectionKey.OP_READ);
            // Allocate an EchoClient instance and attach it to this selection key.
            EchoClient echoClient = new EchoClient();
            clientKey.attach(echoClient);

            InetAddress clientAddress = clientChannel.socket().getInetAddress();
            System.out.println("Accepted connection from " + clientAddress.getHostAddress() + ".");
        } catch (Exception e) {
            System.out.println("Failed to accept new client.");
            e.printStackTrace();
        }
    }

    /**
     * Read from a client. Enqueue the data on the clients output
     * queue and set the selector to notify on OP_WRITE.
     */
    private void doRead(SelectionKey sk) {
        SocketChannel channel = (SocketChannel) sk.channel();
        ByteBuffer bb = ByteBuffer.allocate(8192);
        int len;

        try {
            len = channel.read(bb);
            if (len < 0) {
                disconnect(sk);
                return;
            }
        } catch (Exception e) {
            System.out.println("Failed to read from client.");
            e.printStackTrace();
            disconnect(sk);
            return;
        }

        // Flip the buffer.
        bb.flip();
        tp.execute(new HandleMsg(sk,bb));
    }

    /**
     * Called when a SelectionKey is ready for writing.
     */
    private void doWrite(SelectionKey sk) {
        SocketChannel channel = (SocketChannel) sk.channel();
        EchoClient echoClient = (EchoClient) sk.attachment();
        LinkedList<ByteBuffer> outq = echoClient.getOutputQueue();

        ByteBuffer bb = outq.getLast();
        try {
            int len = channel.write(bb);
            if (len == -1) {
                disconnect(sk);
                return;
            }

            if (bb.remaining() == 0) {
                // The buffer was completely written, remove it.
                outq.removeLast();
            }
        } catch (Exception e) {
            System.out.println("Failed to write to client.");
            e.printStackTrace();
            disconnect(sk);
        }

        // If there is no more data to be written, remove interest in
        // OP_WRITE.
        if (outq.size() == 0) {
            sk.interestOps(SelectionKey.OP_READ);
        }
    }

    private void disconnect(SelectionKey sk) {
        SocketChannel channel = (SocketChannel) sk.channel();

        InetAddress clientAddress = channel.socket().getInetAddress();
        System.out.println(clientAddress.getHostAddress() + " disconnected.");

        try {
            channel.close();
        } catch (Exception e) {
            System.out.println("Failed to close client socket channel.");
            e.printStackTrace();
        }
    }

    private void startServer() throws Exception {
        selector = SelectorProvider.provider().openSelector();

        // Create non-blocking server socket.
        ServerSocketChannel ssc = ServerSocketChannel.open();
        ssc.configureBlocking(false);

        // Bind the server socket to localhost.
//        InetSocketAddress isa = new InetSocketAddress(InetAddress.getLocalHost(), 8000);
        InetSocketAddress isa = new InetSocketAddress(8000);
        ssc.socket().bind(isa);

        // Register the socket for select events.
        SelectionKey acceptKey = ssc.register(selector, SelectionKey.OP_ACCEPT);

        // Loop forever.
        for (;;) {
             selector.select();
//            if(selector.selectNow()==0){
//                continue;
//            }
            Set readyKeys = selector.selectedKeys();
            Iterator i = readyKeys.iterator();
            long e=0;
            while (i.hasNext()) {
                SelectionKey sk = (SelectionKey) i.next();
                i.remove();

                if (sk.isAcceptable()) {
                    doAccept(sk);
                }
                else if (sk.isValid() && sk.isReadable()) {
                	if(!geym_time_stat.containsKey(((SocketChannel)sk.channel()).socket()))
                		geym_time_stat.put(((SocketChannel)sk.channel()).socket(),
                			System.currentTimeMillis());
                    doRead(sk);
                }
                else if (sk.isValid() && sk.isWritable()) {
                    doWrite(sk);
                    e=System.currentTimeMillis();
                    long b=geym_time_stat.remove(((SocketChannel)sk.channel()).socket());
                    System.out.println("spend:"+(e-b)+"ms");
                }
            }
        }
    }

    // Main entry point.
    public static void main(String[] args) {
        MultiThreadNIOEchoServer echoServer = new MultiThreadNIOEchoServer();
        try {
            echoServer.startServer();
        } catch (Exception e) {
            System.out.println("Exception caught, program exiting...");
            e.printStackTrace();
        }
    }
}
package geym.ch2;


public class PriorityDemo {
    public static class HightPriority extends Thread{
        static int count=0;
        public void run(){
            while(true){
                synchronized(PriorityDemo.class){
                    count++;
                    if(count>10000000){
                        System.out.println("HightPriority is complete");
                        break;
                    }
                }
            }
        }
    }
    public static class LowPriority extends Thread{
        static int count=0;
        public void run(){
            while(true){
                synchronized(PriorityDemo.class){
                    count++;
                    if(count>10000000){
                        System.out.println("LowPriority is complete");
                        break;
                    }
                }
            }
        }
    }

    /**
     * HightPriority先完成的次数多，但是 不保证
     *
     * @param args
     * @throws InterruptedException
     */
    public static void main(String[] args) throws InterruptedException {
        Thread high=new HightPriority();
        LowPriority low=new LowPriority();
        high.setPriority(Thread.MIN_PRIORITY);
        low.setPriority(Thread.MAX_PRIORITY);
        low.start();
        high.start();
    }
}
package geym.ch7;

import java.util.concurrent.Callable;

public class RealData implements Callable<String> {
    private String para;
    public RealData(String para){
        this.para=para;
    }
    @Override
    public String call() throws Exception {

        StringBuffer sb=new StringBuffer();
        for (int i = 0; i < 10; i++) {
            sb.append(para);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        return sb.toString();
    }
}

package geym.ch5;

import java.util.concurrent.locks.ReentrantLock;

public class ReenterLock implements Runnable{
	public static ReentrantLock lock=new ReentrantLock();
	public static int i=0;
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			lock.lock();
			try{
				i++;
			}finally{
				lock.unlock();
			}
		}
	}
	public static void main(String[] args) throws InterruptedException {
		ReenterLock tl=new ReenterLock();
		Thread t1=new Thread(tl);
		Thread t2=new Thread(tl);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}

package geym.ch5;

import java.util.concurrent.locks.ReentrantLock;

public class ReenterLock2 implements Runnable{
	public static ReentrantLock lock=new ReentrantLock();
	public static int i=0;
	@Override
	public void run() {
		for(int j=0;j<10000000;j++){
			lock.lock();
			lock.lock();
			try{
				i++;
			}finally{
				lock.unlock();
				lock.unlock();
			}
		}
	}
	public static void main(String[] args) throws InterruptedException {
		ReenterLock2 tl=new ReenterLock2();
		Thread t1=new Thread(tl);
		Thread t2=new Thread(tl);
		t1.start();t2.start();
		t1.join();t2.join();
		System.out.println(i);
	}
}

package geym.ch5;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ReenterLockCondition implements Runnable{
	public static ReentrantLock lock=new ReentrantLock();
	public static Condition condition = lock.newCondition();
	@Override
	public void run() {
		try {
			lock.lock();
			condition.await();
			System.out.println("Thread is going on");
		} catch (InterruptedException e) {
			e.printStackTrace();
		}finally{
			lock.unlock();
		}
	}
	public static void main(String[] args) throws InterruptedException {
		ReenterLockCondition tl=new ReenterLockCondition();
		Thread t1=new Thread(tl);
		t1.start();
		Thread.sleep(2000);
		//通知线程t1继续执行
		lock.lock();
		condition.signal();
		lock.unlock();
	}
}

package geym.ch5;

import geym.ch5.deadlock.DeadlockChecker;

import java.util.concurrent.locks.ReentrantLock;

public class ReenterLockInt implements Runnable {
	public static ReentrantLock lock1 = new ReentrantLock();
	public static ReentrantLock lock2 = new ReentrantLock();
	int lock;
	/**
	 * 控制加锁顺序，方便构造死锁
	 * @param lock
	 */
	public ReenterLockInt(int lock) {
		this.lock = lock;
	}

	@Override
	public void run() {
		try {
			if (lock == 1) {
				lock1.lockInterruptibly();
				try{
					Thread.sleep(500);
				}catch(InterruptedException e){}
				lock2.lockInterruptibly();
			} else {
				lock2.lockInterruptibly();
				try{
					Thread.sleep(500);
				}catch(InterruptedException e){}
				lock1.lockInterruptibly();
			}

		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			if (lock1.isHeldByCurrentThread())
				lock1.unlock();
			if (lock2.isHeldByCurrentThread())
				lock2.unlock();
			System.out.println(Thread.currentThread().getId()+":线程退出");
		}
	}

	public static void main(String[] args) throws InterruptedException {
		ReenterLockInt r1 = new ReenterLockInt(1);
		ReenterLockInt r2 = new ReenterLockInt(2);
		Thread t1 = new Thread(r1);
		Thread t2 = new Thread(r2);
		t1.start();t2.start();
		Thread.sleep(1000);
		//中断其中一个线程
		DeadlockChecker.check();
	}
}

package geym.ch6;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class RejectThreadPoolDemo {
	public static class MyTask implements Runnable {
		@Override
		public void run() {
			System.out.println(System.currentTimeMillis() + ":Thread ID:"
					+ Thread.currentThread().getId());
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		MyTask task = new MyTask();
		ExecutorService es = new ThreadPoolExecutor(5, 5,
                0L, TimeUnit.MILLISECONDS,
                new SynchronousQueue<Runnable>(),
                Executors.defaultThreadFactory(),
                new RejectedExecutionHandler(){
					@Override
					public void rejectedExecution(Runnable r,
							ThreadPoolExecutor executor) {
						System.out.println(r.toString()+" is discard");
					}
		});
		for (int i = 0; i < Integer.MAX_VALUE; i++) {
			es.submit(task);
			Thread.sleep(10);
		}
	}
}

package geym.ch6;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledExecutorServiceDemo {
    public static void main(String[] args) {
        ScheduledExecutorService ses=Executors.newScheduledThreadPool(10);
        //如果前面的任务没有完成，则调度也不会启动
        ses.scheduleWithFixedDelay(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                    System.out.println(System.currentTimeMillis()/1000);
//                    if(System.currentTimeMillis()%2==0){
//                    	System.out.println("exception");
//                    	throw new RuntimeException();
//                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, 0, 2, TimeUnit.SECONDS);

    }
}
package geym.ch5;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class SemapDemo implements Runnable{
    final Semaphore semp = new Semaphore(5);
    @Override
    public void run() {
        try {
            semp.acquire();
            //模拟耗时操作
            Thread.sleep(2000);
            System.out.println(Thread.currentThread().getId()+":done!");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally{
        	semp.release();
        }
    }

    public static void main(String[] args) {
        ExecutorService exec = Executors.newFixedThreadPool(20);
        final SemapDemo demo=new SemapDemo();
        for(int i=0;i<20;i++){
            exec.submit(demo);
        }
    }
}

package geym.ch2;



public class SimpleWN {
	final static Object object = new Object();
	public static class T1 extends Thread{
        public void run()
        {
            synchronized (object) {
                System.out.println(System.currentTimeMillis()+":T1 start! ");
                try {
                	System.out.println(System.currentTimeMillis()+":T1 wait for object ");
                	object.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(System.currentTimeMillis()+":T1 end!");
            }
        }
	}
	public static class T2 extends Thread{
        public void run()
        {
            synchronized (object) {
                System.out.println(System.currentTimeMillis()+":T2 start! notify one thread");
                object.notify();
                System.out.println(System.currentTimeMillis()+":T2 end!");
                try {
					Thread.sleep(2000);
				} catch (InterruptedException e) {
				}
            }
        }
	}
	public static void main(String[] args) {
        Thread t1 = new T1() ;
        Thread t2 = new T2() ;
//        Thread t1_1 = new T1() ;
//        t1_1.start();
        t1.start();
        t2.start();
	}
}
package geym.ch2;

public class SimpleWNA {
	final static Object object = new Object();
	public static class T1 extends Thread{
        public void run()
        {
            synchronized (object) {
                System.out.println("T1 start! wait on object");
                try {
                    object.wait();
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("T1 end!");
            }
        }
	}
	public static class T2 extends Thread{
        public void run()
        {
            synchronized (object) {
                System.out.println("T2 start! notify all threads");
                object.notifyAll();
                System.out.println("T2 end!");
                try {
					Thread.sleep(2000);
				} catch (InterruptedException e) {
				}
            }
        }
	}
	public static void main(String[] args) throws InterruptedException {
        Thread t1 = new T1() ;
        Thread t1_1 = new T1() ;
        t1_1.start();
        t1.start();
        Thread.sleep(1000);
        Thread t2 = new T2() ;
        t2.start();
	}
}
package geym.ch6.simple;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;


/**
 * 使用简单线程池和直接开启线程的差别
 * @author Administrator
 *
 */
public class TestThreadPool {
	public static class MyThread implements Runnable{
		protected String name;
		public MyThread(){
		}
		public MyThread(String name){
			this.name=name;
		}
		@Override
		public void run() {
			try {
				Thread.sleep(100);
				//System.out.print(name+" ");
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	public  static void main(String args[]) throws InterruptedException {
		long starttime=System.currentTimeMillis();
		for(int i=0;i<1000;i++){
			ThreadPool.getInstance().start(new MyThread("testThreadPool"+Integer.toString(i)));
		}

		long endtime=System.currentTimeMillis();
		System.out.println("testThreadPool"+": "+(endtime-starttime));
		System.out.println("getCreatedThreadsCount:"+ThreadPool.getInstance().getCreatedThreadsCount());
		Thread.sleep(1000);
	}


}
package geym.ch6;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * 自定义ThreadFactory
 * @author Administrator
 *
 */
public class TFThreadPoolDemo {
	public static class MyTask implements Runnable {
		@Override
		public void run() {
			System.out.println(System.currentTimeMillis() + ":Thread ID:"
					+ Thread.currentThread().getId());
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		MyTask task = new MyTask();
		ExecutorService es = new ThreadPoolExecutor(5, 5,
                0L, TimeUnit.MILLISECONDS,
                new SynchronousQueue<Runnable>(),
                new ThreadFactory(){
					@Override
					public Thread newThread(Runnable r) {
						Thread t= new Thread(r);
						t.setDaemon(true);
						System.out.println("create "+t);
						return t;
					}
				}
               );
		for (int i = 0; i < 5; i++) {
			es.submit(task);
		}
		Thread.sleep(2000);
	}
}
package geym.ch9;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadLocalDemo {
	private static final  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    public static class ParseDate implements Runnable{
    	int i=0;
    	public ParseDate(int i){this.i=i;}
		public void run() {
			try {
				Date t=sdf.parse("2015-03-29 19:29:"+i%60);
				System.out.println(i+":"+t);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
    }
	public static void main(String[] args) {
		ExecutorService es=Executors.newFixedThreadPool(10);
		for(int i=0;i<1000;i++){
			es.execute(new ParseDate(i));
		}
	}
}
package geym.ch9;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadLocalDemo2 {
	static ThreadLocal<SimpleDateFormat> tl=new ThreadLocal<SimpleDateFormat>();
    public static class ParseDate implements Runnable{
    	int i=0;
    	public ParseDate(int i){this.i=i;}
		public void run() {
			try {
				if(tl.get()==null){
					tl.set(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
				}
				Date t=tl.get().parse("2015-03-29 19:29:"+i%60);
				System.out.println(i+":"+t);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
    }
	public static void main(String[] args) {
		ExecutorService es=Executors.newFixedThreadPool(10);
		for(int i=0;i<1000;i++){
			es.execute(new ParseDate(i));
		}

	}

}
package geym.ch9;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadLocalDemoBad {
	static ThreadLocal<SimpleDateFormat> tl=new ThreadLocal<SimpleDateFormat>();
	private static final  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    public static class ParseDate implements Runnable{
    	int i=0;
    	public ParseDate(int i){this.i=i;}
		public void run() {
			try {
				if(tl.get()==null){
					tl.set(sdf);
				}
				Date t=tl.get().parse("2015-03-29 19:29:"+i%60);
				System.out.println(i+":"+t);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
    }
	public static void main(String[] args) {
		ExecutorService es=Executors.newFixedThreadPool(10);
		for(int i=0;i<1000;i++){
			es.execute(new ParseDate(i));
		}

	}

}
package geym.ch6.simple;

import java.util.List;
import java.util.Vector;

public class ThreadPool
{
    private static ThreadPool instance = null;

    //空闲的线程队列
    private List<Worker> idleThreads;
    //已有的线程总数
    private int threadCounter;
    private boolean isShutDown = false;

    private ThreadPool()
    {
        this.idleThreads = new Vector(5);
        threadCounter = 0;
    }

    public int getCreatedThreadsCount() {
        return threadCounter;
    }

    //取得线程池的实例
    public synchronized static ThreadPool getInstance() {
        if (instance == null)
            instance = new ThreadPool();
        return instance;
    }

    //将线程放入池中
    protected synchronized void repool(Worker repoolingThread)
    {
        if (!isShutDown)
        {
            idleThreads.add(repoolingThread);
        }
        else
        {
            repoolingThread.shutDown();//关闭线程
        }
    }

    //停止池中所有线程
    public synchronized void shutdown()
    {
       isShutDown = true;
       for (int threadIndex = 0; threadIndex < idleThreads.size(); threadIndex++)
       {
             Worker idleThread = (Worker) idleThreads.get(threadIndex);
             idleThread.shutDown();
       }
    }

    //执行任务
    public synchronized void start(Runnable target)
    {
        Worker thread = null;
        //如果有空闲线程，则直接使用
        if (idleThreads.size() > 0)
        {
            int lastIndex = idleThreads.size() - 1;
            thread = (Worker) idleThreads.get(lastIndex);
            idleThreads.remove(lastIndex);
            //立即执行这个任务
            thread.setTarget(target);
        }
        //没有空闲线程，则创建新线程
        else
        {
            threadCounter++;
            // 创建新线程，
            thread = new Worker(target, "PThread #" + threadCounter, this);
            //启动这个线程
            thread.start();
        }
    }
}package geym.ch6;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolDemo {
	public static class MyTask implements Runnable {
		@Override
		public void run() {
			System.out.println(System.currentTimeMillis() + ":Thread ID:"
					+ Thread.currentThread().getId());
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public static void main(String[] args) {
		MyTask task = new MyTask();
		ExecutorService es = Executors.newFixedThreadPool(5);
		for (int i = 0; i < 10; i++) {
			//es.submit(task);
			es.execute(task);
		}
	}
}
package geym.ch5;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class TimeLock implements Runnable {
	public static ReentrantLock lock = new ReentrantLock();

	@Override
	public void run() {
		try {
			if (lock.tryLock(5, TimeUnit.SECONDS)) {
				Thread.sleep(6000);
			} else {
				System.out.println("get lock failed");
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			if(lock.isHeldByCurrentThread())
				lock.unlock();
		}
	}

	public static void main(String[] args) {
		TimeLock tl = new TimeLock();
		Thread t1 = new Thread(tl);
		Thread t2 = new Thread(tl);
		t1.start();
		t2.start();
	}
}
package geym.ch10;

import java.util.ArrayList;

/**
 * 两个线程都过了数组大小检查，先后插入数据时 引起 out of bound
 * @author Geym
 *
 */
public class UnsafeArrayList {
    static ArrayList al=new ArrayList();
    static class AddTask implements Runnable{
        @Override
        public void run() {
        	try {
				Thread.sleep(100);
			} catch (InterruptedException e) {}
            for(int i=0;i<1000000;i++)
                al.add(new Object());
        }
    }
    public static void main(String[] args) throws InterruptedException {
        Thread t1=new Thread(new AddTask(),"t1");
        Thread t2=new Thread(new AddTask(),"t2");
        t1.start();
        t2.start();
        Thread t3=new Thread(new Runnable(){
			@Override
			public void run() {
				while(true){
					try {
						Thread.sleep(1000);
					} catch (InterruptedException e) {}
				}
			}
        },"t3");
        t3.start();
    }
}
package geym.ch6.simple;

public class Worker extends Thread
{
	//线程池
    private ThreadPool pool;
    //任务
    private Runnable target;
    private boolean isShutDown = false;
    private boolean isIdle = false;

    public Worker(Runnable target, String name, ThreadPool pool)
    {
        super(name);
        this.pool = pool;
        this.target = target;
    }

    public Runnable getTarget()
    {
        return target;
    }

    public boolean isIdle()
    {
        return isIdle;
    }
    public void run()
    {
        while (!isShutDown)
        {
            isIdle = false;
            if (target != null)
            {
            	// 运行任务
                target.run();
            }
            //任务结束了
            isIdle = true;
            try
            {
            	//该任务结束后，不关闭线程，而是放入线程池空闲队列
                pool.repool(this);
                synchronized (this)
                {
                	//线程空闲，等待新的任务到来
                    wait();
                }
            }
            catch (InterruptedException ie)
            {
            }
            isIdle = false;
        }
    }


    public synchronized void setTarget(java.lang.Runnable newTarget)
    {
        target = newTarget;
        //设置了任务之后，通知run方法，开始执行这个任务
        notifyAll();
    }

    public synchronized void shutDown()
    {
        isShutDown = true;
        notifyAll();
    }
}








package concurrency.lock;

import java.util.concurrent.locks.StampedLock;

public class StampedLockTest {

    private double x, y;//内部定义表示坐标点
    private final StampedLock s1 = new StampedLock();//定义了StampedLock锁,

    void move(double deltaX, double deltaY) {
        long stamp = s1.writeLock();//这里的含义和distanceFormOrigin方法中 s1.readLock()是类似的
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            s1.unlockWrite(stamp);//退出临界区,释放写锁
        }
    }

    double distanceFormOrigin() {//只读方法
        long stamp = s1.tryOptimisticRead();  //试图尝试一次乐观读 返回一个类似于时间戳的邮戳整数stamp 这个stamp就可以作为这一个所获取的凭证
        double currentX = x, currentY = y;//读取x和y的值,这时候我们并不确定x和y是否是一致的
        if (!s1.validate(stamp)) {//判断这个stamp是否在读过程发生期间被修改过,如果stamp没有被修改过,责任无这次读取时有效的,因此就可以直接return了,反之,如果stamp是不可用的,则意味着在读取的过程中,可能被其他线程改写了数据,因此,有可能出现脏读,如果如果出现这种情况,我们可以像CAS操作那样在一个死循环中一直使用乐观锁,知道成功为止
            stamp = s1.readLock();//也可以升级锁的级别,这里我们升级乐观锁的级别,将乐观锁变为悲观锁, 如果当前对象正在被修改,则读锁的申请可能导致线程挂起.
            try {
                currentX = x;
                currentY = y;
            } finally {
                s1.unlockRead(stamp);//退出临界区,释放读锁
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }

    public static void main(String[] args) {
        new StampedLockTest().distanceFormOrigin();
    }
}

package concurrency;

import sun.awt.Mutex;

import java.util.Random;
import java.util.concurrent.Semaphore;

public class SemaphoreApp {

    public static void main(String[] args) {


        final Semaphore available = new Semaphore(3);

        // 匿名Runnable实例。定义线程运行程序。
        Runnable limitedCall = new Runnable() {
              // 最多可以发出3个"许可"
            final Random rand = new Random();
            int count = 0;

            public void run() {
                int time = rand.nextInt(15);
                int num = count++;

                try {
                    available.acquire();    // 当前线程获取"许可"。若没有获取许可，则等待于此。
                    System.out.println("Executing " + "long-running action for " + time + " seconds... #" + num);
                    Thread.sleep(time * 1000);
                    System.out.println("Done with #" + num + "!");
                } catch (InterruptedException intEx) {
                    intEx.printStackTrace();
                } finally {
                    available.release();     // 当前线程释放"许可"
                }
            }
        };

        for (int i = 0; i < 10; i++) {
            new Thread(limitedCall).start();
        }
    }
}
package concurrency;


import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;

public class RecursiveTaskTest extends RecursiveTask<Integer> {
    private volatile static int count = 0;
    private int start;
    private int end;

    public RecursiveTaskTest(int start, int end) {
        this.start = start;
        this.end = end;
    }

    public static final int threadhold = 2;

    @Override
    protected Integer compute() {
        int sum = 0;
        System.out.println("开启了一条线程单独干: " + count++);
        // 如果任务足够小, 就直接执行
        boolean canCompute = (end - start) <= threadhold;
        if (canCompute) {
            for (int i = start; i <= end; i++) {
                sum += i;
            }
        } else {
            //任务大于阈值, 分裂为2个任务
            int middle = (start + end) / 2;
            RecursiveTaskTest recursiveTaskTest1 = new RecursiveTaskTest(start, middle);
            RecursiveTaskTest recursiveTaskTest2 = new RecursiveTaskTest(middle + 1, end);

            // 开启线程
//            recursiveTaskTest1.fork();
//            recursiveTaskTest2.fork();
            invokeAll(recursiveTaskTest1, recursiveTaskTest2);

            Integer join1 = recursiveTaskTest1.join();
            Integer join2 = recursiveTaskTest2.join();

            // 结果合并
//            sum = join1 + join2;
            sum = join1;
        }
        return sum;
    }


    // 测试
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ForkJoinPool forkJoinPool = new ForkJoinPool();

        RecursiveTaskTest recursiveTaskTest = new RecursiveTaskTest(1, 1000000);
        ForkJoinTask<Integer> result = forkJoinPool.submit(recursiveTaskTest);
        System.out.println(result.get());

    }
}

package concurrency;

import java.util.concurrent.*;

public class ScheduledThreadPoolTest {

    public static void main(String[] args) {

//        ScheduledExecutorService poolExecutor = Executors.newSingleThreadScheduledExecutor();
//        new ThreadPoolExecutor()
        ScheduledExecutorService poolExecutor = Executors.newSingleThreadScheduledExecutor();

        poolExecutor.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println("==================================");
            }
        }, 1, 5, TimeUnit.SECONDS);

//        poolExecutor.scheduleAtFixedRate(new Runnable() {//每隔一段时间打印系统时间，证明两者是互不影响的
//
//            @Override
//
//            public void run() {
//
//                System.out.println(System.nanoTime());
//
//            }
//
//        }, 1000, 2000, TimeUnit.MILLISECONDS);

    }
}

package concurrency;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;

public class SemaphoreParkingCars {

    private static final int NUMBER_OF_CARS = 30;
    private static final int NUMBER_OF_PARKING_SLOT = 10;

    public static void main(String[] args) {
        Semaphore parkingSlot = new Semaphore(NUMBER_OF_PARKING_SLOT, true);    // "车位",采用FIFO,设置true。


        ExecutorService service = Executors.newCachedThreadPool();    // 创建线程池。模拟30辆车"停车"。

        for (int carNo = 1; carNo <= NUMBER_OF_CARS; carNo++) {
            service.execute(new Car(parkingSlot, carNo));
        }

        sleep(3000);
        service.shutdown();    // 关闭线程池。

        // 输出剩余可以用的资源数。
//        System.out.println(parkingSlot.availablePermits() + " 个停车位可以用!");
    }

    private static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }


}


class Car implements Runnable {
    private final Semaphore parkingSlot;
    private int carNo;

    public Car(Semaphore parkingSlot, int carNo) {
        this.parkingSlot = parkingSlot;
        this.carNo = carNo;
    }

    public void run() {
        try {
            parkingSlot.acquire();    // 车尝试获取"车位"
            parking();
            sleep(300);
            leaving();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            parkingSlot.release();    // 释放"车位"
            System.out.println(parkingSlot.availablePermits() + " 个停车位可以用!");
        }
    }

    private void parking() {
        System.out.println(String.format("%d号车泊车", carNo));
    }

    private void leaving() {
        System.out.println(String.format("%d号车离开车位", carNo));
    }

    private static void sleep(long millis) {

        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}

package concurrency;

import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CylicBarrierTest {

    static CyclicBarrier c = new CyclicBarrier(2);

    static ExecutorService pool = Executors.newFixedThreadPool(2);

    public static void main(String args[]) {

        pool.execute(new Runnable() {
            public void run() {
                System.out.println("this is A");
                try {
                    c.await();
                    System.out.println("this is Aa");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        pool.execute(new Runnable() {
            public void run() {
                System.out.println("this is B");
                try {
                    c.await();
                    System.out.println("this is Bb");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        pool.shutdown();
    }

}

package concurrency;

import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingDeque;

/**
* 将Executor和BlockingQueue功能融合在一起，能够将Callable的任务提交给它来运行， 然后使用take()方法获得已经完毕的结果
*
* @author zhy
*
*/
public class CompletionServiceDemo
{

    public static void main(String[] args) throws InterruptedException,
            ExecutionException
    {
        /**
         * 内部维护11个线程的线程池
         */
        ExecutorService exec = Executors.newFixedThreadPool(11);
        /**
         * 容量为10的堵塞队列
         */
        final BlockingQueue<Future<Integer>> queue = new LinkedBlockingDeque<Future<Integer>>(
                10);
        //实例化CompletionService
        final CompletionService<Integer> completionService = new ExecutorCompletionService<Integer>(
                exec, queue);

        /**
         * 模拟瞬间产生10个任务，且每一个任务运行时间不一致
         */
        for (int i = 0; i < 10; i++)
        {
            completionService.submit(new Callable<Integer>()
            {
                @Override
                public Integer call() throws Exception
                {
                    int ran = new Random().nextInt(1000);
                    Thread.sleep(ran);
                    System.out.println(Thread.currentThread().getName()
                            + " 歇息了 " + ran);
                    return ran;
                }
            });
        }

        /**
         * 马上输出结果
         */
        for (int i = 0; i < 10; i++)
        {
            try
            {
                //谁最先运行完毕，直接返回
                Future<Integer> f = completionService.take();
                System.out.println(f.get());
            } catch (InterruptedException e)
            {
                e.printStackTrace();
            } catch (ExecutionException e)
            {
                e.printStackTrace();
            }
        }

        exec.shutdown();

    }

}

package concurrency;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
* <p>Title: ConditionTest</p>
* <p>Description: </p>
* <p>Copyright: Copyright (c) 2019</p>
* <p>Company: 寿险总部核心系统开发部后端批处理系统开发团队再保精算开发组</p>
*
* @author EX-ZHANGYONGTIAN001
* @version 1.0.0
* @date 2019-3-13  10:24
*/
public class ConditionTest {


    final Lock lock = new ReentrantLock();
    final Condition condition = lock.newCondition();

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        ConditionTest test = new ConditionTest();
        Producer producer = test.new Producer();
        Consumer consumer = test.new Consumer();


        consumer.start();
        producer.start();
    }

    class Producer extends Thread {

        @Override
        public void run() {
            produce();
        }

        private void produce() {
            try {
                lock.lock();
                System.out.println("我拿到锁" + this.currentThread().getName());
                condition.signalAll();
                System.out.println("我发出了一个信号：" + this.currentThread().getName());
            } finally {
                lock.unlock();
            }
        }
    }

    class Consumer extends Thread {

        @Override
        public void run() {
            consume();
        }

        private void consume() {

            try {
                lock.lock();
                System.out.println("我在等一个新信号" + this.currentThread().getName());
                condition.await();

            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } finally {
                System.out.println("拿到一个信号" + this.currentThread().getName());
                lock.unlock();
            }

        }
    }

}

package concurrency;

import java.util.concurrent.Exchanger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
* <p>Title: ExchangeTest</p>
* <p>Description: </p>
* <p>Copyright: Copyright (c) 2019</p>
* <p>Company: 寿险总部核心系统开发部后端批处理系统开发团队再保精算开发组</p>
* * Exchanger（交换者），它是用于线程间的协作工具类，主要用于线程间数据的交换。它提供了一个同步点，在这个同步点，两个线程可以交换彼此的数据。下面看具体demo：
*
* @author EX-ZHANGYONGTIAN001
* @version 1.0.0
* @date 2019-3-12  17:03
*/
public class ExchangeTest {


    private static final Exchanger<String> exgr = new Exchanger<String>();

    private static ExecutorService pool = Executors.newFixedThreadPool(2);

    public static void main(String args[]) {

        pool.execute(new Runnable() {
            public void run() {
                String A = "银行流水A";
                try {
                    A = exgr.exchange(A);
                    System.out.println("A 当前的值：" + A);
                } catch (InterruptedException e) {

                }
            }
        });

        pool.execute(new Runnable() {
            public void run() {
                String B = "银行流水B";
                try {
                    B = exgr.exchange(B);
                    System.out.println("B 当前的值：" + B);
                } catch (InterruptedException e) {

                }
            }
        });

        pool.shutdown();

    }
} package concurrency;

  import java.util.PriorityQueue;
  import java.util.concurrent.locks.Condition;
  import java.util.concurrent.locks.Lock;
  import java.util.concurrent.locks.ReentrantLock;

  /**
  * <p>Title: ConditionTest2</p>
  * <p>Description: </p>
  * <p>Copyright: Copyright (c) 2019</p>
  * <p>Company: 寿险总部核心系统开发部后端批处理系统开发团队再保精算开发组</p>
  *
  * @author EX-ZHANGYONGTIAN001
  * @version 1.0.0
  * @date 2019-3-13  10:35
  */
  public class ConditionTest2 {
      private int queueSize = 10;
      private PriorityQueue<Integer> queue = new PriorityQueue<Integer>(queueSize);
      private Lock lock = new ReentrantLock();
      private Condition notFull = lock.newCondition();
      private Condition notEmpty = lock.newCondition();

      public static void main(String[] args) throws InterruptedException {
          ConditionTest2 test = new ConditionTest2();
          Producer producer = test.new Producer();
          Consumer consumer = test.new Consumer();
          producer.start();
          consumer.start();
          Thread.sleep(0);
          producer.interrupt();
          consumer.interrupt();
      }

      class Consumer extends Thread {
          @Override
          public void run() {
              consume();
          }

          volatile boolean flag = true;

          private void consume() {
              while (flag) {
                  lock.lock();
                  try {
                      while (queue.size() == 0) {
                          try {
                              System.out.println("队列空，等待数据");
                              notEmpty.await();
                          } catch (InterruptedException e) {
                              flag = false;
                          }
                      }
                      queue.poll();                //每次移走队首元素
                      notFull.signal();
                      System.out.println("从队列取走一个元素，队列剩余" + queue.size() + "个元素");
                  } finally {
                      lock.unlock();
                  }
              }
          }
      }

      class Producer extends Thread {
          @Override
          public void run() {
              produce();
          }

          volatile boolean flag = true;

          private void produce() {
              while (flag) {
                  lock.lock();
                  try {
                      while (queue.size() == queueSize) {
                          try {
                              System.out.println("队列满，等待有空余空间");
                              notFull.await();
                          } catch (InterruptedException e) {

                              flag = false;
                          }
                      }
                      queue.offer(1);        //每次插入一个元素
                      notEmpty.signal();
                      System.out.println("向队列取中插入一个元素，队列剩余空间：" + (queueSize - queue.size()));
                  } finally {
                      lock.unlock();
                  }
              }
          }
      }
  }

  package concurrency;

  /**
  * <p>Title: ExchangerDemo</p>
  * <p>Description: </p>
  * <p>Copyright: Copyright (c) 2019</p>
  * <p>Company: 寿险总部核心系统开发部后端批处理系统开发团队再保精算开发组</p>
  *
  * Exchanger() 创建一个新的 Exchanger。
  V exchange(V x) 等待另一个线程到达此交换点（除非当前线程被中断），然后将给定的对象传送给该线程，并接收该线程的对象。

  V exchange(V x, long timeout, TimeUnit unit) 等待另一个线程到达此交换点（除非当前线程被中断，或者超出了指定的等待时间），然后将给定的对象传送给该线程，同时接收该线程的对象。
  例：以下这个程序demo要做的事情就是生产者在交换前生产5个"生产者"，然后再与消费者交换5个数据，然后再生产5个"交换后生产者"，而消费者要在交换前消费5个"消费者"，然后再与生产者交换5个数据，然后再消费5个"交换后消费者"

  * @author EX-ZHANGYONGTIAN001
  * @version 1.0.0
  * @date 2019-3-12  17:53
  */

  import java.util.ArrayList;
  import java.util.Iterator;
  import java.util.List;
  import java.util.concurrent.Exchanger;

  /**
  * 两个线程间的数据交换
  */
  public class ExchangerDemo {
      private static final Exchanger<List<String>> ex = new Exchanger<List<String>>();

      private static void sleep(long millis) {
          try {
              Thread.sleep(millis);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }

      /**
       * 内部类，数据生成者
       */
      class DataProducer implements Runnable {
          private List<String> list = new ArrayList<String>();

          public void run() {
              System.out.println("生产者开始生产数据");
              for (int i = 1; i <= 5; i++) {
                  System.out.println("生产了第" + i + "个数据，耗时1秒");
                  list.add("生产者" + i);
                  sleep(1000);
              }
              System.out.println("生产数据结束");
              System.out.println("开始与消费者交换数据");

              try {
                  //将数据准备用于交换，并返回消费者的数据
                  list = (List<String>) ex.exchange(list);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }

              System.out.println("结束与消费者交换数据");
              System.out.println("生产者与消费者交换数据后，再生产数据");
              for (int i = 6; i < 10; i++) {
                  System.out.println("交换后生产了第" + i + "个数据，耗时1秒");
                  list.add("交换后生产者" + i);
                  sleep(1000);
              }

              System.out.println("遍历生产者交换后的数据");
              for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {
                  System.out.println(iterator.next());
              }
          }

      }


      /**
       * 内部类，数据消费者
       */
      class DataConsumer implements Runnable {
          private List<String> list = new ArrayList<String>();

          public void run() {
              System.out.println("消费者开始消费数据");
              for (int i = 1; i <= 5; i++) {
                  System.out.println("消费了第" + i + "个数据");
                  // 消费者产生数据，后面交换的时候给生产者
                  list.add("消费者" + i);
              }

              System.out.println("消费数据结束");
              System.out.println("开始与生产者交换数据");
              try {
                  // 进行数据交换，返回生产者的数据
                  list = (List<String>) ex.exchange(list);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }

              System.out.println("消费者与生产者交换数据后，再消费数据");
              for (int i = 6; i < 10; i++) {
                  System.out.println("交换后消费了第" + i + "个数据");
                  list.add("交换后消费者" + i);
                  sleep(1000);
              }
              sleep(1000);
              System.out.println("开始遍历消费者交换后的数据");

              for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {
                  System.out.println(iterator.next());
              }
          }
      }

      // 主方法
      public static void main(String args[]) {
          ExchangerDemo et = new ExchangerDemo();
          new Thread(et.new DataProducer()).start();
          new Thread(et.new DataConsumer()).start();
      }
  }

