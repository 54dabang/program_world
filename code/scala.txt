package org.learningconcurrency
package ch8



import akka.actor.Actor
import akka.actor.ActorRef
import akka.event.Logging
import akka.actor.Props
import akka.actor.ActorSystem
import scala.io.Source
import scala.collection._



class HelloActor(val hello: String) extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case `hello` =>
      log.info(s"Received a '$hello'... $hello!")
    case msg     =>
      log.info(s"Unexpected message '$msg'")
      context.stop(self)
  }
}


object HelloActor {
  def props(hello: String) = Props(new HelloActor(hello))
  def propsVariant(hello: String) = Props(classOf[HelloActor], hello)
}


object ActorsCreate extends App {
  val hiActor: ActorRef = ourSystem.actorOf(HelloActor.props("hi"), name = "greeter")
  hiActor ! "hi"
  Thread.sleep(1000)
  hiActor ! "hola"
  Thread.sleep(1000)
  ourSystem.shutdown()
}


class DeafActor extends Actor {
  val log = Logging(context.system, this)
  def receive = PartialFunction.empty
  override def unhandled(msg: Any) = msg match {
    case msg: String => log.info(s"could not handle '$msg'")
    case _           => super.unhandled(msg)
  }
}


object ActorsUnhandled extends App {
  val deafActor = ourSystem.actorOf(Props[DeafActor], name = "deafy")
  deafActor ! "hi"
  Thread.sleep(1000)
  deafActor ! 1234
  Thread.sleep(1000)
  ourSystem.shutdown()
}


class CountdownActor extends Actor {
  var n = 10
  def counting: Actor.Receive = {
    case "count" =>
      n -= 1
      log(s"n = $n")
      if (n == 0) context.become(done)
  }
  def done = PartialFunction.empty
  def receive = counting
}


object ActorsCountdown extends App {
  val countdown = ourSystem.actorOf(Props[CountdownActor])
  for (i <- 0 until 20) countdown ! "count"
  Thread.sleep(1000)
  ourSystem.shutdown()
}


class DictionaryActor extends Actor {
  private val log = Logging(context.system, this)
  private val dictionary = mutable.Set[String]()
  def receive = uninitialized
  def uninitialized: PartialFunction[Any, Unit] = {
    case DictionaryActor.Init(path) =>
      val stream = getClass.getResourceAsStream(path)
      val words = Source.fromInputStream(stream)
      for (w <- words.getLines) dictionary += w
      context.become(initialized)
  }
  def initialized: PartialFunction[Any, Unit] = {
    case DictionaryActor.IsWord(w) =>
      log.info(s"word '$w' exists: ${dictionary(w)}")
    case DictionaryActor.End =>
      dictionary.clear()
      context.become(uninitialized)
  }
  override def unhandled(msg: Any) = {
    log.info(s"message $msg should not be sent in this state.")
  }
}


object DictionaryActor {
  case class Init(path: String)
  case class IsWord(w: String)
  case object End
}


object ActorsBecome extends App {
  val dict = ourSystem.actorOf(Props[DictionaryActor], "dictionary")
  dict ! DictionaryActor.IsWord("program")
  Thread.sleep(1000)
  dict ! DictionaryActor.Init("/org/learningconcurrency/words.txt") // or /usr/share/dict/words
  Thread.sleep(1000)
  dict ! DictionaryActor.IsWord("program")
  Thread.sleep(1000)
  dict ! DictionaryActor.IsWord("balaban")
  Thread.sleep(1000)
  dict ! DictionaryActor.End
  Thread.sleep(1000)
  dict ! DictionaryActor.IsWord("termination")
  Thread.sleep(1000)
  ourSystem.shutdown()
}


class ParentActor extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case "create" =>
      context.actorOf(Props[ChildActor])
      log.info(s"created a new child - children = ${context.children}")
    case "sayhi" =>
      log.info("Kids, say hi!")
      for (c <- context.children) c ! "sayhi"
    case "stop" =>
      log.info("parent stopping")
      context.stop(self)
  }
}


class ChildActor extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case "sayhi" =>
      val parent = context.parent
      log.info(s"my parent $parent made me say hi!")
  }
  override def postStop() {
    log.info("child stopped!")
  }
}


object ActorsHierarchy extends App {
  val parent = ourSystem.actorOf(Props[ParentActor], "parent")
  parent ! "create"
  parent ! "create"
  Thread.sleep(1000)
  parent ! "sayhi"
  Thread.sleep(1000)
  parent ! "stop"
  Thread.sleep(1000)
  ourSystem.shutdown()
}


class CheckActor extends Actor {
  import akka.actor.{Identify, ActorIdentity}
  val log = Logging(context.system, this)
  def receive = {
    case path: String =>
      log.info(s"checking path $path")
      context.actorSelection(path) ! Identify(path)
    case ActorIdentity(path, Some(ref)) =>
      log.info(s"found actor $ref on $path")
    case ActorIdentity(path, None) =>
      log.info(s"could not find an actor on $path")
  }
}


object ActorsIdentify extends App {
  val checker = ourSystem.actorOf(Props[CheckActor], "checker")
  checker ! "../*"
  Thread.sleep(1000)
  checker ! "../../*"
  Thread.sleep(1000)
  checker ! "/system/*"
  Thread.sleep(1000)
  checker ! "/user/checker2"
  Thread.sleep(1000)
  checker ! "akka://OurExampleSystem/system"
  Thread.sleep(1000)
  ourSystem.stop(checker)
  Thread.sleep(1000)
  ourSystem.shutdown()
}


class LifecycleActor extends Actor {
  val log = Logging(context.system, this)
  var child: ActorRef = _
  def receive = {
    case num: Double  => log.info(s"got a double - $num")
    case num: Int     => log.info(s"got an integer - $num")
    case lst: List[_] => log.info(s"list - ${lst.head}, ...")
    case txt: String  => child ! txt
  }
  override def preStart(): Unit = {
    log.info("about to start")
    child = context.actorOf(Props[StringPrinter], "kiddo")
  }
  override def preRestart(reason: Throwable, msg: Option[Any]): Unit = {
    log.info(s"about to restart because of $reason, during message $msg")
    super.preRestart(reason, msg)
  }
  override def postRestart(reason: Throwable): Unit = {
    log.info(s"just restarted due to $reason")
    super.postRestart(reason)
  }
  override def postStop() = log.info("just stopped")
}


class StringPrinter extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case msg => log.info(s"child got message '$msg'")
  }
  override def preStart(): Unit = log.info(s"child about to start.")
  override def postStop(): Unit = log.info(s"child just stopped.")
}


object ActorsLifecycle extends App {
  val testy = ourSystem.actorOf(Props[LifecycleActor], "testy")
  testy ! math.Pi
  Thread.sleep(1000)
  testy ! 7
  Thread.sleep(1000)
  testy ! "hi there!"
  Thread.sleep(1000)
  testy ! Nil
  Thread.sleep(1000)
  testy ! "sorry about that"
  Thread.sleep(1000)
  ourSystem.stop(testy)
  Thread.sleep(1000)
  ourSystem.shutdown()
}












package org.learningconcurrency
package ch6



import scala.reactive._



object AkkaStreams extends App {
  import akka.actor.ActorSystem
  import akka.stream._
  import akka.stream.scaladsl._

  implicit val system = ActorSystem("system")

  val numbers = Iterator.from(1).take(100)

  def isPrime(n: Int) = (2 to (n - 1)).forall(n % _ != 0)

  Flow(numbers)
    .filter(isPrime)
    .map(num => s"Prime number: $num")
    .foreach(println)
    .onComplete(FlowMaterializer(MaterializerSettings())) {
      case _ => system.shutdown()
    }

}


object ReactiveCollections extends App {

  def isPrime(n: Int) = (2 to (n - 1)).forall(n % _ != 0)

  val numbers = new Reactive.Emitter[Int]
  numbers
    .filter(isPrime)
    .map(num => s"Prime number: $num")
    .foreach(println)

  for (i <- 0 until 100) numbers += i

}
package org.learningconcurrency
package ch4





// // only enable with Scala 2.10.4
// object Finagle extends App {
//   import com.twitter.util.{Future, Promise}

//   val tombola = Future {
//     scala.util.Random.shuffle((0 until 10000).toVector)
//   }

//   tombola onSuccess { numbers =>
//     log(s"And the winner is: ${numbers.head}")
//   }

//   tombola onSuccess { numbers =>
//     log(s"Once, more, the winner is: ${numbers.head}")
//   }

// }


object Scalaz extends App {
  import scalaz.concurrent._

  val tombola = Future {
    scala.util.Random.shuffle((0 until 10000).toVector)
  }

  tombola.runAsync { numbers =>
    log(s"And the winner is: ${numbers.head}")
  }

  tombola.runAsync { numbers =>
    log(s"... ahem, winner is: ${numbers.head}")
  }

}

package org.learningconcurrency
package ch4






object AsyncBasic extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.async.Async.{async, await}

  val workerName: Future[String] = async {
    Thread.currentThread.getName
  }

  workerName foreach {
    name => log(s"Future completed by worker $name")
  }

}


object AsyncAwait extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.async.Async.{async, await}
  import scala.io.Source

  val timetableFuture: Future[String] = async {
    val utc: Future[String] = async { Source.fromURL("http://www.timeapi.org/utc/now").mkString }
    val pdt: Future[String] = async { Source.fromURL("http://www.timeapi.org/pdt/now").mkString }
    val wet: Future[String] = async { Source.fromURL("http://www.timeapi.org/west/now").mkString }
    s"""Timetable
    Universal Time                 ${await { utc } }
    Pacific Daylight Time          ${await { pdt } }
    Western European Summer Time   ${await { wet } }
    """
  }

  timetableFuture foreach {
    timetable => log(timetable)
  }

}


object AsyncWhile extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.async.Async.{async, await}

  def delay(nSeconds: Int) = async {
    blocking {
      Thread.sleep(nSeconds * 1000)
    }
  }

  def simpleCount(): Future[Unit] = async {
    log("T-minus 2 seconds")
    await { delay(1) }
    log("T-minus 1 second")
    await { delay(1) }
    log("done!")
  }

  simpleCount()

  Thread.sleep(3000)

  def countdown(nSeconds: Int)(count: Int => Unit): Future[Unit] = async {
    var i = nSeconds
    while (i > 0) {
      count(i)
      await { delay(1) }
      i -= 1
    }
  }

  countdown(10) { n =>
    log(s"T-minus $n seconds")
  } foreach {
    _ => log(s"This program is over!")
  }

}

package org.learningconcurrency
package ch7






object AtomicHistoryBad extends App {
  import java.util.concurrent.atomic._
  import scala.annotation.tailrec
  import scala.concurrent._
  import ExecutionContext.Implicits.global

  val urls = new AtomicReference[List[String]](Nil)
  val clen = new AtomicInteger(0)

  def addUrl(url: String): Unit = {
    @tailrec def append(): Unit = {
      val oldUrls = urls.get
      if (!urls.compareAndSet(oldUrls, url :: oldUrls)) append()
    }
    append()
    clen.addAndGet(url.length + 1)
  }

  def getUrlArray(): Array[Char] = {
    val array = new Array[Char](clen.get)
    val urlList = urls.get
    for ((character, i) <- urlList.map(_ + "\n").flatten.zipWithIndex) {
      array(i) = character
    }
    array
  }

  Future {
    try { log(s"sending: ${getUrlArray().mkString}") }
    catch { case e: Exception => log(s"problems getting the array $e") }
  }

  Future {
    addUrl("http://scala-lang.org")
    addUrl("https://github.com/scala/scala")
    addUrl("http://www.scala-lang.org/api")
    log("done browsing")
  }

}


object AtomicHistorySTM extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  val urls = Ref[List[String]](Nil)
  val clen = Ref(0)

  def addUrl(url: String): Unit = atomic { implicit txn =>
    urls() = url :: urls()
    clen() = clen() + url.length + 1
  }

  def getUrlArray(): Array[Char] = atomic { implicit txn =>
    val array = new Array[Char](clen())
    for ((character, i) <- urls().map(_ + "\n").flatten.zipWithIndex) {
      array(i) = character
    }
    array
  }

  Future {
    addUrl("http://scala-lang.org")
    addUrl("https://github.com/scala/scala")
    addUrl("http://www.scala-lang.org/api")
    log("done browsing")
  }

  Thread.sleep(25)

  Future {
    try { log(s"sending: ${getUrlArray().mkString}") }
    catch { case e: Exception => log(s"problems getting the array $e") }
  }

}
















package org.learningconcurrency
package ch3






object AtomicUid extends App {
  import java.util.concurrent.atomic._
  private val uid = new AtomicLong(0L)

  def getUniqueId(): Long = uid.incrementAndGet()

  execute {
    log(s"Got a unique id asynchronously: ${getUniqueId()}")
  }

  log(s"Got a unique id: ${getUniqueId()}")
}


object AtomicUidCAS extends App {
  import java.util.concurrent.atomic._
  import scala.annotation.tailrec
  private val uid = new AtomicLong(0L)

  @tailrec def getUniqueId(): Long = {
    val oldUid = uid.get
    val newUid = oldUid + 1
    if (uid.compareAndSet(oldUid, newUid)) newUid
    else getUniqueId()
  }

  execute {
    log(s"Got a unique id asynchronously: $getUniqueId")
  }

  log(s"Got a unique id: $getUniqueId")
}


object AtomicLock extends App {
  import java.util.concurrent.atomic._
  private val lock = new AtomicBoolean(false)
  def mySynchronized(body: =>Unit): Unit = {
    while (!lock.compareAndSet(false, true)) {}
    try body
    finally lock.set(false)
  }

  var count = 0
  for (i <- 0 until 10) execute {
    mySynchronized { count += 1 }
  }
  Thread.sleep(1000)
  log(s"Count is: $count")
}


object AtomicStack {
  import java.util.concurrent.atomic._
  import scala.concurrent._
  import scala.annotation.tailrec

  trait Stack
  case class Node(head: Int, tail: Stack) extends Stack
  case object Bottom extends Stack

  private val stack = new AtomicReference[Stack](Bottom)
  @tailrec def push(x: Int) {
    val oldTop = stack.get()
    val newTop = Node(x, oldTop)
    if (!stack.compareAndSet(oldTop, newTop)) push(x)
  }
  @tailrec def pop(): Option[Int] = {
    stack.get() match {
      case Bottom => None
      case oldTop @ Node(head, newTop) =>
        if (stack.compareAndSet(oldTop, newTop)) Some(head)
        else pop()
    }
  }

  def main(args: Array[String]) {
    execute {
      @tailrec def poll() {
        pop() match {
          case Some(-1) =>
            log("Got -1. Done!")
          case Some(x) =>
            log(s"Got $x")
            poll()
          case None =>
            poll()
        }
      }
      poll()
    }

    push(1)
    push(2)
    push(3)
    Thread.sleep(100)
    push(-1)
  }

}


object AtomicArrays extends App {
  import java.util.concurrent.atomic._
  import scala.concurrent._

  private val counts = new AtomicIntegerArray(4)
  def lowerBound(): Int = {
    var cnt = 0
    for (i <- 0 until counts.length) cnt += counts.get(i)
    cnt
  }

  for (i <- 0 until counts.length) execute {
    for (_ <- 0 until 200) counts.incrementAndGet(i)
  }

  log(s"Count lower bound: ${lowerBound()}")
  log(s"Count lower bound: ${lowerBound()}")
  log(s"Count lower bound: ${lowerBound()}")
}




package org.learningconcurrency
package ch5



import scala.collection._
import scala.collection.par._
import scala.collection.par.Scheduler.Implicits.global



object BlitzComparison extends App {
  val array = (0 until 100000).toArray
  @volatile var x = 0

  val seqtime = warmedTimed(1000) {
    array.reduce(_ + _)
  }
  val partime = warmedTimed(1000) {
    array.par.reduce(_ + _)
  }
  val blitztime = warmedTimed(1000) {
    x = array.toPar.reduce(_ + _)
  }

  log(s"sequential time - $seqtime")
  log(s"parallel time   - $partime")
  log(s"ScalaBlitz time - $blitztime")
}


object BlitzHierarchy extends App {
  val array = (0 until 100000).toArray
  val range = 0 until 100000

  def sum(xs: Zippable[Int]): Int = {
    xs.reduce(_ + _)
  }

  println(sum(array.toPar))

  println(sum(range.toPar))

}



package org.learningconcurrency
package ch4






object BlockingAwait extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.duration._
  import scala.io.Source

  val urlSpecSizeFuture = Future { Source.fromURL("http://www.w3.org/Addressing/URL/url-spec.txt").size }
  val urlSpecSize = Await.result(urlSpecSizeFuture, 10.seconds)

  log(s"url spec contains $urlSpecSize characters")

}


object BlockingSleepBad extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.duration._

  val startTime = System.nanoTime

  val futures = for (_ <- 0 until 16) yield Future {
    Thread.sleep(1000)
  }

  for (f <- futures) Await.ready(f, Duration.Inf)

  val endTime = System.nanoTime

  log(s"Total execution time of the program = ${(endTime - startTime) / 1000000} ms")
  log(s"Note: there are ${Runtime.getRuntime.availableProcessors} CPUs on this machine")

}


object BlockingSleepOk extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.duration._

  val startTime = System.nanoTime

  val futures = for (_ <- 0 until 16) yield Future {
    blocking {
      Thread.sleep(1000)
    }
  }

  for (f <- futures) Await.ready(f, Duration.Inf)

  val endTime = System.nanoTime

  log(s"Total execution time of the program = ${(endTime - startTime) / 1000000} ms")

}

package org.learningconcurrency
package ch3






object CollectionsBad extends App {
  import scala.collection._

  val buffer = mutable.ArrayBuffer[Int]()

  def add(numbers: Seq[Int]) = execute {
    buffer ++= numbers
    log(s"buffer = $buffer")
  }

  add(0 until 10)
  add(10 until 20)
}


object CollectionsSynchronized extends App {
  import scala.collection._

  val buffer = new mutable.BufferProxy[Int] with mutable.SynchronizedBuffer[Int] {
    val self = mutable.ArrayBuffer[Int]()
  }

  execute {
    buffer ++= (0 until 10)
    log(s"buffer = $buffer")
  }

  execute {
    buffer ++= (10 until 20)
    log(s"buffer = $buffer")
  }

}


object MiscSyncVars extends App {
  import scala.concurrent._
  val sv = new SyncVar[String]

  execute {
    Thread.sleep(500)
    log("sending a message")
    sv.put("This is secret.")
  }

  log(s"get  = ${sv.get}")
  log(s"take = ${sv.take()}")

  execute {
    Thread.sleep(500)
    log("sending another message")
    sv.put("Secrets should not be logged!")
  }

  log(s"take = ${sv.take()}")
  log(s"take = ${sv.take(timeout = 1000)}")
}


object MiscDynamicVars extends App {
  import scala.util.DynamicVariable

  val dynlog = new DynamicVariable[String => Unit](log)
  def secretLog(msg: String) = println(s"(unknown thread): $msg")

  execute {
    dynlog.value("Starting asynchronous execution.")
    dynlog.withValue(secretLog) {
      dynlog.value("Nobody knows who I am.")
    }
    dynlog.value("Ending asynchronous execution.")
  }

  dynlog.value("is calling the log method!")
}


object CollectionsIterators extends App {
  import java.util.concurrent._

  val queue = new LinkedBlockingQueue[String]
  for (i <- 1 to 5500) queue.offer(i.toString)
  execute {
    val it = queue.iterator
    while (it.hasNext) log(it.next())
  }
  for (i <- 1 to 5500) queue.poll()
}


object CollectionsConcurrentMap extends App {
  import java.util.concurrent.ConcurrentHashMap
  import scala.collection._
  import scala.collection.convert.decorateAsScala._
  import scala.annotation.tailrec

  val emails = new ConcurrentHashMap[String, List[String]]().asScala

  execute {
    emails("James Gosling") = List("james@javalove.com")
    log(s"emails = $emails")
  }

  execute {
    emails.putIfAbsent("Alexey Pajitnov", List("alexey@tetris.com"))
    log(s"emails = $emails")
  }

  execute {
    emails.putIfAbsent("Alexey Pajitnov", List("alexey@welltris.com"))
    log(s"emails = $emails")
  }

}


object CollectionsConcurrentMapIncremental extends App {
  import java.util.concurrent.ConcurrentHashMap
  import scala.collection._
  import scala.collection.convert.decorateAsScala._
  import scala.annotation.tailrec

  val emails = new ConcurrentHashMap[String, List[String]]().asScala

  @tailrec def addEmail(name: String, address: String) {
    emails.get(name) match {
      case Some(existing) =>
        if (!emails.replace(name, existing, address :: existing)) addEmail(name, address)
      case None =>
        if (emails.putIfAbsent(name, address :: Nil) != None) addEmail(name, address)
    }
  }

  execute {
    addEmail("Yukihiro Matsumoto", "ym@ruby.com")
    log(s"emails = $emails")
  }

  execute {
    addEmail("Yukihiro Matsumoto", "ym@ruby.io")
    log(s"emails = $emails")
  }

}


object CollectionsConcurrentMapBulk extends App {
  import scala.collection._
  import scala.collection.convert.decorateAsScala._
  import java.util.concurrent.ConcurrentHashMap

  val names = new ConcurrentHashMap[String, Int]().asScala
  names("Johnny") = 0
  names("Jane") = 0
  names("Jack") = 0

  execute {
    for (n <- 0 until 10) names(s"John $n") = n
  }

  execute {
    for (n <- names) log(s"name: $n")
  }

}


object CollectionsTrieMapBulk extends App {
  import scala.collection._

  val names = new concurrent.TrieMap[String, Int]
  names("Janice") = 0
  names("Jackie") = 0
  names("Jill") = 0

  execute {
    for (n <- 10 until 100) names(s"John $n") = n
  }

  execute {
    log("snapshot time!")
    for (n <- names.map(_._1).toSeq.sorted) log(s"name: $n")
  }

}





package org.learningconcurrency
package ch8



import akka.actor._
import akka.event.Logging
import akka.util.Timeout
import akka.pattern.{ask, pipe, gracefulStop}
import akka.util.Timeout
import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util._



class Pongy extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case "ping" =>
      log.info("Got a ping -- ponging back!")
      sender ! "pong"
      context.stop(self)
  }
  override def postStop() = log.info("pongy going down")
}


class Pingy extends Actor {
  def receive = {
    case pongyRef: ActorRef =>
      implicit val timeout = Timeout(2 seconds)
      val future = pongyRef ? "ping"
      pipe(future) to sender
  }
}


class Master extends Actor {
  val log = Logging(context.system, this)
  val pingy = ourSystem.actorOf(Props[Pingy], "pingy")
  val pongy = ourSystem.actorOf(Props[Pongy], "pongy")
  def receive = {
    case "start" =>
      pingy ! pongy
    case "pong" =>
      log.info("got a pong back!")
      context.stop(self)
  }
  override def postStop() = log.info("master going down")
}


object CommunicatingAsk extends App {
  val masta = ourSystem.actorOf(Props[Master], "masta")
  masta ! "start"
  Thread.sleep(1000)
  ourSystem.shutdown()
}


class Router extends Actor {
  var i = 0
  val children = for (_ <- 0 until 4) yield context.actorOf(Props[StringPrinter])
  def receive = {
    case "stop" => context.stop(self)
    case msg =>
      children(i) forward msg
      i = (i + 1) % 4
  }
}


object CommunicatingRouter extends App {
  val router = ourSystem.actorOf(Props[Router], "router")
  router ! "Hi."
  router ! "I'm talking to you!"
  Thread.sleep(1000)
  router ! "stop"
  Thread.sleep(1000)
  ourSystem.shutdown()
}


object CommunicatingPoisonPill extends App {
  val masta = ourSystem.actorOf(Props[Master], "masta")
  masta ! akka.actor.PoisonPill
  Thread.sleep(1000)
  ourSystem.shutdown()
}


class GracefulPingy extends Actor {
  val pongy = context.actorOf(Props[Pongy], "pongy")
  context.watch(pongy)

  def receive = {
    case GracefulPingy.CustomShutdown =>
      context.stop(pongy)
    case Terminated(`pongy`) =>
      context.stop(self)
  }
}


object GracefulPingy {
  object CustomShutdown
}


object CommunicatingGracefulStop extends App {
  val grace = ourSystem.actorOf(Props[GracefulPingy], "grace")
  val stopped = gracefulStop(grace, 3.seconds, GracefulPingy.CustomShutdown)
  stopped onComplete {
    case Success(x) =>
      log("graceful shutdown successful")
      ourSystem.shutdown()
    case Failure(t) =>
      log("grace not stopped!")
      ourSystem.shutdown()
  }
}







package org.learningconcurrency
package ch7






object CompositionSideEffects extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  val myValue = Ref(0)

  def inc() = atomic { implicit txn =>
    log(s"Incrementing ${myValue()}")
    myValue() = myValue() + 1
  }

  Future { inc() }
  Future { inc() }

}


object CompositionEscape extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  val myValue = Ref(0)

  atomic { implicit txn =>
    Future {
      Thread.sleep(500)
      myValue() = myValue() + 1
    } onComplete {
      case t => println(t)
    }
  }

  Thread.sleep(1000)
}


object CompositionCorrectSideEffect extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  val myValue = Ref(0)

  def inc() = atomic { implicit txn =>
    val valueAtStart = myValue()
    Txn.afterCommit { _ =>
      log(s"Incrementing $valueAtStart")
    }
    myValue() = myValue() + 1
  }

  Future { inc() }
  Future { inc() }

}


object CompositionLoggingRollback extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  val myValue = Ref(0)

  def inc() = atomic { implicit txn =>
    Txn.afterRollback { _ =>
      log(s"rollin' back")
    }
    myValue() = myValue() + 1
  }

  Future { inc() }
  Future { inc() }

}


object CompositionList extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  case class Node(val elem: Int, val next: Ref[Node]) {
    def append(n: Node): Unit = atomic { implicit txn =>
      val oldNext = next()
      next() = n
      n.next() = oldNext
    }
    def nextNode: Node = next.single()
    def appendIfEnd(n: Node) = next.single.transform {
      oldNext => if (oldNext == null) n else oldNext
    }
  }

  val nodes = Node(1, Ref(Node(4, Ref(Node(5, Ref(null))))))
  val f = Future { nodes.append(Node(2, Ref(null))) }
  val g = Future { nodes.append(Node(3, Ref(null))) }

  for (_ <- f; _ <- g) log(s"Next node is: ${nodes.nextNode}")

}


object CompositionMutations extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._
  import CompositionList.Node

  def nodeToString(n: Node): String = atomic { implicit txn =>
    val b = new StringBuilder
    var curr = n
    while (curr != null) {
      b ++= s"${curr.elem}, "
      curr = curr.next()
    }
    b.toString
  }

}


object CompositionSortedList extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._
  import CompositionList._
  import CompositionMutations._
  import scala.annotation.tailrec

  class TSortedList {
    val head = Ref[Node](null)

    override def toString = atomic { implicit txn =>
      val headNode = head()
      nodeToString(headNode)
    }

    def insert(x: Int): this.type = atomic { implicit txn =>
      @tailrec def insert(n: Node): Unit = {
        if (n.next() == null || n.next().elem > x) n.append(new Node(x, Ref(null)))
        else insert(n.next())
      }

      if (head() == null || head().elem > x) head() = new Node(x, Ref(head()))
      else insert(head())
      this
    }
  }

  val sortedList = new TSortedList

  val f = Future { sortedList.insert(1); sortedList.insert(4) }
  val g = Future { sortedList.insert(2); sortedList.insert(3) }

  for (_ <- f; _ <- g) log(s"sorted list - $sortedList")

}


object CompositionExceptions extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._
  import CompositionSortedList._

  def pop(lst: TSortedList, n: Int): Unit = atomic { implicit txn =>
    var left = n
    while (left > 0) {
      lst.head() = lst.head().next()
      left -= 1
    }
  }

  val lst = new TSortedList
  lst.insert(4)
  lst.insert(9)
  lst.insert(1)
  lst.insert(16)

  Future { pop(lst, 2) } foreach { case _ => log(s"removed 2 elements - $lst") }
  Thread.sleep(1000)
  Future { pop(lst, 3) }.failed foreach { case t => log(s"oops $t - $lst") }
  Thread.sleep(1000)
  Future {
    atomic { implicit txn =>
      pop(lst, 1)
      sys.error("")
    }
  }.failed foreach { case t => log(s"oops again $t - $lst") }
  Thread.sleep(1000)

  import scala.util.control.Breaks._
  Future {
    breakable {
      atomic { implicit txn =>
        for (n <- List(1, 2, 3)) {
          pop(lst, n)
          break
        }
      }
    }
    log(s"after removing - $lst")
  }
  Thread.sleep(1000)

  import scala.util.control._
  Future {
    breakable {
      atomic.withControlFlowRecognizer {
        case c: ControlThrowable => false
      } { implicit txn =>
        for (n <- List(1, 2, 3)) {
          pop(lst, n)
          break
        }
      }
    }
    log(s"after removing - $lst")
  }

}


object CompositionCatchingExceptions extends App {
  import scala.concurrent.stm._
  import CompositionSortedList._
  import CompositionExceptions.pop

  val lst = new TSortedList
  lst.insert(4)
  lst.insert(9)
  lst.insert(1)
  lst.insert(16)

  atomic { implicit txn =>
    // note - a failed nested transaction executes the top-level `afterRollback` callback!
    // Txn.afterRollback { _ => log(s"afterRollback") }
    pop(lst, 2)
    log(s"lst = $lst")
    try { pop(lst, 3) }
    catch { case e: Exception => log(s"Houston... $e!") }
    pop(lst, 1)
  }

  log(s"result - $lst")
}





package org.learningconcurrency
package ch6






object CompositionMapAndFilter extends App {
  import rx.lang.scala._
  import scala.concurrent.duration._

  val odds = Observable.interval(0.5.seconds).filter(_ % 2 == 1).map(n => s"odd number $n").take(5)
  odds.subscribe(log _, e => log(s"unexpected $e"), () => log("no more odds"))

  val evens = for (n <- Observable.from(0 until 9); if n % 2 == 0) yield s"even number $n"
  evens.subscribe(log _)

}


object CompositionConcatAndFlatten extends App {
  import rx.lang.scala._
  import scala.concurrent._
  import scala.concurrent.duration._
  import ExecutionContext.Implicits.global
  import scala.io.Source

  def fetchQuote(): Future[String] = Future {
    blocking {
      val url = "http://www.iheartquotes.com/api/v1/random?show_permalink=false&show_source=false"
      Source.fromURL(url).getLines.mkString
    }
  }

  def fetchQuoteObservable(): Observable[String] = Observable.from(fetchQuote())

  def quotes: Observable[Observable[String]] = Observable.interval(0.5.seconds).take(5).map {
    n => fetchQuoteObservable().map(txt => s"$n) $txt")
  }

  log(s"Using concat")
  quotes.concat.subscribe(log _)

  Thread.sleep(6000)

  log(s"Now using flatten")
  quotes.flatten.subscribe(log _)

  Thread.sleep(6000)

  log(s"Now using flatMap")
  Observable.interval(0.5.seconds).take(5).flatMap({
    n => fetchQuoteObservable().map(txt => s"$n) $txt")
  }).subscribe(log _)

  Thread.sleep(6000)

  log(s"Now using good ol' for-comprehensions")
  val qs = for {
    n   <- Observable.interval(0.5.seconds).take(5)
    txt <- fetchQuoteObservable()
  } yield s"$n) $txt"
  qs.subscribe(log _)

  Thread.sleep(6000)

}


// There is always one more bug.
object CompositionRetry extends App {
  import rx.lang.scala._
  import scala.concurrent.duration._
  import scala.io.Source
  import Observable._

  def randomQuote = Observable.create[String] { obs =>
    val url = "http://www.iheartquotes.com/api/v1/random?" +
      "show_permalink=false&show_source=false"
    obs.onNext(Source.fromURL(url).getLines.mkString)
    obs.onCompleted()
    Subscription()
  }

  def errorMessage = items("Retrying...") ++ error(new Exception)

  def shortQuote = for {
    txt     <- randomQuote
    message <- if (txt.length < 100) items(txt) else errorMessage
  } yield message

  shortQuote.retry(5).subscribe(log _, e => log(s"too long - $e"), () => log("done!"))

}


object CompositionScan extends App {
  import rx.lang.scala._

  CompositionRetry.shortQuote.retry.repeat.take(100).scan(0) {
    (n, q) => if (q == "Retrying...") n + 1 else n
  } subscribe(n => log(s"$n / 100"))
}


object CompositionReduce extends App {
  import rx.lang.scala._
  import scala.concurrent.duration._

  def shortQuote = CompositionRetry.randomQuote.retry.take(5).filter(_ != "Retrying...")
  val shortQuotesCollection = (shortQuote ++ shortQuote ++ shortQuote).foldLeft("") { (acc, q) =>
    s"$acc$q\n\n"
  }

  shortQuotesCollection.subscribe(log _)

}


object CompositionErrors extends App {
  import rx.lang.scala._

  val status = Observable[String] { sub =>
    sub.onNext("ok")
    sub.onNext("still ok")
    sub.onError(new Exception("very bad"))
  }

  val fixedStatus = status.onErrorReturn(e => e.getMessage)
  fixedStatus.subscribe(log _)

  val continuedStatus = status.onErrorResumeNext(e => Observable.items("better", "much better"))
  continuedStatus.subscribe(log _)

}






package org.learningconcurrency
package ch5






object ConcurrentWrong extends App {
  import scala.collection._
  import scala.concurrent.ExecutionContext.Implicits.global
  import ParHtmlSpecSearch.getHtmlSpec
  import ch4.FuturesCallbacks.getUrlSpec

  def intersection(a: GenSet[String], b: GenSet[String]): GenSet[String] = {
    val result = new mutable.HashSet[String]
    for (x <- a.par) if (b contains x) result.add(x)
    result
  }

  val ifut = for {
    htmlSpec <- getHtmlSpec()
    urlSpec <- getUrlSpec()
  } yield {
    val htmlWords = htmlSpec.mkString.split("\\s+").toSet
    val urlWords = urlSpec.mkString.split("\\s+").toSet
    intersection(htmlWords, urlWords)
  }

  ifut onComplete {
    case t => log(s"Result: $t")
  }
}


object ConcurrentCollections extends App {
  import java.util.concurrent.ConcurrentSkipListSet
  import scala.collection._
  import scala.collection.convert.decorateAsScala._
  import scala.concurrent.ExecutionContext.Implicits.global
  import ParHtmlSpecSearch.getHtmlSpec
  import ch4.FuturesCallbacks.getUrlSpec

  def intersection(a: GenSet[String], b: GenSet[String]): GenSet[String] = {
    val skiplist = new ConcurrentSkipListSet[String]
    for (x <- a.par) if (b contains x) skiplist.add(x)
    val result: Set[String] = skiplist.asScala
    result
  }

  val ifut = for {
    htmlSpec <- getHtmlSpec()
    urlSpec <- getUrlSpec()
  } yield {
    val htmlWords = htmlSpec.mkString.split("\\s+").toSet
    val urlWords = urlSpec.mkString.split("\\s+").toSet
    intersection(htmlWords, urlWords)
  }

  ifut foreach { case i =>
    log(s"intersection = $i")
  }

}


object ConcurrentCollectionsBad extends App {
  import java.util.concurrent.ConcurrentSkipListSet
  import scala.collection._
  import scala.collection.parallel._

  def toPar[T](c: ConcurrentSkipListSet[T]): ParSet[T] = ???

  val c = new ConcurrentSkipListSet[Int]
  for (i <- 0 until 100) c.add(i)

  for (x <- toPar(c)) c.add(x) // bad
}


object ConcurrentTrieMap extends App {
  import scala.collection._

  val cache = new concurrent.TrieMap[Int, String]()
  for (i <- 0 until 100) cache(i) = i.toString

  for ((number, string) <- cache.par) cache(-number) = s"-$string"

  log(s"cache - ${cache.keys.toList.sorted}")
}



package org.learningconcurrency
package ch5



import scala.collection.parallel._



class ParString(val str: String)
extends immutable.ParSeq[Char] {
  def apply(i: Int) = str.charAt(i)

  def length = str.length

  def seq = new collection.immutable.WrappedString(str)

  def splitter = new ParStringSplitter(str, 0, str.length)

  override def newCombiner = new ParStringCombiner

}


class ParStringSplitter(private val s: String, private var i: Int, private val limit: Int) extends SeqSplitter[Char] {
  final def hasNext = i < limit
  final def next = {
    val r = s.charAt(i)
    i += 1
    r
  }
  def remaining = limit - i
  def dup = new ParStringSplitter(s, i, limit)
  def split = {
    val rem = remaining
    if (rem >= 2) psplit(rem / 2, rem - rem / 2)
    else Seq(this)
  }
  def psplit(sizes: Int*): Seq[ParStringSplitter] = {
    val ss = for (sz <- sizes) yield {
      val nlimit = (i + sz) min limit
      val ps = new ParStringSplitter(s, i, nlimit)
      i = nlimit
      ps
    }
    if (i == limit) ss else ss :+ new ParStringSplitter(s, i, limit)
  }
}


class ParStringCombiner extends Combiner[Char, ParString] {
  import scala.collection.mutable.ArrayBuffer
  private var sz = 0
  private val chunks = new ArrayBuffer += new StringBuilder
  private var lastc = chunks.last

  def size: Int = sz

  def +=(elem: Char): this.type = {
    lastc += elem
    sz += 1
    this
  }

  def clear = {
    chunks.clear
    chunks += new StringBuilder
    lastc = chunks.last
    sz = 0
  }

  def result: ParString = {
    val rsb = new StringBuilder
    for (sb <- chunks) rsb.append(sb)
    new ParString(rsb.toString)
  }

  def combine[U <: Char, NewTo >: ParString](that: Combiner[U, NewTo]) =
    if (that eq this) this else that match {
      case that: ParStringCombiner =>
        sz += that.sz
        chunks ++= that.chunks
        lastc = chunks.last
        this
  }
}


object CustomCharCount extends App {
  val txt = "A custom text " * 250000
  val partxt = new ParString(txt)

  val seqtime = warmedTimed(50) {
    txt.foldLeft(0)((n, c) => if (Character.isUpperCase(c)) n + 1 else n)
  }

  log(s"Sequential time - $seqtime ms")

  val partime = warmedTimed(50) {
    partxt.aggregate(0)((n, c) => if (Character.isUpperCase(c)) n + 1 else n, _ + _)
  }

  log(s"Parallel time   - $partime ms")

}


object CustomCharFilter extends App {
  val txt = "A custom txt" * 25000
  val partxt = new ParString(txt)

  val seqtime = warmedTimed(250) {
    txt.filter(_ != ' ')
  }

  log(s"Sequential time - $seqtime ms")

  val partime = warmedTimed(250) {
    partxt.filter(_ != ' ')
  }

  log(s"Parallel time   - $partime ms")

}


package org.learningconcurrency
package ch9






object Deadlock extends App {

  class Account(var money: Int)

  def send(a: Account, b: Account, n: Int) = a.synchronized {
    b.synchronized {
      a.money -= n
      b.money += n
    }
  }

  val a = new Account(1000)
  val b = new Account(2000)
  val t1 = ch2.thread { for (i <- 0 until 100) send(a, b, 1) }
  val t2 = ch2.thread { for (i <- 0 until 100) send(b, a, 1) }
  t1.join()
  t2.join()

}


object Correctness extends App {
  import java.util.concurrent.atomic._
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.annotation.tailrec

  class Accumulator[T](z: T)(op: (T, T) => T) {
    private val value = new AtomicReference(z)
    @tailrec final def add(v: T): Unit = {
      val ov = value.get
      val nv = op(ov, v)
      if (!value.compareAndSet(ov, nv)) add(v)
    }
    def apply() = value.get
  }

  class CountDownLatch(n: Int)(onDone: =>Unit) {
    private val left = new AtomicInteger(n)
    def count() =
      if (left.decrementAndGet() == 0) onDone
  }

  def fold[T](fs: Seq[Future[T]])(z: T)(op: (T, T) => T): Future[T] = {
    val p = Promise[T]()
    val accu = new Accumulator(z)(op)
    val latch = new CountDownLatch(fs.length)({
      val total = accu()
      p.trySuccess(total)
    })
    for (f <- fs) f foreach { case v =>
      accu.add(v)
      latch.count()
    }
    p.future
  }

  val fs = for (i <- 0 until 5) yield Future { i }
  val folded = fold(fs)(0)(_ + _)
  folded foreach { case v => log(s"folded: $v") }

}


object Performance extends App {
  import java.util.concurrent.atomic._
  import scala.annotation.tailrec
  import org.scalameter._

  class Accumulator[T](z: T)(op: (T, T) => T) {
    private val value = new AtomicReference(z)
    @tailrec final def add(v: T): Unit = {
      val ov = value.get
      val nv = op(ov, v)
      if (!value.compareAndSet(ov, nv)) add(v)
    }
    def apply() = value.get
  }

  val time = measure {
    val acc = new Accumulator(0L)(_ + _)
    var i = 0
    val total = 1000000
    while (i < total) {
      acc.add(i)
      i += 1
    }
  }

  println("Running time: " + time)

  val accTime = config(
    Key.exec.minWarmupRuns -> 20,
    Key.exec.maxWarmupRuns -> 40,
    Key.exec.benchRuns -> 30,
    Key.verbose -> true
  ) withWarmer(new Warmer.Default) measure {
    val acc = new Accumulator(0L)(_ + _)
    var i = 0
    val total = 1000000
    while (i < total) {
      acc.add(i)
      i += 1
    }
  }

  println("Accumulator time: " + accTime)

  class LongAccumulator(z: Long)(op: (Long, Long) => Long) {
    private val value = new AtomicLong(z)
    @tailrec final def add(v: Long): Unit = {
      val ov = value.get
      val nv = op(ov, v)
      if (!value.compareAndSet(ov, nv)) add(v)
    }
    def apply() = value.get
  }

  val longAccTime = config(
    Key.exec.minWarmupRuns -> 20,
    Key.exec.maxWarmupRuns -> 40,
    Key.exec.benchRuns -> 30,
    Key.verbose -> true
  ) withWarmer(new Warmer.Default) measure {
    val acc = new LongAccumulator(0L)(_ + _)
    var i = 0
    val total = 1000000
    while (i < total) {
      acc.add(i)
      i += 1
    }
  }

  println("Long accumulator time: " + longAccTime)

  val longAccTime4 = config(
    Key.exec.minWarmupRuns -> 20,
    Key.exec.maxWarmupRuns -> 40,
    Key.exec.benchRuns -> 30,
    Key.verbose -> true
  ) withWarmer(new Warmer.Default) measure {
    val acc = new LongAccumulator(0L)(_ + _)
    val total = 1000000
    val p = 4
    val threads = for (j <- 0 until p) yield ch2.thread {
      val start = j * total / p
      var i = start
      while (i < start + total / p) {
        acc.add(i)
        i += 1
      }
    }
    for (t <- threads) t.join()
  }

  println("4 threads long accumulator time: " + longAccTime4)

  class ParLongAccumulator(z: Long)(op: (Long, Long) => Long) {
    private val par = Runtime.getRuntime.availableProcessors * 128
    private val values = new AtomicLongArray(par)
    @tailrec final def add(v: Long): Unit = {
      val id = Thread.currentThread.getId.toInt
      val i = math.abs(scala.util.hashing.byteswap32(id)) % par
      val ov = values.get(i)
      val nv = op(ov, v)
      if (!values.compareAndSet(i, ov, nv)) add(v)
    }
    def apply(): Long = {
      var total = 0L
      for (i <- 0 until values.length) total = op(total, values.get(i))
      total
    }
  }

  val parLongAccTime = config(
    Key.exec.minWarmupRuns -> 100,
    Key.exec.maxWarmupRuns -> 200,
    Key.exec.benchRuns -> 80,
    Key.verbose -> true
  ) withWarmer(new Warmer.Default) measure {
    val acc = new ParLongAccumulator(0L)(_ + _)
    val total = 1000000
    val p = 4
    val threads = for (j <- 0 until p) yield ch2.thread {
      val start = j * total / p
      var i = start
      while (i < start + total / p) {
        acc.add(i)
        i += 1
      }
    }
    for (t <- threads) t.join()
  }

  println("Parallel long accumulator time: " + parLongAccTime)

}

package org.learningconcurrency
package ch3






object ExecutorsCreate extends App {
  import scala.concurrent._
  val executor = new java.util.concurrent.ForkJoinPool
  executor.execute(new Runnable {
    def run() = log("This task is run asynchronously.")
  })
}


object ExecutionContextGlobal extends App {
  import scala.concurrent._
  val ectx = ExecutionContext.global
  ectx.execute(new Runnable {
    def run() = log("Running on the execution context.")
  })
}


object ExecutionContextCreate extends App {
  import scala.concurrent._
  val ectx = ExecutionContext.fromExecutorService(new forkjoin.ForkJoinPool)
  ectx.execute(new Runnable {
    def run() = log("Running on the execution context again.")
  })
}


object ExecutionContextSleep extends App {
  import scala.concurrent._
  for (i <- 0 until 32) execute {
    Thread.sleep(2000)
    log(s"Task $i completed.")
  }
  Thread.sleep(10000)
}


package org.learningconcurrency
package ch3



import java.io._
import java.util.concurrent._
import java.util.concurrent.atomic._
import scala.annotation.tailrec
import scala.collection._
import scala.collection.convert.decorateAsScala._
import org.apache.commons.io.FileUtils



object FileSystemTest extends App {
  val fileSystem = new FileSystem(".")

  fileSystem.logMessage("Testing log!")

  fileSystem.deleteFile("test.txt")

  fileSystem.copyFile("build.sbt", "build.sbt.backup")

  val rootFiles = fileSystem.filesInDir("")
  log("All files in the root dir: " + rootFiles.mkString(", "))
}


class FileSystem(val root: String) {

  val logger = new Thread {
    setDaemon(true)
    override def run() {
      while (true) {
        val msg = messages.take()
        log(msg)
      }
    }
  }

  logger.start()

  private val messages = new LinkedBlockingQueue[String]

  def logMessage(msg: String): Unit = messages.add(msg)

  sealed trait State

  class Idle extends State

  class Creating extends State

  class Copying(val n: Int) extends State

  class Deleting extends State

  class Entry(val isDir: Boolean) {
    val state = new AtomicReference[State](new Idle)
  }

  val files: concurrent.Map[String, Entry] =
    //new ConcurrentHashMap().asScala
    new concurrent.TrieMap()

  for (file <- FileUtils.iterateFiles(new File(root), null, false).asScala) {
    files.put(file.getName, new Entry(false))
  }

  @tailrec private def prepareForDelete(entry: Entry): Boolean = {
    val s0 = entry.state.get
    s0 match {
      case i: Idle =>
        if (entry.state.compareAndSet(s0, new Deleting)) true
        else prepareForDelete(entry)
      case c: Creating =>
        logMessage("File currently being created, cannot delete.")
        false
      case c: Copying =>
        logMessage("File currently being copied, cannot delete.")
        false
      case d: Deleting =>
        false
    }
  }

  def deleteFile(filename: String): Unit = {
    files.get(filename) match {
      case None =>
        logMessage(s"Cannot delete - path '$filename' does not exist!")
      case Some(entry) if entry.isDir =>
        logMessage(s"Cannot delete - path '$filename' is a directory!")
      case Some(entry) =>
        execute {
          if (prepareForDelete(entry)) {
            if (FileUtils.deleteQuietly(new File(filename)))
              files.remove(filename)
          }
        }
    }
  }

  @tailrec private def acquire(entry: Entry): Boolean = {
    val s0 = entry.state.get
    s0 match {
      case _: Creating | _: Deleting =>
        logMessage("File inaccessible, cannot copy.")
        false
      case i: Idle =>
        if (entry.state.compareAndSet(s0, new Copying(1))) true
        else acquire(entry)
      case c: Copying =>
        if (entry.state.compareAndSet(s0, new Copying(c.n + 1))) true
        else acquire(entry)
    }
  }

  @tailrec private def release(entry: Entry): Unit = {
    val s0 = entry.state.get
    s0 match {
      case i: Idle =>
        sys.error("Error - released more times than acquired.")
      case c: Creating =>
        if (!entry.state.compareAndSet(s0, new Idle)) release(entry)
      case c: Copying if c.n <= 0 =>
        sys.error("Error - cannot have 0 or less copies in progress!")
      case c: Copying =>
        val newState = if (c.n == 1) new Idle else new Copying(c.n - 1)
        if (!entry.state.compareAndSet(s0, newState)) release(entry)
      case d: Deleting =>
        sys.error("Error - releasing a file that is being deleted!")
    }
  }

  def copyFile(src: String, dest: String): Unit = {
    files.get(src) match {
      case None =>
        logMessage(s"File '$src' does not exist.")
      case Some(srcEntry) if srcEntry.isDir =>
        sys.error(s"Path '$src' is a directory!")
      case Some(srcEntry) =>
        execute {
          if (acquire(srcEntry)) try {
            val destEntry = new Entry(false)
            destEntry.state.set(new Creating)
            if (files.putIfAbsent(dest, destEntry) == None) try {
              FileUtils.copyFile(new File(src), new File(dest))
            } finally release(destEntry)
          } finally release(srcEntry)
        }
    }
  }

  def filesInDir(dir: String): Iterable[String] = {
    // trie map snapshots
    for ((name, state) <- files; if name.startsWith(dir)) yield name
  }

}package org.learningconcurrency
package ch9



import scala.collection._
import scala.util.{Try, Success, Failure}
import scala.swing._
import scala.swing.event._
import javax.swing.table._
import javax.swing._
import javax.swing.border._
import java.awt.Color
import java.io.File
import rx.lang.scala._
import scala.concurrent._
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._
import akka.actor._
import akka.pattern.{ask, pipe}
import akka.util.Timeout
import ch6._



abstract class FTPClientFrame extends MainFrame {
  import BorderPanel.Position._

  title = "ScalaFTP"

  class FilePane extends BorderPanel {
    object pathBar extends BorderPanel {
      val label = new Label("Path:")
      val filePath = new TextField(".") {
        border = BorderFactory.createLineBorder(Color.LIGHT_GRAY, 1, true)
        editable = false
      }
      val upButton = new Button("^")
      layout(label) = West
      layout(filePath) = Center
      layout(upButton) = East
      border = BorderFactory.createEmptyBorder(2, 2, 2, 2)
    }
    layout(pathBar) = North

    object scrollPane extends ScrollPane {
      val columnNames = Array[AnyRef]("Filename", "Size", "Date modified")
      val fileTable = new Table {
        showGrid = true
        model = new DefaultTableModel(columnNames, 0) {
          override def isCellEditable(r: Int, c: Int) = false
        }
        selection.intervalMode = Table.IntervalMode.Single
      }
      contents = fileTable
    }
    layout(scrollPane) = Center

    object buttons extends GridPanel(1, 2) {
      val copyButton = new Button("Copy")
      val deleteButton = new Button("Delete")
      contents += copyButton
      contents += deleteButton
    }
    layout(buttons) = South

    var parent: String = "."
    var dirFiles: Seq[FileInfo] = Nil

    def table = scrollPane.fileTable

    def currentPath = pathBar.filePath.text
  }

  object files extends GridPanel(1, 2) {
    val leftPane = new FilePane
    val rightPane = new FilePane
    contents += leftPane
    contents += rightPane

    def opposite(pane: FilePane) = {
      if (pane eq leftPane) rightPane else leftPane
    }
  }

  object menu extends MenuBar {
    object file extends Menu("File") {
      val exit = new MenuItem("Exit ScalaFTP")
      contents += exit
    }
    object help extends Menu("Help") {
      val about = new MenuItem("About...")
      contents += about
    }
    contents += file
    contents += help
  }

  object status extends BorderPanel {
    val label = new Label("connecting...", null, Alignment.Left)
    layout(new Label("Status: ")) = West
    layout(label) = Center
  }

  contents = new BorderPanel {
    layout(menu) = North
    layout(files) = Center
    layout(status) = South
  }

}


class FTPClientActor(implicit val timeout: Timeout) extends Actor {
  import FTPClientActor._
  import FTPServerActor._

  def unconnected: Actor.Receive = {
    case Start(host) =>
      // connect to server
      val serverActorPath = s"akka.tcp://FTPServerSystem@$host/user/server"
      val serverActorSel = context.actorSelection(serverActorPath)
      serverActorSel ! Identify(())
      context.become(connecting(sender))
  }

  def connecting(application: ActorRef): Actor.Receive = {
    case ActorIdentity(_, Some(ref)) =>
      application ! true
      println("found: " + ref)
      context.become(connected(ref))
    case ActorIdentity(_, None) =>
      application ! false
      context.become(unconnected)
  }

  def connected(serverActor: ActorRef): Actor.Receive = {
    case command: Command =>
      (serverActor ? command).pipeTo(sender)
  }

  def receive = unconnected

}


object FTPClientActor {
  case class Start(serverActorUrl: String)
}


trait FTPClientApi {
  implicit val timeout: Timeout = Timeout(4 seconds)
  val system = ch8.remotingSystem("FTPClientSystem", 0)
  val clientActor = system.actorOf(Props(classOf[FTPClientActor], timeout))

  def host: String

  val connected: Future[Boolean] = {
    val f = clientActor ? FTPClientActor.Start(host)
    f.mapTo[Boolean]
  }

  def getFileList(dir: String): Future[(String, Seq[FileInfo])] = {
    val f = clientActor ? FTPServerActor.GetFileList(dir)
    f.mapTo[Seq[FileInfo]].map(fs => (dir, fs))
  }

  def copyFile(srcpath: String, destpath: String): Future[String] = {
    val f = clientActor ? FTPServerActor.CopyFile(srcpath, destpath)
    f.mapTo[Try[String]].map {
      case Success(s) => s
      case Failure(t) => throw t
    }
  }

  def deleteFile(srcpath: String): Future[String] = {
    val f = clientActor ? FTPServerActor.DeleteFile(srcpath)
    f.mapTo[Try[String]].map {
      case Success(s) => s
      case Failure(t) => throw t
    }
  }

}


trait FTPClientLogic {
  self: FTPClientFrame with FTPClientApi =>

  connected.onComplete {
    case Success(true) =>
      swing {
        status.label.text = "Connected!"
        refreshPane(files.leftPane)
        refreshPane(files.rightPane)
      }
    case Success(false) =>
      swing { status.label.text = "Could not find server." }
    case Failure(t) =>
      swing { status.label.text = s"Could not connect to server: $t" }
  }

  def updatePane(pane: FilePane, dir: String, files: Seq[FileInfo]): Unit = {
    val table = pane.scrollPane.fileTable
    table.model match {
      case d: DefaultTableModel =>
        d.setRowCount(0)
        pane.parent = if (dir == ".") "." else dir.take(dir.lastIndexOf(File.separator))
        pane.dirFiles = files.sortBy(!_.isDir)
        for (f <- pane.dirFiles) d.addRow(f.toRow)
    }
  }

  def refreshPane(pane: FilePane): Unit = {
    val dir = pane.pathBar.filePath.text
    getFileList(dir) onComplete {
      case Success((dir, files)) =>
        swing { updatePane(pane, dir, files) }
      case Failure(t) =>
        swing { status.label.text = s"Could not update file pane: $t" }
    }
  }

  def setupPane(pane: FilePane): Unit = {
    val fileClicks = pane.table.rowDoubleClicks.map(row => pane.dirFiles(row))
    fileClicks.filter(_.isDir).subscribe { fileInfo =>
      pane.pathBar.filePath.text = pane.pathBar.filePath.text + File.separator + fileInfo.name
      refreshPane(pane)
    }
    pane.pathBar.upButton.clicks.subscribe { _ =>
      pane.pathBar.filePath.text = pane.parent
      refreshPane(pane)
    }

    def rowActions(button: Button): Observable[FileInfo] = button.clicks
      .map(_ => pane.table.peer.getSelectedRow)
      .filter(_ != -1)
      .map(row => pane.dirFiles(row))
    def setStatus(txt: String) = {
      status.label.text = txt
      refreshPane(files.leftPane)
      refreshPane(files.rightPane)
    }

    val rowCopies = rowActions(pane.buttons.copyButton)
      .map(info => (info, files.opposite(pane).currentPath))
    rowCopies.subscribe { t =>
      val (info, destDir) = t
      val dest = destDir + File.separator + info.name
      copyFile(info.path, dest) onComplete {
        case Success(s) =>
          swing { setStatus(s"File copied: $s") }
        case Failure(t) =>
          swing { setStatus(s"Could not copy file: $t")}
      }
    }

    val rowDeletes = rowActions(pane.buttons.deleteButton)
    rowDeletes.subscribe { info =>
      deleteFile(info.path) onComplete {
        case Success(s) =>
          swing { setStatus(s"File deleted: $s") }
        case Failure(t) =>
          swing { setStatus(s"Could not delete file: $t") }
      }
    }
  }

  setupPane(files.leftPane)
  setupPane(files.rightPane)

  menu.file.exit.reactions += {
    case ButtonClicked(_) =>
      system.stop(clientActor)
      system.shutdown()
      sys.exit(0)
  }

  menu.help.about.reactions += {
    case ButtonClicked(_) =>
      Dialog.showMessage(message = "ScalaFTP version 0.1, made in Switzerland", title = "About ScalaFTP")
  }

}


object FTPClient extends SimpleSwingApplication {

  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName)
  } catch {
    case e: Exception =>
      // ignore
      log(s"could not change look&feel: $e")
  }

  def top = new FTPClientFrame with FTPClientApi with FTPClientLogic {
    def host = hostArg
  }

  var hostArg: String = ""

  override def main(args: Array[String]) {
    hostArg = if (args.length > 0) args(0) else {
      println("usage (from sbt):")
      println("    run <ftp-server-url>")
      println("    runMain org.learningconcurrency.ch9.FTPClient <ftp-server-url>")
      sys.exit(1)
    }
    super.main(args)
  }

}

package org.learningconcurrency
package ch9



import rx.lang.scala._
import scala.collection._
import scala.util.Try
import scala.concurrent._
import scala.concurrent.ExecutionContext.Implicits.global
import akka.actor._
import akka.pattern.pipe
import akka.event.Logging
import scala.concurrent.stm._
import java.io._
import org.apache.commons.io.FileUtils
import org.apache.commons.io.filefilter.TrueFileFilter
import scala.collection._
import scala.collection.convert.decorateAsScala._



class FileSystem(val rootpath: String) {
  val files = TMap[String, FileInfo]()

  def init() = atomic { implicit txn =>
    files.clear()

    val rootDir = new File(rootpath)
    val all = TrueFileFilter.INSTANCE
    val fileIterator = FileUtils.iterateFilesAndDirs(rootDir, all, all).asScala
    for (file <- fileIterator) {
      val info = FileInfo(file)
      //if (info.isDir && info.path.contains("src")) println(info)
      files(info.path) = info
    }
  }

  def getFileList(dir: String): Map[String, FileInfo] = atomic { implicit txn =>
    files.filter(_._2.parent == dir)
  }

  private def copyOnDisk(srcfile: File, destfile: File) = {
    FileUtils.copyFile(srcfile, destfile)
    atomic { implicit txn =>
      val ninfo = files(srcfile.getPath)
      files(srcfile.getPath) = ninfo.copy(state = ninfo.state.dec)
      files(destfile.getPath) = FileInfo(destfile)
    }
  }

  def copyFile(srcpath: String, destpath: String): String = atomic { implicit txn =>
    import FileSystem._
    val srcfile = new File(srcpath)
    val destfile = new File(destpath)
    val info = files(srcpath)
    if (files.contains(destpath)) sys.error(s"Destination $destpath already exists.")
    info.state match {
      case Created => sys.error(s"File $srcpath being created.")
      case Deleted => sys.error(s"File $srcpath already deleted.")
      case Idle | Copying(_) =>
        files(srcpath) = info.copy(state = info.state.inc)
        files(destpath) = FileInfo.creating(destfile, info.size)
        Txn.afterCommit { _ => copyOnDisk(srcfile, destfile) }
        srcpath
    }
  }

  def deleteFile(srcpath: String): String = atomic { implicit txn =>
    import FileSystem._
    val info = files(srcpath)
    info.state match {
      case Created => sys.error(s"File $srcpath not yet created.")
      case Copying(_) => sys.error(s"Cannot delete $srcpath, file being copied.")
      case Deleted => sys.error(s"File $srcpath already being deleted.")
      case Idle =>
        files(srcpath) = info.copy(state = Deleted)
        Txn.afterCommit { _ =>
          FileUtils.forceDelete(info.toFile)
          files.single.remove(srcpath)
        }
        srcpath
    }
  }

  def findFiles(regex: String): Seq[FileInfo] = {
    val snapshot = files.single.snapshot
    val infos = snapshot.values.toArray
    infos.par.filter(_.path.matches(regex)).seq
  }

}


object FileSystem {
  sealed trait State {
    def inc: State
    def dec: State
  }
  case object Created extends State {
    def inc = sys.error("File being created.")
    def dec = sys.error("File being created.")
  }
  case object Idle extends State {
    def inc = Copying(1)
    def dec = sys.error("Idle not copied.")
  }
  case class Copying(n: Int) extends State {
    def inc = Copying(n + 1)
    def dec = if (n > 1) Copying(n - 1) else Idle
  }
  case object Deleted extends State {
    def inc = sys.error("Cannot copy deleted.")
    def dec = sys.error("Deleted not copied")
  }
}


class FTPServerActor(fileSystem: FileSystem) extends Actor {
  import FTPServerActor._

  val log = Logging(context.system, this)

  def receive = {
    case GetFileList(dir) =>
      //println(fileSystem.files.snapshot.map(_._2).filter(_.isDir).filter(_.path.contains("src")).mkString("\n"))
      val filesMap = fileSystem.getFileList(dir)
      val files = filesMap.map(_._2).to[Seq]
      sender ! files
    case CopyFile(srcpath, destpath) =>
      Future {
        Try(fileSystem.copyFile(srcpath, destpath))
      } pipeTo sender
    case DeleteFile(path) =>
      Future {
        Try(fileSystem.deleteFile(path))
      } pipeTo sender
    case FindFiles(regex) =>
      Future {
        Try(fileSystem.findFiles(regex))
      } pipeTo sender
  }
}


object FTPServerActor {
  sealed trait Command
  case class GetFileList(dir: String) extends Command
  case class CopyFile(srcpath: String, destpath: String) extends Command
  case class DeleteFile(path: String) extends Command
  case class FindFiles(regex: String) extends Command

  def apply(fs: FileSystem) = Props(classOf[FTPServerActor], fs)
}


object FTPServer extends App {
  val fileSystem = new FileSystem(".")
  fileSystem.init()

  val port = args(0).toInt
  val actorSystem = ch8.remotingSystem("FTPServerSystem", port)
  val serverActor = actorSystem.actorOf(FTPServerActor(fileSystem), "server")
  val fileEventSubscription = fileSystemEvents(".").subscribe { event =>
    event match {
      case FileCreated(path) =>
        fileSystem.files.single(path) = FileInfo(new File(path))
      case FileDeleted(path) =>
        fileSystem.files.single.remove(path)
      case FileModified(path) =>
        fileSystem.files.single(path) = FileInfo(new File(path))
    }
  }
}


object FTPServerBench extends App {
  import org.scalameter._

  val fileSystem = new FileSystem(".")
  fileSystem.init()

  val runningTime = config(
    Key.exec.minWarmupRuns -> 100,
    Key.exec.maxWarmupRuns -> 200,
    Key.exec.benchRuns -> 1000,
    Key.verbose -> true
  ) withWarmer(new Warmer.Default) measure {
    fileSystem.findFiles(".*ch5.*")
  }

  println("Running time: " + runningTime)

}








package org.learningconcurrency
package ch4






object FuturesComputation extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global

  Future {
    log(s"the future is here")
  }

  log(s"the future is coming")

}


object FuturesDataType extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.io.Source

  val buildFile: Future[String] = Future {
    val f = Source.fromFile("build.sbt")
    try f.getLines.mkString("\n") finally f.close()
  }

  log(s"started reading build file asynchronously")
  log(s"status: ${buildFile.isCompleted}")
  Thread.sleep(250)
  log(s"status: ${buildFile.isCompleted}")
  log(s"status: ${buildFile.value}")

}


object FuturesCallbacks extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.io.Source

  def getUrlSpec(): Future[Seq[String]] = Future {
    val f = Source.fromURL("http://www.w3.org/Addressing/URL/url-spec.txt")
    try f.getLines.toList finally f.close()
  }

  val urlSpec: Future[Seq[String]] = getUrlSpec()

  def find(lines: Seq[String], word: String) = lines.zipWithIndex collect {
    case (line, n) if line.contains(word) => (n, line)
  } mkString("\n")

  urlSpec foreach {
    lines => log(s"Found occurrences of 'telnet'\n${find(lines, "telnet")}\n")
  }

  urlSpec foreach {
    lines => log(s"Found occurrences of 'password'\n${find(lines, "password")}\n")
  }

  log("callbacks installed, continuing with other work")

}


object FuturesFailure extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.io.Source

  val urlSpec: Future[String] = Future {
    Source.fromURL("http://www.w3.org/non-existent-url-spec.txt").mkString
  }

  urlSpec.failed foreach {
    case t => log(s"exception occurred - $t")
  }
}


object FuturesExceptions extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.io.Source

  val file = Future { Source.fromFile(".gitignore-SAMPLE").getLines.mkString("\n") }

  file foreach {
    text => log(text)
  }

  file.failed foreach {
    case fnfe: java.io.FileNotFoundException => log(s"Cannot find file - $fnfe")
    case t => log(s"Failed due to $t")
  }

  import scala.util.{Try, Success, Failure}

  file onComplete {
    case Success(text) => log(text)
    case Failure(t) => log(s"Failed due to $t")
  }

}


object FuturesTry extends App {
  import scala.util._

  val threadName: Try[String] = Try(Thread.currentThread.getName)
  val someText: Try[String] = Try("Try objects are created synchronously")
  val message: Try[String] = for {
    tn <- threadName
    st <- someText
  } yield s"$st, t = $tn"

  message match {
    case Success(msg) => log(msg)
    case Failure(error) => log(s"There should be no $error here.")
  }

}


object FuturesNonFatal extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global

  val f = Future { throw new InterruptedException }
  val g = Future { throw new IllegalArgumentException }
  f.failed foreach { case t => log(s"error - $t") }
  g.failed foreach { case t => log(s"error - $t") }
}


object FuturesClumsyCallback extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import org.apache.commons.io.FileUtils._
  import java.io._
  import scala.io.Source
  import scala.collection.convert.decorateAsScala._

  def blacklistFile(filename: String) = Future {
    val lines = Source.fromFile(filename).getLines
    lines.filter(!_.startsWith("#")).toList
  }

  def findFiles(patterns: List[String]): List[String] = {
    val root = new File(".")
    for {
      f <- iterateFiles(root, null, true).asScala.toList
      pat <- patterns
      abspat = root.getCanonicalPath + File.separator + pat
      if f.getCanonicalPath.contains(abspat)
    } yield f.getCanonicalPath
  }

  blacklistFile(".gitignore") foreach {
    case lines =>
      val files = findFiles(lines)
      log(s"matches: ${files.mkString("\n")}")
  }
}


object FuturesMap extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.io.Source
  import scala.util.Success

  val buildFile = Future { Source.fromFile("build.sbt").getLines }
  val gitignoreFile = Future { Source.fromFile(".gitignore-SAMPLE").getLines }

  val longestBuildLine = buildFile.map(lines => lines.maxBy(_.length))
  val longestGitignoreLine = for (lines <- gitignoreFile) yield lines.maxBy(_.length)

  longestBuildLine onComplete {
    case Success(line) => log(s"the longest line is '$line'")
  }

  longestGitignoreLine.failed foreach {
    case t => log(s"no longest line, because ${t.getMessage}")
  }
}


object FuturesFlatMapRaw extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.io.Source

  val netiquette = Future { Source.fromURL("http://www.ietf.org/rfc/rfc1855.txt").mkString }
  val urlSpec = Future { Source.fromURL("http://www.w3.org/Addressing/URL/url-spec.txt").mkString }
  val answer = netiquette.flatMap { nettext =>
    urlSpec.map { urltext =>
      "First, read this: " + nettext + ". Now, try this: " + urltext
    }
  }

  answer foreach {
    case contents => log(contents)
  }
}


object FuturesFlatMap extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.io.Source

  val netiquette = Future { Source.fromURL("http://www.ietf.org/rfc/rfc1855.txt").mkString }
  val urlSpec = Future { Source.fromURL("http://www.w3.org/Addressing/URL/url-spec.txt").mkString }
  val answer = for {
    nettext <- netiquette
    urltext <- urlSpec
  } yield {
    "First of all, read this: " + nettext + " Once you're done, try this: " + urltext
  }

  answer foreach {
    case contents => log(contents)
  }

}


object FuturesDifferentFlatMap extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.io.Source

  val answer = for {
    nettext <- Future { Source.fromURL("http://www.ietf.org/rfc/rfc1855.txt").mkString }
    urltext <- Future { Source.fromURL("http://www.w3.org/Addressing/URL/url-spec.txt").mkString }
  } yield {
    "First of all, read this: " + nettext + " Once you're done, try this: " + urltext
  }

  answer foreach {
    case contents => log(contents)
  }

}


object FuturesRecover extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.io.Source

  val netiquetteUrl = "http://www.ietf.org/rfc/rfc1855.doc"
  val netiquette = Future { Source.fromURL(netiquetteUrl).mkString } recover {
    case f: java.io.FileNotFoundException =>
      "Dear boss, thank you for your e-mail." +
      "You might be interested to know that ftp links " +
      "can also point to regular files we keep on our servers."
  }

  netiquette foreach {
    case contents => log(contents)
  }

}


object FuturesReduce extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global

  val squares = for (i <- 0 until 10) yield Future { i * i }
  val sumOfSquares = Future.reduce(squares)(_ + _)

  sumOfSquares foreach {
    case sum => log(s"Sum of squares = $sum")
  }
}



package org.learningconcurrency
package ch2






object JMMPublicationWrong extends App {
  class Num(var x: Int)
  var num = new Num(-1)
  val t = thread {
    for (i <- 1 until 10000000) num = new Num(i)
  }
  while (t.isAlive) assert(num.x != 0)
}


object JMMPublicationRight extends App {
  class Num(val x: Int)
  @volatile var num = new Num(-1)
  val t = thread {
    for (i <- 1 until 10000000) num = new Num(i)
  }
  while (t.isAlive) assert(num.x != 0)
}

//  rules for happens-before are:
// Program order rule. Each action in a thread happens-before every ac-
// tion in that thread that comes later in the program order.
// Monitor lock rule. An unlock on a monitor lock happens-before every
// subsequent lock on that same monitor lock.3
// Volatile variable rule. A write to a volatile field happens-before every
// subsequent read of that same field.4
// Thread start rule. A call to Thread.start on a thread happens-before
// every action in the started thread.
// Thread termination rule. Any action in a thread happens-before any other thread detects that thread has terminated, either by success- fully return from Thread.join or by Thread.isAlive returning false.
// Interruption rule. A thread calling interrupt on another thread happens-before the interrupted thread detects the interrupt (either by having InterruptedException thrown, or invoking isInter- rupted or interrupted).
// Finalizer rule. The end of a constructor for an object happens-before the start of the finalizer for that object.
// Transitivity. If A happens-before B, and B happens-before C, then A happens-before C.


package org.learningconcurrency
package ch3






object LazyValsCreate extends App {
  import scala.concurrent._

  lazy val obj = new AnyRef
  lazy val nondeterministic = s"made by ${Thread.currentThread.getName}"

  execute {
    log(s"Execution context thread sees object = $obj")
    log(s"Execution context thread sees nondeterministic = $nondeterministic")
  }

  log(s"Main thread sees object = $obj")
  log(s"Main thread sees nondeterministic = $nondeterministic")
}


object LazyValsObject extends App {
  object Lazy {
    log("Running Lazy constructor.")
  }

  log("Main thread is about to reference Lazy.")
  Lazy
  log("Main thread completed.")
}


object LazyValsUnderTheHood extends App {
  @volatile private var _bitmap = false
  private var _obj: AnyRef = _
  def obj = if (_bitmap) _obj else this.synchronized {
    if (!_bitmap) {
      _obj = new AnyRef
      _bitmap = true
    }
    _obj
  }

  log(s"$obj"); log(s"$obj")
}


object LazyValsInspectMainThread extends App {
  val mainThread = Thread.currentThread

  lazy val x = {
    log(s"running Lazy ctor")
    Thread.sleep(1000)
    log(s"main thread state - ${mainThread.getState}")
  }

  execute { x }

  log("started asynchronous thread")
  Thread.sleep(200)
  log("log about to access x")
  x
}


object LazyValsDeadlock extends App {
  object A {
    lazy val x: Int = B.y
  }
  object B {
    lazy val y: Int = A.x
  }

  execute { B.y }

  A.x
}


object LazyValsAndSynchronized extends App {
  lazy val terminatedThread = {
    val t = ch2.thread {
      LazyValsAndSynchronized.synchronized {}
    }
    t.join()
    t.getState
  }

  terminatedThread
}


object LazyValsAndBlocking extends App {
  lazy val x: Int = {
    val t = ch2.thread {
      println(s"Initializing $x.")
    }
    t.join()
    1
  }
  x
}


object LazyValsAndMonitors extends App {
  lazy val x = 1
  this.synchronized {
    val t = ch2.thread { x }
    t.join()
  }
}




package org.learningconcurrency
package ch6






object ObservablesItems extends App {
  import rx.lang.scala._

  val o = Observable.items("Pascal", "Java", "Scala")
  o.subscribe(name => log(s"learned the $name language"))
  o.subscribe(name => log(s"forgot the $name language"))

}


object ObservablesTimer extends App {
  import rx.lang.scala._
  import scala.concurrent.duration._

  val o = Observable.timer(1.second)
  o.subscribe(_ => log(s"Timeout!"))
  o.subscribe(_ => log(s"Another timeout!"))
}


object ObservablesExceptions extends App {
  import rx.lang.scala._

  val o = Observable.items(1, 2) ++ Observable.error(new RuntimeException) ++ Observable.items(3, 4)
  o.subscribe(
    x => log(s"number $x"),
    t => log(s"an error occurred: $t")
  )
}


object ObservablesLifetime extends App {
  import rx.lang.scala._

  val classics = List("Il buono, il brutto, il cattivo.", "Back to the future", "Die Hard")
  val o = Observable.from(classics)

  o.subscribe(new Observer[String] {
    override def onNext(m: String) = log(s"Movies Watchlist - $m")
    override def onError(e: Throwable) = log(s"Ooops - $e!")
    override def onCompleted() = log(s"No more movies.")
  })
}


object ObservablesCreate extends App {
  import rx.lang.scala._

  val vms = Observable.create[String] { obs =>
    obs.onNext("JVM")
    obs.onNext(".NET")
    obs.onNext("DartVM")
    obs.onCompleted()
    Subscription()
  }

  log(s"About to subscribe")
  vms.subscribe(log _, e => log(s"oops - $e"), () => log("Done!"))
  log(s"Subscription returned")

}


object ObservablesCreateFuture extends App {
  import rx.lang.scala._
  import scala.concurrent._
  import ExecutionContext.Implicits.global

  val f = Future {
    Thread.sleep(500)
    "Back to the Future(s)"
  }

  val o = Observable.create[String] { obs =>
    f foreach {
      case s =>
        obs.onNext(s)
        obs.onCompleted()
    }
    f.failed foreach {
      case t => obs.onError(t)
    }
    Subscription()
  }

  o.subscribe(log _)

}


object ObservablesFromFuture extends App {
  import rx.lang.scala._
  import scala.concurrent._
  import ExecutionContext.Implicits.global

  val o = Observable.from(Future {
    Thread.sleep(500)
    "Back to the Future(s)"
  })

  o.subscribe(log _)
}


object ObservablesCombinators extends App {
  import rx.lang.scala._

  val roles = Observable.items("The Good", "The Bad", "The Ugly")
  val names = Observable.items("Clint Eastwood", "Lee Van Cleef", "Eli Wallach")
  val zipped = names.zip(roles).map { case (name, role) => s"$name - $role" }

  zipped.subscribe(log _)

}


object ObservablesSubscriptions extends App {
  import rx.lang.scala._
  import org.apache.commons.io.monitor._

  def modifiedFiles(directory: String): Observable[String] = {
    Observable.create { observer =>
      val fileMonitor = new FileAlterationMonitor(1000)
      val fileObs = new FileAlterationObserver(directory)
      val fileLis = new FileAlterationListenerAdaptor {
        override def onFileChange(file: java.io.File) {
          observer.onNext(file.getName)
        }
      }
      fileObs.addListener(fileLis)
      fileMonitor.addObserver(fileObs)
      fileMonitor.start()

      Subscription { fileMonitor.stop() }
    }
  }

  log(s"starting to monitor files")
  val subscription = modifiedFiles(".").subscribe(filename => log(s"$filename modified!"))
  log(s"please modify and save a file")

  Thread.sleep(10000)

  subscription.unsubscribe()
  log(s"monitoring done")

}


object ObservablesHot extends App {
  import rx.lang.scala._
  import org.apache.commons.io.monitor._

  val fileMonitor = new FileAlterationMonitor(1000)
  fileMonitor.start()

  def modifiedFiles(directory: String): Observable[String] = {
    val fileObs = new FileAlterationObserver(directory)
    fileMonitor.addObserver(fileObs)
    Observable.create { observer =>
      val fileLis = new FileAlterationListenerAdaptor {
        override def onFileChange(file: java.io.File) {
          observer.onNext(file.getName)
        }
      }
      fileObs.addListener(fileLis)

      Subscription { fileObs.removeListener(fileLis) }
    }
  }

  log(s"first subscribe call")
  val subscription1 = modifiedFiles(".").subscribe(filename => log(s"$filename modified!"))

  Thread.sleep(6000)

  log(s"another subscribe call")
  val subscription2 = modifiedFiles(".").subscribe(filename => log(s"$filename changed!"))

  Thread.sleep(6000)

  log(s"unsubscribed second call")
  subscription2.unsubscribe()

  Thread.sleep(6000)

  fileMonitor.stop()

}


object ObservablesHotVsCold extends App {
  import java.util.{Timer, TimerTask}
  import scala.collection._
  import rx.lang.scala._

  val songs = List("Eye of the Tiger", "You Spin Me Round", "Rebel Yell")
  val myPlaylist = Observable.from(songs)

  object Player extends TimerTask {
    val timer = new Timer
    var index = 0
    var subscribers = mutable.Set[Subscriber[String]]()
    def start() = timer.schedule(this, 0L, 1000L)
    def stop() = timer.cancel()

    def run() {
      index = (index + 1) % songs.length
      Player.synchronized { for (s <- subscribers) s.onNext(songs(index)) }
    }
    def turnOn(s: Subscriber[String]) = Player.synchronized { subscribers += s }
    def turnOff(s: Subscriber[String]) = Player.synchronized { subscribers -= s }
  }
  Player.start()

  val currentlyPlaying = Observable[String] { subscriber =>
    Player.turnOn(subscriber)
    subscriber.add(Subscription { Player.turnOff(subscriber) })
  }

  log(s"adding to a cold observable")
  myPlaylist.subscribe(log _)
  log(s"adding to a cold observable again")
  myPlaylist.subscribe(log _)
  Thread.sleep(2000)

  log(s"adding to a hot observable")
  val subscription1 = currentlyPlaying.subscribe(log _)
  Thread.sleep(2400)
  subscription1.unsubscribe()
  Thread.sleep(1200)
  log(s"adding to a hot observable again")
  val subscription2 = currentlyPlaying.subscribe(log _)
  Thread.sleep(2400)
  subscription2.unsubscribe()
  Thread.sleep(1200)
  log(s"Done -- shutting down the Player")
  Player.stop()

}










package org.learningconcurrency



import scala.concurrent._



package object ch3 {

  def execute(body: =>Unit) = ExecutionContext.global.execute(new Runnable {
    def run() = body
  })

}

package org.learningconcurrency






package object ch5 {
  @volatile var dummy: Any = _

  def timed[T](body: =>T): Double = {
    val start = System.nanoTime
    dummy = body
    val end = System.nanoTime
    ((end - start) / 1000) / 1000.0
  }

  def warmedTimed[T](times: Int = 200)(body: =>T): Double = {
    for (_ <- 0 until times) body
    timed(body)
  }
}

package org.learningconcurrency



import scala.swing._
import scala.swing.event._
import javax.swing._
import java.awt.event._
import rx.lang.scala._
import java.util.concurrent.Executor



package object ch6 {

  implicit class ButtonOps(val self: Button) {
    def clicks = Observable[Unit] { sub =>
      self.reactions += {
        case ButtonClicked(_) => sub.onNext(())
      }
    }
  }

  implicit class TextFieldOps(val self: TextField) {
    def texts = Observable[String] { sub =>
      self.reactions += {
        case ValueChanged(_) => sub.onNext(self.text)
      }
    }
  }

  implicit class TableOps(val self: Table) {
    def rowDoubleClicks = Observable[Int] { sub =>
      self.peer.addMouseListener(new MouseAdapter {
        override def mouseClicked(e: java.awt.event.MouseEvent) {
          if (e.getClickCount == 2) {
            val row = self.peer.getSelectedRow
            sub.onNext(row)
          }
        }
      })
    }
  }

  def swing(body: =>Unit) = {
    val r = new Runnable {
      def run() = body
    }
    javax.swing.SwingUtilities.invokeLater(r)
  }

  val swingScheduler = new Scheduler {
    val asJavaScheduler = rx.schedulers.Schedulers.from(new Executor {
      def execute(r: Runnable) = javax.swing.SwingUtilities.invokeLater(r)
    })
  }


}
package org.learningconcurrency



import akka.actor.ActorSystem
import com.typesafe.config._



package object ch8 {

  lazy val ourSystem = ActorSystem("OurExampleSystem")

  def remotingConfig(port: Int) = ConfigFactory.parseString(s"""
akka {
  actor.provider = "akka.remote.RemoteActorRefProvider"
  remote {
    enabled-transports = ["akka.remote.netty.tcp"]
    netty.tcp {
      hostname = "127.0.0.1"
      port = $port
    }
  }
}
  """)

  def remotingSystem(name: String, port: Int) = ActorSystem(name, remotingConfig(port))

}


package org.learningconcurrency



import java.io._
import java.text.SimpleDateFormat
import org.apache.commons.io.FileUtils
import org.apache.commons.io.monitor._
import rx.lang.scala._



package ch9 {

  case class FileInfo(path: String, name: String, parent: String, modified: String, isDir: Boolean, size: Long, state: FileSystem.State) {
    def toRow = Array[AnyRef](name, if (isDir) "" else size / 1000 + "kB", modified)
    def toFile = new File(path)
  }

  object FileInfo {
    def apply(file: File): FileInfo = {
      val path = file.getPath
      val name = file.getName
      val parent = file.getParent
      val modified = dateFormat.format(file.lastModified)
      val isDir = file.isDirectory
      val size = if (isDir) -1 else FileUtils.sizeOf(file)
      FileInfo(path, name, parent, modified, isDir, size, FileSystem.Idle)
    }

    def creating(file: File, size: Long): FileInfo = {
      val path = file.getPath
      val name = file.getName
      val parent = file.getParent
      val modified = dateFormat.format(System.currentTimeMillis)
      val isDir = false
      FileInfo(path, name, parent, modified, isDir, size, FileSystem.Created)
    }
  }

  sealed trait FileEvent
  case class FileCreated(path: String) extends FileEvent
  case class FileDeleted(path: String) extends FileEvent
  case class FileModified(path: String) extends FileEvent

}


package object ch9 {

  val dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss")

  def fileSystemEvents(rootPath: String): Observable[FileEvent] = {
    Observable.create { obs =>
      val fileMonitor = new FileAlterationMonitor(1000)
      val fileObs = new FileAlterationObserver(rootPath)
      val fileLis = new FileAlterationListenerAdaptor {
        override def onFileCreate(file: File) =
          obs.onNext(FileCreated(file.getPath))
        override def onFileChange(file: File) =
          obs.onNext(FileModified(file.getPath))
        override def onFileDelete(file: File) =
          obs.onNext(FileDeleted(file.getPath))
        override def onDirectoryCreate(file: File) =
          obs.onNext(FileCreated(file.getPath))
        override def onDirectoryChange(file: File) =
          obs.onNext(FileModified(file.getPath))
        override def onDirectoryDelete(file: File) =
          obs.onNext(FileDeleted(file.getPath))
      }
      fileObs.addListener(fileLis)
      fileMonitor.addObserver(fileObs)
      fileMonitor.start()

      Subscription { fileMonitor.stop() }
    }
  }

}


package org





package object learningconcurrency {

  def log(msg: String) {
    println(s"${Thread.currentThread.getName}: $msg")
  }

}

package org.learningconcurrency






package object ch2 {

  def thread(body: =>Unit): Thread = {
    val t = new Thread {
      override def run() = body
    }
    t.start()
    t
  }

}

package org.learningconcurrency
package ch5






object ParBasic extends App {
  import scala.collection._

  val numbers = scala.util.Random.shuffle(Vector.tabulate(5000000)(i => i))

  val seqtime = timed {
    val n = numbers.max
    println(s"largest number $n")
  }

  log(s"Sequential time $seqtime ms")

  val partime = timed {
    val n = numbers.par.max
    println(s"largest number $n")
  }

  log(s"Parallel time $partime ms")
}


object ParUid extends App {
  import scala.collection._
  import java.util.concurrent.atomic._
  private val uid = new AtomicLong(0L)

  val seqtime = timed {
    for (i <- 0 until 10000000) uid.incrementAndGet()
  }
  log(s"Sequential time $seqtime ms")

  val partime = timed {
    for (i <- (0 until 10000000).par) uid.incrementAndGet()
  }
  log(s"Parallel time $partime ms")

}


object ParGeneric extends App {
  import scala.collection._
  import scala.io.Source

  def findLongestLine(xs: GenSeq[String]): Unit = {
    val line = xs.maxBy(_.length)
    log(s"Longest line - $line")
  }

  val doc = Array.tabulate(1000)(i => "lorem ipsum " * (i % 10))

  findLongestLine(doc)
  findLongestLine(doc.par)

}


object ParConfig extends App {
  import scala.collection._
  import scala.concurrent.forkjoin.ForkJoinPool

  val fjpool = new ForkJoinPool(2)
  val myTaskSupport = new parallel.ForkJoinTaskSupport(fjpool)
  val numbers = scala.util.Random.shuffle(Vector.tabulate(5000000)(i => i))
  val partime = timed {
    val parnumbers = numbers.par
    parnumbers.tasksupport = myTaskSupport
    val n = parnumbers.max
    println(s"largest number $n")
  }
  log(s"Parallel time $partime ms")
}


object ParHtmlSpecSearch extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.collection._
  import scala.io.Source

  def getHtmlSpec() = Future {
    val specSrc: Source = Source.fromURL("http://www.w3.org/MarkUp/html-spec/html-spec.txt")
    try specSrc.getLines.toArray finally specSrc.close()
  }

  getHtmlSpec() foreach { case specDoc =>
    log(s"Download complete!")

    def search(d: GenSeq[String]) = warmedTimed() {
      d.indexWhere(line => line.matches(".*TEXTAREA.*"))
    }

    val seqtime = search(specDoc)
    log(s"Sequential time $seqtime ms")

    val partime = search(specDoc.par)
    log(s"Parallel time $partime ms")
  }

}


object ParNonParallelizableCollections extends App {
  import scala.collection._

  val list = List.fill(1000000)("")
  val vector = Vector.fill(1000000)("")
  log(s"list conversion time: ${timed(list.par)} ms")
  log(s"vector conversion time: ${timed(vector.par)} ms")
}


object ParNonParallelizableOperations extends App {
  import scala.collection._
  import scala.concurrent.ExecutionContext.Implicits.global
  import ParHtmlSpecSearch.getHtmlSpec

  getHtmlSpec() foreach { case specDoc =>
    def allMatches(d: GenSeq[String]) = warmedTimed() {
      val results = d.foldLeft("")((acc, line) => if (line.matches(".*TEXTAREA.*")) s"$acc\n$line" else acc)
      // Note: must use "aggregate" instead of "foldLeft"!
    }

    val seqtime = allMatches(specDoc)
    log(s"Sequential time - $seqtime ms")

    val partime = allMatches(specDoc.par)
    log(s"Parallel time   - $partime ms")
  }
}


object ParNonDeterministicOperation extends App {
  import scala.collection._
  import scala.concurrent.ExecutionContext.Implicits.global
  import ParHtmlSpecSearch.getHtmlSpec

  getHtmlSpec() foreach { case specDoc =>
    val seqresult = specDoc.find(line => line.matches(".*TEXTAREA.*"))
    val parresult = specDoc.par.find(line => line.matches(".*TEXTAREA.*"))
    log(s"Sequential result - $seqresult")
    log(s"Parallel result   - $parresult")
  }
}


object ParNonCommutativeOperator extends App {
  import scala.collection._

  val doc = mutable.ArrayBuffer.tabulate(20)(i => s"Page $i, ")
  def test(doc: GenIterable[String]) {
    val seqtext = doc.seq.reduceLeft(_ + _)
    val partext = doc.par.reduce(_ + _)
    log(s"Sequential result - $seqtext\n")
    log(s"Parallel result   - $partext\n")
  }
  test(doc)
  test(doc.toSet)
}


object ParNonAssociativeOperator extends App {
  import scala.collection._

  def test(doc: GenIterable[Int]) {
    val seqtext = doc.seq.reduceLeft(_ - _)
    val partext = doc.par.reduce(_ - _)
    log(s"Sequential result - $seqtext\n")
    log(s"Parallel result   - $partext\n")
  }
  test(0 until 30)
}


object ParMultipleOperators extends App {
  import scala.collection._
  import scala.concurrent.ExecutionContext.Implicits.global
  import ParHtmlSpecSearch.getHtmlSpec

  getHtmlSpec() foreach { case specDoc =>
    val length = specDoc.aggregate(0)(
      (count: Int, line: String) => count + line.length,
      (count1: Int, count2: Int) => count1 + count2
    )
    log(s"Total characters in HTML spec - $length")
  }
}


object ParSideEffectsIncorrect extends App {
  import scala.collection._

  def intSize(a: GenSet[Int], b: GenSet[Int]): Int = {
    var count = 0
    for (x <- a) if (b contains x) count += 1
    count
  }
  val seqres = intSize((0 until 1000).toSet, (0 until 1000 by 4).toSet)
  val parres = intSize((0 until 1000).par.toSet, (0 until 1000 by 4).par.toSet)
  log(s"Sequential result - $seqres")
  log(s"Parallel result   - $parres")
}


object ParSideEffectsCorrect extends App {
  import scala.collection._
  import java.util.concurrent.atomic._

  def intSize(a: GenSet[Int], b: GenSet[Int]): Int = {
    val count = new AtomicInteger(0)
    for (x <- a) if (b contains x) count.incrementAndGet()
    count.get
  }
  val seqres = intSize((0 until 1000).toSet, (0 until 1000 by 4).toSet)
  val parres = intSize((0 until 1000).par.toSet, (0 until 1000 by 4).par.toSet)
  log(s"Sequential result - $seqres")
  log(s"Parallel result   - $parres")
}


object ParMutableWrong extends App {
  import scala.collection._

  val buffer = mutable.ArrayBuffer[Int]() ++= (0 until 250)
  for (x <- buffer.par) buffer += x
  log(buffer.toString)
}






package org.learningconcurrency
package ch3






object ProcessRun extends App {
  import scala.sys.process._

  val command = "ls"
  val exitcode = command.!

  log(s"command exited with status $exitcode")

}


object ProcessLineCount extends App {
  import scala.sys.process._

  def lineCount(filename: String): Int = {
    val output = s"wc $filename".!!

    output.trim.split(" ").head.toInt
  }

  val lc = lineCount("build.sbt")
  log(s"File build.sbt has $lc lines.")
}


object ProcessAsync extends App {
  import scala.sys.process._
  val lsProcess = "ls -R /".run()
  Thread.sleep(1000)
  log("Timeout - killing ls!")
  lsProcess.destroy()
}


object ProcessList extends App {
  import scala.sys.process._

  def processes(): Stream[(Int, String)] = {
    val proclines = "ps -A".lines_!
    proclines.tail map { line =>
      val parts = line.trim.split(" ")
      (parts.head.toInt, parts.last)
    }
  }

  val currprocs = processes()
  val jvms = currprocs.filter(_._2.contains("java"))
  log(s"listing currently running JVM instances...")
  for (jvm <- jvms) {
    log(s"${jvm._1} ${jvm._2}")
  }

}


object ProcessFiles extends App {
  import scala.sys.process._

  def files(pattern: String): Stream[String] = s"find /home/ -name $pattern".lines_!

  for (file <- files("scala")) log(s"found - $file")
}


object ProcessPipelining extends App {
  import scala.sys.process._

  case class ProcessInfo(pid: Int, name: String)

  def processes(pattern: String): Stream[ProcessInfo] = {
    val proclines = "ps -A" #| s"grep $pattern" lines_!;
    proclines map { line =>
      val parts = line.trim.split(" ")
      ProcessInfo(parts.head.toInt, parts.last)
    }
  }

  val jvms = processes("java")
  for (jvm <- jvms) {
    log(s"Found a running `java` process, pid = ${jvm.pid}")
  }

}


package org.learningconcurrency
package ch4






object PromisesCreate extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global

  val p = Promise[String]
  val q = Promise[String]

  p.future foreach {
    case text => log(s"Promise p succeeded with '$text'")
  }

  p success "kept"

  val secondAttempt = p trySuccess "kept again"

  log(s"Second attempt to complete the same promise went well? $secondAttempt")

  q failure new Exception("not kept")

  q.future.failed foreach {
    case t => log(s"Promise q failed with $t")
  }

}


object PromisesCustomAsync extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.util.control.NonFatal

  def myFuture[T](body: =>T): Future[T] = {
    val p = Promise[T]

    global.execute(new Runnable {
      def run() = try {
        val result = body
        p success result
      } catch {
        case NonFatal(e) =>
          p failure e
      }
    })

    p.future
  }

  val future = myFuture {
    "naaa" + "na" * 8 + " Katamari Damacy!"
  }

  future foreach {
    case text => log(text)
  }

}


object PromisesAndCallbacks extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import org.apache.commons.io.monitor._
  import java.io.File

  def fileCreated(directory: String): Future[String] = {
    val p = Promise[String]

    val fileMonitor = new FileAlterationMonitor(1000)
    val observer = new FileAlterationObserver(directory)
    val listener = new FileAlterationListenerAdaptor {
      override def onFileCreate(file: File) {
        try p.trySuccess(file.getName)
        finally fileMonitor.stop()
      }
    }
    observer.addListener(listener)
    fileMonitor.addObserver(observer)
    fileMonitor.start()

    p.future
  }

  fileCreated(".") foreach {
    case filename => log(s"Detected new file '$filename'")
  }

}


object PromisesAndCustomOperations extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global

  implicit class FutureOps[T](val self: Future[T]) {
    def or(that: Future[T]): Future[T] = {
      val p = Promise[T]
      self onComplete { case x => p tryComplete x }
      that onComplete { case y => p tryComplete y }
      p.future
    }
  }

  val f = Future { "now" } or Future { "later" }

  f foreach {
    case when => log(s"The future is $when")
  }

}


object PromisesAndTimers extends App {
  import java.util._
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import PromisesAndCustomOperations._

  private val timer = new Timer(true)

  def timeout(millis: Long): Future[Unit] = {
    val p = Promise[Unit]
    timer.schedule(new TimerTask {
      def run() = p success ()
    }, millis)
    p.future
  }

  val f = timeout(1000).map(_ => "timeout!") or Future {
    Thread.sleep(999)
    "work completed!"
  }

  f foreach {
    case text => log(text)
  }

}


object PromisesCancellation extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global

  def cancellable[T](b: Future[Unit] => T): (Promise[Unit], Future[T]) = {
    val p = Promise[Unit]
    val f = Future {
      val r = b(p.future)
      if (!p.tryFailure(new Exception))
        throw new CancellationException
      r
    }
    (p, f)
  }

  val (cancel, value) = cancellable { cancel =>
    var i = 0
    while (i < 5) {
      if (cancel.isCompleted) throw new CancellationException
      Thread.sleep(500)
      log(s"$i: working")
      i += 1
    }
    "resulting value"
  }

  Thread.sleep(1500)

  cancel trySuccess ()

  log("computation cancelled!")
}


package org.learningconcurrency
package ch8



import akka.actor._
import akka.event.Logging
import scala.collection._



object RemotingPongySystem extends App {
  val system = remotingSystem("PongyDimension", 24321)
  val pongy = system.actorOf(Props[Pongy], "pongy")
  Thread.sleep(15000)
  system.shutdown()
}


class Runner extends Actor {
  val log = Logging(context.system, this)
  val pingy = context.actorOf(Props[Pingy], "pingy")
  def receive = {
    case "start" =>
      val path = context.actorSelection("akka.tcp://PongyDimension@127.0.0.1:24321/user/pongy")
      path ! Identify(0)
    case ActorIdentity(0, Some(ref)) =>
      pingy ! ref
    case ActorIdentity(0, None) =>
      log.info("Something's wrong -- no pongy anywhere!")
      context.stop(self)
    case "pong" =>
      log.info("got a pong from another dimension.")
      context.stop(self)
  }
}


object RemotingPingySystem extends App {
  val system = remotingSystem("PingyDimension", 24567)
  val runner = system.actorOf(Props[Runner], "runner")
  runner ! "start"
  Thread.sleep(5000)
  system.shutdown()
}

package org.learningconcurrency
package ch7






object RetryHeadWaitBad extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._
  import CompositionSortedList._

  def headWait(lst: TSortedList): Int = atomic { implicit txn =>
    while (lst.head() == null) {}
    lst.head().elem
  }

  val myList = new TSortedList

  Future {
    val headElem = headWait(myList)
    log(s"The first element is $headElem")
  }
  Thread.sleep(1000)
  Future { myList.insert(1) }

}


object RetryHeadWait extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._
  import CompositionSortedList._

  def headWait(lst: TSortedList): Int = atomic { implicit txn =>
    if (lst.head() != null) lst.head().elem
    else retry
  }

  val myList = new TSortedList

  Future {
    blocking {
      log(s"The first element is ${headWait(myList)}")
    }
  }
  Thread.sleep(1000)
  Future { myList.insert(1) }

}


object RetryChaining extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._
  import CompositionSortedList._
  import RetryHeadWait._

  val queue1 = new TSortedList
  val queue2 = new TSortedList

  val consumer = Future {
    blocking {
      atomic { implicit txn =>
        log(s"probe queue1")
        log(s"got: ${headWait(queue1)}")
      } orAtomic { implicit txn =>
        log(s"probe list2")
        log(s"got: ${headWait(queue2)}")
      }
    }
  }
  Thread.sleep(50)
  Future { queue2.insert(2) }
  Thread.sleep(50)
  Future { queue1.insert(1) }

}


object RetryTimeouts extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  val message = Ref("")

  Future {
    blocking {
      atomic.withRetryTimeout(1000) { implicit txn =>
        if (message() != "") s"got a message - ${message()}"
        else retry
      }
    }
  } foreach {
    case msg => log(msg)
  }

  Thread.sleep(1025)

  atomic { implicit txn =>
    message() = "Howdy!"
  }

}


object RetryFor extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  val message = Ref("")

  Future {
    blocking {
      atomic { implicit txn =>
        if (message() == "") {
          retryFor(1000)
          log(s"no message - '${message()}'")
        } else log(s"got a message - '${message()}'")
      }
    }
  }

  Thread.sleep(1025)

  message.single() = "Howdy!"

}






package org.learningconcurrency
package ch6






object SchedulersComputation extends App {
  import rx.lang.scala._

  val scheduler = schedulers.ComputationScheduler()
  val numbers = Observable.from(0 until 20)
  numbers.subscribe(n => log(s"num $n"))
  numbers.observeOn(scheduler).subscribe(n => log(s"num $n"))

}


object SchedulersSwing extends scala.swing.SimpleSwingApplication {
  import rx.lang.scala._
  import scala.swing._
  import scala.swing.event._

  def top = new MainFrame {
    title = "Swing Observables"

    val button = new Button {
      text = "Click"
    }

    contents = button

    val buttonClicks = Observable[Unit] { sub =>
      button.reactions += {
        case ButtonClicked(_) => sub.onNext(())
      }
    }

    buttonClicks.subscribe(_ => log("button clicked"))
  }

}


object SchedulersBrowser extends scala.swing.SimpleSwingApplication {
  import rx.lang.scala._
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.duration._
  import scala.swing._
  import scala.swing.event._
  import scala.io.Source
  import java.util.concurrent.Executor

  abstract class BrowserFrame extends MainFrame {
    title = "MiniBrowser"

    val termfield = new TextField("http://www.w3.org/Addressing/URL/url-spec.txt")
    val pagefield = new TextArea
    val button = new Button {
      text = "Feeling Lucky"
    }

    contents = new BorderPanel {
      import BorderPanel.Position._
      layout(new BorderPanel {
        layout(new Label("URL:")) = West
        layout(termfield) = Center
        layout(button) = East
      }) = North
      layout(pagefield) = Center
    }

    size = new Dimension(1024, 768)
  }

  trait BrowserLogic {
    self: BrowserFrame =>

    def suggestRequest(term: String): Observable[String] = {
      val url = s"http://suggestqueries.google.com/complete/search?client=firefox&q=$term"
      val request = Future { Source.fromURL(url).mkString }
      Observable.from(request).timeout(0.5.seconds).onErrorResumeNext(Observable.items("(no suggestions)"))
    }

    def pageRequest(url: String): Observable[String] = {
      val request = Future { Source.fromURL(url).mkString }
      Observable.from(request).timeout(4.seconds).onErrorResumeNext(t => Observable.items(s"Could not load page: $t"))
    }

    termfield.texts.map(suggestRequest).concat.observeOn(swingScheduler).subscribe {
      response => pagefield.text = response
    }

    button.clicks.map(_ => pageRequest(termfield.text)).concat.observeOn(swingScheduler).subscribe {
      response => pagefield.text = response
    }
  }

  def top = new BrowserFrame with BrowserLogic

}

package org.learningconcurrency
package ch6






object SubjectsOS extends App {
  import rx.lang.scala._
  import scala.concurrent.duration._
  import ObservablesSubscriptions._

  object RxOS {
    val messageBus = Subject[String]()
    messageBus.subscribe(log _)
  }

  object TimeModule {
    val systemClock = Observable.interval(1.seconds).map(t => s"systime: $t")
  }

  object FileSystemModule {
    val fileModifications = modifiedFiles(".").map(filename => s"file modification: $filename")
  }

  log(s"RxOS booting...")
  val modules = List(
    TimeModule.systemClock,
    FileSystemModule.fileModifications
  )
  val loadedModules = modules.map(_.subscribe(RxOS.messageBus))
  log(s"RxOS boot sequence finished!")

  Thread.sleep(10000)
  for (mod <- loadedModules) mod.unsubscribe()
  log(s"RxOS going for shutdown")

}


object SubjectsOSLog extends App {
  import rx.lang.scala._
  import SubjectsOS.{TimeModule, FileSystemModule}

  object RxOS {
    val messageBus = Subject[String]()
    val messageLog = subjects.ReplaySubject[String]()
    messageBus.subscribe(log _)
    messageBus.subscribe(messageLog)
  }

  val loadedModules = List(
    TimeModule.systemClock,
    FileSystemModule.fileModifications
  ).map(_.subscribe(RxOS.messageBus))

  log(s"RxOS booting")
  Thread.sleep(1000)
  log(s"RxOS booted!")
  Thread.sleep(10000)
  for (mod <- loadedModules) mod.unsubscribe()
  log(s"RxOS dumping the complete event log")
  RxOS.messageLog.subscribe(log _)
  log(s"RxOS going for shutdown")

}


object SubjectsOSRegistry extends App {
  import rx.lang.scala._

  object KernelModuleC {
    private val newKeys = Subject[(String, String)]()
    val registry = subjects.BehaviorSubject(Map[String, String]())
    newKeys.scan(Map[String, String]())(_ + _).subscribe(registry)
    def add(kv: (String, String)) = newKeys.onNext(kv)
  }

  KernelModuleC.registry.subscribe(reg => log(s"App A sees registry $reg"))

  log("RxOS about to add home dir")
  Thread.sleep(1000)
  KernelModuleC.add("dir.home" -> "/home/")

  object KernelModuleD {
    type Reg = Map[String, String]
    val registryDiffs = KernelModuleC.registry.scan((prev: Reg, curr: Reg) => curr -- prev.keys).drop(1)
  }
  KernelModuleD.registryDiffs.subscribe(diff => log(s"App B detects registry change: $diff"))

  log("RxOS about to add root dir")
  Thread.sleep(1000)
  KernelModuleC.add("dir.root" -> "/root/")

}


object SubjectsAsync extends App {
  import rx.lang.scala._

  object ProcessModule {
    private val added = Subject[Either[Int, Int]]()
    private val ended = Subject[Either[Int, Int]]()
    private val events = (added merge ended).scan(Set[Int]()) {
      case (set, Right(pid)) => set + pid
      case (set, Left(pid)) => set - pid
    }
    val processes = subjects.AsyncSubject[Set[Int]]()
    events.subscribe(processes)
    def add(pid: Int) = added.onNext(Right(pid))
    def end(pid: Int) = ended.onNext(Left(pid))
  }

  ProcessModule.add(1)
  ProcessModule.add(2)
  ProcessModule.add(3)

  log("RxOS processes started")
  Thread.sleep(1000)
  log("RxOS going for shutdown!")

  ProcessModule.end(1)
  ProcessModule.processes.subscribe(pids => log(s"need to force-kill processes ${pids.mkString(",")}"))
  Thread.sleep(1000)
  ProcessModule.processes.onCompleted()

}

package org.learningconcurrency
package ch8



import akka.actor._
import akka.event.Logging
import akka.pattern.pipe
import akka.actor.SupervisorStrategy._
import org.apache.commons.io.FileUtils
import scala.io.Source
import scala.collection._
import scala.concurrent._
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._



class Naughty extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case s: String => log.info(s)
    case msg => throw new RuntimeException
  }
  override def postRestart(t: Throwable) = log.info("naughty restarted")
}


class Supervisor extends Actor {
  val child = context.actorOf(Props[Naughty], "victim")
  def receive = PartialFunction.empty
  override val supervisorStrategy =
    OneForOneStrategy() {
      case ake: ActorKilledException => Restart
      case _ => Escalate
    }
}


object SupervisionKill extends App {
  val s = ourSystem.actorOf(Props[Supervisor], "super")
  ourSystem.actorSelection("/user/super/*") ! Kill
  ourSystem.actorSelection("/user/super/*") ! "sorry about that"
  ourSystem.actorSelection("/user/super/*") ! "kaboom".toList
  Thread.sleep(1000)
  ourSystem.stop(s)
  Thread.sleep(1000)
  ourSystem.shutdown()
}


class Downloader extends Actor {
  def receive = {
    case DownloadManager.Download(url, dest) =>
      val content = Source.fromURL(url)
      FileUtils.write(new java.io.File(dest), content.mkString)
      sender ! DownloadManager.Finished(dest)
  }
}


class DownloadManager(val downloadSlots: Int) extends Actor {
  val log = Logging(context.system, this)
  val downloaders = mutable.Queue[ActorRef]()
  val pendingWork = mutable.Queue[DownloadManager.Download]()
  val workItems = mutable.Map[ActorRef, DownloadManager.Download]()

  override def preStart(): Unit = {
    for (i <- 0 until downloadSlots) downloaders.enqueue(context.actorOf(Props[Downloader], s"dl$i"))
  }

  private def checkMoreDownloads(): Unit = {
    if (pendingWork.nonEmpty && downloaders.nonEmpty) {
      val dl = downloaders.dequeue()
      val workItem = pendingWork.dequeue()
      log.info(s"$workItem starting, ${downloaders.size} download slots left")
      dl ! workItem
      workItems(dl) = workItem
    }
  }

  def receive = {
    case msg @ DownloadManager.Download(url, dest) =>
      pendingWork.enqueue(msg)
      checkMoreDownloads()
    case DownloadManager.Finished(dest) =>
      workItems.remove(sender)
      downloaders.enqueue(sender)
      log.info(s"Download to '$dest' finished, ${downloaders.size} download slots left")
      checkMoreDownloads()
  }

  override val supervisorStrategy =
    OneForOneStrategy(maxNrOfRetries = 6, withinTimeRange = 30 seconds) {
      case fnf: java.io.FileNotFoundException =>
        log.info(s"Resource could not be found: $fnf")
        workItems.remove(sender)
        downloaders.enqueue(sender)
        Resume
      case _ =>
        Escalate
    }
}


object DownloadManager {
  case class Download(url: String, dest: String)
  case class Finished(dest: String)
}


object SupervisionDownloader extends App {
  import DownloadManager._
  val downloadManager = ourSystem.actorOf(Props(classOf[DownloadManager], 4), "manager")
  downloadManager ! Download("http://www.w3.org/Addressing/URL/url-spec.txt", "url-spec.txt")
  Thread.sleep(1000)
  downloadManager ! Download("https://github.com/scala/scala/blob/master/README.md", "README.md")
  Thread.sleep(5000)
  ourSystem.stop(downloadManager)
  Thread.sleep(5000)
  ourSystem.shutdown()
}









package org.learningconcurrency
package ch2






object SynchronizedProtectedUid extends App {

  var uidCount = 0L

  def getUniqueId() = this.synchronized {
    val freshUid = uidCount + 1
    uidCount = freshUid
    freshUid
  }

  def printUniqueIds(n: Int): Unit = {
    val uids = for (i <- 0 until n) yield getUniqueId()
    println(s"Generated uids: $uids")
  }

  val t = thread{
    printUniqueIds(5)
  }
  printUniqueIds(5)
  t.join()

}


// we should skip this one
object SynchronizedSharedStateAccess extends App {
  for (i <- 0 until 10000) {
    var t1started = false
    var t2started = false
    var t1index = 0
    var t2index = 0

    val t1 = thread {
      Thread.sleep(1)
      this.synchronized { t1started = true }
      val t2s = this.synchronized { t2started }
      t2index = if (t2started) 0 else 1
    }
    val t2 = thread {
      Thread.sleep(1)
      this.synchronized { t2started = true }
      val t1s = this.synchronized { t1started }
      t1index = if (t1s) 0 else 1
    }

    t1.join()
    t2.join()
    assert(!(t1index == 1 && t2index == 1), s"t1 = $t1index, t2 = $t2index")
  }
}


object SynchronizedNesting extends App {
  import scala.collection._
  private val transfers = mutable.ArrayBuffer[String]()
  def logTransfer(name: String, n: Int): Unit = transfers.synchronized {
    transfers += s"transfer to account '$name' = $n"
  }
  class Account(val name: String, var money: Int)
  def add(account: Account, n: Int) = account.synchronized {
    account.money += n
    if (n > 10) logTransfer(account.name, n)
  }
  val jane = new Account("Jane", 100)
  val john = new Account("John", 200)
  val t1 = thread { add(jane, 5) }
  val t2 = thread { add(john, 50) }
  val t3 = thread { add(jane, 70) }
  t1.join(); t2.join(); t3.join()
  log(s"--- transfers ---\n$transfers")
}


object SynchronizedDeadlock extends App {
  import SynchronizedNesting.Account
  def send(a: Account, b: Account, n: Int) = a.synchronized {
    b.synchronized {
      a.money -= n
      b.money += n
    }
  }
  val a = new Account("Jill", 1000)
  val b = new Account("Jack", 2000)
  val t1 = thread { for (i <- 0 until 100) send(a, b, 1) }
  val t2 = thread { for (i <- 0 until 100) send(b, a, 1) }
  t1.join()
  t2.join()
  log(s"a = ${a.money}, b = ${b.money}")
}


object SynchronizedNoDeadlock extends App {
  import SynchronizedProtectedUid._
  class Account(val name: String, var money: Int) {
    val uid = getUniqueId()
  }
  def send(a1: Account, a2: Account, n: Int) {
    def adjust() {
      a1.money -= n
      a2.money += n
    }
    if (a1.uid < a2.uid)
      a1.synchronized { a2.synchronized { adjust() } }
    else
      a2.synchronized { a1.synchronized { adjust() } }
  }
  val a = new Account("Jill", 1000)
  val b = new Account("Jack", 2000)
  val t1 = thread { for (i <- 0 until 100) send(a, b, 1) }
  val t2 = thread { for (i <- 0 until 100) send(b, a, 1) }
  t1.join()
  t2.join()
  log(s"a = ${a.money}, b = ${b.money}")
}


object SynchronizedDuplicates extends App {
  import scala.collection._
  val duplicates = mutable.Set[Int]()
  val numbers = mutable.ArrayBuffer[Int]()
  def isDuplicate(n: Int): Unit = duplicates.synchronized {
    duplicates.contains(n)
  }
  def addDuplicate(n: Int): Unit = duplicates.synchronized {
    duplicates += n
  }
  def addNumber(n: Int): Unit = numbers.synchronized {
    numbers += n
    if (numbers.filter(_ == n).size > 1) addDuplicate(n)
  }
  val threads = for (i <- 1 to 2) yield thread {
    for (n <- 0 until i * 10) addNumber(n)
  }
  for (t <- threads) t.join()
  println(duplicates.mkString("\n"))
}


object SynchronizedBadPool extends App {
  import scala.collection._
  private val tasks = mutable.Queue[() => Unit]()
  val worker = new Thread {
    def poll(): Option[() => Unit] = tasks.synchronized {
      if (tasks.nonEmpty) Some(tasks.dequeue()) else None
    }
    override def run() = while (true) poll() match {
      case Some(task) => task()
      case None =>
    }
  }
  worker.setDaemon(true)
  worker.start()

  def asynchronous(body: =>Unit) = tasks.synchronized {
    tasks.enqueue(() => body)
  }

  asynchronous { log("Hello") }
  asynchronous { log(" world!")}
  Thread.sleep(100)
}


object SynchronizedGuardedBlocks extends App {
  val lock = new AnyRef
  var message: Option[String] = None
  val greeter = thread {
    lock.synchronized {
      while (message == None) lock.wait()
      log(message.get)
    }
  }
  lock.synchronized {
    message = Some("Hello!")
    lock.notify()
  }
  greeter.join()
}


object SynchronizedPool extends App {
  import scala.collection._

  private val tasks = mutable.Queue[() => Unit]()

  object Worker extends Thread {
    setDaemon(true)
    def poll() = tasks.synchronized {
      while (tasks.isEmpty) tasks.wait()
      tasks.dequeue()
    }
    override def run() = while (true) {
      val task = poll()
      task()
    }
  }

  Worker.start()

  def asynchronous(body: =>Unit) = tasks.synchronized {
    tasks.enqueue(() => body)
    tasks.notify()
  }

  asynchronous { log("Hello ") }
  asynchronous { log("World!") }
}


object SynchronizedGracefulShutdown extends App {
  import scala.collection._
  import scala.annotation.tailrec

  private val tasks = mutable.Queue[() => Unit]()

  object Worker extends Thread {
    var terminated = false
    def poll(): Option[() => Unit] = tasks.synchronized {
      while (tasks.isEmpty && !terminated) tasks.wait()
      if (!terminated) Some(tasks.dequeue()) else None
    }
    @tailrec override def run() = poll() match {
      case Some(task) => task(); run()
      case None =>
    }
    def shutdown() = tasks.synchronized {
      terminated = true
      tasks.notify()
    }
  }

  Worker.start()

  def asynchronous(body: =>Unit) = tasks.synchronized {
    tasks.enqueue(() => body)
    tasks.notify()
  }

  asynchronous { log("Hello ") }
  asynchronous { log("World!") }

  Thread.sleep(1000)

  Worker.shutdown()
}



package org.learningconcurrency
package ch2






object ThreadsMain extends App {
  val name = Thread.currentThread.getName
  println(s"I am the thread $name")
}


object ThreadsStart extends App {
  class MyThread extends Thread {
    override def run(): Unit = {
      println(s"I am ${Thread.currentThread.getName}")
    }
  }

  val t = new MyThread()
  t.start()
  println(s"I am ${Thread.currentThread.getName}")
}


object ThreadsCreation extends App {

  class MyThread extends Thread {
    override def run(): Unit = {
      println("New thread running.")
    }
  }
  val t = new MyThread

  t.start()
  t.join()
  println("New thread joined.")

}


object ThreadsSleep extends App {

  val t = thread {
    Thread.sleep(1000)
    log("New thread running.")
    Thread.sleep(1000)
    log("Still running.")
    Thread.sleep(1000)
    log("Completed.")
  }
  t.join()
  log("New thread joined.")

}


object ThreadsNondeterminism extends App {

  val t = thread { log("New thread running.") }
  log("...")
  log("...")
  t.join()
  log("New thread joined.")

}


object ThreadsCommunicate extends App {
  var result: String = null
  val t = thread { result = "\nTitle\n" + "=" * 5 }
  t.join()
  log(result)
}


object ThreadsUnprotectedUid extends App {

  var uidCount = 0L

  def getUniqueId() = {
    val freshUid = uidCount + 1
    uidCount = freshUid
    freshUid
  }

  def printUniqueIds(n: Int): Unit = {
    val uids = for (i <- 0 until n) yield getUniqueId()
    log(s"Generated uids: $uids")
  }

  val t = thread {
    printUniqueIds(5)
  }
  printUniqueIds(5)
  t.join()

}


object ThreadSharedStateAccessReordering extends App {
  for (i <- 0 until 100000) {
    var a = false
    var b = false
    var x = -1
    var y = -1

    val t1 = thread {
      //Thread.sleep(2)
      a = true
      y = if (b) 0 else 1
    }
    val t2 = thread {
      //Thread.sleep(2)
      b = true
      x = if (a) 0 else 1
    }

    t1.join()
    t2.join()
    assert(!(x == 1 && y == 1), s"x = $x, y = $y")
  }
}
















package org.learningconcurrency
package ch7






object TransactionLocals extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._
  import CompositionSortedList._

  val myLog = TxnLocal("")

  def clearList(lst: TSortedList) = atomic { implicit txn =>
    while (lst.head() != null) {
      myLog() = myLog() + "\nremoved " + lst.head().elem
      lst.head() = lst.head().next()
    }
  }

  val myList = new TSortedList().insert(14).insert(22)
  def clearWithLog(): String = atomic { implicit txn =>
    clearList(myList)
    myLog()
  }
  val f = Future { clearWithLog() }
  val g = Future { clearWithLog() }
  for (h1 <- f; h2 <- g) {
    log(s"Log for f: $h1\nLog for g: $h2")
  }

}


object TransactionalArray extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  val pages = Seq.fill(5)("Scala 2.10 is out, " * 7)
  val website = TArray(pages)

  def replace(pat: String, txt: String): Unit = atomic { implicit txn =>
    for (i <- 0 until website.length) website(i) = website(i).replace(pat, txt)
  }

  def asString = atomic { implicit txn =>
    var s: String = ""
    for (i <- 0 until website.length) s += s"Page $i\n=======\n${website(i)}\n\n"
    s
  }

  Future { replace("2.10", "2.11") }
  Thread.sleep(30)
  Future { replace("2.11", "2.12") }
  Thread.sleep(250)
  Future { log(s"Document\n$asString") }

}


object TransactionalMap extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  val tmap = TMap("a" -> 1, "B" -> 2, "C" -> 3)

  Future {
    atomic { implicit txn =>
      tmap("A") = 1
      tmap.remove("a")
    }
  }
  Thread.sleep(23)
  Future {
    val snap = tmap.single.snapshot
    log(s"atomic snapshot: $snap")
  }

}


object TransactionalDocument extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._

  class TDocument(val name: String) {
    val pages = Ref(TArray.ofDim[String](0))

    def addPage(page: String): this.type = atomic { implicit txn =>
      val oarray = pages()
      val narray = TArray.ofDim[String](oarray.length + 1)
      for (i <- 0 until oarray.length) narray(i) = oarray(i)
      narray(oarray.length) = page
      pages() = narray
      this
    }

    override def toString = atomic { implicit txn =>
      val array = pages()
      (0 until array.length).map(i => s"Page $i\n=======\n${array(i)}\n\n").mkString
    }
  }

  val doc = new TDocument("MyBook")
  doc.addPage("My Book Title")
  doc.addPage("Abstract: This is a book about concurrency.")

  Future { doc.addPage("Why is concurrency important.") }
  Future { doc.addPage("What concurrency means to you.") }
  Thread.sleep(250)
  Future { log(s"Document\n$doc") }

}


object TransactionalLibrary extends App {
  import scala.concurrent._
  import ExecutionContext.Implicits.global
  import scala.concurrent.stm._
  import TransactionalDocument._

  class TLibrary {
    val documents = TMap.empty[String, TDocument]

    def addDoc(doc: TDocument): this.type = atomic { implicit txn =>
      if (documents.contains(doc.name)) sys.error("Document ${doc.name} already exists!")
      else documents(doc.name) = doc
      this
    }

    def removeDoc(name: String): Option[TDocument] = documents.single.remove(name)

    def findDocs(pattern: String): List[String] = atomic { implicit txn =>
      documents.filter({
        case (name, doc) =>
          val pages = doc.pages()
          (0 until pages.length).exists(i => pages(i).contains(pattern))
      }).keys.toList
    }
  }

  val library = new TLibrary()
  library.addDoc(new TDocument("README.md").addPage("Attention - important!"))

  Future {
    library.addDoc(new TDocument("ElManual.md").addPage("Es muy importante!"))
    Thread.sleep(5)
    library.removeDoc("README.md")
  }
  Future {
    val matches = library.findDocs("important").mkString("\n")
    log(s"Matches:\n$matches")
  }

}





package org.learningconcurrency
package ch2






object UnsafeUid extends App {
  import scala.annotation.tailrec
  private val unsafe = scala.concurrent.util.Unsafe.instance
  private val uidCountOffset = unsafe.objectFieldOffset(UnsafeUid.getClass.getDeclaredField("uidCount"))
  @volatile var uidCount = 0L

  @tailrec def getUniqueId(): Long = {
    val oldUid = uidCount
    val newUid = uidCount + 1
    if (unsafe.compareAndSwapLong(UnsafeUid, uidCountOffset, oldUid, newUid)) newUid
    else getUniqueId()
  }

  def getUniqueIds(n: Int): Unit = {
    val uids = for (i <- 0 until n) yield getUniqueId()
    log(s"Generated uids: $uids")
  }

  val t = thread {
    getUniqueIds(5)
  }
  getUniqueIds(5)
  t.join()

}


package org.learningconcurrency
package ch2






object Volatile extends App {
  case class Page(txt: String, var position: Int)
  val pages = for (i <- 1 to 5) yield
    new Page("Na" * (100 - 20 * i) + " Batman!", -1)
  @volatile var found = false
  for (p <- pages) yield thread {
    var i = 0
    while (i < p.txt.length && !found)
      if (p.txt(i) == '!') {
        p.position = i
        found = true
      } else i += 1
  }
  while (!found) {}
  log(s"results: ${pages.map(_.position)}")
}


object VolatileScan extends App {
  val document: Seq[String] = for (i <- 1 to 5) yield "lorem ipsum " * (1000 - 200 * i) + "Scala"
  var results = Array.fill(document.length)(-1)
  @volatile var found = false
  val threads = for (i <- 0 until document.length) yield thread {
    def scan(n: Int, words: Seq[String], query: String): Unit =
      if (words(n) == query) {
        results(i) = n
        found = true
      } else if (!found) scan(n + 1, words, query)
    scan(0, document(i).split(" "), "Scala")
  }
  for (t <- threads) t.join()
  log(s"Found: ${results.find(_ != -1)}")
}


object VolatileUnprotectedUid extends App {

  @volatile var uidCount = 0L

  def getUniqueId() = {
    val freshUid = uidCount + 1
    uidCount = freshUid
    freshUid
  }

  def printUniqueIds(n: Int): Unit = {
    val uids = for (i <- 0 until n) yield getUniqueId()
    log(s"Generated uids: $uids")
  }

  val t = thread {
    printUniqueIds(5)
  }
  printUniqueIds(5)
  t.join()

}


object VolatileSharedStateAccess extends App {
  for (i <- 0 until 10000) {
    @volatile var t1started = false
    @volatile var t2started = false
    var t1index = -1
    var t2index = -1

    val t1 = thread {
      Thread.sleep(1)
      t1started = true
      t2index = if (t2started) 0 else 1
    }
    val t2 = thread {
      Thread.sleep(1)
      t2started = true
      t1index = if (t1started) 0 else 1
    }

    t1.join()
    t2.join()
    assert(!(t1index == 1 && t2index == 1), s"t1 = $t1index, t2 = $t2index")
  }
}



package highperfscala.option

import scala.language.higherKinds

// Taken from https://bertails.org/2015/02/15/abstract-algebraic-data-type/
trait OptionSig {
  type Option[+_]
  type Some[+A] <: Option[A]
  type None <: Option[Nothing]
}

abstract class OptionOps[Sig <: OptionSig] {
  def some[A](x: A): Sig#Some[A]
  def none: Sig#None
  def fold[A, B](opt: Sig#Option[A])(ifNone: => B, ifSome: A => B): B
}

object OptionOps {
  def apply[Sig <: OptionSig](implicit ops: OptionOps[Sig]): OptionOps[Sig] =
    ops
}

import scalaz.Show

class OptionShow[Sig <: OptionSig : OptionOps] {

  def optionShow[A: Show]: Show[Sig#Option[A]] = {

    // retrieving the typeclass instances
    val showA = Show[A]
    val ops = OptionOps[Sig]

    val instance = new Show[Sig#Option[A]] {
      override def shows(opt: Sig#Option[A]): String = ops.fold(opt)(
        "none",
        x => s"some(${showA.shows(x)})"
      )
    }

    instance
  }

}

object OptionShow {

  implicit def apply[Sig <: OptionSig : OptionOps]: OptionShow[Sig] =
    new OptionShow[Sig]
}

trait ScalaOption extends OptionSig {

  type Option[+A] = scala.Option[A]
  type Some[+A] = scala.Some[A]
  type None = scala.None.type

}

object ScalaOption {

  implicit object ops extends OptionOps[ScalaOption] {

    def some[A](x: A): ScalaOption#Some[A] = scala.Some(x)

    val none: ScalaOption#None = scala.None

    def fold[A, B](opt: ScalaOption#Option[A])(ifNone: => B, ifSome: A => B): B =
      opt match {
        case scala.None => ifNone
        case scala.Some(x) => ifSome(x)
      }

  }

}

trait NullOption extends OptionSig {

  type Option[+A] = Any
  type Some[+A] = Any
  type None = Null

}

object NullOption {

  implicit object ops extends OptionOps[NullOption] {

    def some[A](x: A): NullOption#Some[A] = x

    val none: NullOption#None = null

    def fold[A, B](opt: NullOption#Option[A])(ifNone: => B, ifSome: A => B): B = {
      if (opt == null) ifNone
      else ifSome(opt.asInstanceOf[A])
    }

  }

}
package highperfscala.orderbook

// API externalized from chapter 2

object Commands {
  sealed trait Command
  case class AddLimitOrder(i: CommandInstant, o: LimitOrder) extends Command
  case class CancelOrder(i: CommandInstant, id: OrderId) extends Command
}

object Events {
  sealed trait Event
  case class OrderExecuted(
    i: EventInstant, buy: Execution, sell: Execution) extends Event
  case class LimitOrderAdded(i: EventInstant) extends Event
  case class OrderCancelRejected(i: EventInstant, id: OrderId) extends Event
  case class OrderCanceled(i: EventInstant, id: OrderId) extends Event
}
package highperfscala.clientreports.views

import org.joda.time.Instant

sealed trait LastHourPnL
case object LastHourPositive extends LastHourPnL
case object LastHourNegative extends LastHourPnL

sealed trait LastDayPnL
case object LastDayPositive extends LastDayPnL
case object LastDayNegative extends LastDayPnL

sealed trait LastSevenDayPnL
case object LastSevenDayPositive extends LastSevenDayPnL
case object LastSevenDayNegative extends LastSevenDayPnL

case class Ticker(value: String) extends AnyVal

case class TradingPerformanceTrend(
  ticker: Ticker,
  lastHour: LastHourPnL,
  lastDay: LastDayPnL,
  lastSevenDay: LastSevenDayPnL)

case class Price(value: BigDecimal) extends AnyVal
object Price {
  def average(ps: List[Price]): Price = {
    val prices = ps.map(_.value)
    Price(prices.sum / prices.length)
  }
}
case class OrderId(value: Long) extends AnyVal
case class CreatedTimestamp(value: Instant) extends AnyVal
case class ClientId(value: Long) extends AnyVal
sealed trait Order {
  def created: CreatedTimestamp
  def id: OrderId
  def ticker: Ticker
  def price: Price
  def clientId: ClientId
}
case class BuyOrder(
  created: CreatedTimestamp, id: OrderId, ticker: Ticker, price: Price,
  clientId: ClientId) extends Order
case class SellOrder(
  created: CreatedTimestamp, id: OrderId, ticker: Ticker, price: Price,
  clientId: ClientId) extends Order

case class Execution(created: CreatedTimestamp, id: OrderId, price: Price)

case class PnL(value: BigDecimal) extends AnyVal
object PnL {
  val zero: PnL = PnL(BigDecimal(0))
}

sealed trait PeriodPnL
case object PeriodPositive extends PeriodPnL
case object PeriodNegative extends PeriodPnL

case class GenerateTradingPerformanceTrend(
  tickers: List[Ticker], clientId: ClientId)
package highperfscala.dataanalysis

import org.joda.time.DateTime

case class TimestampMinutes(value: Int) extends AnyVal {

  def next: TimestampMinutes = TimestampMinutes(value + 1)
}
object TimestampMinutes {
  def fromDateTime(dt: DateTime): TimestampMinutes = TimestampMinutes(
      (dt.withSecondOfMinute(0).withMillisOfSecond(0)
      .getMillis / (1000 * 60)).toInt)
}

case class AskPrice(value: Int) extends AnyVal

case class BidPrice(value: Int) extends AnyVal

case class Execution(time: TimestampMinutes, ask: AskPrice, bid: BidPrice)

case class Midpoint(time: TimestampMinutes, value: Double)
object Midpoint {

  def fromAskAndBid(
    time: TimestampMinutes,
    askPrice: AskPrice,
    bidPrice: BidPrice): Midpoint =
    Midpoint(time, (bidPrice.value + askPrice.value) / 2D)

  def fromExecution(ex: Execution): Midpoint =
    fromAskAndBid(ex.time, ex.ask, ex.bid)

}

case class MinuteRollUp(value: Int) extends AnyVal

case class Return(value: Double) extends AnyVal

object Return {
  def fromMidpoint(start: Midpoint, end: Midpoint): Return =
    Return((end.value - start.value) / start.value * 100)

  implicit val returnOrdering = new Ordering[Return] {
    override def compare(x: Return, y: Return): Int =
      x.value.compare(y.value)
  }
}

package highperfscala.concurrency.backtesting

import org.joda.time.MonthDay

import scalaz.concurrent.Task

object Backtest {

  case class PnL(value: BigDecimal) extends AnyVal
  object PnL {
    def merge(x: PnL, y: PnL): PnL = PnL(x.value + y.value)
    val zero: PnL = PnL(0)
  }
  case class BacktestPerformanceSummary(pnl: PnL)
  case class DecisionDelayMillis(value: Long) extends AnyVal

  def originalBacktest(
    testDays: List[MonthDay],
    decisionDelay: DecisionDelayMillis): BacktestPerformanceSummary = {
    val pnls = for {
      d <- testDays
      _ = Thread.sleep(decisionDelay.value)
    } yield PnL(10)
    BacktestPerformanceSummary(pnls.reduceOption(PnL.merge).getOrElse(PnL.zero))
  }

  def backtestWithoutConcurrency(
    testDays: List[MonthDay],
    decisionDelay: DecisionDelayMillis): Task[BacktestPerformanceSummary] = {
    val ts = for (d <- testDays) yield Task.delay {
      Thread.sleep(decisionDelay.value)
      PnL(10)
    }
    Task.gatherUnordered(ts).map(pnls => BacktestPerformanceSummary(
      pnls.reduceOption(PnL.merge).getOrElse(PnL.zero)))
  }

  def backtestWithAllForked(
    testDays: List[MonthDay],
    decisionDelay: DecisionDelayMillis): Task[BacktestPerformanceSummary] = {
    val ts = for (d <- testDays) yield Task.fork {
      Thread.sleep(decisionDelay.value)
      Task.now(PnL(10))
    }
    Task.gatherUnordered(ts).map(pnls => BacktestPerformanceSummary(
      pnls.reduceOption(PnL.merge).getOrElse(PnL.zero)))
  }

  def backtestWithBatchedForking(
    testDays: List[MonthDay],
    decisionDelay: DecisionDelayMillis): Task[BacktestPerformanceSummary] = {
    val ts = for (d <- testDays) yield Task.delay {
      Thread.sleep(decisionDelay.value)
      PnL(10)
    }
    Task.gatherUnordered(ts.sliding(30, 30).toList.map(xs =>
      Task.fork(Task.gatherUnordered(xs)))).map(pnls =>
      BacktestPerformanceSummary(
        pnls.flatten.reduceOption(PnL.merge).getOrElse(PnL.zero)))
  }
}
package highperfscala.concurrency.backtesting

import java.util.concurrent.TimeUnit

import highperfscala.concurrency.backtesting.Backtest.{BacktestPerformanceSummary, DecisionDelayMillis}
import org.joda.time.{DateTime, Interval, MonthDay}
import org.openjdk.jmh.annotations.Mode._
import org.openjdk.jmh.annotations._

import scala.annotation.tailrec

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class BacktestBenchmarks {

  import BacktestBenchmarks._

  @Benchmark
  def withoutConcurrency(state: BenchmarkState): BacktestPerformanceSummary =
    Backtest.backtestWithoutConcurrency(state.backtestDays, state.decisionDelay)
      .unsafePerformSync

  @Benchmark
  def withBatchedForking(state: BenchmarkState): BacktestPerformanceSummary =
    Backtest.backtestWithBatchedForking(state.backtestDays, state.decisionDelay)
      .unsafePerformSync

  @Benchmark
  def withAllForked(state: BenchmarkState): BacktestPerformanceSummary =
    Backtest.backtestWithAllForked(state.backtestDays, state.decisionDelay)
      .unsafePerformSync
}

object BacktestBenchmarks {

  private def daysWithin(i: Interval): List[MonthDay] = {
    @tailrec
    def recurse(xs: List[MonthDay], current: DateTime): List[MonthDay] =
      current.isAfter(i.getEnd) match {
        case true => xs
        case false => recurse(
          new MonthDay(current.getMonthOfYear, current.getDayOfMonth) :: xs,
          current.plusDays(1))
      }
    recurse(Nil, i.getStart)
  }

  // Constant starting point to avoid differences due to number of days
  // per month
  private val end: DateTime = new DateTime(2016, 1, 1, 0, 0, 0, 0)
  private def trailingMonths(backtestIntervalMonths: Int): Interval =
    new Interval(
      end.minusMonths(backtestIntervalMonths), end)

  @State(Scope.Benchmark)
  class BenchmarkState {
    @Param(Array("1", "10"))
    var decisionDelayMillis: Long = 0
    @Param(Array("1", "12", "24" ))
    var backtestIntervalMonths: Int = 0

    var decisionDelay: DecisionDelayMillis = DecisionDelayMillis(-1)
    var backtestDays: List[MonthDay] = Nil

    @Setup
    def setup(): Unit = {
      decisionDelay = DecisionDelayMillis(decisionDelayMillis)
      backtestDays = daysWithin(trailingMonths(backtestIntervalMonths))
    }
  }
}
package highperfscala.concurrency.backtesting

import java.util.concurrent.TimeUnit

import org.joda.time.{DateTime, Interval}

import scala.concurrent.{Await, Future}

object Backtesting {

  sealed trait Strategy

  case class PnL(value: BigDecimal) extends AnyVal
  case class BacktestPerformanceSummary(pnl: PnL)

  case class Ticker(value: String) extends AnyVal

  def backtest(
    strategy: Strategy,
    ticker: Ticker,
    testInterval: Interval): BacktestPerformanceSummary = ???

  sealed trait VectorBasedReturnSeriesFrame

  def loadReturns(testInterval: Interval): VectorBasedReturnSeriesFrame = ???

  case object Dave1 extends Strategy
  case object Dave2 extends Strategy

  object Serial {
    def lastMonths(months: Int): Interval =
      new Interval(new DateTime().minusMonths(months), new DateTime())
    backtest(Dave1, Ticker("AAPL"), lastMonths(3))
    backtest(Dave1, Ticker("GOOG"), lastMonths(3))
    backtest(Dave2, Ticker("AAPL"), lastMonths(3))
    backtest(Dave2, Ticker("GOOG"), lastMonths(2))
  }

  object ForComprehension {
    def lastMonths(months: Int): Interval =
      new Interval(new DateTime().minusMonths(months), new DateTime())

    implicit val ec = scala.concurrent.ExecutionContext.Implicits.global
    val summariesF = for {
      firstDaveAapl <- Future(backtest(Dave1, Ticker("AAPL"), lastMonths(3)))
      firstDaveGoog <- Future(backtest(Dave1, Ticker("GOOG"), lastMonths(3)))
      secondDaveAapl <- Future(backtest(Dave2, Ticker("AAPL"), lastMonths(3)))
      secondDaveGoog <- Future(backtest(Dave2, Ticker("GOOG"), lastMonths(2)))
    } yield (firstDaveAapl, firstDaveGoog, secondDaveAapl, secondDaveGoog)

    Await.result(summariesF, scala.concurrent.duration.Duration(1, TimeUnit.SECONDS))

    Future(1).flatMap(f1 => Future(2).flatMap(f2 => Future(3).map(f3 => (f1, f2, f3))))
  }

  object Concurrency {
    def lastMonths(months: Int): Interval =
      new Interval(new DateTime().minusMonths(months), new DateTime())

    implicit val ec = scala.concurrent.ExecutionContext.Implicits.global
    val firstDaveAaplF = Future(backtest(Dave1, Ticker("AAPL"), lastMonths(3)))
    val firstDaveGoogF = Future(backtest(Dave1, Ticker("GOOG"), lastMonths(3)))
    val secondDaveAaplF = Future(backtest(Dave2, Ticker("AAPL"), lastMonths(3)))
    val secondDaveGoogF = Future(backtest(Dave2, Ticker("GOOG"), lastMonths(2)))
    val z = for {
      firstDaveAapl <- firstDaveAaplF
      firstDaveGoog <- firstDaveGoogF
      secondDaveAapl <- secondDaveAaplF
      secondDaveGoog <- secondDaveGoogF
    } yield (firstDaveAapl, firstDaveGoog, secondDaveAapl, secondDaveGoog)

  }

}
package highperfscala
package benchmarks

import highperfscala.benchmarks.BatchExample._
import org.openjdk.jmh.annotations._

// Scala transcription of
// http://hg.openjdk.java.net/code-tools/jmh/file/bcec9a03787f/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_26_BatchSize.java
//
// Run via
// sbt 'project performance;jmh:run .*BatchExample -f 1 -jvmArgs "-Xmx1G -Xms1G"'
@State(Scope.Thread)
class BatchExample {
  @Benchmark
  @Warmup(iterations = 5, time = 1)
  @Measurement(iterations = 5, time = 1)
  @BenchmarkMode(Array(Mode.Throughput))
  def measureWrong_1(): java.util.List[String] = {
    xs.add(xs.size() / 2, "something")
    xs
  }

  @Benchmark
  @Warmup(iterations = 5, time = 5)
  @Measurement(iterations = 5, time = 5)
  @BenchmarkMode(Array(Mode.Throughput))
  def measureWrong_5(): java.util.List[String] = {
    xs.add(xs.size() / 2, "something")
    xs
  }

  @Benchmark
  @Warmup(iterations = 5, batchSize = 5000)
  @Measurement(iterations = 5, batchSize = 5000)
  @BenchmarkMode(Array(Mode.SingleShotTime))
  def measureRight(): java.util.List[String] = {
    xs.add(xs.size() / 2, "something")
    xs
  }

  @Setup(Level.Iteration)
  def setup(): Unit = xs.clear()
}

object BatchExample {
  val xs = new java.util.LinkedList[String]()
}
package highperfscala.free

import java.util.concurrent.atomic.{AtomicBoolean, AtomicLong}
import java.util.concurrent.{LinkedBlockingQueue, TimeUnit}

import highperfscala.free.GenericBenchmark.{BenchmarkIterationCount, MessageSentTimestamp, MessagesPerSecond}
import org.mpierce.metrics.reservoir.hdrhistogram.HdrHistogramReservoir

import scala.language.postfixOps

object BboUpdatedBenchmark {

  private def generateDeterministicSample(): List[BboUpdated] = {
    val t = Ticker("XYZ")
    (1 to 5000).foldLeft(List.empty[BboUpdated]) {
      case (acc, i) =>
        val event = acc.headOption match {
          case Some(h) => i % 2 == 0 match {
            case true => BboUpdated(
              t, Bid(h.bid.value + 0.41), Offer(h.bid.value + 0.29))
            case false => BboUpdated(
              t, Bid(h.bid.value - 0.35), Offer(h.bid.value - 0.25))
          }
          case None => BboUpdated(t, Bid(22.45), Offer(23.51))
        }
        (event.bid.value >= event.offer.value match {
          case true => event.copy(offer = Offer(event.bid.value + 0.47))
          case false => event
        }) :: acc
    }
  }


  sealed trait ExecutionStrategy
  case object WithoutFree extends ExecutionStrategy
  case object WithThunk extends ExecutionStrategy
  case object WithTask extends ExecutionStrategy

  def main(args: Array[String]): Unit = {
    val histogram = new HdrHistogramReservoir()
    val queue = new LinkedBlockingQueue[(MessageSentTimestamp, BboUpdated)](100)
    val isRecording = new AtomicBoolean(false)
    val isDoneProcessing = new AtomicBoolean(false)

    if (args.length != 3) sys.error("Missing required args")
    val mps = MessagesPerSecond(args(0).toInt)
    val bic = BenchmarkIterationCount(args(1).toInt)
    val executionStrategy = args(2) match {
      case "without-free" => WithoutFree
      case "with-thunk" => WithThunk
      case "with-task" => WithTask
      case unsupported => sys.error(
        s"Unsupported execution strategy: $unsupported")
    }

    {
      val eventThread = new Thread(new Runnable {
        val count = new AtomicLong(0)
        val strategy = new ProductionStrategy(new AtomicLong(0))
        def run(): Unit = while (true) {
          def updateHistogram(l: ProcessingLatencyMs): Unit =
            if (isRecording.get()) histogram.update(l.value)

          Option(queue.poll(5, TimeUnit.SECONDS)) match {
            case Some((ts, e)) => executionStrategy match {
              case WithoutFree => BboUpdatedPipeline.strategyPipeline(
                updateHistogram, strategy, ts, e)
              case WithThunk => BboUpdatedPipeline.runWithFoldInterpreter(
                updateHistogram, strategy, ts, e)
              case WithTask => BboUpdatedPipeline.runWithTaskInterpreter(
                updateHistogram, strategy, ts, e)
            }
            case None => isDoneProcessing.set(true)
          }
        }
      })
      eventThread.setDaemon(true)
      eventThread.start()
    }

    def afterWarmUp(): Unit = {
      while (!isDoneProcessing.get()) Thread.sleep(1000)

      isRecording.set(true)
      isDoneProcessing.set(false)
    }

    GenericBenchmark.runBenchmark[BboUpdated, Option[Either[Bid, Offer]]](
      generateDeterministicSample(), mps, bic,
      (None, (ts, acc, e) => {
        queue.put((ts, e))
        None
      }),
      afterWarmUp,
      (ts, e) => queue.offer((ts, e)))

    while (!isDoneProcessing.get()) Thread.sleep(1000)

    GenericBenchmark.printSnapshot(histogram.getSnapshot)
  }

}
package highperfscala.free

import highperfscala.free.GenericBenchmark.MessageSentTimestamp

import scala.concurrent.duration._
import scala.language.{higherKinds, postfixOps}
import scalaz.concurrent.Task
import scalaz.{-\/, \/-, ~>}

object BboUpdatedPipeline {

  sealed trait BboProcessingFailure
  object BboProcessingFailure {
    def enrichmentFailure(t: Ticker): BboProcessingFailure =
      EnrichmentFailure(t)
    def journalingFailure: BboProcessingFailure = JournalingFailure
    def tradeAuthorizationFailure: BboProcessingFailure = TradeAuthorizationFailure
  }

  case class EnrichmentFailure(t: Ticker) extends BboProcessingFailure
  case object JournalingFailure extends BboProcessingFailure
  case object TradeAuthorizationFailure extends BboProcessingFailure

  import BboProcessingFailure._

  def enrichEvent(e: BboUpdated): BboUpdated = e
  def journalEvent(e: BboUpdated): Unit = ()
  def performPreTradeBalanceChecks(e: BboUpdated): Unit = ()
  def sendTradingDecision(d: Either[Bid, Offer]): Unit = ()

  def strategyPipeline(
    recordProcessingLatency: ProcessingLatencyMs => Unit,
    s: TradingStrategy,
    ts: MessageSentTimestamp,
    e: BboUpdated): Unit = {
    val enriched = enrichEvent(e)
    journalEvent(enriched)
    performPreTradeBalanceChecks(enriched)
    val d = s.makeTradingDecision(enriched)
    d.foreach(sendTradingDecision)
    recordProcessingLatency(ProcessingLatencyMs(
      System.currentTimeMillis() - ts.value))
  }

  private val pipeline = for {
    enriched <- StartWith(enrichEvent) within (8 millis) orElse (e =>
      enrichmentFailure(e.ticker))
    _ <- Step(journalEvent(enriched)) within (9 millis) orElse
      journalingFailure
    _ <- Step(performPreTradeBalanceChecks(enriched)) within (10 millis) orElse
      tradeAuthorizationFailure
    decision <- MakeTradingDecision(enriched)
  } yield decision

  case class PipelineState(
    ts: MessageSentTimestamp,
    strategy: TradingStrategy,
    event: BboUpdated)

  private def logFailure(f: BboProcessingFailure): Unit = ()
  private def logException(e: Throwable): Unit = ()

  private def hasProcessingTimeExpired(
    ts: MessageSentTimestamp, l: LimitMs): Boolean =
    System.currentTimeMillis() - ts.value >= l.value

  def runWithFoldInterpreter(
    recordProcessingLatency: ProcessingLatencyMs => Unit,
    strategy: TradingStrategy,
    ts: MessageSentTimestamp,
    e: BboUpdated): Unit = {
    val (_, decision) = pipeline.free.foldRun(
      PipelineState(ts, strategy, e)) {
      case (state, StartProcessing(whenActive, whenExpired, limitMs)) =>
        state -> (hasProcessingTimeExpired(state.ts, limitMs) match {
          case true => whenExpired(e)
          case false => whenActive(e)
        })
      case (state, Timed(whenActive, whenExpired, limitMs)) =>
        state -> (hasProcessingTimeExpired(state.ts, limitMs) match {
          case true => whenExpired()
          case false => whenActive()
        })
      case (state, TradingDecision(runStrategy)) =>
        state -> runStrategy(state.strategy)
    }

    decision.fold(logFailure, {
      case Some(order) =>
        sendTradingDecision(order)
        recordProcessingLatency(ProcessingLatencyMs(
          System.currentTimeMillis() - ts.value))
      case None =>
        recordProcessingLatency(ProcessingLatencyMs(
          System.currentTimeMillis() - ts.value))
    })
  }

  private def thunkToTask(ps: PipelineState): Thunk ~> Task = new (Thunk ~> Task) {
    def apply[B](t: Thunk[B]): Task[B] = t match {
      case StartProcessing(whenActive, whenExpired, limitMs) => Task.suspend(
        hasProcessingTimeExpired(ps.ts, limitMs) match {
          case true => Task.now(whenExpired(ps.event))
          case false => Task.now(whenActive(ps.event))
        })
      case Timed(whenActive, whenExpired, limitMs) => Task.suspend(
        hasProcessingTimeExpired(ps.ts, limitMs) match {
          case true => Task.now(whenExpired())
          case false => Task.now(whenActive())
        })
      case TradingDecision(runStrategy) =>
        Task.fork(Task.now(runStrategy(ps.strategy)))
    }
  }

  def runWithTaskInterpreter(
    recordProcessingLatency: ProcessingLatencyMs => Unit,
    s: TradingStrategy,
    ts: MessageSentTimestamp,
    e: BboUpdated) = {
    pipeline.free.foldMap(thunkToTask(PipelineState(ts, s, e)))
      .unsafePerformAsync {
        case -\/(ex) => logException(ex)
        case \/-(\/-(decision)) =>
          decision.foreach(sendTradingDecision)
          recordProcessingLatency(ProcessingLatencyMs(
            System.currentTimeMillis() - ts.value))
        case \/-(-\/(failure)) => logFailure(failure)
      }
  }
}
package highperfscala.concurrency.blocking

import scala.concurrent.{ExecutionContext, Future}

object BlockingExample {

  case class Ticker(value: String) extends AnyVal

  case class ClientId(value: Long) extends AnyVal

  case class Order(ticker: Ticker, clientId: ClientId)

  object Order {

    val staticList = List(
      Order(Ticker("FOO"), ClientId(12345)),
      Order(Ticker("FOO"), ClientId(5437)),
      Order(Ticker("BAR"), ClientId(12345)),
      Order(Ticker("FOO"), ClientId(9864)),
      Order(Ticker("BAR"), ClientId(12345)),
      Order(Ticker("BAR"), ClientId(5680)),
      Order(Ticker("BAR"), ClientId(12345)),
      Order(Ticker("FOO"), ClientId(542467))
    )
  }

  object JdbcOrderRepository {

    def findBuyOrders(
      client: ClientId,
      ticker: Ticker)(implicit ec: ExecutionContext): Future[List[Order]] = Future {
      Thread.sleep(100)
      Order.staticList.filter(o => o.clientId == client && o.ticker == ticker)
    }(ec)

    import scala.concurrent.ExecutionContext.Implicits.global

    def findBuyOrdersWithBlocking(
      client: ClientId,
      ticker: Ticker): Future[List[Order]] = Future {
      scala.concurrent.blocking {
        Thread.sleep(100)
        Order.staticList.filter(o => o.clientId == client && o.ticker == ticker)
      }
    }

  }

}
package highperfscala.concurrency.blocking

import java.util.concurrent.{ExecutorService, Executors, TimeUnit}

import highperfscala.concurrency.blocking.BlockingExample.{ClientId, Order, Ticker}
import org.openjdk.jmh.annotations.Mode.Throughput
import org.openjdk.jmh.annotations._

import scala.concurrent.duration.Duration
import scala.concurrent.{Await, ExecutionContext, Future}

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class BlockingFutureBenchmarks {

  import BlockingFutureBenchmarks._

  @Benchmark
  def withDefaultContext(state: BlockingFutureState): List[List[Order]] = {
    val futures = (1 until state.operations).map{_ =>
      BlockingExample.JdbcOrderRepository.findBuyOrders(
        state.clientId, state.ticker
      )(state.defaultC)
    }

    implicit val ex = state.defaultC
    Await.result(
      Future.sequence(futures).map(_.toList),
      Duration("5 minutes")
    )
  }

  @Benchmark
  def withDedicatedContext(state: BlockingFutureState): List[List[Order]] = {
    val futures = (1 until state.operations).map{_ =>
      BlockingExample.JdbcOrderRepository.findBuyOrders(
        state.clientId, state.ticker
      )(state.dedicatedC)
    }

    implicit val ex = state.defaultC  // we use CPU-bound context for computations below
    Await.result(
      Future.sequence(futures).map(_.toList),
      Duration("5 minutes")
    )
  }

}

object BlockingFutureBenchmarks {

  @State(Scope.Benchmark)
  class BlockingFutureState {

    @Param(Array("10", "1000"))
    var operations: Int = 0

    val clientId = ClientId(12345)
    val ticker = Ticker("FOO")

    var defaultC: ExecutionContext = null
    var dedicatedC: ExecutionContext = null
    var es: ExecutorService = null

    @Setup(Level.Trial)
    def setup(): Unit = {
      defaultC = scala.concurrent.ExecutionContext.global
      es = {
        val i = Runtime.getRuntime.availableProcessors * 20
        Executors.newFixedThreadPool(i)
      }
      dedicatedC = ExecutionContext.fromExecutorService(es)
    }

    @TearDown(Level.Trial)
    def tearDown(): Unit = {
      es.shutdownNow()
    }

  }

}
package highperfscala
package orderbook

import java.util.concurrent.TimeUnit

import highperfscala.orderbook.Commands._
import highperfscala.orderbook.Events.Event
import org.openjdk.jmh.annotations.Mode.Throughput
import org.openjdk.jmh.annotations._

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class CancelBenchmarks {
  import CancelBenchmarks._

  @Benchmark
  def eagerCancelLastOrderInLine(b: BookWithLargeQueue): (QueueOrderBook, Event) =
    QueueOrderBook.handle(systemEventTime, b.eagerBook, b.cancelLast)

  @Benchmark
  def eagerCancelFirstOrderInLine(b: BookWithLargeQueue): (QueueOrderBook, Event) =
    QueueOrderBook.handle(systemEventTime, b.eagerBook, b.cancelFirst)

  @Benchmark
  def eagerCancelNonexistentOrder(b: BookWithLargeQueue): (QueueOrderBook, Event) =
    QueueOrderBook.handle(systemEventTime, b.eagerBook, b.cancelNonexistent)

  @Benchmark
  def lazyCancelLastOrderInLine(b: BookWithLargeQueue): (LazyCancelOrderBook, Event) =
    LazyCancelOrderBook.handle(systemEventTime, b.lazyBook, b.cancelLast)

  @Benchmark
  def lazyCancelFirstOrderInLine(b: BookWithLargeQueue): (LazyCancelOrderBook, Event) =
    LazyCancelOrderBook.handle(systemEventTime, b.lazyBook, b.cancelFirst)

  @Benchmark
  def lazyCancelNonexistentOrder(b: BookWithLargeQueue): (LazyCancelOrderBook, Event) =
    LazyCancelOrderBook.handle(systemEventTime, b.lazyBook, b.cancelNonexistent)
}

object CancelBenchmarks {

  val systemEventTime = () => EventInstant.now()

  @State(Scope.Benchmark)
  class BookWithLargeQueue {
    private val p = Price(BigDecimal(1.00))
    private val firstId: Int = 1
    private val defaultCancelLast = CancelOrder(
      CommandInstant.now(), OrderId(-1))

    @Param(Array("1", "10"))
    var enqueuedOrderCount: Int = 0

    var eagerBook: QueueOrderBook = QueueOrderBook.empty

    var lazyBook: LazyCancelOrderBook = LazyCancelOrderBook.empty

    @Setup(Level.Trial)
    def setup(): Unit = {
      if (enqueuedOrderCount < 0)
        sys.error(s"Invalid enqueued order count = $enqueuedOrderCount")
      assert(eagerBook == QueueOrderBook.empty)
      assert(lazyBook == LazyCancelOrderBook.empty)
      assert(cancelLast == defaultCancelLast)

      cancelLast = CancelOrder(
        CommandInstant.now(), OrderId(enqueuedOrderCount))
      eagerBook = {
        (firstId to enqueuedOrderCount).foldLeft(QueueOrderBook.empty) {
          case (ob, i) =>
            QueueOrderBook.handle(
              () => EventInstant.now(),
              ob, AddLimitOrder(
                CommandInstant.now(), BuyLimitOrder(OrderId(i), p)))._1
        }
      }
      lazyBook = {
        (firstId to enqueuedOrderCount).foldLeft(LazyCancelOrderBook.empty) {
          case (ob, i) =>
            LazyCancelOrderBook.handle(
              () => EventInstant.now(),
              ob, AddLimitOrder(
                CommandInstant.now(), BuyLimitOrder(OrderId(i), p)))._1
        }
      }

      assert(cancelLast != defaultCancelLast)
      if (enqueuedOrderCount > 0)
        assert(eagerBook.bids.head._2.size == enqueuedOrderCount,
          s"Book built incorrectly! Expected book to contain " +
            s"$enqueuedOrderCount bids for $p, but actual book is $eagerBook")
    }

    var cancelLast: CancelOrder = defaultCancelLast
    val cancelFirst: CancelOrder = CancelOrder(
      CommandInstant.now(), OrderId(firstId))
    val cancelNonexistent: CancelOrder = CancelOrder(
      CommandInstant.now(), OrderId(-1))
  }
}

package highperfscala
package benchmarks

import java.util.concurrent.TimeUnit

import highperfscala.benchmarks.CancelBenchmarks._
import highperfscala.orderbook.Commands._
import highperfscala.orderbook.Events.Event
import highperfscala.orderbook.{BuyLimitOrder, OrderId, Price, OrderBook}
import org.openjdk.jmh.annotations._
import org.openjdk.jmh.annotations.Mode._

// Run via
// sbt ';project performance;jmh:run .*CancelBenchmarks -wi 3 -i 10 -f 1 -wbs 100000 -bs 100000 -jvmArgs "-Xmx1G -Xms1G" -foe true -p enqueuedOrderCount=10,100,1000,5000'
@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
class CancelBenchmarks {

  @Benchmark
  def cancelLastOrderInLine(b: BookWithLargeQueue): (OrderBook, Event) =
    OrderBook.handle(b.book, b.cancelLast)

  @Benchmark
  def cancelFirstOrderInLine(b: BookWithLargeQueue): (OrderBook, Event) =
    OrderBook.handle(b.book, b.cancelFirst)

  @Benchmark
  def cancelNonexistentOrder(b: BookWithLargeQueue): (OrderBook, Event) =
    OrderBook.handle(b.book, b.cancelNonexistent)
}

object CancelBenchmarks {

  @State(Scope.Benchmark)
  class BookWithLargeQueue {
    private val p = Price(BigDecimal(1.00))
    private val firstId: Int = 1
    private val defaultCancelLast = CancelOrder(OrderId(-1))

    @Param(Array("1", "100", "1000"))
    var enqueuedOrderCount: Int = 0

    var book: OrderBook = OrderBook.empty

    @Setup(Level.Trial)
    def setup(): Unit = {
      if (enqueuedOrderCount < 0)
        sys.error(s"Invalid enqueued order count = $enqueuedOrderCount")
      assert(book == OrderBook.empty)
      assert(cancelLast == defaultCancelLast)

      cancelLast = CancelOrder(OrderId(enqueuedOrderCount))
      book = {
        (firstId to enqueuedOrderCount).foldLeft(OrderBook.empty) {
          case (ob, i) =>
            OrderBook.handle(ob, AddLimitOrder(BuyLimitOrder(OrderId(i), p)))._1
        }
      }

      assert(cancelLast != defaultCancelLast)
      if (enqueuedOrderCount > 0)
        assert(book.bids.head._2.size == enqueuedOrderCount,
          s"Book built incorrectly! Expected book to contain " +
            s"$enqueuedOrderCount bids for $p, but actual book is $book")
    }

    var cancelLast: CancelOrder = defaultCancelLast
    val cancelFirst: CancelOrder = CancelOrder(OrderId(firstId))
    val cancelNonexistent: CancelOrder = CancelOrder(OrderId(-1))
  }
}
package highperfscala.crdt

case class CounterUpdate(i: Int)

case class GCounterState(uid: Int, counter: Int)

class StateBasedGCounter(
  val uid: Int,
  count: Int,
  otherCounters: Map[Int, Int]) {

  def value: Int = count + otherCounters.values.sum

  def update(
    change: CounterUpdate): (StateBasedGCounter, GCounterState) = {
    (new StateBasedGCounter(uid, count + change.i, otherCounters),
      GCounterState(uid, count))
  }

  def merge(other: GCounterState): StateBasedGCounter = {
    val newValue = other.counter max otherCounters.getOrElse(other.uid, 0)
    new StateBasedGCounter(uid, count, otherCounters.+(other.uid -> newValue))
  }
}

class OperationBasedCounter(count: Int) {

  def value: Int = count

  def update(change: CounterUpdate): (OperationBasedCounter, CounterUpdate) =
    new OperationBasedCounter(count + change.i) -> change

  def merge(operation: CounterUpdate): OperationBasedCounter =
    update(operation)._1

}

case class PNCounterState(
  incState: GCounterState,
  decState: GCounterState)

object StateBasedPNCounter {
  def newCounter(uid: Int): StateBasedPNCounter =
    new StateBasedPNCounter(
      new StateBasedGCounter(uid, 0, Map.empty),
      new StateBasedGCounter(uid, 0, Map.empty)
    )
}

class StateBasedPNCounter private(
  incCounter: StateBasedGCounter,
  decCounter: StateBasedGCounter) {

  def value = incCounter.value - decCounter.value

  def update(change: CounterUpdate): (StateBasedPNCounter, PNCounterState) = {
    val (newIncCounter, newDecCounter, stateUpdate) =
      change match {
        case CounterUpdate(c) if c >= 0 =>
          val (iC, iState) = incCounter.update(change)
          val dState = GCounterState(decCounter.uid, decCounter.value)
          (iC, decCounter, PNCounterState(iState, dState))
        case CounterUpdate(c) if c < 0 =>
          val (dC, dState) = decCounter.update(change)
          val iState = GCounterState(incCounter.uid, incCounter.value)
          (incCounter, dC, PNCounterState(iState, dState))
      }

    (new StateBasedPNCounter(newIncCounter, newDecCounter), stateUpdate)
  }

  def merge(other: PNCounterState): StateBasedPNCounter =
    new StateBasedPNCounter(
      incCounter.merge(other.incState),
      decCounter.merge(other.decState)
    )
}package highperfscala.dataanalysis.util

import java.io._

import highperfscala.dataanalysis.Execution
import org.slf4s.Logging

import scala.collection.mutable.ListBuffer

object DataCodec extends Logging {

  def write(cs: List[Execution], output: File): Unit = {
    val oos = new ObjectOutputStream(new FileOutputStream(output))
    cs.foreach(oos.writeObject)
    oos.close()
  }

  def read(input: File): List[Execution] = {
    val fis = new FileInputStream(input)

    val ois = new ObjectInputStream(fis)
    val commandBuilder = ListBuffer[Execution]()
    while(fis.available() != 0) {
      commandBuilder.append(ois.readObject().asInstanceOf[Execution])
    }
    ois.close()
    fis.close()

    commandBuilder.result()
  }

  def read(input: InputStream): List[Execution] = {
    val ois = new ObjectInputStream(input)
    val commandBuilder = ListBuffer[Execution]()
    while(input.available() != 0) {
      commandBuilder.append(ois.readObject().asInstanceOf[Execution])
    }
    ois.close()

    commandBuilder.result()
  }

}
package highperfscala.orderbook.util

import java.io._

import highperfscala.orderbook.Commands.Command
import org.slf4s.Logging

import scala.collection.mutable.ListBuffer

/**
  * This module provides functions to persist to/load from disk a list of
  * commands.
  */
object DataCodec extends Logging {

  def write(cs: List[Command], output: File): Unit = {
    val oos = new ObjectOutputStream(new FileOutputStream(output))
    cs.foreach(oos.writeObject)
    oos.close()
  }

  def read(input: File): List[Command] = {
    val fis = new FileInputStream(input)
    val ois = new ObjectInputStream(fis)
    val commandBuilder = ListBuffer[Command]()
    while(fis.available() != 0) {
      commandBuilder.append(ois.readObject().asInstanceOf[Command])
    }
    ois.close()
    fis.close()

    commandBuilder.result()
  }

}
package highperfscala
package benchmarks
package util

import java.io._

import orderbook.Commands.Command
import org.slf4s.Logging

import scala.collection.mutable.ListBuffer

/**
  * This module provides functions to persist to/load from disk a list of
  * commands.
  */
object DataCodec extends Logging {

  def write(cs: List[Command], output: File): Unit = {
    val oos = new ObjectOutputStream(new FileOutputStream(output))
    cs.foreach(oos.writeObject)
    oos.close()
  }

  def read(input: File): List[Command] = {
    val fis = new FileInputStream(input)
    val ois = new ObjectInputStream(fis)
    val commandBuilder = ListBuffer[Command]()
    while(fis.available() != 0) {
      commandBuilder.append(ois.readObject().asInstanceOf[Command])
    }
    ois.close()
    fis.close()

    commandBuilder.result()
  }

}
package highperfscala.dataanalysis.util

import highperfscala.dataanalysis._
import org.joda.time.DateTime

object DataGenerator {

  import java.io.File

  import org.scalacheck.Gen

  import scala.util.Random

  private def genExecution(time: DateTime): Gen[Execution] = for {
    bid <- Gen.chooseNum(1, 100)
    ask <- Gen.chooseNum(bid, bid+20)
    et = TimestampMinutes.fromDateTime(time)
  } yield Execution(et, AskPrice(ask), BidPrice(bid))

  def main(args: Array[String]): Unit = {

    val outputFile = new File(args(0))
    val minutes = args(1).toInt

    val startDt = DateTime.now().minusMinutes(minutes)

    val xs = for {
      i <- 0 to minutes
      time = startDt.plusMinutes(i)
      execCount = Random.nextInt(5) + 1
    } yield Gen.listOfN(execCount, genExecution(time)).sample.get

    DataCodec.write(xs.flatten.toList, outputFile)
  }

}
package highperfscala
package benchmarks
package util

object DataGenerator {

  import java.io.File

  import orderbook.Commands.{AddLimitOrder, CancelOrder, Command}
  import orderbook._
  import org.scalacheck.Gen

  import scala.util.Random

  /**
    * Generates fake historical data consisting of a list of commands to
    * be applied to an order book.
    */
  def main(args: Array[String]): Unit = {

    val outputFile = new File(args(0))
    val commandCount = args(1).toInt

    val orderedCommands = Random.shuffle(
      Gen.listOfN(commandCount / 2, LimitOrder.genLimitOrder).sample.get
        .map { order =>
          val nextCommand =
            if (cancelOrder()) CancelOrder(order.id)
            else AddLimitOrder(oppositeOrder(order))

          List(AddLimitOrder(order), nextCommand)
        })

    val commands = merge(orderedCommands, Nil)

    DataCodec.write(commands, outputFile)
  }

  /**
    * Randomly decide if an order should be canceled
    */
  private def cancelOrder(): Boolean = Random.nextInt(3) == 0

  private def oppositeOrder(o: LimitOrder): LimitOrder = o match {
    case BuyLimitOrder(_, price) =>
      SellLimitOrder(OrderId.genOrderId.sample.get, price)
    case SellLimitOrder(_, price) =>
      BuyLimitOrder(OrderId.genOrderId.sample.get, price)
  }

  /**
    * Merge a list of pairs, introducing randomness while making sure that
    * an order's complement comes later in the stream.
    */
  private def merge(ls: List[List[Command]], acc: List[Command]): List[Command] =
    ls match {
      case Nil => acc.reverse
      case List(c) :: rest => merge(rest, c :: acc)
      case List(c1, c2) :: rest =>
        merge(Random.shuffle(List(c2) :: rest), c1 :: acc)
    }

}
package highperfscala.free

import highperfscala.free.BboUpdatedPipeline.BboProcessingFailure

import scala.concurrent.duration.Duration
import Thunk._

class TimedStep[R](f: => R, d: Duration) {
  def orElse[L](l: => L): EitherFree[Thunk, L, R] =
    new EitherFree(timed(() => f, () => l, LimitMs(d.toMillis)))
}

class Step[R](f: => R) {
  def within(d: Duration): TimedStep[R] = new TimedStep[R](f, d)
}
object Step {
  def apply[R](f: => R): Step[R] = new Step(f)
}

class TimedStartingStep[R](f: BboUpdated => R, d: Duration) {
  def orElse[L](b: BboUpdated => L): EitherFree[Thunk, L, R] =
    new EitherFree(startProcessing(f, b, LimitMs(d.toMillis)))
}

class StartWith[R](f: BboUpdated => R) {
  def within(d: Duration): TimedStartingStep[R] = new TimedStartingStep[R](f, d)
}
object StartWith {
  def apply[R](f: BboUpdated => R): StartWith[R] = new StartWith(f)
}

object MakeTradingDecision {
  def apply(e: BboUpdated): EitherFree[Thunk, BboProcessingFailure, Option[Either[Bid, Offer]]] =
    new EitherFree(tradingDecision(_.makeTradingDecision(e)))

}
package highperfscala.free

import scalaz.{Free, \/}
import language.higherKinds

class EitherFree[A[_], L, R](val free: Free[A, L \/ R]) {
  def map[RR](f: R => RR): EitherFree[A, L, RR] =
    new EitherFree(free.map(_.map(f)))
  def flatMap[RR](f: R => EitherFree[A, L, RR]): EitherFree[A, L, RR] =
    new EitherFree(free.flatMap(_.fold(l =>
      Free.point[A, L \/ RR](\/.left[L, RR](l)), z => f(z).free)))
}
package highperfscala.clientreports.streams

import org.joda.time.{Duration, Instant}

object EventSourcing {

  sealed trait PnlEvent
  case class PnlIncreased(
    created: EventInstant, clientId: ClientId, ticker: Ticker, profit: Pnl
  ) extends PnlEvent
  case class PnlDecreased(
    created: EventInstant, clientId: ClientId, ticker: Ticker, loss: Pnl)
    extends PnlEvent

  case class Pnl(value: BigDecimal) extends AnyVal {
    def isProfit: Boolean = value.signum >= 0
    def +(p: Pnl): Pnl = Pnl(value + p.value)
    def -(p: Pnl): Pnl = Pnl(value - p.value)
  }
  object Pnl {
    def fromBidExecution(bid: Price, buy: Price): Pnl =
      Pnl(bid.value - buy.value)
    def fromOfferExecution(offer: Price, sell: Price): Pnl =
      Pnl(sell.value - offer.value)
    val zero: Pnl = Pnl(BigDecimal(0))
  }

  case class PendingOrder(ticker: Ticker, price: Price, clientId: ClientId)
  case class TradeState(
    pendingBuys: Map[OrderId, PendingOrder],
    pendingSells: Map[OrderId, PendingOrder]) {
    def cancelOrder(id: OrderId): TradeState = copy(
      pendingBuys = pendingBuys - id, pendingSells = pendingSells - id)
    def addPendingBuy(o: PendingOrder, id: OrderId): TradeState =
      copy(pendingBuys = pendingBuys + (id -> o))
    def addPendingSell(o: PendingOrder, id: OrderId): TradeState =
      copy(pendingSells = pendingSells + (id -> o))
  }
  object TradeState {
    val empty: TradeState = TradeState(Map.empty, Map.empty)
  }

  def processPnl(
    s: TradeState,
    e: OrderBookEvent): (TradeState, Option[PnlEvent]) = e match {
    case BuyOrderSubmitted(_, id, t, p, cId) =>
      s.addPendingBuy(PendingOrder(t, p, cId), id) -> None
    case SellOrderSubmitted(_, id, t, p, cId) =>
      s.addPendingSell(PendingOrder(t, p, cId), id) -> None
    case OrderCanceled(_, id) => s.cancelOrder(id) -> None
    case OrderExecuted(ts, id, price) =>
      val (p, o) = (s.pendingBuys.get(id), s.pendingSells.get(id)) match {
        case (Some(order), None) =>
          Pnl.fromBidExecution(order.price, price) -> order
        case (None, Some(order)) =>
          Pnl.fromOfferExecution(price, order.price) -> order
        case error => sys.error(
          s"Unsupported retrieval of ID = $id returned: $error")
      }
      s.cancelOrder(id) -> Some(
        if (p.isProfit) PnlIncreased(ts, o.clientId, o.ticker, p)
        else PnlDecreased(ts, o.clientId, o.ticker, p))
  }

  sealed trait LastHourPnL
  case object LastHourPositive extends LastHourPnL
  case object LastHourNegative extends LastHourPnL

  case class HourInstant(value: Instant) extends AnyVal {
    def isSameHour(h: HourInstant): Boolean =
      h.value.toDateTime.getHourOfDay == value.toDateTime.getHourOfDay
  }
  object HourInstant {
    def create(i: EventInstant): HourInstant =
      HourInstant(i.value.toDateTime.withMillisOfSecond(0)
        .withSecondOfMinute(0).withMinuteOfHour(0).toInstant)
  }
  case class HourlyPnlTrendCalculated(
    start: HourInstant,
    clientId: ClientId,
    ticker: Ticker,
    pnl: LastHourPnL)

  case class HourlyState(
    keyToHourlyPnl: Map[(ClientId, Ticker), (HourInstant, Pnl)])
  object HourlyState {
    val empty: HourlyState = HourlyState(Map.empty)
  }
  def processHourlyPnl(
    s: HourlyState,
    e: PnlEvent): (HourlyState, Option[HourlyPnlTrendCalculated]) = {
    def processChange(
      ts: EventInstant,
      clientId: ClientId,
      ticker: Ticker,
      pnl: Pnl): (HourlyState, Option[HourlyPnlTrendCalculated]) = {
      val (start, p) = s.keyToHourlyPnl.get((clientId, ticker)).fold(
        (HourInstant.create(ts), Pnl.zero))(identity)
      start.isSameHour(HourInstant.create(ts)) match {
        case true => (s.copy(keyToHourlyPnl = s.keyToHourlyPnl +
          ((clientId, ticker) ->(start, p + pnl))), None)
        case false => (s.copy(keyToHourlyPnl =
          s.keyToHourlyPnl + ((clientId, ticker) ->
            (HourInstant.create(ts), Pnl.zero + pnl))),
          Some(HourlyPnlTrendCalculated(start, clientId, ticker,
            p.isProfit match {
              case true => LastHourPositive
              case false => LastHourNegative
            })))
      }
    }

    e match {
      case PnlIncreased(ts, clientId, ticker, pnl) => processChange(
        ts, clientId, ticker, pnl)
      case PnlDecreased(ts, clientId, ticker, pnl) => processChange(
        ts, clientId, ticker, pnl)
    }
  }

  case class PipelineState(tradeState: TradeState, hourlyState: HourlyState)
  object PipelineState {
    val empty: PipelineState = PipelineState(TradeState.empty, HourlyState.empty)
  }

  def pipeline(
    initial: PipelineState,
    f: HourlyPnlTrendCalculated => Unit,
    xs: Stream[OrderBookEvent]): PipelineState = xs.foldLeft(initial) {
    case (PipelineState(ts, hs), e) =>
      val (tss, pnlEvent) = processPnl(ts, e)
      PipelineState(tss,
        pnlEvent.map(processHourlyPnl(hs, _)).fold(hs) {
          case (hss, Some(hourlyEvent)) =>
            f(hourlyEvent)
            hss
          case (hss, None) => hss
        })
  }

  def main(args: Array[String]): Unit = {
    val now = EventInstant(HourInstant.create(EventInstant(
      new Instant())).value)
    val Foo = Ticker("FOO")

    pipeline(PipelineState.empty, println, Stream(
      BuyOrderSubmitted(now, OrderId(1), Foo, Price(21.07), ClientId(1)),
      OrderExecuted(EventInstant(now.value.plus(Duration.standardMinutes(30))),
        OrderId(1), Price(21.00)),
      BuyOrderSubmitted(EventInstant(now.value.plus(
        Duration.standardMinutes(35))),
        OrderId(2), Foo, Price(24.02), ClientId(1)),
      OrderExecuted(EventInstant(now.value.plus(Duration.standardHours(1))),
        OrderId(2), Price(24.02))))
  }
}
package highperfscala.features

import highperfscala.orderbook.Events.OrderExecuted
import highperfscala.orderbook.{EventInstant, Execution}

import scalaz.{@@, Tag}

object FeatureGeneration {

  case class MidpointPrice(value: BigDecimal) extends AnyVal
  object MidpointPrice {
    def create(buy: Execution, sell: Execution): MidpointPrice =
      MidpointPrice((buy.price.value + sell.price.value) / BigDecimal(2))
  }
  case class EventSeconds(value: Long) extends AnyVal
  object EventSeconds {
    def create(i: EventInstant): EventSeconds =
      EventSeconds(i.value.getMillis / 1000l)
  }

  sealed trait PerSecond
  def midpointPerSecond(p: MidpointPrice): MidpointPrice @@ PerSecond = Tag(p)

  // Illustrate example with fold to show the principle of monoid

  def foo(xs: List[OrderExecuted]) = {
    val secondlyPrices = xs.map(e => e.i -> MidpointPrice.create(e.buy, e.sell))
      .groupBy(z => EventSeconds.create(z._1))
      // What about missing indices?
      .mapValues(prices => midpointPerSecond(MidpointPrice(
      prices.map(_._2).reduceOption((x, y) =>
        MidpointPrice(x.value + y.value)).getOrElse(MidpointPrice(
        BigDecimal(0))).value / prices.size)))
      .toList.sortWith((x, y) => x._1.value <= y._1.value)
      .map(_._2)

    secondlyPrices.sliding(size = 6)
    secondlyPrices.sliding(size = 11)
    secondlyPrices.sliding(size = 21)


  }

}
package highperfscala
package benchmarks

import java.io.File
import highperfscala.orderbook.Commands.Command
import highperfscala.orderbook.OrderBook
import org.mpierce.metrics.reservoir.hdrhistogram.HdrHistogramReservoir
import util._

import scala.annotation.tailrec

object FinalLatencyBenchmark {

  case class CommandsPerSecond(value: Int) extends AnyVal
  case class BenchmarkIterationCount(value: Int) extends AnyVal
  case class CommandSentTimestamp(value: Long) extends AnyVal

  def runBenchmark(
    sampleCommands: List[Command],
    cps: CommandsPerSecond,
    count: BenchmarkIterationCount): Unit = {
    val totalCommandCount = cps.value * count.value

    jvmWarmUp(sampleCommands)

    @tailrec
    def sendCommands(
      xs: List[(Command, Int)],
      ob: OrderBook,
      testStart: Long,
      histogram: HdrHistogramReservoir): (OrderBook, HdrHistogramReservoir) =
      xs match {
        case head :: tail =>
          val (command, offsetInMs) = head
          val shouldStart = testStart + offsetInMs

          while (shouldStart > System.currentTimeMillis()) {
            // keep the thread busy while waiting for the next batch to be sent
          }

          val newBook = OrderBook.handle(ob, command)._1
          val operationEnd = System.currentTimeMillis()
          histogram.update(operationEnd - shouldStart)

          sendCommands(tail, newBook, testStart, histogram)
        case Nil => (ob, histogram)
      }

    val (_, histogram) = sendCommands(
      generateCount(sampleCommands, totalCommandCount)
        .grouped(cps.value)
        .toList.zipWithIndex
        .flatMap {
          case (secondBatch, sBatchIndex) =>
            val batchOffsetInMs = sBatchIndex * 1000
            val commandIntervalInMs = 1000.0 / cps.value
            secondBatch.zipWithIndex.map {
              case (command, commandIndex) =>
                val commandOffsetInMs =
                  Math.floor(commandIntervalInMs * commandIndex).toInt
                (command, batchOffsetInMs + commandOffsetInMs)
            }
        },
      OrderBook.empty,
      System.currentTimeMillis(),
      new HdrHistogramReservoir())

    printSnapshot(histogram.getSnapshot)
  }

  def main(args: Array[String]): Unit = {
    runBenchmark(DataCodec.read(new File(args(0))),
      CommandsPerSecond(args(1).toInt),
      BenchmarkIterationCount(args(2).toInt))
  }
}
package highperfscala.benchmarks

import java.io.File

import highperfscala.benchmarks.util._
import highperfscala.orderbook.Commands.Command
import highperfscala.orderbook.OrderBook
import org.mpierce.metrics.reservoir.hdrhistogram.HdrHistogramReservoir

import scala.annotation.tailrec

object FirstLatencyBenchmark {

  def main(args: Array[String]): Unit = {

    val commandSample = DataCodec.read(new File(args(0)))
    val (commandsPerSecond, iterations) = (args(1).toInt, args(2).toInt)
    val totalCommandCount = commandsPerSecond * iterations

    jvmWarmUp(commandSample)

    @tailrec
    def sendCommands(
      xs: List[(List[Command], Int)],
      ob: OrderBook,
      testStart: Long,
      histogram: HdrHistogramReservoir): (OrderBook, HdrHistogramReservoir) =
      xs match {
        case head :: tail =>
          val (batch, offsetInSeconds) = head
          val shouldStart = testStart + (1000 * offsetInSeconds)

          while (shouldStart > System.currentTimeMillis()) {
            // keep the thread busy while waiting for the next batch to be sent
          }

          val updatedBook = batch.foldLeft(ob) {
            case (accBook, c) =>
              val operationStart = System.currentTimeMillis()
              val newBook = OrderBook.handle(accBook, c)._1
              val operationEnd = System.currentTimeMillis()
              // record latency
              histogram.update(operationEnd - operationStart)
              newBook
          }

          sendCommands(tail, updatedBook, testStart, histogram)
        case Nil => (ob, histogram)
      }

    val (_, histogram) = sendCommands(
      // Organizes commands per 1 second batches
      generateCount(commandSample, totalCommandCount)
        .grouped(commandsPerSecond).zipWithIndex
        .toList,
      OrderBook.empty,
      System.currentTimeMillis(),
      new HdrHistogramReservoir())

    printSnapshot(histogram.getSnapshot)
  }
}
package highperfscala.concurrency.future

import scala.concurrent.Future
import scala.util.{Failure, Success}
import scalaz.{\/-, \/}

object FutureErrorHandling {
  def main(args: Array[String]): Unit = {
    implicit val context = scala.concurrent.ExecutionContext.global
    def failedTransform(): Unit = {
      Future("not-an-integer").map(_.toInt).map(i => {
        println("Multiplying")
        i * 2
      })
      Thread.sleep(1000)
    }

    def recoverWith(): Unit = {
      Future("not-an-integer").map(_.toInt).recover {
        case _: NumberFormatException => -2
      }.map(i => {
        println("Multiplying")
        i * 2
      }).onComplete {
        case Success(i) => println(s"Multiplication result = $i")
        case Failure(e) => println(s"Failed due to ${e.getMessage}")
      }
      Thread.sleep(1000)
    }

    def disjunction(): Unit = {
      scalaz.\/.right[Throwable, Int](1).map(_ * 2)

    }

    recoverWith()
  }
}
package highperfscala.concurrency.future

object FutureExample {

  def main(args: Array[String]): Unit = {
    import scala.concurrent.Future
    implicit val context = scala.concurrent.ExecutionContext.global
    Future(1).map(_ + 1).filter(_ % 2 == 0).foreach(println)

    Future(1).map(i => {
      println(Thread.currentThread().getName)
      i + 1
    }).filter(i => {
      println(Thread.currentThread().getName)
      i % 2 == 0
    }).foreach(println)
  }
}
package highperfscala.free

import com.codahale.metrics.Snapshot
import org.slf4s.Logging

object GenericBenchmark extends Logging {
  private def infiniteCommands[A](sample: List[A]): Stream[A] =
    Stream.continually(sample.toStream).flatten

  private def generateCount[A](sample: List[A], count: Int): List[A] =
    infiniteCommands(sample).take(count).toList

  private def jvmWarmUp[A, B](
    sample: List[A],
    init: B,
    f: (MessageSentTimestamp, B, A) => B): Unit = {
    log.debug("Begin warm up")
    val commands = generateCount(sample, 100000)
    commands.foldLeft(init) {
      case (acc, a) =>
        f(MessageSentTimestamp(System.currentTimeMillis()), acc, a)
    }
    log.debug(s"End warm up")
  }

  def printSnapshot(s: Snapshot): Unit = println {
    s"""
       |Processed ${s.size} commands
       |mean latency: ${s.getMean} ms
       |median latency: ${s.getMedian} ms
       |75p latency: ${s.get75thPercentile()} ms
       |99p latency: ${s.get99thPercentile()} ms
       |99.9p latency: ${s.get999thPercentile()} ms
       |Maximum latency: ${s.getMax} ms
        """.stripMargin
  }

  case class MessagesPerSecond(value: Int) extends AnyVal
  case class BenchmarkIterationCount(value: Int) extends AnyVal
  case class MessageSentTimestamp(value: Long) extends AnyVal

  def runBenchmark[A, B](
    sampleMessages: List[A],
    mps: MessagesPerSecond,
    count: BenchmarkIterationCount,
    warmup: (B, (MessageSentTimestamp, B, A) => B),
    afterWarmUp: () => Unit,
    handleEvent: (MessageSentTimestamp, A) => Unit): Unit = {
    val totalMessageCount = mps.value * count.value

    Function.tupled(jvmWarmUp(
      sampleMessages, _: B, _: (MessageSentTimestamp, B, A) => B))(warmup)

    afterWarmUp()

    var messagesWithOffset =
      generateCount(sampleMessages, totalMessageCount)
        .grouped(mps.value)
        .toList.zipWithIndex
        .flatMap {
          case (secondBatch, sBatchIndex) =>
            val batchOffsetInMs = sBatchIndex * 1000
            val messageIntervalInMs = 1000.0 / mps.value
            secondBatch.zipWithIndex.map {
              case (command, commandIndex) =>
                val commandOffsetInMs =
                  Math.floor(messageIntervalInMs * commandIndex).toInt
                (command, batchOffsetInMs + commandOffsetInMs)
            }
        }

    val testStart = System.currentTimeMillis()

    while (messagesWithOffset.nonEmpty) {
      val (message, offsetInMs) = messagesWithOffset.head
      val shouldStart = testStart + offsetInMs

      while (shouldStart > System.currentTimeMillis()) {
        // keep the thread busy while waiting for the next batch to be sent
      }

      handleEvent(MessageSentTimestamp(shouldStart), message)
      messagesWithOffset = messagesWithOffset.tail
    }
  }
}
package highperfscala.specialization

object Inheritance {

  class ParentFoo[@specialized T](t: T)
  class ChildFoo[T](t: T) extends ParentFoo[T](t)

  def newChildFoo(i: Int): ChildFoo[Int] = new ChildFoo(i)

  trait ParentBar[@specialized T] {
    def t(): T
  }

  class ChildBar[@specialized T](val t: T) extends ParentBar[T]

  def newChildBar(i: Int): ChildBar[Int] = new ChildBar(i)
}
package highperfscala.orderbook

import java.util.concurrent.TimeUnit

import highperfscala.orderbook.Commands.{CancelOrder, AddLimitOrder}
import org.openjdk.jmh.annotations.Mode.Throughput
import org.openjdk.jmh.annotations._
import InterleavedOrderBenchmarks._

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class InterleavedOrderBenchmarks {

  @Benchmark
  def eagerOneToOneCT(state: InterleavedOrderState): QueueOrderBook = {
    val b1 = QueueOrderBook.handle(() => EventInstant.now(),
      state.eagerBook, firstCancel)._1
    QueueOrderBook.handle(() => EventInstant.now(),
      b1, firstCrossSell)._1
  }

  @Benchmark
  def lazyOneToOneCT(state: InterleavedOrderState): LazyCancelOrderBook = {
    val b1 = LazyCancelOrderBook.handle(() => EventInstant.now(),
      state.lazyBook, firstCancel)._1
    LazyCancelOrderBook.handle(() => EventInstant.now(),
      b1, firstCrossSell)._1
  }

  @Benchmark
  def eagerTwoToOneCT(state: InterleavedOrderState): QueueOrderBook = {
    val b1 = QueueOrderBook.handle(() => EventInstant.now(),
      state.eagerBook, firstCancel)._1
    val b2 = QueueOrderBook.handle(() => EventInstant.now(),
      b1, secondCancel)._1
    QueueOrderBook.handle(() => EventInstant.now(),
      b2, firstCrossSell)._1
  }

  @Benchmark
  def lazyTwoToOneCT(state: InterleavedOrderState): LazyCancelOrderBook = {
    val b1 = LazyCancelOrderBook.handle(() => EventInstant.now(),
      state.lazyBook, firstCancel)._1
    val b2 = LazyCancelOrderBook.handle(() => EventInstant.now(),
      b1, secondCancel)._1
    LazyCancelOrderBook.handle(() => EventInstant.now(),
      b2, firstCrossSell)._1
  }

  @Benchmark
  def eagerOneToTwoCT(state: InterleavedOrderState): QueueOrderBook = {
    val b1 = QueueOrderBook.handle(() => EventInstant.now(),
      state.eagerBook, firstCancel)._1
    val b2 = QueueOrderBook.handle(() => EventInstant.now(),
      b1, firstCrossSell)._1
    QueueOrderBook.handle(() => EventInstant.now(),
      b2, secondCrossSell)._1
  }

  @Benchmark
  def lazyOneToTwoCT(state: InterleavedOrderState): LazyCancelOrderBook = {
    val b1 = LazyCancelOrderBook.handle(() => EventInstant.now(),
      state.lazyBook, firstCancel)._1
    val b2 = LazyCancelOrderBook.handle(() => EventInstant.now(),
      b1, firstCrossSell)._1
    LazyCancelOrderBook.handle(() => EventInstant.now(),
      b2, secondCrossSell)._1
  }
}

object InterleavedOrderBenchmarks {
  private val bidPrice = Price(BigDecimal(5))
  private val maxOrderCount = 30

  val firstCancel: CancelOrder = CancelOrder(CommandInstant.now(), OrderId(1))
  val secondCancel: CancelOrder = CancelOrder(CommandInstant.now(), OrderId(2))
  val firstCrossSell: AddLimitOrder = AddLimitOrder(CommandInstant.now(),
    SellLimitOrder(OrderId(maxOrderCount + 1), Price(bidPrice.value - 1)))
  val secondCrossSell: AddLimitOrder = AddLimitOrder(CommandInstant.now(),
    SellLimitOrder(OrderId(maxOrderCount + 2), Price(bidPrice.value - 1)))

  @State(Scope.Benchmark)
  class InterleavedOrderState {
    var lazyBook: LazyCancelOrderBook = LazyCancelOrderBook.empty
    var eagerBook: QueueOrderBook = QueueOrderBook.empty

    @Setup
    def setup(): Unit = {
      lazyBook = (1 to maxOrderCount).foldLeft(LazyCancelOrderBook.empty) {
        case (b, i) => LazyCancelOrderBook.handle(
          () => EventInstant.now(), b, AddLimitOrder(
            CommandInstant.now(), BuyLimitOrder(OrderId(i), bidPrice)))._1
      }
      eagerBook = (1 to maxOrderCount).foldLeft(QueueOrderBook.empty) {
        case (b, i) => QueueOrderBook.handle(
          () => EventInstant.now(), b, AddLimitOrder(
            CommandInstant.now(), BuyLimitOrder(OrderId(i), bidPrice)))._1
      }
    }
  }
}
package highperfscala
package benchmarks

import java.io._
import java.net._

object IoExample {

  def main(args: Array[String]): Unit = {

    new Thread(new Runnable {
      def run(): Unit = {
        var messageCount = 0
        val welcomeSocket = new ServerSocket(6789)
        val connectionSocket = welcomeSocket.accept()
        val inFromClient = new BufferedReader(new InputStreamReader(
          connectionSocket.getInputStream()))
        while (messageCount < 10000) {
          val clientSentence = inFromClient.readLine()
          System.out.println("Received: " + clientSentence)
          messageCount = messageCount + 1
        }
      }
    }).start()

    Thread.sleep(100)

    val clientSocket = new Socket("localhost", 6789)
    val outToServer = new DataOutputStream(clientSocket.getOutputStream())
    val pw = new PrintWriter("/tmp/foobar")
    for (i <- 1 to 10000) {
      println("Writing message")
      outToServer.writeBytes("hello\n")
      Thread.sleep(1)
      pw.write("hello\n")
    }
    pw.close()
    clientSocket.close()
  }
}
package highperfscala.orderbook

import java.io.File

import highperfscala.orderbook.util.DataCodec
import org.mpierce.metrics.reservoir.hdrhistogram.HdrHistogramReservoir
import util._

object LatencyBenchmark {

  sealed trait BookImplementation
  case object QueueImplementation extends BookImplementation
  case object LazyImplementation extends BookImplementation
  object BookImplementation {
    def fromString(s: String): Option[BookImplementation] =
      s.toLowerCase() match {
        case "lazy" => Some(LazyImplementation)
        case "queue" => Some(QueueImplementation)
        case _ => None
      }
  }

  def main(args: Array[String]): Unit = {

    val commandSample = DataCodec.read(new File(args(0)))
    val (commandsPerSecond, iterations) = (args(1).toInt, args(2).toInt)
    val bookImplementation = BookImplementation.fromString(args(3)).fold(
      sys.error(s"Unsupported book implementation = ${args(3)}"))(identity)

    val totalCommandCount = commandsPerSecond * iterations

    // Circular dependency with BookImplementation
    jvmWarmUp(commandSample, bookImplementation)

    val histogram = new HdrHistogramReservoir()

    var commandsWithOffset =
      generateCount(commandSample, totalCommandCount)
        .grouped(commandsPerSecond)
        .toList.zipWithIndex
        .flatMap {
          case (secondBatch, sBatchIndex) =>
            val batchOffsetInMs = sBatchIndex * 1000
            val commandIntervalInMs = 1000.0 / commandsPerSecond
            secondBatch.zipWithIndex.map {
              case (command, commandIndex) =>
                val commandOffsetInMs =
                  Math.floor(commandIntervalInMs * commandIndex).toInt
                (command, batchOffsetInMs + commandOffsetInMs)
            }
        }

    val systemEventTime = () => EventInstant.now()
    val testStart = System.currentTimeMillis()

    // This is terrible duplication
    bookImplementation match {
      case LazyImplementation =>
        var book = LazyCancelOrderBook.empty

        while (commandsWithOffset.nonEmpty) {
          val (command, offsetInMs) = commandsWithOffset.head
          val shouldStart = testStart + offsetInMs

          while (shouldStart > System.currentTimeMillis()) {
            // keep the thread busy while waiting for the next batch to be sent
          }

          book = LazyCancelOrderBook.handle(systemEventTime, book, command)._1
          val end = System.currentTimeMillis()
          // record latency
          histogram.update(end - shouldStart)

          commandsWithOffset = commandsWithOffset.tail
        }

        printSnapshot(histogram.getSnapshot)
      case QueueImplementation =>
        var book = QueueOrderBook.empty

        while (commandsWithOffset.nonEmpty) {
          val (command, offsetInMs) = commandsWithOffset.head
          val shouldStart = testStart + offsetInMs

          while (shouldStart > System.currentTimeMillis()) {
            // keep the thread busy while waiting for the next batch to be sent
          }

          book = QueueOrderBook.handle(systemEventTime, book, command)._1
          val end = System.currentTimeMillis()
          // record latency
          histogram.update(end - shouldStart)

          commandsWithOffset = commandsWithOffset.tail
        }

        printSnapshot(histogram.getSnapshot)
    }
  }

}
package highperfscala
package orderbook

import highperfscala.orderbook.Commands._
import highperfscala.orderbook.Events._

import scala.annotation.tailrec
import scala.collection.immutable.{Queue, TreeMap}

// http://web.archive.org/web/20110312023826/http://www.quantcup.org/home/howtohft_howtobuildafastlimitorderbook
case class LazyCancelOrderBook(
  activeIds: Set[OrderId],
  pendingCancelIds: Set[OrderId],
  bids: TreeMap[Price, Queue[BuyLimitOrder]],
  offers: TreeMap[Price, Queue[SellLimitOrder]]) {
  def bestBid: Option[BuyLimitOrder] = bids.lastOption.flatMap(_._2.headOption)
  def bestOffer: Option[SellLimitOrder] =
    offers.headOption.flatMap(_._2.headOption)
}

object LazyCancelOrderBook {
  val noEvent: Option[Event] = None
  val empty: LazyCancelOrderBook = LazyCancelOrderBook(
    Set.empty,
    Set.empty,
    TreeMap.empty[Price, Queue[BuyLimitOrder]],
    TreeMap.empty[Price, Queue[SellLimitOrder]])

  // Could make sense to handle with State monad
  def handle(
    currentTime: () => EventInstant,
    ob: LazyCancelOrderBook,
    c: Command): (LazyCancelOrderBook, Event) = c match {
    case AddLimitOrder(_, o) => handleAddLimitOrder(currentTime, ob, o)
    case CancelOrder(_, id) => handleCancelOrder(currentTime, ob, id)
  }

  // Am cheating by adding order to book if current level does not have active
  // order
  private def handleAddLimitOrder(
    currentTime: () => EventInstant,
    ob: LazyCancelOrderBook,
    lo: LimitOrder): (LazyCancelOrderBook, Event) = lo match {
    case b: BuyLimitOrder =>
      @tailrec
      def findActiveOrder(
        q: Queue[SellLimitOrder],
        idsToRemove: Set[OrderId]): (Option[SellLimitOrder], Option[Queue[SellLimitOrder]], Set[OrderId]) =
        q.dequeueOption match {
          case Some((o, qq)) => ob.pendingCancelIds.contains(o.id) match {
            case true =>
              findActiveOrder(qq, idsToRemove + o.id)
            case false =>
              (Some(o), if (qq.nonEmpty) Some(qq) else None, idsToRemove + o.id)
          }
          case None => (None, None, idsToRemove)
        }

      def restLimitOrder: (LazyCancelOrderBook, Event) = {
        val orders = ob.bids.getOrElse(b.price, Queue.empty)
        ob.copy(bids = ob.bids + (b.price -> orders.enqueue(b)),
          activeIds = ob.activeIds + b.id) -> LimitOrderAdded(currentTime())
      }

      ob.bestOffer.exists(_.price.value <= b.price.value) match {
        case true => ob.offers.headOption.fold(restLimitOrder) {
          case (p, q) => findActiveOrder(q, Set.empty) match {
            case (Some(o), Some(qq), rms) => (ob.copy(
              offers = ob.offers + (o.price -> qq),
              activeIds = ob.activeIds -- rms), OrderExecuted(currentTime(),
              Execution(b.id, o.price), Execution(o.id, o.price)))
            case (Some(o), None, rms) => (ob.copy(
              offers = ob.offers - o.price, activeIds = ob.activeIds -- rms),
              OrderExecuted(currentTime(),
                Execution(b.id, o.price), Execution(o.id, o.price)))
            case (None, _, rms) =>
              val bs = ob.bids.getOrElse(b.price, Queue.empty).enqueue(b)
              (ob.copy(bids = ob.bids + (b.price -> bs),
                offers = ob.offers - p,
                activeIds = ob.activeIds -- rms + b.id),
                LimitOrderAdded(currentTime()))
          }
        }
        case false => restLimitOrder
      }

    case s: SellLimitOrder =>
      @tailrec
      def findActiveOrder(
        q: Queue[BuyLimitOrder],
        idsToRemove: Set[OrderId]): (Option[BuyLimitOrder], Option[Queue[BuyLimitOrder]], Set[OrderId]) =
        q.dequeueOption match {
          case Some((o, qq)) => ob.pendingCancelIds.contains(o.id) match {
            case true =>
              findActiveOrder(qq, idsToRemove + o.id)
            case false =>
              (Some(o), if (qq.nonEmpty) Some(qq) else None, idsToRemove + o.id)
          }
          case None => (None, None, idsToRemove)
        }

      def restLimitOrder: (LazyCancelOrderBook, Event) = {
        val orders = ob.offers.getOrElse(s.price, Queue.empty)
        ob.copy(offers = ob.offers + (s.price -> orders.enqueue(s)),
          activeIds = ob.activeIds + s.id) ->
          LimitOrderAdded(currentTime())
      }

      ob.bestBid.exists(_.price.value >= s.price.value) match {
        case true => ob.bids.headOption.fold(restLimitOrder) {
          case (p, q) => findActiveOrder(q, Set.empty) match {
            case (Some(o), Some(qq), rms) => (ob.copy(
              bids = ob.bids + (o.price -> qq), activeIds = ob.activeIds -- rms),
              OrderExecuted(currentTime(),
                Execution(o.id, o.price), Execution(s.id, o.price)))

            case (Some(o), None, rms) => (ob.copy(
              bids = ob.bids - o.price, activeIds = ob.activeIds -- rms),
              OrderExecuted(currentTime(),
                Execution(o.id, o.price), Execution(s.id, o.price)))

            // If no order found, implies that the queue is now empty
            case (None, _, rms) =>
              val os = ob.offers.getOrElse(s.price, Queue.empty).enqueue(s)
              (ob.copy(offers = ob.offers + (s.price -> os),
                bids = ob.bids - p, activeIds = ob.activeIds -- rms + s.id),
                LimitOrderAdded(currentTime()))
          }
        }
        case false => restLimitOrder
      }
  }

  private def handleCancelOrder(
    currentTime: () => EventInstant,
    ob: LazyCancelOrderBook,
    id: OrderId): (LazyCancelOrderBook, Event) =
    ob.activeIds.contains(id) match {
      case true => ob.copy(activeIds = ob.activeIds - id,
        pendingCancelIds = ob.pendingCancelIds + id) ->
        OrderCanceled(currentTime(), id)
      case false => ob -> OrderCancelRejected(currentTime(), id)
    }
}


package highperfscala.orderbook

import highperfscala.orderbook.Commands.{AddLimitOrder, CancelOrder}
import highperfscala.orderbook.Events.{OrderCancelRejected, OrderCanceled}
import org.scalacheck.Prop
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification

class LazyCancelOrderBookCancelingSpec extends Specification with ScalaCheck {

  """Given empty book
    |When cancel order arrives
    |Then OrderCancelRejected
  """.stripMargin ! Prop.forAll(
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (id, ci, ei) =>
    LazyCancelOrderBook.handle(
      () => ei, LazyCancelOrderBook.empty, CancelOrder(ci, id))._2 ====
      OrderCancelRejected(ei, id)
  }

  """Given empty book
    |and buy limit order added
    |When cancel order arrives
    |Then OrderCanceled
  """.stripMargin ! Prop.forAll(
    BuyLimitOrder.genBuyLimitOrder,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (o, ci, ei) =>
    (LazyCancelOrderBook.handle(
      () => ei, _: LazyCancelOrderBook, AddLimitOrder(ci, o))).andThen {
      case (ob, _) => LazyCancelOrderBook.handle(
        () => ei, ob, CancelOrder(ci, o.id))._2
    }(LazyCancelOrderBook.empty) ==== OrderCanceled(ei, o.id)
  }

  """Given empty book
    |and sell limit order added
    |When cancel order arrives
    |Then OrderCanceled
  """.stripMargin ! Prop.forAll(
    SellLimitOrder.genSellLimitOrder,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (o, ci, ei) =>
    (LazyCancelOrderBook.handle(
      () => ei, _: LazyCancelOrderBook, AddLimitOrder(ci, o))).andThen {
      case (ob, _) => LazyCancelOrderBook.handle(
        () => ei, ob, CancelOrder(ci, o.id))._2
    }(LazyCancelOrderBook.empty) ==== OrderCanceled(ei, o.id)
  }

}
package highperfscala.orderbook

import highperfscala.orderbook.Commands.{AddLimitOrder, CancelOrder}
import highperfscala.orderbook.Events.{LimitOrderAdded, OrderCancelRejected, OrderExecuted}
import org.scalacheck.Prop
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification

class LazyCancelOrderBookTradingSpec extends Specification with ScalaCheck {

  """Given empty book
    |When limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(
    LimitOrder.genLimitOrder,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (l, ci, ei) =>
    LazyCancelOrderBook.handle(
      () => ei, LazyCancelOrderBook.empty, AddLimitOrder(ci, l))._2 ====
      LimitOrderAdded(ei)
  }

  """Given empty book
    |and buy limit order added
    |When resting sell limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(
    BuyLimitOrder.genBuyLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (buy, id, ci, ei) =>
    (LazyCancelOrderBook.handle(
      () => ei, _: LazyCancelOrderBook, AddLimitOrder(ci, buy))).andThen {
      case (ob, _) => LazyCancelOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
        SellLimitOrder(id, Price(buy.price.value + 0.01))))._2
    }(LazyCancelOrderBook.empty) ==== LimitOrderAdded(ei)
  }

  """Given empty book
    |and sell limit order added
    |When resting buy limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(
    SellLimitOrder.genSellLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (sell, id, ci, ei) =>
    (LazyCancelOrderBook.handle(() => ei, _: LazyCancelOrderBook, AddLimitOrder(ci, sell)))
      .andThen {
        case (ob, _) => LazyCancelOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
          BuyLimitOrder(id, Price(sell.price.value - 0.01))))._2
      }(LazyCancelOrderBook.empty) ==== LimitOrderAdded(ei)
  }

  """Given empty book
    |and buy limit order added
    |When crossing sell limit order arrives
    |Then OrderExecuted
  """.stripMargin ! Prop.forAll(
    BuyLimitOrder.genBuyLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (buy, id, ci, ei) =>
    (LazyCancelOrderBook.handle(() => ei, _: LazyCancelOrderBook, AddLimitOrder(ci, buy)))
      .andThen {
        case (ob, _) => LazyCancelOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
          SellLimitOrder(id, Price(buy.price.value - 0.01))))._2
      }(LazyCancelOrderBook.empty) ==== OrderExecuted(ei,
      Execution(buy.id, buy.price), Execution(id, buy.price))
  }

  """Given empty book
    |and sell limit order added
    |When crossing buy limit order arrives
    |Then OrderExecuted
  """.stripMargin ! Prop.forAll(
    SellLimitOrder.genSellLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (sell, id, ci, ei) =>
    (LazyCancelOrderBook.handle(() => ei, _: LazyCancelOrderBook, AddLimitOrder(ci, sell)))
      .andThen {
        case (ob, _) => LazyCancelOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
          BuyLimitOrder(id, Price(sell.price.value + 0.01))))._2
      }(LazyCancelOrderBook.empty) ==== OrderExecuted(ei,
      Execution(id, sell.price), Execution(sell.id, sell.price))
  }

  """Given empty book
    |When cancel order command arrives
    |Then OrderCancelRejected
  """.stripMargin ! Prop.forAll(
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (id, ci, ei) =>
    LazyCancelOrderBook.handle(() => ei, LazyCancelOrderBook.empty, CancelOrder(ci, id))
      ._2 ==== OrderCancelRejected(ei, id)
  }
}
package highperfscala
package orderbook

import orderbook.Commands._
import orderbook.Events._

import scala.collection.immutable.TreeMap

// http://web.archive.org/web/20110312023826/http://www.quantcup.org/home/howtohft_howtobuildafastlimitorderbook
case class ListOrderBook(
  bids: TreeMap[Price, List[BuyLimitOrder]],
  offers: TreeMap[Price, List[SellLimitOrder]]) {
  def bestBid: Option[BuyLimitOrder] = bids.lastOption.flatMap(_._2.headOption)
  def bestOffer: Option[SellLimitOrder] =
    offers.headOption.flatMap(_._2.headOption)
}

object ListOrderBook {
  val noEvent: Option[Event] = None
  val empty: ListOrderBook = ListOrderBook(
    TreeMap.empty[Price, List[BuyLimitOrder]],
    TreeMap.empty[Price, List[SellLimitOrder]])

  // Could make sense to handle with State monad
  def handle(
    currentTime: () => EventInstant,
    ob: ListOrderBook,
    c: Command): (ListOrderBook, Event) = c match {
    case AddLimitOrder(_, o) => handleAddLimitOrder(currentTime, ob, o)
    case CancelOrder(_, id) => handleCancelOrder(currentTime, ob, id)
  }

  private def handleAddLimitOrder(
    currentTime: () => EventInstant,
    ob: ListOrderBook,
    o: LimitOrder): (ListOrderBook, Event) = o match {
    case oo: BuyLimitOrder =>
      ob.bestOffer.exists(oo.price.value >= _.price.value) match {
        case true => crossBookBuy(currentTime, ob, oo)
        case false =>
          val orders = ob.bids.getOrElse(oo.price, Nil)
          ob.copy(bids = ob.bids + (oo.price -> orders.:+(oo))) ->
            LimitOrderAdded(currentTime())
      }
    case oo: SellLimitOrder =>
      ob.bestBid.exists(oo.price.value <= _.price.value) match {
        case true => crossBookSell(currentTime, ob, oo)
        case false =>
          val orders = ob.offers.getOrElse(oo.price, Nil)
          ob.copy(offers = ob.offers + (oo.price -> orders.:+(oo))) ->
            LimitOrderAdded(currentTime())
      }
  }

  private def handleCancelOrder(
    currentTime: () => EventInstant,
    ob: ListOrderBook,
    id: OrderId): (ListOrderBook, Event) = {
    ob.bids.find { case (p, q) => q.exists(_.id == id) }.fold(
      ob.offers.find { case (p, q) => q.exists(_.id == id) }
        .fold[(ListOrderBook, Event)](ob ->
        OrderCancelRejected(currentTime(), id)) {
        case (p, q) =>
          // It's awkward to duplicate the queue remove logic, but the different
          // types for bid vs offer make it difficult to share the code
          val updatedQ = q.filter(_.id != id)
          ob.copy(offers = updatedQ.nonEmpty match {
            case true => ob.offers + (p -> updatedQ)
            case false => ob.offers - p
          }) -> OrderCanceled(currentTime(), id)
      }) { case (p, q) =>
      val updatedQ = q.filter(_.id != id)
      ob.copy(bids = updatedQ.nonEmpty match {
        case true => ob.bids + (p -> updatedQ)
        case false => ob.bids - p
      }) -> OrderCanceled(currentTime(), id)
    }
  }

  private def crossBookSell(
    currentTime: () => EventInstant,
    ob: ListOrderBook,
    s: SellLimitOrder): (ListOrderBook, Event) =
    ob.bids.lastOption.fold(handleAddLimitOrder(currentTime, ob, s)) {
      case (_, Nil) => sys.error("Cannot execute cross with empty bids")
      case (_, (o :: Nil)) => (ob.copy(bids = ob.bids - o.price),
        OrderExecuted(currentTime(),
          Execution(o.id, o.price), Execution(s.id, o.price)))
      case (_, (o :: qq)) => (ob.copy(bids = ob.bids + (o.price -> qq)),
        OrderExecuted(currentTime(),
          Execution(o.id, o.price), Execution(s.id, o.price)))
    }

  private def crossBookBuy(
    currentTime: () => EventInstant,
    ob: ListOrderBook,
    b: BuyLimitOrder): (ListOrderBook, Event) =
    ob.offers.headOption.fold(handleAddLimitOrder(currentTime, ob, b)) {
      case (_, Nil) => sys.error("Cannot execute cross with empty offers")
      case (_, (o :: Nil)) => (ob.copy(offers = ob.offers - o.price),
        OrderExecuted(currentTime(), Execution(b.id, o.price),
          Execution(o.id, o.price)))
      case (_, (o :: qq)) => (ob.copy(offers = ob.offers + (o.price -> qq)),
        OrderExecuted(currentTime(),
          Execution(b.id, o.price), Execution(o.id, o.price)))
    }
}

package highperfscala.orderbook

import highperfscala.orderbook.Commands.{AddLimitOrder, CancelOrder}
import highperfscala.orderbook.Events.{OrderCancelRejected, OrderCanceled}
import org.scalacheck.Prop
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification

class ListOrderBookCancelingSpec extends Specification with ScalaCheck {

  """Given empty book
    |When cancel order arrives
    |Then OrderCancelRejected
  """.stripMargin ! Prop.forAll(
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (id, ci, ei) =>
    ListOrderBook.handle(
      () => ei, ListOrderBook.empty, CancelOrder(ci, id))._2 ====
      OrderCancelRejected(ei, id)
  }

  """Given empty book
    |and buy limit order added
    |When cancel order arrives
    |Then OrderCanceled
  """.stripMargin ! Prop.forAll(
    BuyLimitOrder.genBuyLimitOrder,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (o, ci, ei) =>
    (ListOrderBook.handle(
      () => ei, _: ListOrderBook, AddLimitOrder(ci, o))).andThen {
      case (ob, _) => ListOrderBook.handle(
        () => ei, ob, CancelOrder(ci, o.id))._2
    }(ListOrderBook.empty) ==== OrderCanceled(ei, o.id)
  }

  """Given empty book
    |and sell limit order added
    |When cancel order arrives
    |Then OrderCanceled
  """.stripMargin ! Prop.forAll(
    SellLimitOrder.genSellLimitOrder,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (o, ci, ei) =>
    (ListOrderBook.handle(
      () => ei, _: ListOrderBook, AddLimitOrder(ci, o))).andThen {
      case (ob, _) => ListOrderBook.handle(
        () => ei, ob, CancelOrder(ci, o.id))._2
    }(ListOrderBook.empty) ==== OrderCanceled(ei, o.id)
  }

}
package highperfscala.orderbook

import highperfscala.orderbook.Commands.{AddLimitOrder, CancelOrder}
import highperfscala.orderbook.Events.{LimitOrderAdded, OrderCancelRejected, OrderExecuted}
import org.scalacheck.Prop
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification

class ListOrderBookTradingSpec extends Specification with ScalaCheck {

  """Given empty book
    |When limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(
    LimitOrder.genLimitOrder,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (l, ci, ei) =>
    ListOrderBook.handle(
      () => ei, ListOrderBook.empty, AddLimitOrder(ci, l))._2 ====
      LimitOrderAdded(ei)
  }

  """Given empty book
    |and buy limit order added
    |When resting sell limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(
    BuyLimitOrder.genBuyLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (buy, id, ci, ei) =>
    (ListOrderBook.handle(
      () => ei, _: ListOrderBook, AddLimitOrder(ci, buy))).andThen {
      case (ob, _) => ListOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
        SellLimitOrder(id, Price(buy.price.value + 0.01))))._2
    }(ListOrderBook.empty) ==== LimitOrderAdded(ei)
  }

  """Given empty book
    |and sell limit order added
    |When resting buy limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(
    SellLimitOrder.genSellLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (sell, id, ci, ei) =>
    (ListOrderBook.handle(() => ei, _: ListOrderBook, AddLimitOrder(ci, sell)))
      .andThen {
        case (ob, _) => ListOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
          BuyLimitOrder(id, Price(sell.price.value - 0.01))))._2
      }(ListOrderBook.empty) ==== LimitOrderAdded(ei)
  }

  """Given empty book
    |and buy limit order added
    |When crossing sell limit order arrives
    |Then OrderExecuted
  """.stripMargin ! Prop.forAll(
    BuyLimitOrder.genBuyLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (buy, id, ci, ei) =>
    (ListOrderBook.handle(() => ei, _: ListOrderBook, AddLimitOrder(ci, buy)))
      .andThen {
        case (ob, _) => ListOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
          SellLimitOrder(id, Price(buy.price.value - 0.01))))._2
      }(ListOrderBook.empty) ==== OrderExecuted(ei,
      Execution(buy.id, buy.price), Execution(id, buy.price))
  }

  """Given empty book
    |and sell limit order added
    |When crossing buy limit order arrives
    |Then OrderExecuted
  """.stripMargin ! Prop.forAll(
    SellLimitOrder.genSellLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (sell, id, ci, ei) =>
    (ListOrderBook.handle(() => ei, _: ListOrderBook, AddLimitOrder(ci, sell)))
      .andThen {
        case (ob, _) => ListOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
          BuyLimitOrder(id, Price(sell.price.value + 0.01))))._2
      }(ListOrderBook.empty) ==== OrderExecuted(ei,
      Execution(id, sell.price), Execution(sell.id, sell.price))
  }

  """Given empty book
    |When cancel order command arrives
    |Then OrderCancelRejected
  """.stripMargin ! Prop.forAll(
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (id, ci, ei) =>
    ListOrderBook.handle(() => ei, ListOrderBook.empty, CancelOrder(ci, id))
      ._2 ==== OrderCancelRejected(ei, id)
  }
}
package highperfscala.dataanalysis.benchmarks

import java.util.concurrent.TimeUnit

import highperfscala.dataanalysis.benchmarks.ListVectorBenchmarks.ExecutionList
import highperfscala.dataanalysis.util.DataCodec
import highperfscala.dataanalysis.{ListVectorExperiment, Midpoint, MinuteRollUp, Return}
import org.openjdk.jmh.annotations.Mode._
import org.openjdk.jmh.annotations.{BenchmarkMode, _}

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class ListVectorBenchmarks {

  @Benchmark
  def computeReturnsWithList(s: ExecutionList): List[Return] = {
    ListVectorExperiment.computeReturnsWithList(
      MinuteRollUp(s.rollUp),
      s.list
    )
  }

  @Benchmark
  def computeReturnsWithVector(s: ExecutionList): Vector[Return] = {
    ListVectorExperiment.computeReturnsWithVector(
      MinuteRollUp(s.rollUp),
      s.vector
    )
  }

}

object ListVectorBenchmarks {

  @State(Scope.Benchmark)
  class ExecutionList {

    @Param(Array("10", "60", "120"))
    var rollUp: Int = 0

    var list: List[Midpoint] = Nil
    var vector: Vector[Midpoint] = Vector.empty

    @Setup(Level.Trial)
    def setup(): Unit = {
      list = DataCodec.read(
        getClass.getResourceAsStream("/dataanalysis/executions"))
        .map(Midpoint.fromExecution)
      vector = list.toVector
    }
  }

}
package highperfscala.dataanalysis

object ListVectorExperiment {

  def computeReturnsWithList(
    rollUp: MinuteRollUp,
    data: List[Midpoint]): List[Return] = {
    for {
      i <- (rollUp.value until data.size).toList
    } yield Return.fromMidpoint(data(i - rollUp.value), data(i))
  }

  def computeReturnsWithVector(
    rollUp: MinuteRollUp,
    data: Vector[Midpoint]): Vector[Return] = {
    for {
      i <- (rollUp.value until data.size).toVector
    } yield Return.fromMidpoint(data(i - rollUp.value), data(i))
  }

}
package highperfscala.clientreports.streams

import org.joda.time.Instant

import scala.annotation.tailrec
import scala.util.Random

object MarkovChainEventGenerator {

  sealed trait Step
  case object GenerateBuy extends Step
  case object GenerateSell extends Step
  case object GenerateCancel extends Step
  case object GenerateExecution extends Step

  case class Weight(value: Int) extends AnyVal

  case class GeneratedWeight(value: Int) extends AnyVal

  case class StepTransitionWeights(
    buy: Weight,
    sell: Weight,
    cancel: Weight,
    execution: Weight) {

    def weightSum: Weight =
      Weight(buy.value + sell.value + cancel.value + execution.value)

    private val buyRange = 1 to buy.value

    private val sellRange = {
      val start = buy.value + 1
      start to start + sell.value - 1
    }
    private val cancelRange = {
      val start = buy.value + sell.value + 1
      start to start + cancel.value - 1
    }

    private val executionRange = {
      val start = buy.value + sell.value + cancel.value + 1
      start to start + execution.value - 1
    }

    private val allRanges =
      List(buyRange, sellRange, cancelRange, executionRange)

    def stepFrom(gw: GeneratedWeight): Step =
      allRanges.map(_.contains(gw.value)) match {
        case true :: false :: false :: false :: Nil => GenerateBuy
        case false :: true :: false :: false :: Nil => GenerateSell
        case false :: false :: true :: false :: Nil => GenerateCancel
        case false :: false :: false :: true :: Nil => GenerateExecution
        case unsupported => sys.error(
          s"Unsupported result for weight = $gw:  $unsupported")
      }
  }

  case class State(
    pendingOrders: Set[OrderId],
    step: Step)
  object State {
    private val clientIds: Vector[ClientId] =
      (1 to 100).map(i => ClientId(i)).toVector

    private val tickers: Vector[Ticker] = Vector(
      "FOO", "BAR", "XYZ", "RTY", "PLM").map(Ticker.apply)

    val initialBuy: (State, OrderBookEvent) = {
      val e = randomBuySubmitted()
      State(Set(e.id), GenerateBuy) -> e
    }

    val initialSell: (State, OrderBookEvent) = {
      val e = randomSellSubmitted()
      State(Set(e.id), GenerateSell) -> e
    }

    private def randomBuySubmitted() = BuyOrderSubmitted(
      EventInstant(Instant.now()), OrderId(Math.abs(Random.nextLong())),
      tickers(Random.nextInt(tickers.size)), Price(Random.nextInt(100) + 1),
      clientIds(Random.nextInt(clientIds.size)))

    private def randomSellSubmitted() = SellOrderSubmitted(
      EventInstant(Instant.now()), OrderId(Math.abs(Random.nextLong())),
      tickers(Random.nextInt(tickers.size)), Price(Random.nextInt(100) + 1),
      clientIds(Random.nextInt(clientIds.size)))

    private def randomCanceled(id: OrderId) = OrderCanceled(
      EventInstant(Instant.now()), id)

    private def randomExecuted(id: OrderId) = OrderExecuted(
      EventInstant(Instant.now()), id, Price(Random.nextInt(100) + 1))

    def nextState(
      weight: StepTransitionWeights => GeneratedWeight,
      stepToWeights: Map[Step, StepTransitionWeights],
      s: State): (State, OrderBookEvent) = {
      @tailrec
      def loop(): (State, OrderBookEvent) = {
        val transition = stepToWeights(s.step)
        val nextStep = transition.stepFrom(weight(transition))
        nextStep match {
          case GenerateBuy =>
            val e = randomBuySubmitted()
            s.copy(step = nextStep, pendingOrders = s.pendingOrders + e.id) -> e
          case GenerateSell =>
            val e = randomSellSubmitted()
            s.copy(step = nextStep, pendingOrders = s.pendingOrders + e.id) -> e
          case GenerateCancel if s.pendingOrders.nonEmpty =>
            val e = randomCanceled(s.pendingOrders.head)
            s.copy(step = nextStep, pendingOrders = s.pendingOrders - e.id) -> e
          case GenerateCancel if s.pendingOrders.isEmpty => loop()
          case GenerateExecution if s.pendingOrders.nonEmpty =>
            val e = randomExecuted(s.pendingOrders.head)
            s.copy(step = nextStep, pendingOrders = s.pendingOrders - e.id) -> e
          case GenerateExecution if s.pendingOrders.isEmpty => loop()
        }
      }
      loop()
    }
  }

  def main(args: Array[String]): Unit = {
    val stepToWeights = Map[Step, StepTransitionWeights](
      GenerateBuy -> StepTransitionWeights(
        Weight(10), Weight(25), Weight(40), Weight(40)),
      GenerateSell -> StepTransitionWeights(
        Weight(25), Weight(10), Weight(40), Weight(25)),
      GenerateCancel -> StepTransitionWeights(
        Weight(60), Weight(50), Weight(40), Weight(10)),
      GenerateExecution -> StepTransitionWeights(
        Weight(30), Weight(30), Weight(60), Weight(25)))

    val next = State.nextState(
      t => GeneratedWeight(Random.nextInt(t.weightSum.value) + 1),
      stepToWeights, _: State)

    Stream.iterate(State.initialBuy) { case (s, e) => next(s) }
      .take(5)
      .foreach { case (s, e) => println(s"State = $s\nEvent = $e")  }
  }
}
package highperfscala.specialization

object MethodReturnTypes {

  class Foo[T](t: T)

  object Foo {
    def create[T](t: T): Foo[T] = new Foo(t)
    def createSpecialized[@specialized T](t: T): Foo[T] = new Foo(t)
  }

  def boxed: Foo[Int] = Foo.create(1)

  def specialized: Foo[Int] = Foo.createSpecialized(1)
}
package highperfscala.dataanalysis

import scala.annotation.tailrec

class MidpointSeries private(val points: Vector[Midpoint]) extends AnyVal {

  def returns(rollUp: MinuteRollUp): Vector[Return] = {
    for {
      i <- (rollUp.value until points.size).toVector
    } yield Return.fromMidpoint(points(i - rollUp.value), points(i))
  }

  def midpointAt(time: TimestampMinutes): Option[Midpoint] = {
    if (points.isEmpty || time.value < points.head.time.value ||
      time.value > points.last.time.value) {
      None
    } else {
      val index = time.value - points.head.time.value
      Some(points(index))
    }
  }

  private[dataanalysis] def size = points.size // provided for testing

}

object MidpointSeries {

  private def removeDuplicates(v: Vector[Midpoint]): Vector[Midpoint] = {

    @tailrec
    def loop(
      current: Midpoint,
      rest: Vector[Midpoint],
      result: Vector[Midpoint]): Vector[Midpoint] = {
      val sameTime = current +: rest.takeWhile(_.time == current.time)
      val average = sameTime.map(_.value).sum / sameTime.size

      val newResult = result :+ Midpoint(current.time, average)
      rest.drop(sameTime.size - 1) match {
        case h +: r => loop(h, r, newResult)
        case _ => newResult
      }
    }

    v match {
      case h +: rest => loop(h, rest, Vector.empty)
      case _ => Vector.empty
    }
  }

  private def extrapolate(
    a: Midpoint,
    b: Midpoint,
    time: TimestampMinutes): Midpoint = {
    val price = a.value +
      ((time.value - a.time.value) / (b.time.value - a.time.value)) *
        (b.value - a.value)
    Midpoint(time, price)
  }

  private def addMissingDataPoints(v: Vector[Midpoint]): Vector[Midpoint] = {
    @tailrec
    def loop(
      previous: Midpoint,
      rest: Vector[Midpoint],
      result: Vector[Midpoint]): Vector[Midpoint] = rest match {
      case current +: mPoints if previous.time.value == current.time.value - 1 =>
        // Nothing to extrapolate, the data points are consecutive
        loop(current, mPoints, result :+ previous)

      case current +: mPoints if previous.time.value < current.time.value - 1 =>
        //Need to generate a data point
        val newPoint = extrapolate(previous, current, previous.time.next)
        loop(newPoint, rest, result :+ previous)

      case _ => result :+ previous
    }

    v match {
      case h +: rest => loop(h, rest, Vector.empty)
      case _ => Vector.empty
    }
  }

  def fromExecution(executions: Vector[Execution]): MidpointSeries = {
    new MidpointSeries(
      addMissingDataPoints(
        removeDuplicates(
          executions.map(Midpoint.fromExecution))))
  }

}
package highperfscala.dataanalysis

import org.joda.time.DateTime
import org.specs2.mutable.Specification

class MidpointSeriesSpec extends Specification {

  "A MidpointSeries" should {

    "be properly created from execution data points" in {
      val t0 = TimestampMinutes.fromDateTime(DateTime.now)
      val t1 = t0.next
      val t2 = t1.next
      val t3 = t2.next
      val t4 = t3.next
      val t5 = t4.next
      val t6 = t5.next
      val executions = Vector(
        Execution(t0, AskPrice(40), BidPrice(20)),
        Execution(t1, AskPrice(30), BidPrice(25)),
        Execution(t1, AskPrice(50), BidPrice(22)),
        Execution(t4, AskPrice(24), BidPrice(16)),
        Execution(t4, AskPrice(84), BidPrice(78)),
        Execution(t4, AskPrice(64), BidPrice(37)),
        Execution(t6, AskPrice(41), BidPrice(23))
      )

      val series = MidpointSeries.fromExecution(executions)
      series.size ==== 7
      series.midpointAt(t0).get ==== Midpoint(t0, 30)
      series.midpointAt(t1).get ==== Midpoint(t1, 31.75)
      series.midpointAt(t2).get ==== Midpoint(t2, 31.75)
      series.midpointAt(t3).get ==== Midpoint(t3, 31.75)
      series.midpointAt(t4).get ==== Midpoint(t4, 50.5)
      series.midpointAt(t5).get ==== Midpoint(t5, 50.5)
      series.midpointAt(t6).get ==== Midpoint(t6, 32)
      series.midpointAt(t6.next) ==== None
    }

  }

}
package highperfscala.orderbook

import org.joda.time.Instant
import org.scalacheck.Gen

// Model taken from chapter 2

case class Price(value: BigDecimal) extends AnyVal
object Price {
  implicit val genPrice: Gen[Price] = Gen.posNum[Double].map(d =>
    Price(BigDecimal(d)))
  implicit val ordering: Ordering[Price] = new Ordering[Price] {
    def compare(x: Price, y: Price): Int =
      Ordering.BigDecimal.compare(x.value, y.value)
  }
}

case class OrderId(value: Long)
object OrderId {
  implicit val genOrderId: Gen[OrderId] = Gen.posNum[Long].map(OrderId.apply)
}

sealed trait LimitOrder {
  def id: OrderId
  def price: Price
}
object LimitOrder {
  implicit val genLimitOrder: Gen[LimitOrder] = Gen.oneOf(
    BuyLimitOrder.genBuyLimitOrder, SellLimitOrder.genSellLimitOrder)
}
case class BuyLimitOrder(id: OrderId, price: Price) extends LimitOrder
object BuyLimitOrder {
  implicit val genBuyLimitOrder: Gen[BuyLimitOrder] = Gen.zip(
    OrderId.genOrderId, Price.genPrice).map(Function.tupled(BuyLimitOrder.apply))
}
case class SellLimitOrder(id: OrderId, price: Price) extends LimitOrder
object SellLimitOrder {
  implicit val genSellLimitOrder: Gen[SellLimitOrder] = Gen.zip(
    OrderId.genOrderId, Price.genPrice).map(Function.tupled(
    SellLimitOrder.apply))
}

case class Execution(orderId: OrderId, price: Price)

case class CommandInstant(value: Instant) extends AnyVal
object CommandInstant {
  def now(): CommandInstant =
    CommandInstant(new Instant(System.currentTimeMillis()))
  implicit val genCommandInstant: Gen[CommandInstant] =
    Gen.posNum[Long].map(l => CommandInstant(new Instant(l)))
}

case class EventInstant(value: Instant) extends AnyVal
object EventInstant {
  def now(): EventInstant =
    EventInstant(new Instant(System.currentTimeMillis()))
  implicit val genEventInstant: Gen[EventInstant] =
    Gen.posNum[Long].map(l => EventInstant(new Instant(l)))
}
package highperfscala.clientreports.streams

import org.joda.time.Instant

case class Ticker(value: String) extends AnyVal
case class Price(value: BigDecimal) extends AnyVal
case class OrderId(value: Long) extends AnyVal
case class EventInstant(value: Instant) extends AnyVal
case class ClientId(value: Long) extends AnyVal

sealed trait Order {
  def created: EventInstant
  def id: OrderId
  def ticker: Ticker
  def price: Price
  def clientId: ClientId
}
case class BuyOrder(
  created: EventInstant, id: OrderId, ticker: Ticker, price: Price,
  clientId: ClientId) extends Order
case class SellOrder(
  created: EventInstant, id: OrderId, ticker: Ticker, price: Price,
  clientId: ClientId) extends Order

case class Execution(created: EventInstant, id: OrderId, price: Price)


sealed trait OrderBookEvent
case class BuyOrderSubmitted(
  created: EventInstant, id: OrderId, ticker: Ticker, price: Price,
  clientId: ClientId) extends OrderBookEvent
case class SellOrderSubmitted(
  created: EventInstant, id: OrderId, ticker: Ticker, price: Price,
  clientId: ClientId) extends OrderBookEvent
case class OrderCanceled(created: EventInstant, id: OrderId)
  extends OrderBookEvent
case class OrderExecuted(created: EventInstant, id: OrderId, price: Price)
  extends OrderBookEventpackage highperfscala.free

case class Bid(value: BigDecimal) extends AnyVal
case class Offer(value: BigDecimal) extends AnyVal
case class Ticker(value: String) extends AnyVal
case class BboUpdated(ticker: Ticker, bid: Bid, offer: Offer)package highperfscala
package orderbook

import org.scalacheck.Gen

case class Price(value: BigDecimal)
object Price {
  implicit val genPrice: Gen[Price] = Gen.posNum[Double].map(d =>
    Price(BigDecimal(d)))
  implicit val ordering: Ordering[Price] = new Ordering[Price] {
    def compare(x: Price, y: Price): Int =
      Ordering.BigDecimal.compare(x.value, y.value)
  }
}

case class OrderId(value: Long)
object OrderId {
  implicit val genOrderId: Gen[OrderId] = Gen.posNum[Long].map(OrderId.apply)
}

sealed trait LimitOrder {
  def id: OrderId
  def price: Price
}
object LimitOrder {
  implicit val genLimitOrder: Gen[LimitOrder] = Gen.oneOf(
    BuyLimitOrder.genBuyLimitOrder, SellLimitOrder.genSellLimitOrder)
}
case class BuyLimitOrder(id: OrderId, price: Price) extends LimitOrder
object BuyLimitOrder {
  implicit val genBuyLimitOrder: Gen[BuyLimitOrder] = Gen.zip(
    OrderId.genOrderId, Price.genPrice).map(Function.tupled(BuyLimitOrder.apply))
}
case class SellLimitOrder(id: OrderId, price: Price) extends LimitOrder
object SellLimitOrder {
  implicit val genSellLimitOrder: Gen[SellLimitOrder] = Gen.zip(
    OrderId.genOrderId, Price.genPrice).map(Function.tupled(
    SellLimitOrder.apply))
}

case class Execution(orderId: OrderId, price: Price)package highperfscala.option

object NullOptionApp extends Program[NullOption]
package highperfscala.option

import scalaz.{@@, Tag}

sealed trait Opt

// Allocation free Option implementation inspired by the
// abstract ADTs using tagged types
object OptOps {

  def some[@specialized A](x: A): A @@ Opt = Tag(x)
  def nullCheckingSome[@specialized A](x: A): A @@ Opt =
    if (x == null) sys.error("Null values disallowed") else Tag(x)
  def none[A]: A @@ Opt = Tag(null.asInstanceOf[A])

  def isDefined[A](o: A @@ Opt): Boolean = o != null
  def isEmpty[A](o: A @@ Opt): Boolean = !isDefined(o)
  def unsafeGet[A](o: A @@ Opt): A =
    if (isDefined(o)) o.asInstanceOf[A] else sys.error("Cannot get None")

  def fold[A, B](o: A @@ Opt)(ifEmpty: => B)(f: A => B): B =
    if (isEmpty(o)) ifEmpty else f(o.asInstanceOf[A])
}
package highperfscala.option

import java.util.concurrent.TimeUnit

import org.openjdk.jmh.annotations.Mode._
import org.openjdk.jmh.annotations.{BenchmarkMode, _}

import scalaz.@@
import OptionBenchmarks._

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class OptionBenchmarks {

  @Benchmark
  def scalaOption(s: OptionState): Option[ShareCount] = {
    val c = s.counter
    s.counter = s.counter + 1
    c % s.someFrequency match {
      case 0 => Some(ShareCount(s.counter))
      case _ => None
    }
  }

  @Benchmark
  def nullOption(s: OptionState): ShareCount @@ Opt = {
    OptOps.some(ShareCount(s.counter))
    val c = s.counter
    s.counter = s.counter + 1
    c % s.someFrequency match {
      case 0 => OptOps.some(ShareCount(s.counter))
      case _ => OptOps.none
    }
  }

  @Benchmark
  def nullOptionNoneReused(s: OptionState): ShareCount @@ Opt = {
    val c = s.counter
    s.counter = s.counter + 1
    c % s.someFrequency match {
      case 0 => OptOps.some(ShareCount(s.counter))
      case _ => OptionBenchmarks.noShareCount
    }
  }
}

object OptionBenchmarks {

  val noShareCount = OptOps.none[ShareCount]

  case class ShareCount(value: Long) extends AnyVal

  @State(Scope.Benchmark)
  class OptionState {

    @Param(Array("1", "2", "3", "5"))
    var someFrequency: Int = 0

    var counter: Long = 0
  }
}
package highperfscala.option

import java.util.concurrent.TimeUnit

import org.openjdk.jmh.annotations.Mode._
import org.openjdk.jmh.annotations.{BenchmarkMode, _}
import OptionCreationBenchmarks._

import scalaz.@@

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class OptionCreationBenchmarks {

  @Benchmark
  def scalaSome(): Option[ShareCount] = Some(ShareCount(1))

  @Benchmark
  def scalaNone(): Option[ShareCount] = None

  @Benchmark
  def optSome(): ShareCount @@ Opt = OptOps.some(ShareCount(1))

  @Benchmark
  def optSomeWithNullChecking(): ShareCount @@ Opt =
    OptOps.nullCheckingSome(ShareCount(1))

  @Benchmark
  def optNone(): ShareCount @@ Opt = OptOps.none

  @Benchmark
  def optNoneReuse(): ShareCount @@ Opt = noShares
}

object OptionCreationBenchmarks {
  case class ShareCount(value: Long) extends AnyVal
  val noShares: ShareCount @@ Opt = OptOps.none
}
package highperfscala.option

import java.util.concurrent.TimeUnit

import highperfscala.option.OptionBenchmarks.ShareCount
import org.openjdk.jmh.annotations.{Fork, _}
import org.openjdk.jmh.annotations.Mode._
import OptionFoldingBenchmarks._

import scalaz.@@

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class OptionFoldingBenchmarks {

  @Benchmark
  def scalaOption(): ShareCount =
    scalaSome.fold(ShareCount(0))(c => ShareCount(c.value * 2))


  @Benchmark
  def optOption(): ShareCount =
    OptOps.fold(optSome)(ShareCount(0))(c => ShareCount(c.value * 2))

}

object OptionFoldingBenchmarks {

  case class ShareCount(value: Long) extends AnyVal

  val scalaSome: Option[ShareCount] = Some(ShareCount(7))
  val optSome: ShareCount @@ Opt = OptOps.some(ShareCount(7))
}
package highperfscala.option

object OptionzTest {
  def main(args: Array[String]): Unit = {

    val some = OptOps.fold(OptOps.some(25))(7)(_ * 2)
    println(some)
    assert(some == 50)

    val none = OptOps.fold(OptOps.none[Int])(7)(_ * 2)
    println(none)
    assert(none == 7)
  }
}
package highperfscala
package orderbook

import orderbook.Commands._
import orderbook.Events._

import scala.collection.immutable.{Queue, TreeMap}

// http://web.archive.org/web/20110312023826/http://www.quantcup.org/home/howtohft_howtobuildafastlimitorderbook
case class OrderBook(
  bids: TreeMap[Price, Queue[BuyLimitOrder]],
  offers: TreeMap[Price, Queue[SellLimitOrder]]) {
  def bestBid: Option[BuyLimitOrder] = bids.lastOption.flatMap(_._2.headOption)
  def bestOffer: Option[SellLimitOrder] =
    offers.headOption.flatMap(_._2.headOption)
}

object OrderBook {
  val noEvent: Option[Event] = None
  val empty: OrderBook = OrderBook(
    TreeMap.empty[Price, Queue[BuyLimitOrder]],
    TreeMap.empty[Price, Queue[SellLimitOrder]])

  // Could make sense to handle with State monad
  def handle(ob: OrderBook, c: Command): (OrderBook, Event) = c match {
    case AddLimitOrder(o) => handleAddLimitOrder(ob, o)
    case CancelOrder(id) => handleCancelOrder(ob, id)
  }

  private def handleAddLimitOrder(
    ob: OrderBook, o: LimitOrder): (OrderBook, Event) = o match {
    case oo: BuyLimitOrder =>
      ob.bestOffer.exists(oo.price.value >= _.price.value) match {
        case true => crossBookBuy(ob, oo)
        case false =>
          val orders = ob.bids.getOrElse(oo.price, Queue.empty)
          ob.copy(bids = ob.bids + (oo.price -> orders.enqueue(oo))) ->
            LimitOrderAdded
      }
    case oo: SellLimitOrder =>
      ob.bestBid.exists(oo.price.value <= _.price.value) match {
        case true => crossBookSell(ob, oo)
        case false =>
          val orders = ob.offers.getOrElse(oo.price, Queue.empty)
          ob.copy(offers = ob.offers + (oo.price -> orders.enqueue(oo))) ->
            LimitOrderAdded
      }
  }

  private def handleCancelOrder(
    ob: OrderBook, id: OrderId): (OrderBook, Event) = {
    ob.bids.find { case (p, q) => q.exists(_.id == id) }.fold(
      ob.offers.find { case (p, q) => q.exists(_.id == id) }.fold(
        ob -> Event.orderCancelRejected) { case (p, q) =>
        // It's awkward to duplicate the queue remove logic, but the different
        // types for bid vs offer make it difficult to share the code
        val updatedQ = q.filter(_.id != id)
        ob.copy(offers = updatedQ.nonEmpty match {
          case true => ob.offers + (p -> updatedQ)
          case false => ob.offers - p
        }) -> OrderCanceled
      }) { case (p, q) =>
      val updatedQ = q.filter(_.id != id)
      ob.copy(bids = updatedQ.nonEmpty match {
        case true => ob.bids + (p -> updatedQ)
        case false => ob.bids - p
      }) -> OrderCanceled
    }
  }

  private def crossBookSell(
    ob: OrderBook, s: SellLimitOrder): (OrderBook, Event) =
    ob.bids.lastOption.fold(handleAddLimitOrder(ob, s)) { case (_, xs) =>
      val (o, qq) = xs.dequeue
      (ob.copy(bids = qq.isEmpty match {
        case true => ob.bids - o.price
        case false => ob.bids + (o.price -> qq)
      }), OrderExecuted(Execution(o.id, o.price), Execution(s.id, o.price)))
    }

  private def crossBookBuy(
    ob: OrderBook, b: BuyLimitOrder): (OrderBook, Event) =
    ob.offers.headOption.fold(handleAddLimitOrder(ob, b)) { case (_, xs) =>
      val (o, qq) = xs.dequeue
      (ob.copy(offers = qq.isEmpty match {
        case true => ob.offers - o.price
        case false => ob.offers + (o.price -> qq)
      }), OrderExecuted(Execution(b.id, o.price), Execution(o.id, o.price)))
    }
}

object Commands {
  sealed trait Command
  case class AddLimitOrder(o: LimitOrder) extends Command
  case class CancelOrder(id: OrderId) extends Command
}

object Events {
  sealed trait Event
  object Event {
    val orderCancelRejected: Event = OrderCancelRejected
  }
  case class OrderExecuted(buy: Execution, sell: Execution) extends Event
  case object LimitOrderAdded extends Event
  case object OrderCancelRejected extends Event
  case object OrderCanceled extends Event
}
package highperfscala
package orderbook

import highperfscala.orderbook.Commands.{AddLimitOrder, CancelOrder}
import highperfscala.orderbook.Events.{OrderCanceled, OrderCancelRejected}
import org.scalacheck.Prop
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification

class OrderBookCancelingSpec extends Specification with ScalaCheck {

  """Given empty book
    |When cancel order arrives
    |Then OrderCancelRejected
  """.stripMargin ! Prop.forAll(OrderId.genOrderId) { id =>
    OrderBook.handle(OrderBook.empty, CancelOrder(id))._2 ====
      OrderCancelRejected
  }

  """Given empty book
    |and buy limit order added
    |When cancel order arrives
    |Then OrderCanceled
  """.stripMargin ! Prop.forAll(BuyLimitOrder.genBuyLimitOrder) { o =>
    (OrderBook.handle(_: OrderBook, AddLimitOrder(o))).andThen {
      case (ob, _) => OrderBook.handle(ob, CancelOrder(o.id))._2
    }(OrderBook.empty) ==== OrderCanceled
  }

  """Given empty book
    |and sell limit order added
    |When cancel order arrives
    |Then OrderCanceled
  """.stripMargin ! Prop.forAll(SellLimitOrder.genSellLimitOrder) { o =>
    (OrderBook.handle(_: OrderBook, AddLimitOrder(o))).andThen {
      case (ob, _) => OrderBook.handle(ob, CancelOrder(o.id))._2
    }(OrderBook.empty) ==== OrderCanceled
  }

}
package highperfscala.orderbook

import highperfscala.orderbook.Commands.{CancelOrder, AddLimitOrder}
import highperfscala.orderbook.Events.{OrderCancelRejected, OrderExecuted, LimitOrderAdded}
import org.scalacheck.Prop
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification

class OrderBookTradingSpec extends Specification with ScalaCheck {

  """Given empty book
    |When limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(LimitOrder.genLimitOrder) { l =>
    OrderBook.handle(OrderBook.empty, AddLimitOrder(l))._2 ==== LimitOrderAdded
  }

  """Given empty book
    |and buy limit order added
    |When resting sell limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(BuyLimitOrder.genBuyLimitOrder,
    OrderId.genOrderId) { (buy, id) =>
    (OrderBook.handle(_: OrderBook, AddLimitOrder(buy))).andThen {
      case (ob, _) => OrderBook.handle(ob, AddLimitOrder(
        SellLimitOrder(id, Price(buy.price.value + 0.01))))._2
    }(OrderBook.empty) ==== LimitOrderAdded
  }

  """Given empty book
    |and sell limit order added
    |When resting buy limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(SellLimitOrder.genSellLimitOrder,
    OrderId.genOrderId) { (sell, id) =>
    (OrderBook.handle(_: OrderBook, AddLimitOrder(sell))).andThen {
      case (ob, _) => OrderBook.handle(ob, AddLimitOrder(
        BuyLimitOrder(id, Price(sell.price.value - 0.01))))._2
    }(OrderBook.empty) ==== LimitOrderAdded
  }

  """Given empty book
    |and buy limit order added
    |When crossing sell limit order arrives
    |Then OrderExecuted
  """.stripMargin ! Prop.forAll(BuyLimitOrder.genBuyLimitOrder,
    OrderId.genOrderId) { (buy, id) =>
    (OrderBook.handle(_: OrderBook, AddLimitOrder(buy))).andThen {
      case (ob, _) => OrderBook.handle(ob, AddLimitOrder(
        SellLimitOrder(id, Price(buy.price.value - 0.01))))._2
    }(OrderBook.empty) ==== OrderExecuted(
      Execution(buy.id, buy.price), Execution(id, buy.price))
  }

  """Given empty book
    |and sell limit order added
    |When crossing buy limit order arrives
    |Then OrderExecuted
  """.stripMargin ! Prop.forAll(SellLimitOrder.genSellLimitOrder,
    OrderId.genOrderId) { (sell, id) =>
    (OrderBook.handle(_: OrderBook, AddLimitOrder(sell))).andThen {
      case (ob, _) => OrderBook.handle(ob, AddLimitOrder(
        BuyLimitOrder(id, Price(sell.price.value + 0.01))))._2
    }(OrderBook.empty) ==== OrderExecuted(
      Execution(id, sell.price), Execution(sell.id, sell.price))
  }

  """Given empty book
    |When cancel order command arrives
    |Then OrderCancelRejected
  """.stripMargin ! Prop.forAll(OrderId.genOrderId) { id =>
    OrderBook.handle(OrderBook.empty, CancelOrder(id))._2 ====
      OrderCancelRejected
  }
}
package highperfscala.concurrency.future

import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Failure, Success}

object OrderSubmission {

  trait RawOrder
  trait OrderSubmitted

  trait ValidatedOrder
  object ValidatedOrder {
    def fromRawOrder(o: RawOrder): Option[ValidatedOrder] = None
  }

  trait AccountPositions

  def submitOrder(
    ec: ExecutionContext,
    sendToExchange: ValidatedOrder => Future[OrderSubmitted],
    updatePositions: OrderSubmitted => Future[AccountPositions],
    o: RawOrder): Unit = {
    implicit val iec = ec

    (for {
      vo <- ValidatedOrder.fromRawOrder(o).fold(Future.failed[ValidatedOrder](
        new Exception("Order failed validation")))(Future.successful)
      os <- sendToExchange(vo)
      ap <- updatePositions(os)
    } yield (os, ap)).onComplete {
      case Success((os, ap)) => // Marshal order submission info to caller
      case Failure(e) => // Marshal appropriate error response to caller
    }
  }

  def submitOrderWithMetrics(
    ec: ExecutionContext,
    sendToExchange: ValidatedOrder => Future[OrderSubmitted],
    updatePositions: OrderSubmitted => Future[AccountPositions],
    incrementExchangeErrorCount: () => Unit,
    o: RawOrder): Unit = {
    implicit val iec = ec

    (for {
      vo <- ValidatedOrder.fromRawOrder(o).fold(Future.failed[ValidatedOrder](
        new Exception("Order failed validation")))(Future.successful)
      os <- {
        val f = sendToExchange(vo)
        f.onFailure({ case e => incrementExchangeErrorCount() })
        f
      }
      ap <- updatePositions(os)
    } yield (os, ap)).onComplete {
      case Success((os, ap)) => // Marshal order submission info to caller
      case Failure(e) => // Marshal appropriate error response to caller
    }
  }

}
package highperfscala
package orderbook

import Commands._
import com.codahale.metrics.Snapshot
import highperfscala.orderbook.LatencyBenchmark.{LazyImplementation, QueueImplementation, BookImplementation}
import org.slf4s.Logging

package object util extends Logging {

  def infiniteCommands(sample: List[Command]): Stream[Command] =
    Stream.continually(sample.toStream).flatten

  def generateCount(sample: List[Command], count: Int): List[Command] =
    infiniteCommands(sample).take(count).toList

  def jvmWarmUp(sample: List[Command], impl: BookImplementation): Unit = {
    log.debug("Begin warmUp")
    val commands = util.generateCount(sample, 100000)
    val systemEventTime = () => EventInstant.now()
    impl match {
      case QueueImplementation => commands.foldLeft(QueueOrderBook.empty) {
        case (book, command) => QueueOrderBook.handle(
          systemEventTime, book, command)._1
      }
      case LazyImplementation => commands.foldLeft(LazyCancelOrderBook.empty) {
        case (book, command) => LazyCancelOrderBook.handle(
          systemEventTime, book, command)._1
      }
    }
    log.debug("End warmUp")
  }

  def printSnapshot(s: Snapshot): Unit = println {
    s"""
       |Processed ${s.size} commands
       |99p latency: ${s.get99thPercentile()} ms
       |99.9p latency: ${s.get999thPercentile()} ms
       |Maximum latency: ${s.getMax} ms
        """.stripMargin
  }


}
package highperfscala
package benchmarks

import com.codahale.metrics.Snapshot
import orderbook.Commands.Command
import orderbook.OrderBook
import org.slf4s.Logging

package object util extends Logging {

  def infiniteCommands(sample: List[Command]): Stream[Command] =
    Stream.continually(sample.toStream).flatten

  def generateCount(sample: List[Command], count: Int): List[Command] =
    infiniteCommands(sample).take(count).toList

  def jvmWarmUp(sample: List[Command]): Unit = {
    log.debug("Begin warm up")
    val commands = util.generateCount(sample, 100000)
    commands.foldLeft(OrderBook.empty) {
      case (book, command) => OrderBook.handle(book, command)._1
    }
    log.debug("End warm up")
  }

  def printSnapshot(s: Snapshot): Unit = println {
    s"""
       |Processed ${s.size} commands
       |99p latency: ${s.get99thPercentile()} ms
       |99.9p latency: ${s.get999thPercentile()} ms
       |Maximum latency: ${s.getMax} ms
        """.stripMargin
  }


}
package highperfscala.patternmatch

import scala.annotation.switch
import scalaz.{@@, Tag}

object PatternMatching {

  sealed trait Event
  case object E1 extends Event
  case object E2 extends Event
  case object E3 extends Event

  sealed trait Foo

  case class IntBar(i: Int, b: Bar)
  def intBar: IntBar = IntBar(1, Bar(2))

  def tuple2Boxed(): (Int, Bar) = (1, Bar(2))

  def tuple2: (Int, Double) = (1, 2.0)

  def tuple3(): (Int, Double, Int) = (1, 2.0, 3)

  case class Triple(x: Int, y: Double, z: Int)

  def triple(): Triple = Triple(1, 2.0, 3)


  def arrayExample(): Array[Bar] = {
    Array(Bar(1), Bar(2), Bar(3))
    //      .map(b => b.copy(b.value + 1))
  }

  def arrayIntExample(): Array[Int] = {
    Array(1, 2, 3).map(i => i * 2)
    //      .map(b => b.copy(b.value + 1))
  }

  def tagFoo(i: Int): Int @@ Foo = {
    Tag.apply(i)
  }

  def useFoo(i: Int @@ Foo): Option[String] = {
    Some((5 + Tag.unwrap(i)).toString)
  }

  case class Bar(value: Int) extends AnyVal
  Bar.unapply(Bar(1))

  sealed trait Side
  case object Buy extends Side
  case object Sell extends Side
  def handleOrder(s: Side): Boolean = s match {
    case Buy => true
    case Sell => false
  }

  sealed trait Order
  case class BuyOrder(price: Double) extends Order
  case class SellOrder(price: Double) extends Order
  def handleOrder(o: Order): Boolean = o match {
    case BuyOrder(price) if price > 2.0 => true
    case BuyOrder(_) => false
    case SellOrder(_) => false
  }

  def handleGuard(e: Bar): Option[String] = e match {
    case ee if ee.value > 5 => None
    case Bar(4) => Some("4")
  }

  val z = 4
  def handleInt(e: Int): Option[String] = e match {
    case 2 => Some("res")
    case 3 => None
    case `z` => None
  }

  case class ShareCount(value: Int) extends AnyVal
  def handleAnyVal(e: ShareCount): Option[String] = e match {
    case ShareCount(2) => Some("res")
    case ShareCount(3) => None
    case ShareCount(4) => None
  }

  def processShareCount(sc: ShareCount): Boolean = (sc: @switch) match {
    case ShareCount(1) => true
    case _ => false
  }

}
package highperfscala.patternmatch

import java.util.concurrent.TimeUnit

import highperfscala.patternmatch.PatternMatchingBenchmarks._
import org.openjdk.jmh.annotations.Mode._
import org.openjdk.jmh.annotations._

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class PatternMatchingBenchmarks {

  @Benchmark
  def matchIntLiterals(i: PatternMatchState): Int = i.matchIndex match {
    case 1 => 1
    case 2 => 2
    case 3 => 3
    case 4 => 4
    case 5 => 5
    case 6 => 6
    case 7 => 7
    case 8 => 8
    case 9 => 9
    case 10 => 10
  }

  @Benchmark
  def matchIntVariables(ii: PatternMatchState): Int = ii.matchIndex match {
    case `a` => 1
    case `b` => 2
    case `c` => 3
    case `d` => 4
    case `e` => 5
    case `f` => 6
    case `g` => 7
    case `h` => 8
    case `i` => 9
    case `j` => 10
  }

  @Benchmark
  def matchAnyVal(i: PatternMatchState): Int = CheapFoo(i.matchIndex) match {
    case CheapFoo(1) => 1
    case CheapFoo(2) => 2
    case CheapFoo(3) => 3
    case CheapFoo(4) => 4
    case CheapFoo(5) => 5
    case CheapFoo(6) => 6
    case CheapFoo(7) => 7
    case CheapFoo(8) => 8
    case CheapFoo(9) => 9
    case CheapFoo(10) => 10
  }

  @Benchmark
  def matchCaseClass(i: PatternMatchState): Int =
    ExpensiveFoo(i.matchIndex) match {
      case ExpensiveFoo(1) => 1
      case ExpensiveFoo(2) => 2
      case ExpensiveFoo(3) => 3
      case ExpensiveFoo(4) => 4
      case ExpensiveFoo(5) => 5
      case ExpensiveFoo(6) => 6
      case ExpensiveFoo(7) => 7
      case ExpensiveFoo(8) => 8
      case ExpensiveFoo(9) => 9
      case ExpensiveFoo(10) => 10
    }

}

object PatternMatchingBenchmarks {

  case class CheapFoo(value: Int) extends AnyVal

  case class ExpensiveFoo(value: Int)

  private val (a, b, c, d, e, f, g, h, i, j) = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

  @State(Scope.Benchmark)
  class PatternMatchState {

    @Param(Array("1", "5", "10"))
    var matchIndex: Int = 0
  }
}
package highperfscala.clientreports.views

import org.joda.time.{Duration, Instant, Interval}

object PerformanceReporting {

  def trend(
    now: () => Instant,
    findOrders: (Interval, Ticker) => List[Order],
    findExecutions: (Interval, Ticker) => List[Execution],
    request: GenerateTradingPerformanceTrend): List[TradingPerformanceTrend] = {
    def periodPnL(
      duration: Duration): Map[Ticker, PeriodPnL] = {
      val currentTime = now()
      val interval = new Interval(currentTime.minus(duration), currentTime)
      (for {
        ticker <- request.tickers
        orders = findOrders(interval, ticker)
        executions = findExecutions(interval, ticker)
        idToExecPrice = executions.groupBy(_.id).mapValues(es =>
          Price.average(es.map(_.price)))
        signedExecutionPrices = for {
          o <- orders
          if o.clientId == request.clientId
          price <- idToExecPrice.get(o.id).map(p => o match {
            case _: BuyOrder => Price(p.value * -1)
            case _: SellOrder => p
          }).toList
        } yield price
        trend = signedExecutionPrices.foldLeft(PnL.zero) {
          case (pnl, p) => PnL(pnl.value + p.value)
        } match {
          case p if p.value >= PnL.zero.value => PeriodPositive
          case _ => PeriodNegative
        }
      } yield ticker -> trend).toMap
    }

    val tickerToLastHour = periodPnL(Duration.standardHours(1)).mapValues {
      case PeriodPositive => LastHourPositive
      case PeriodNegative => LastHourNegative
    }
    val tickerToLastDay = periodPnL(Duration.standardDays(1)).mapValues {
      case PeriodPositive => LastDayPositive
      case PeriodNegative => LastDayNegative
    }
    val tickerToLastSevenDays = periodPnL(Duration.standardDays(7)).mapValues {
      case PeriodPositive => LastSevenDayPositive
      case PeriodNegative => LastSevenDayNegative
    }

    tickerToLastHour.zip(tickerToLastDay).zip(tickerToLastSevenDays).map({
      case (((t, lastHour), (_, lastDay)), (_, lastSevenDays)) =>
        TradingPerformanceTrend(t, lastHour, lastDay, lastSevenDays)
    }).toList
  }
}
package highperfscala.free

case class ProcessingLatencyMs(value: Long) extends AnyVal
package highperfscala.option


class Program[Sig <: OptionSig : OptionOps] extends App {

  val ops = OptionOps[Sig]
  import ops._

  // a little dance to derive our Show instance
  import scalaz.std.anyVal.intInstance
  val showOptOptInt = {
    implicit val showOptInt = OptionShow[Sig].optionShow[Int]
    OptionShow[Sig].optionShow[Sig#Option[Int]]
  }

  // scalaz's syntax tricks are awesome
  import showOptOptInt.showSyntax._

  val optOpt = some(some(42))

  println("optOpt: " + optOpt.shows)

  val optNone = some(none)

  println("optNone: " + optNone.shows)

}package highperfscala.benchmarks

import highperfscala.orderbook._
import highperfscala.orderbook.Commands._

import scala.util.Random

object PseudoBenchmark {
  def main(args: Array[String]): Unit = {
    //  """Given empty book
    //    |and buy limit order added
    //    |and second buy limit order added
    //    |and first buy limit order canceled
    //    |When market sell order arrives
    //    |Then OrderExecuted
    //  """.stripMargin
    val commands = Array[Command](
      AddLimitOrder(BuyLimitOrder(OrderId(1), Price(BigDecimal(2.00)))),
      AddLimitOrder(BuyLimitOrder(OrderId(2), Price(BigDecimal(2.00)))),
      CancelOrder(OrderId(1)))

    def nextCommandIndex(i: Int): Int = {
      def randomized(): Int = Random.nextInt(commands.length)
      def sequential(): Int = i % commands.length
      randomized()
    }


    println {
      (0 to 100000000).foldLeft(OrderBook.empty) { case (ob, i) =>
        OrderBook.handle(ob, commands(nextCommandIndex(i)))._1
      }
    }
  }
}
package highperfscala.clientreports.views

sealed trait PseudoView[A] {
  def map[B](f: A => B): PseudoView[B]
  def toList: List[A]
}

final class InitialView[A](xs: List[A]) extends PseudoView[A] {
  def map[B](f: A => B): PseudoView[B] = new ComposedView[A, B](xs, f)
  def toList: List[A] = xs
}

final class ComposedView[A, B](xs: List[A], fa: A => B) extends PseudoView[B] {
  def map[C](f: B => C): PseudoView[C] = new ComposedView(xs, f.compose(fa))
  def toList: List[B] = xs.map(fa)
}

object PseudoView {
  def view[A, B](xs: List[A]): PseudoView[A] = new InitialView(xs)
}

object PseudoViewExample {

  def main(args: Array[String]): Unit = {
    println("PseudoView evaluation:")
    val listPseudoView = PseudoView.view(List(0, 1, 2)).map(i => {
      println(s"Adding one to $i")
      i + 1
    }).map(i => {
      println(s"Multiplying $i")
      i * 2
    })

    println("--- Converting PseudoView to List ---")
    println(listPseudoView.toList)
  }
}
package highperfscala
package orderbook

import scala.collection.immutable.{TreeMap, Queue}
import orderbook.Commands._
import orderbook.Events._

// Taken originally from Chapter 2
// http://web.archive.org/web/20110312023826/http://www.quantcup.org/home/howtohft_howtobuildafastlimitorderbook
case class QueueOrderBook(
  bids: TreeMap[Price, Queue[BuyLimitOrder]],
  offers: TreeMap[Price, Queue[SellLimitOrder]]) {
  def bestBid: Option[BuyLimitOrder] = bids.lastOption.flatMap(_._2.headOption)
  def bestOffer: Option[SellLimitOrder] =
    offers.headOption.flatMap(_._2.headOption)
}

object QueueOrderBook {
  val noEvent: Option[Event] = None
  val empty: QueueOrderBook = QueueOrderBook(
    TreeMap.empty[Price, Queue[BuyLimitOrder]],
    TreeMap.empty[Price, Queue[SellLimitOrder]])

  // Could make sense to handle with State monad
  def handle(
    currentTime: () => EventInstant,
    ob: QueueOrderBook,
    c: Command): (QueueOrderBook, Event) = c match {
    case AddLimitOrder(_, o) => handleAddLimitOrder(currentTime, ob, o)
    case CancelOrder(_, id) => handleCancelOrder(currentTime, ob, id)
  }

  private def handleAddLimitOrder(
    currentTime: () => EventInstant,
    ob: QueueOrderBook,
    o: LimitOrder): (QueueOrderBook, Event) = o match {
    case oo: BuyLimitOrder =>
      ob.bestOffer.exists(oo.price.value >= _.price.value) match {
        case true => crossBookBuy(currentTime, ob, oo)
        case false =>
          val orders = ob.bids.getOrElse(oo.price, Queue.empty)
          ob.copy(bids = ob.bids + (oo.price -> orders.enqueue(oo))) ->
            LimitOrderAdded(currentTime())
      }
    case oo: SellLimitOrder =>
      ob.bestBid.exists(oo.price.value <= _.price.value) match {
        case true => crossBookSell(currentTime, ob, oo)
        case false =>
          val orders = ob.offers.getOrElse(oo.price, Queue.empty)
          ob.copy(offers = ob.offers + (oo.price -> orders.enqueue(oo))) ->
            LimitOrderAdded(currentTime())
      }
  }

  private def handleCancelOrder(
    currentTime: () => EventInstant,
    ob: QueueOrderBook,
    id: OrderId): (QueueOrderBook, Event) = {
    ob.bids.find { case (p, q) => q.exists(_.id == id) }.fold(
      ob.offers.find { case (p, q) => q.exists(_.id == id) }
        .fold[(QueueOrderBook, Event)](ob ->
        OrderCancelRejected(currentTime(), id)) {
        case (p, q) =>
          // It's awkward to duplicate the queue remove logic, but the different
          // types for bid vs offer make it difficult to share the code
          val updatedQ = q.filter(_.id != id)
          ob.copy(offers = updatedQ.nonEmpty match {
            case true => ob.offers + (p -> updatedQ)
            case false => ob.offers - p
          }) -> OrderCanceled(currentTime(), id)
      }) { case (p, q) =>
      val updatedQ = q.filter(_.id != id)
      ob.copy(bids = updatedQ.nonEmpty match {
        case true => ob.bids + (p -> updatedQ)
        case false => ob.bids - p
      }) -> OrderCanceled(currentTime(), id)
    }
  }

  private def crossBookSell(
    currentTime: () => EventInstant,
    ob: QueueOrderBook, s: SellLimitOrder): (QueueOrderBook, Event) =
    ob.bids.lastOption.fold(handleAddLimitOrder(currentTime, ob, s)) {
      case (_, xs) =>
        val (o, qq) = xs.dequeue
        (ob.copy(bids = qq.isEmpty match {
          case true => ob.bids - o.price
          case false => ob.bids + (o.price -> qq)
        }), OrderExecuted(currentTime(), Execution(o.id, o.price), Execution(s.id, o.price)))
    }

  private def crossBookBuy(
    currentTime: () => EventInstant,
    ob: QueueOrderBook, b: BuyLimitOrder): (QueueOrderBook, Event) =
    ob.offers.headOption.fold(handleAddLimitOrder(currentTime, ob, b)) {
      case (_, xs) =>
        val (o, qq) = xs.dequeue
        (ob.copy(offers = qq.isEmpty match {
          case true => ob.offers - o.price
          case false => ob.offers + (o.price -> qq)
        }), OrderExecuted(
          currentTime(), Execution(b.id, o.price), Execution(o.id, o.price)))
    }
}
package highperfscala.orderbook

import highperfscala.orderbook.Commands.{AddLimitOrder, CancelOrder}
import highperfscala.orderbook.Events.{OrderCancelRejected, OrderCanceled}
import org.scalacheck.Prop
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification

class QueueOrderBookCancelingSpec extends Specification with ScalaCheck {

  """Given empty book
    |When cancel order arrives
    |Then OrderCancelRejected
  """.stripMargin ! Prop.forAll(
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (id, ci, ei) =>
    QueueOrderBook.handle(
      () => ei, QueueOrderBook.empty, CancelOrder(ci, id))._2 ====
      OrderCancelRejected(ei, id)
  }

  """Given empty book
    |and buy limit order added
    |When cancel order arrives
    |Then OrderCanceled
  """.stripMargin ! Prop.forAll(
    BuyLimitOrder.genBuyLimitOrder,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (o, ci, ei) =>
    (QueueOrderBook.handle(
      () => ei, _: QueueOrderBook, AddLimitOrder(ci, o))).andThen {
      case (ob, _) => QueueOrderBook.handle(
        () => ei, ob, CancelOrder(ci, o.id))._2
    }(QueueOrderBook.empty) ==== OrderCanceled(ei, o.id)
  }

  """Given empty book
    |and sell limit order added
    |When cancel order arrives
    |Then OrderCanceled
  """.stripMargin ! Prop.forAll(
    SellLimitOrder.genSellLimitOrder,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (o, ci, ei) =>
    (QueueOrderBook.handle(
      () => ei, _: QueueOrderBook, AddLimitOrder(ci, o))).andThen {
      case (ob, _) => QueueOrderBook.handle(
        () => ei, ob, CancelOrder(ci, o.id))._2
    }(QueueOrderBook.empty) ==== OrderCanceled(ei, o.id)
  }

}
package highperfscala.orderbook

import highperfscala.orderbook.Commands.{AddLimitOrder, CancelOrder}
import highperfscala.orderbook.Events.{LimitOrderAdded, OrderCancelRejected, OrderExecuted}
import org.scalacheck.Prop
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification

class QueueOrderBookTradingSpec extends Specification with ScalaCheck {

  """Given empty book
    |When limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(
    LimitOrder.genLimitOrder,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (l, ci, ei) =>
     QueueOrderBook.handle(
      () => ei,  QueueOrderBook.empty, AddLimitOrder(ci, l))._2 ====
      LimitOrderAdded(ei)
  }

  """Given empty book
    |and buy limit order added
    |When resting sell limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(
    BuyLimitOrder.genBuyLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (buy, id, ci, ei) =>
    ( QueueOrderBook.handle(
      () => ei, _:  QueueOrderBook, AddLimitOrder(ci, buy))).andThen {
      case (ob, _) =>  QueueOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
        SellLimitOrder(id, Price(buy.price.value + 0.01))))._2
    }( QueueOrderBook.empty) ==== LimitOrderAdded(ei)
  }

  """Given empty book
    |and sell limit order added
    |When resting buy limit order arrives
    |Then LimitOrderAdded
  """.stripMargin ! Prop.forAll(
    SellLimitOrder.genSellLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (sell, id, ci, ei) =>
    ( QueueOrderBook.handle(() => ei, _:  QueueOrderBook, AddLimitOrder(ci, sell)))
      .andThen {
        case (ob, _) =>  QueueOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
          BuyLimitOrder(id, Price(sell.price.value - 0.01))))._2
      }( QueueOrderBook.empty) ==== LimitOrderAdded(ei)
  }

  """Given empty book
    |and buy limit order added
    |When crossing sell limit order arrives
    |Then OrderExecuted
  """.stripMargin ! Prop.forAll(
    BuyLimitOrder.genBuyLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (buy, id, ci, ei) =>
    ( QueueOrderBook.handle(() => ei, _:  QueueOrderBook, AddLimitOrder(ci, buy)))
      .andThen {
        case (ob, _) =>  QueueOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
          SellLimitOrder(id, Price(buy.price.value - 0.01))))._2
      }( QueueOrderBook.empty) ==== OrderExecuted(ei,
      Execution(buy.id, buy.price), Execution(id, buy.price))
  }

  """Given empty book
    |and sell limit order added
    |When crossing buy limit order arrives
    |Then OrderExecuted
  """.stripMargin ! Prop.forAll(
    SellLimitOrder.genSellLimitOrder,
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (sell, id, ci, ei) =>
    ( QueueOrderBook.handle(() => ei, _:  QueueOrderBook, AddLimitOrder(ci, sell)))
      .andThen {
        case (ob, _) =>  QueueOrderBook.handle(() => ei, ob, AddLimitOrder(ci,
          BuyLimitOrder(id, Price(sell.price.value + 0.01))))._2
      }( QueueOrderBook.empty) ==== OrderExecuted(ei,
      Execution(id, sell.price), Execution(sell.id, sell.price))
  }

  """Given empty book
    |When cancel order command arrives
    |Then OrderCancelRejected
  """.stripMargin ! Prop.forAll(
    OrderId.genOrderId,
    CommandInstant.genCommandInstant,
    EventInstant.genEventInstant) { (id, ci, ei) =>
     QueueOrderBook.handle(() => ei,  QueueOrderBook.empty, CancelOrder(ci, id))
      ._2 ==== OrderCancelRejected(ei, id)
  }
}
package highperfscala.dataanalysis

import org.saddle._

trait ReturnSeriesFrame

class VectorBasedReturnSeriesFrame(
  val series: Vector[Vector[Return]]) extends ReturnSeriesFrame {

  lazy val scalingVector: Vector[Double] =
    for (i <- series.indices.toVector) yield series(i).max.value

}

class ArrayBasedReturnSeriesFrame(
  val series: Array[Array[Return]]) extends ReturnSeriesFrame {

  lazy val scalingVector: Array[Double] = {
    val v = new Array[Double](series.length)
    for (i <- series.indices) {
      v(i) = series(i).max.value
    }
    v
  }

}

class MatrixBasedReturnSeriesFrame(
  val series: Mat[Return]) extends ReturnSeriesFrame {

  val scalingVector: Array[Double] = {
    val v = new Array[Double](series.cols().size)
    for (i <- v.indices) {
      v(i) = series.col(i).toSeq.max.value
    }
    v
  }

  val scalingVec: Vec[Double] = Vec(scalingVector)

}

object ReturnSeriesFrame {

  def newArrayBasedFrame(series: Array[Array[Return]]): ArrayBasedReturnSeriesFrame = {
    new ArrayBasedReturnSeriesFrame(series)
  }

  def newMatrixBasedFrame(series: Array[Array[Return]]): MatrixBasedReturnSeriesFrame = {
    new MatrixBasedReturnSeriesFrame(Mat(series))
  }

  def scaleVector(frame: VectorBasedReturnSeriesFrame): VectorBasedReturnSeriesFrame = {
    new VectorBasedReturnSeriesFrame(
      frame.series.zip(frame.scalingVector).map { case (series, scaling) =>
        series.map(point => Return(point.value / scaling))
      }
    )
  }

  def scaleWithMap(frame: ArrayBasedReturnSeriesFrame): ArrayBasedReturnSeriesFrame = {
    new ArrayBasedReturnSeriesFrame(
      frame.series.zip(frame.scalingVector).map { case (series, scaling) =>
        series.map(point => Return(point.value / scaling))
      })
  }

  def scaleWithSpire(frame: ArrayBasedReturnSeriesFrame): ArrayBasedReturnSeriesFrame = {
    import spire.syntax.cfor._

    val result = new Array[Array[Return]](frame.series.length)

    cfor(0)(_ < frame.series.length, _ + 1) { i =>
      val s = frame.series(i)
      val scaled = new Array[Return](s.length)
      cfor(0)(_ < s.length, _ + 1) { j =>
        val point = s(j)
        scaled(j) = Return(point.value / frame.scalingVector(i))
      }
      result(i) = scaled
    }

    new ArrayBasedReturnSeriesFrame(result)
  }

  def scaleWithSaddle(frame: MatrixBasedReturnSeriesFrame): MatrixBasedReturnSeriesFrame =
    new MatrixBasedReturnSeriesFrame(
      (frame.series.map(_.value) dot frame.scalingVec).map(Return.apply)
    )

}
package highperfscala.dataanalysis.benchmarks

import java.util.concurrent.TimeUnit

import highperfscala.dataanalysis._
import highperfscala.dataanalysis.benchmarks.ReturnSeriesFrameBenchmarks.SeriesState
import org.openjdk.jmh.annotations._
import org.openjdk.jmh.annotations.Mode._

import scala.util.Random

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class ReturnSeriesFrameBenchmarks {

  @Benchmark
  def normalizeVectors(s: SeriesState): VectorBasedReturnSeriesFrame = {
    ReturnSeriesFrame.scaleVector(s.vectorBased)
  }

  @Benchmark
  def normalizeArray(s: SeriesState): ArrayBasedReturnSeriesFrame = {
    ReturnSeriesFrame.scaleWithMap(s.arrayBased)
  }

  @Benchmark
  def normalizeSpireLoop(s: SeriesState): ArrayBasedReturnSeriesFrame = {
    ReturnSeriesFrame.scaleWithSpire(s.arrayBased)
  }

  @Benchmark
  def normalizeSaddleMatrix(s: SeriesState): MatrixBasedReturnSeriesFrame = {
    ReturnSeriesFrame.scaleWithSaddle(s.matrixBased)
  }

}

object ReturnSeriesFrameBenchmarks {

  @State(Scope.Benchmark)
  class SeriesState {

    @Param(Array("10"))
    var seriesCount: Int = 0

    @Param(Array(/*"60", "1440",*/ "300000"))
    var seriesSize: Int = 0

    var vectorBased: VectorBasedReturnSeriesFrame = null
    var arrayBased: ArrayBasedReturnSeriesFrame = null
    var matrixBased: MatrixBasedReturnSeriesFrame = null

    @Setup(Level.Trial)
    def setup(): Unit = {
      val series = new Array[Array[Return]](seriesCount)
      for(i <- 0 until seriesCount){
        val localSeries = new Array[Return](seriesSize)
        for(j <- 0 until seriesSize){
          localSeries(j) = Return(Random.nextInt(100))
        }
        series(i) = localSeries
      }

      val vectors = series.map(_.toVector).toVector

      vectorBased = new VectorBasedReturnSeriesFrame(vectors)
      arrayBased = ReturnSeriesFrame.newArrayBasedFrame(series)
      matrixBased = ReturnSeriesFrame.newMatrixBasedFrame(series)
      vectorBased.scalingVector
      arrayBased.scalingVector
    }
  }

}
package highperfscala.concurrency.future

import java.util.concurrent.TimeoutException

import scala.concurrent.duration.Duration
import scala.concurrent.{Awaitable, Await}
import scala.util.{Failure, Success, Try}

  object SafeAwait {
    def result[T](
      awaitable: Awaitable[T],
      atMost: Duration): Option[T] = Try(Await.result(awaitable, atMost)) match {
      case Success(t) => Some(t)
      case Failure(_: TimeoutException) => None
      case Failure(e) => throw e
    }
  }
package highperfscala.option

object ScalaOptionExample {

  def optionalInt(i: Int): Option[Int] = Some(i)

}
package highperfscala
package benchmarks

import java.io.File
import highperfscala.orderbook.Commands.Command
import highperfscala.orderbook.OrderBook
import org.mpierce.metrics.reservoir.hdrhistogram.HdrHistogramReservoir
import util._

import scala.annotation.tailrec

object SecondLatencyBenchmark {

  def main(args: Array[String]): Unit = {

    val commandSample = DataCodec.read(new File(args(0)))
    val (commandsPerSecond, iterations) = (args(1).toInt, args(2).toInt)
    val totalCommandCount = commandsPerSecond * iterations

    jvmWarmUp(commandSample)

    @tailrec
    def sendCommands(
      xs: List[(List[Command], Int)],
      ob: OrderBook,
      testStart: Long,
      histogram: HdrHistogramReservoir): (OrderBook, HdrHistogramReservoir) =
      xs match {
        case head :: tail =>
          val (batch, offsetInSeconds) = head
          val shouldStart = testStart + (1000 * offsetInSeconds)

          while (shouldStart > System.currentTimeMillis()) {
            // keep the thread busy while waiting for the next batch to be sent
          }

          val updatedBook = batch.foldLeft(ob) {
            case (accBook, c) =>
              val newBook = OrderBook.handle(accBook, c)._1
              val operationEnd = System.currentTimeMillis()
              // record latency
              histogram.update(operationEnd - shouldStart)
              newBook
          }

          sendCommands(tail, updatedBook, testStart, histogram)
        case Nil => (ob, histogram)
      }

    val (_, histogram) = sendCommands(
      // Organizes commands per 1 second batches
      generateCount(commandSample, totalCommandCount)
        .grouped(commandsPerSecond).zipWithIndex
        .toList,
      OrderBook.empty,
      System.currentTimeMillis(),
      new HdrHistogramReservoir())

    printSnapshot(histogram.getSnapshot)
  }

}
package highperfscala.crdt

class OperationBasedGSet[A](set: Set[A]) {

  def value = set

  def contains(a: A) = set.contains(a)

  def update(a: AddElement[A]): (OperationBasedGSet[A], AddElement[A]) =
    (new OperationBasedGSet(set + a.a), a)

  def merge(other: AddElement[A]): OperationBasedGSet[A] =
    new OperationBasedGSet(set + other.a)

}

case class AddElement[A](a: A)

case class GSetState[A](set: Set[A])

class StateBasedGSet[A](set: Set[A]) {

  def value: Set[A] = set

  def contains(a: A): Boolean = set.contains(a)

  def update(a: AddElement[A]): (StateBasedGSet[A], GSetState[A]) = {
    val newSet = new StateBasedGSet(set + a.a)
    (newSet, GSetState(newSet.value))
  }

  def merge(other: GSetState[A]): StateBasedGSet[A] = {
    new StateBasedGSet(set ++ other.set)
  }

}package highperfscala.specialization

object Specialization {

  case class ShareCount[@specialized(Long, Int) T](value: T)

  def newShareCount(l: Long): ShareCount[Long] = ShareCount(l)

  case class Foo[@specialized(Int, Long) X, @specialized(Int, Long) Y](
    value: X, result: Y)

  def makeFoo: Foo[Int, Int] = Foo(1, 2).copy(value = 22)


  case class Bar[X, Y](value: X, result: Y)

  def makeBar: Bar[Int, Int] = Bar(1, 2)

  case class Defined(value: Int, result: Int)

  def makeDefined: Defined = Defined(1, 2).copy(value = 22)
}
package highperfscala.specialization

import java.util.concurrent.TimeUnit

import org.openjdk.jmh.annotations.Mode._
import org.openjdk.jmh.annotations._

import SpecializationBenchmark._

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class SpecializationBenchmark {

  @Benchmark
  def specialized(): Double =
    specializedExecution.shareCount.toDouble * specializedExecution.price

  @Benchmark
  def boxed(): Double =
    boxedExecution.shareCount.toDouble * boxedExecution.price
}

object SpecializationBenchmark {
  class SpecializedExecution[@specialized(Int) T1, @specialized(Double) T2](
    val shareCount: Long, val price: Double)
  class BoxingExecution[T1, T2](val shareCount: T1, val price: T2)

  val specializedExecution: SpecializedExecution[Int, Double] =
    new SpecializedExecution(10l, 2d)
  val boxedExecution: BoxingExecution[Long, Double] = new BoxingExecution(10l, 2d)
}
package highperfscala.clientreports.streams

import scala.annotation.tailrec

object StreamsExamples {

  def powerOf2: Stream[Int] = {
    def next(n: Int): Stream[Int] = {
      println(s"Adding $n")
      n #:: next(2 * n)
    }
    1 #:: next(1)
  }

  def recursivePowerOf2(n: Int): Stream[Int] =
    math.pow(2, n).toInt #:: recursivePowerOf2(n+1)

  @tailrec
  def drop[A](s: Stream[A], count: Int): Stream[A] = count match {
    case 0 => s
    case n if n > 0 => drop(s.tail, count - 1)
    case n if n < 0 => throw new Exception("cannot drop negative count")
  }

  def max(s: => Stream[Int]): Option[Int] = {
    @tailrec
    def loop(ss: Stream[Int], current: Option[Int]): Option[Int] = ss match {
      case Stream.Empty => current
      case h #:: rest if current.exists(_ >= h) => loop(rest, current)
      case h #:: rest => loop(rest, Some(h))
    }
    loop(s, None)
  }

  def memoizingMax(s: => Stream[Int]): Option[Int] = {
    @tailrec
    def loop(ss: Stream[Int], current: Int): Int = ss match {
      case Stream.Empty => current
      case h #:: rest if h > current => loop(rest, h)
      case h #:: rest if h <= current => loop(rest, current)
    }

    // This pattern matching creates a reference to the tail of s and
    // prevents eager garbage collection of the intermediate elements.
    s match {
      case Stream.Empty => None
      case h #:: rest => Some(loop(rest, h))
    }
  }

  def range(s: Seq[Int]): Int = s.max - s.min

}
package highperfscala.anyval

import scala.util.Random
import scalaz.{@@, Tag}

object TaggedTypes {

  sealed trait PriceTag

  type Price = BigDecimal @@ PriceTag

  object Price {
    def newPrice(p: BigDecimal): Price =
      Tag[BigDecimal, PriceTag](p)

    def lowerThan(a: Price, b: Price): Boolean =
      Tag.unwrap(a) < Tag.unwrap(b)
  }

  def newPriceArray(count: Int): Array[Price] = {
    val a = new Array[Price](count)
    for (i <- 0 until count) {
      a(i) = Price.newPrice(BigDecimal(Random.nextInt()))
    }
    a
  }

}
package highperfscala.tailrec

import java.io.{BufferedReader, IOException}

import scala.annotation.tailrec

object TailRecursion {

  // This function cannot be marked @tailrec since the call to `sum`
  // is not the last instruction
  def sum(l: List[Int]): Int = l match {
    case Nil => 0
    case x :: xs => x + sum(xs)
  }

  def tailrecSum(l: List[Int]): Int = {
    @tailrec
    def loop(list: List[Int], acc: Int): Int = list match {
      case Nil => acc
      case x :: xs => loop(xs, acc + x)
    }
    loop(l, 0)
  }

  def sum2(l: List[Int]): Int = {

    def loop(list: List[Int], acc: Int): Int = list match {
      case Nil => acc
      case x :: xs => info(xs, acc + x)
    }

    def info(list: List[Int], acc: Int): Int = {
      println(s"${list.size} elements to examine. sum so far: $acc")
      loop(list, acc)
    }

    loop(l, 0)
  }

  def tailrecSum2(l: List[Int]): Int = {

    @tailrec
    def loop(list: List[Int], acc: Int): Int = list match {
      case Nil => acc
      case x :: xs =>
        println(s"${list.size} elements to examine. sum so far: $acc")
        loop(list, acc)
    }

    loop(l, 0)
  }

  def sumFromReader(br: BufferedReader): Int = {

    def read(acc: Int, reader: BufferedReader): Int = {
      Option(reader.readLine().toInt)
        .fold(acc)(i => read(acc + i, reader))
    }

    read(0, br)
  }

  def tailrecSumFromReader(br: BufferedReader): Int = {
    @tailrec
    def read(acc: Int, reader: BufferedReader): Int = {
      val opt = Option(reader.readLine().toInt)
      if (opt.isEmpty) acc else read(acc + opt.get, reader)
    }

    read(0, br)
  }

  class Printer(msg: String) {
    def printMessageNTimes(n: Int): Unit = {
      if (n > 0) {
        println(msg)
        printMessageNTimes(n - 1)
      }
    }
  }

  class TailRecPrinter(msg: String) {
    @tailrec
    final def printMessageNTimes(n: Int): Unit = {
      if (n > 0) {
        println(msg)
        printMessageNTimes(n - 1)
      }
    }
  }

  def tryCatchBlock(l: List[Int]): Int = {
    def loop(list: List[Int], acc: Int): Int = list match {
      case Nil => acc
      case x :: xs =>
        try {
          loop(xs, acc + x)
        } catch {
          case e: IOException =>
            println(s"Recursion got interrupted by exception")
            acc
        }
    }


    loop(l, 0)
  }

}
package highperfscala.concurrency.task

import scala.concurrent.duration.Duration
import scala.concurrent.{Await, ExecutionContext, Future, Promise}
import scala.util.{Failure, Success}
import scalaz.concurrent.Task
import scalaz.{-\/, \/, \/-}

object TaskExample {

  def createAndRunTask(): Unit = {
    val t = Task {
      println("Computing the answer...")
      Thread.sleep(2000)
      40 + 2
    }

    t.unsafePerformAsync {
      case \/-(answer) => println("The answer is " + answer)
      case -\/(ex) => println("Failed to compute the answer: " + ex)
    }

    println("Waiting for the answer")
  }

  object CallbackAPI {

    import scala.concurrent.ExecutionContext.Implicits.global

    def doCoolThings[A](a: => A, f: (Throwable \/ A) => Unit): Unit =
      Future(a).onComplete {
        case Failure(ex) => f(-\/(ex))
        case Success(res) => f(\/-(res))
      }
  }

  def doCoolThingsToTask[A](a: => A): Task[A] =
    Task.async { f =>
      CallbackAPI.doCoolThings[A](a, res => f(res))
    }

  def futureToTask[A](future: Future[A])(implicit ec: ExecutionContext): Task[A] =
    Task.async { f =>
      future.onComplete {
        case Success(res) => f(\/-(res))
        case Failure(ex) => f(-\/(ex))
      }
    }

  def taskToFuture[A](t: Task[A]): Future[A] = {
    val p = Promise[A]()
    t.unsafePerformAsync {
      case \/-(a) => p.success(a)
      case -\/(ex) => p.failure(ex)
    }
    p.future
  }

  def mapFuture() = {
    import scala.concurrent.ExecutionContext.Implicits.global
    println("Main thread: " + Thread.currentThread.getName)
    val f = Future {
      println("First execution: " + Thread.currentThread.getName)
      40
    }
    f.map { i =>
      println("Second execution: " + Thread.currentThread.getName)
      i + 2
    }
    Await.result(f, Duration("1 second"))
  }

  def flatMapFuture() = {
    import scala.concurrent.ExecutionContext.Implicits.global
    println("Main thread: " + Thread.currentThread.getName)
    val f = Future {
      println("First execution: " + Thread.currentThread.getName)
      40
    }
    f.flatMap { i => Future {
      println("Second execution: " + Thread.currentThread.getName)
      i + 2
    }
    }
    Await.result(f, Duration("1 second"))
  }

  def mapTask() = {
    println("Main thread: " + Thread.currentThread.getName)
    val f = Task {
      println("First execution: " + Thread.currentThread.getName)
      40
    }
    f.map { i =>
      println("Second execution: " + Thread.currentThread.getName)
      i + 2
    }.unsafePerformSync
  }

  def flatMapTask() = {
    println("Main thread: " + Thread.currentThread.getName)
    val f = Task {
      println("First execution: " + Thread.currentThread.getName)
      40
    }
    f.flatMap { i => Task {
      println("Second execution: " + Thread.currentThread.getName)
      i + 2
    }
    }.unsafePerformSync
  }

}
package highperfscala.concurrency.task

import java.util.concurrent.{ExecutorService, Executors, TimeUnit}

import org.openjdk.jmh.annotations.Mode.Throughput
import org.openjdk.jmh.annotations._

import scala.concurrent.{ExecutionContext, Future, Await}
import scala.concurrent.duration.Duration
import scalaz.concurrent.Task

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class TaskFutureBenchmarks {

  import TaskFutureBenchmarks._

  @Benchmark
  def mapWithFuture(state: TaskFutureState): Int = {
    implicit val ec = state.context
    val init = Future(0)
    val res = (1 until state.operations).foldLeft(init)((f, _) => f.map(_ + 1))
    Await.result(res, Duration("5 minutes"))
  }

  @Benchmark
  def mapWithTask(state: TaskFutureState): Int = {
    val init = Task(0)(state.es)
    val res = (1 until state.operations).foldLeft(init)((t, _) => t.map(_ + 1))
    res.unsafePerformSync
  }

  @Benchmark
  def flatMapWithFuture(state: TaskFutureState): Int = {
    implicit val ec = state.context
    val init = Future(0)
    val res = (1 until state.operations).foldLeft(init)((f, _) =>
      f.flatMap(i => Future(i + 1)))
    Await.result(res, Duration("5 minutes"))
  }

  @Benchmark
  def flatMapWithTask(state: TaskFutureState): Int = {
    val init = Task(0)(state.es)
    val res = (1 until state.operations).foldLeft(init)((t, _) =>
      t.flatMap(i => Task(i + 1)(state.es)))
    res.unsafePerformSync
  }

}

object TaskFutureBenchmarks {

  @State(Scope.Benchmark)
  class TaskFutureState {

    @Param(Array("5", "10", "100"))
    var operations: Int = 0

    var es: ExecutorService = null
    var context: ExecutionContext = null

    @Setup(Level.Trial)
    def setup(): Unit = {
      es = Executors.newFixedThreadPool(20)
      context = ExecutionContext.fromExecutor(es)
    }

    @TearDown(Level.Trial)
    def tearDown(): Unit = {
      es.shutdownNow()
    }
  }

}
package highperfscala
package benchmarks

import java.io.File
import highperfscala.orderbook.OrderBook
import util._

object ThroughputBenchmark {

  def main(args: Array[String]): Unit = {

    val commandSample = DataCodec.read(new File(args(0)))
    val commandCount = args(1).toInt

    jvmWarmUp(commandSample)

    val commands = generateCount(commandSample, commandCount)

    val start = System.currentTimeMillis()
    commands.foldLeft(OrderBook.empty)(OrderBook.handle(_, _)._1)
    val end = System.currentTimeMillis()
    val delayInSeconds = (end - start) / 1000.0

    println {
      s"""
         |Processed ${commands.size} commands
         |in $delayInSeconds seconds
         |Throughput: ${commands.size / delayInSeconds} operations/sec"""
        .stripMargin
    }
  }
}
package highperfscala.free

import scala.language.{higherKinds, implicitConversions, postfixOps}
import scalaz.{-\/, Free, Functor, \/, \/-}

case class LimitMs(value: Long) extends AnyVal

sealed trait Thunk[A]
case class Timed[A](
  whenActive: () => A,
  whenExpired: () => A,
  limit: LimitMs) extends Thunk[A]
case class StartProcessing[A](
  whenActive: BboUpdated => A,
  whenExpired: BboUpdated => A,
  limit: LimitMs) extends Thunk[A]
case class TradingDecision[A](
  makeDecision: TradingStrategy => A) extends Thunk[A]

object Thunk {
  implicit val functor: Functor[Thunk] = new Functor[Thunk] {
    def map[A, B](t: Thunk[A])(f: (A) => B): Thunk[B] = t match {
      case Timed(whenActive, whenExpired, limit) =>
        Timed(() => f(whenActive()), () => f(whenExpired()), limit)
      case StartProcessing(whenActive, whenExpired, limit) =>
        StartProcessing(c => f(whenActive(c)), c => f(whenExpired(c)), limit)
      case TradingDecision(makeDecision) => TradingDecision(
        (makeDecision.apply _).andThen(f))
    }
  }

  def timed[L, R](
    f: () => R,
    exp: () => L,
    limit: LimitMs): Free[Thunk, L \/ R] = Free.liftF(
    Timed(() => \/-(f()), () => -\/(exp()), limit))
  def startProcessing[L, R](
    f: BboUpdated => R,
    exp: BboUpdated => L,
    limit: LimitMs): Free[Thunk, L \/ R] =
    Free.liftF(StartProcessing(f.andThen(\/-(_)), exp.andThen(-\/(_)), limit))
  def tradingDecision[L, R](f: TradingStrategy => R): Free[Thunk, L \/ R] =
    Free.liftF(TradingDecision((f.apply _).andThen(\/-(_))))
}
package highperfscala.free

import java.util.concurrent.atomic.AtomicLong
import java.util.concurrent.locks.LockSupport

trait TradingStrategy {
  def makeTradingDecision(e: BboUpdated): Option[Either[Bid, Offer]]
}

class ProductionStrategy(counter: AtomicLong) extends TradingStrategy {
  def makeTradingDecision(e: BboUpdated): Option[Either[Bid, Offer]] = {
    val c = counter.getAndIncrement()
    c % 1000 == 0 match {
      case true =>
        Thread.sleep(10)
        Some(Right(e.offer))
      case false =>
        LockSupport.parkNanos(20000) // 0.02ms
        c % 3 == 0 match {
          case true => Some(Left(e.bid))
          case false => None
        }
    }
  }
}

package highperfscala.concurrency.future

import java.util.concurrent.TimeUnit

import org.openjdk.jmh.annotations.Mode.Throughput
import org.openjdk.jmh.annotations._

import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class TransformFutureBenchmarks {

  import TransformFutureBenchmarks._

  @Benchmark
  def manyTransforms(state: TransformFutureState): Int = {
    import scala.concurrent.ExecutionContext.Implicits._
    val init = Future(0)
    val res = (1 until state.operations).foldLeft(init)((f, _) => f.map(_ + 1))
    Await.result(res, Duration("5 minutes"))
  }

  @Benchmark
  def oneTransform(state: TransformFutureState): Int = {
    import scala.concurrent.ExecutionContext.Implicits._
    val res = Future {
      (1 until state.operations).foldLeft(0)((acc, _) => acc + 1)
    }
    Await.result(res, Duration("5 minutes"))
  }

}

object TransformFutureBenchmarks {

  @State(Scope.Benchmark)
  class TransformFutureState {

    @Param(Array("5", "10"))
    var operations: Int = 0

  }

}
package highperfscala.specialization

object UnexpectedAllocations {

  case class ShareCount(value: Int) extends AnyVal
  case class ExecutionCount(value: Int)

  class Container2[@specialized X, @specialized Y](x: X, y: Y)

  def shareCount = new Container2(ShareCount(1), 1)

  def executionCount = new Container2(ExecutionCount(1), 1)

  def ints = new Container2(1, 1)
}
package highperfscala.anyval

import scala.util.Random

object ValueClasses {

  case class Price(value: BigDecimal) extends AnyVal {

    def lowerThan(p: Price): Boolean = this.value < p.value

  }

  case class OrderId(value: Long) extends AnyVal

  def printInfo(p: Price, oId: OrderId): Unit ={
    println(s"Price: ${p.value}, ID: ${oId.value}")
  }

  def newPriceArray(count: Int): Array[Price] = {
    val a = new Array[Price](count)
    for(i <- 0 until count){
      a(i) = Price(BigDecimal(Random.nextInt()))
    }
    a
  }

}
package highperfscala.clientreports.views

import java.util.concurrent.TimeUnit

import org.openjdk.jmh.annotations.Mode.Throughput
import org.openjdk.jmh.annotations._

@BenchmarkMode(Array(Throughput))
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 30, time = 10, timeUnit = TimeUnit.SECONDS)
@Fork(value = 1, warmups = 1, jvmArgs = Array("-Xms1G", "-Xmx1G"))
class ViewBenchmarks {

  import ViewBenchmarks._

  @Benchmark
  def singleTransformList(state: ViewState): List[Int] =
    state.numbers.map(_ * 2)

  @Benchmark
  def singleTransformView(state: ViewState): Vector[Int] =
    state.numbers.view.map(_ * 2).toVector

  @Benchmark
  def twoTransformsList(state: ViewState): List[Int] =
    state.numbers.map(_ * 2).filter(_ % 3 == 0)

  @Benchmark
  def twoTransformsView(state: ViewState): Vector[Int] =
    state.numbers.view.map(_ * 2).filter(_ % 3 == 0).toVector

  @Benchmark
  def threeTransformsList(state: ViewState): List[Int] =
    state.numbers.map(_ * 2).map(_ + 7).filter(_ % 3 == 0)

  @Benchmark
  def threeTransformsView(state: ViewState): Vector[Int] =
    state.numbers.view.map(_ * 2).map(_ + 7).filter(_ % 3 == 0).toVector
}

object ViewBenchmarks {

  @State(Scope.Benchmark)
  class ViewState {

    @Param(Array("10", "1000", "1000000"))
    var collectionSize: Int = 0

    var numbers: List[Int] = Nil

    @Setup
    def setup(): Unit = {
      numbers = (for (i <- 1 to collectionSize) yield i).toList
    }
  }
}
package highperfscala.clientreports.views

object ViewDemo {

  def main(args: Array[String]): Unit = {
    println("List evaluation:")
    val evens = List(0, 1, 2, 3, 4, 5).map(i => {
      println(s"Adding one to $i")
      i + 1
    }).filter(i => {
      println(s"Filtering $i")
      i % 2 == 0
    })

    println("--- Printing first two even elements ---")
    println(evens.take(2))

    println("View evaluation:")
    val evensView = List(0, 1, 2, 3, 4, 5).view.map(i => {
      println(s"Adding one to $i")
      i + 1
    }).filter(i => {
      println(s"Filtering $i")
      i % 2 == 0
    })

    println("--- Printing first two even elements ---")
    println(evensView.take(2).toList)
  }
}
package highperfscala.clientreports.views

import org.joda.time.{Duration, Instant, Interval}

object ViewPerformanceReporting {

  def trend(
    now: () => Instant,
    findOrders: (Interval, Ticker) => List[Order],
    findExecutions: (Interval, Ticker) => List[Execution],
    request: GenerateTradingPerformanceTrend): List[TradingPerformanceTrend] = {

    def periodPnL(
      duration: Duration): Map[Ticker, PeriodPnL] = {
      val currentTime = now()
      val interval = new Interval(currentTime.minus(duration), currentTime)
      (for {
        ticker <- request.tickers
        orders = findOrders(interval, ticker)
        executions = findExecutions(interval, ticker)
        idToExecPrice = executions.groupBy(_.id).mapValues(es =>
          Price.average(es.map(_.price)))
        signedExecutionPrices = for {
          o <- orders.view
          if o.clientId == request.clientId
          price <- idToExecPrice.get(o.id).map(p => o match {
            case _: BuyOrder => Price(p.value * -1)
            case _: SellOrder => p
          }).toList
        } yield price
        trend = signedExecutionPrices.foldLeft(PnL.zero) {
          case (pnl, p) => PnL(pnl.value + p.value)
        } match {
          case p if p.value >= PnL.zero.value => PeriodPositive
          case _ => PeriodNegative
        }
      } yield ticker -> trend).toMap
    }

    val tickerToLastHour = periodPnL(Duration.standardHours(1)).mapValues {
      case PeriodPositive => LastHourPositive
      case PeriodNegative => LastHourNegative
    }
    val tickerToLastDay = periodPnL(Duration.standardDays(1)).mapValues {
      case PeriodPositive => LastDayPositive
      case PeriodNegative => LastDayNegative
    }
    val tickerToLastSevenDays = periodPnL(Duration.standardDays(7)).mapValues {
      case PeriodPositive => LastSevenDayPositive
      case PeriodNegative => LastSevenDayNegative
    }

    tickerToLastHour.zip(tickerToLastDay).zip(tickerToLastSevenDays).map({
      case (((t, lastHour), (_, lastDay)), (_, lastSevenDays)) =>
        TradingPerformanceTrend(t, lastHour, lastDay, lastSevenDays)
    }).toList
  }

}
