1.2　什么是计算机 2
1.2.1　中央处理器 2
1.2.2　比特和字节 3
1.2.3　内存 3
1.2.4　存储设备 4
1.2.5　输入和输出设备 4
1.2.6　通信设备 5
1.3　编程语言 6
1.3.1　机器语言 6
1.3.2　汇编语言 6
1.3.3　高级语言 7
1.4　操作系统 8
1.4.1　控制和监视系统活动 8
1.4.2　分配和调配系统资源 8
1.4.3　调度操作 8
1.5　Java、万维网以及其他 9
1.6　Java语言规范、API、JDK、JRE和IDE 10
1.7　一个简单的Java程序 11
1.8　创建、编译和执行Java程序 13
1.9　程序设计风格和文档 16
1.9.1　正确的注释和注释风格 16
1.9.2　正确的缩进和空白 16
1.9.3　块的风格 17
1.10　程序设计错误 17
1.10.1　语法错误 17
1.10.2　运行时错误 18
1.10.3　逻辑错误 19
1.10.4　常见错误 19
1.11　使用NetBeans开发Java程序 20
1.11.1　创建Java工程 21
1.11.2　创建Java类 22
1.11.3　编译和运行类 22
1.12　使用Eclipse开发Java程序 23
1.12.1　创建Java工程 23
1.12.2　创建Java类 24
1.12.3　编译和运行类 24
关键术语 25
本章小结 26
测试题 27
编程练习题 27
第2章　基本程序设计 29
2.1　引言 29
2.2　编写简单的程序 29
2.3　从控制台读取输入 32
2.4　标识符 35
2.5　变量 35
2.6　赋值语句和赋值表达式 37
2.7　命名常量 38
2.8　命名习惯 39
2.9　数值数据类型和操作 39
2.9.1　数值类型 39
2.9.2　从键盘读取数值 40
2.9.3　数值操作符 40
2.9.4　幂运算 42
2.10　数值型字面值 43
2.10.1　整型字面值 43
2.10.2　浮点型字面值 43
2.10.3　科学记数法 44
2.11　表达式求值以及操作符优先级 44
2.12　示例学习：显示当前时间 45
2.13　增强赋值操作符 47
2.14　自增和自减操作符 48
2.15　数值类型转换 50
2.16　软件开发过程 52
2.17　示例学习：整钱兑零 55
2.18　常见错误和陷阱 57
关键术语 59
本章小结 60
测试题 60
编程练习题 60
第3章　选择 65
3.1　引言 65
3.2　boolean数据类型 65
3.3　if语句 67
3.4　双分支if-else语句 69
3.5　嵌套的if语句和多分支if-else语句 70
3.6　常见错误和陷阱 72
3.7　产生随机数 75
3.8　示例学习：计算身体质量指数 77
3.9　示例学习：计算税率 78
3.10　逻辑操作符 81
3.11　示例学习：判定闰年 84
3.12　示例学习：彩票 85
3.13　switch语句 87
3.14　条件操作 90
3.15　操作符的优先级和结合规则 91
3.16　调试 92
关键术语 93
本章小结 93
测试题 94
编程练习题 94
第4章　数学函数、字符和字符串 102
4.1　引言 102
4.2　常用数学函数 103
4.2.1　三角函数方法 103
4.2.2　指数函数方法 103
4.2.3　取整方法 104
4.2.4　min、max和abs方法 104
4.2.5　random方法 105
4.2.6　示例学习：计算三角形的角度 105
4.3　字符数据类型和操作 107
4.3.1　Unicode和ASCII码 107
4.3.2　特殊字符的转义序列 108
4.3.3　字符型数据与数值型数据之间的转换 108
4.3.4　字符的比较和测试 109
4.4　String类型 111
4.4.1　获取字符串长度 112
4.4.2　从字符串中获取字符 112
4.4.3　连接字符串 113
4.4.4　字符串的转换 113
4.4.5　从控制台读取字符串 114
4.4.6　从控制台读取字符 114
4.4.7　字符串比较 115
4.4.8　获得子字符串 116
4.4.9　获取字符串中的字符或者子串 117
4.4.10　字符串和数字间的转换 118
4.5　示例学习 120
4.5.1　猜测生日 120
4.5.2　将十六进制数转换为十进制数 123
4.5.3　使用字符串修改彩票程序 124
4.6　格式化控制台输出 126
关键术语 129
本章小结 129
测试题 130
编程练习题 130
第5章　循环 136
5.1　引言 136
5.2　while循环 137
5.3　示例学习：猜数字 139
5.4　循环设计策略 142
5.5　使用用户确认或者标记值控制循环 144
5.6　do-while循环 146
5.7　for循环 148
5.8　采用哪种循环 151
5.9　嵌套循环 153
5.10　最小化数值错误 155
5.11　示例学习 156
5.11.1　求最大公约数 156
5.11.2　预测未来学费 158
5.11.3　将十进制数转换为十六进制数 158
5.12　关键字break和continue 160
5.13　示例学习：判断回文 163
5.14　示例学习：显示素数 164
关键术语 167
本章小结 167
测试题 167
编程练习题 167
第6章　方法 176
6.1　引言 176
6.2　定义方法 177
6.3　调用方法 178
6.4　void方法与返回值方法 180
6.5　按值传参 183
6.6　模块化代码 186
6.7　示例学习：将十六进制数转换为十进制数 188
6.8　重载方法 190
6.9　变量的作用域 192
6.10　示例学习：生成随机字符 193
6.11　方法抽象和逐步求精 195
6.11.1　自顶向下的设计 196
6.11.2　自顶向下和自底向上的实现 197
6.11.3　实现细节 199
6.11.4　逐步求精的优势 201
关键术语 202
本章小结 202
测试题 203
编程练习题 203
第7章　一维数组 212
7.1　引言 212
7.2　数组的基础知识 212
7.2.1　声明数组变量 213
7.2.2　创建数组 213
7.2.3　数组大小和默认值 214
7.2.4　访问数组元素 214
7.2.5　数组初始化简写方式 215
7.2.6　处理数组 215
7.2.7　foreach循环 217
7.3　示例学习：分析数字 219
7.4　示例学习：一副牌 220
7.5　复制数组 222
7.6　将数组传递给方法 223
7.7　方法返回数组 226
7.8　示例学习：统计每个字母出现的次数 226
7.9　可变长参数列表 230
7.10　数组的查找 230
7.10.1　线性查找法 231
7.10.2　二分查找法 231
7.11　数组的排序 234
7.12　Arrays类 235
7.13　命令行参数 237
7.13.1　向main方法传递字符串 237
7.13.2　示例学习：计算器 238
关键术语 239
本章小结 240
测试题 240
编程练习题 240
第8章　多维数组 248
8.1　引言 248
8.2　二维数组基础 248
8.2.1　声明二维数组变量并创建二维数组 249
8.2.2　获取二维数组的长度 250
8.2.3　不规则数组 250
8.3　处理二维数组 251
8.4　将二维数组传递给方法 253
8.5　示例学习：多选题测验评分 254
8.6　示例学习：找出距离最近的点对 255
8.7　示例学习：数独 257
8.8　多维数组 260
8.8.1　示例学习：每日温度和湿度 261
8.8.2　示例学习：猜生日 263
本章小结 264
测试题 264
编程练习题 264
第9章　对象和类 276
9.1　引言 276
9.2　为对象定义类 277
9.3　示例：定义类和创建对象 278
9.4　使用构造方法构造对象 283
9.5　通过引用变量访问对象 284
9.5.1　引用变量和引用类型 284
9.5.2　访问对象的数据和方法 285
9.5.3　引用数据域和null值 285
9.5.4　基本类型变量和引用类型变量的区别 286
9.6　使用Java库中的类 288
9.6.1　Date类 288
9.6.2　Random类 289
9.6.3　Point2D类 289
9.7　静态变量、常量和方法 291
9.8　可见性修饰符 296
9.9　数据域封装 297
9.10　向方法传递对象参数 300
9.11　对象数组 303
9.12　不可变对象和类 305
9.13　变量的作用域 307
9.14　this引用 308
9.14.1　使用this引用数据域 308
9.14.2　使用this调用构造方法 309
关键术语 310
本章小结 311
测试题 311
编程练习题 311
第10章　面向对象思考 316
10.1　引言 316
10.2　类的抽象和封装 316
10.3　面向对象的思想 320
10.4　类的关系 322
10.4.1　关联 323
10.4.2　聚集和组合 324
10.5　示例学习：设计Course类 325
10.6　示例学习：设计栈类 327
10.7　将基本数据类型值作为对象处理 329
10.8　基本类型和包装类类型之间的自动转换 332
10.9　BigInteger和BigDecimal类 333
10.10　String类 334
10.10.1　构造字符串 335
10.10.2　不可变字符串与驻留字符串 335
10.10.3　替换和拆分字符串 336
10.10.4　使用模式匹配、替换和拆分 336
10.10.5　字符串与数组之间的转换 337
10.10.6　将字符和数值转换成字符串 338
10.10.7　格式化字符串 338
10.11　StringBuilder类和StringBuffer类 340
10.11.1　修改StringBuilder中的字符串 341
10.11.2　toString、capacity、length、setLength和charAt方法 343
10.11.3　示例学习：判断回文串时忽略既非字母又非数字的字符 343
关键术语 346
本章小结 346
测试题 346
编程练习题 346
第11章　继承和多态 354
11.1　引言 354
11.2　父类和子类 354
11.3　使用super关键字 360
11.3.1　调用父类的构造方法 360
11.3.2　构造方法链 361
11.3.3　调用父类的普通方法 362
11.4　方法重写 363
11.5　方法重写与重载 364
11.6　Object类及其toString()方法 366
11.7　多态 366
11.8　动态绑定 367
11.9　对象转换和instanceof操作符 370
11.10　Object类的equals方法 374
11.11　ArrayList类 375
11.12　关于列表的一些有用方法 381
11.13　示例学习：自定义栈类 382
11.14　protected数据和方法 383
11.15　防止继承和

第19章 泛型
19．1 引言
19．2 动机和优点
19．3 定义泛型类和接口
19．4 泛型方法
19．5 示例学习：对一个对象数组进行排序
19．6 原生类型和向后兼容
19．7 通配泛型
19．8 泛型的擦除和限制
19．9 示例学习：泛型矩阵类
关键术语
本章小结
测试题
编程练习题

第20章 线性表、栈、队列和优先队列
20．1 引言
20．2 集合
20．3 迭代器
20．4 使用forEach方法
20．5 线性表
20．5．1 11st接口中的通用方法
20．5．2 数组线性表类ArrayList和链表类L1nkedLlst
20．6 Comparator接口
20．7 线性表和集合的静态方法
20．8 示例学习：弹球
20．9 向量类和栈类
20．10 队列和优先队列
20．10．1 Queue接口
20．10．2 双端队列Deque和链表LinkedList
20．11 示例学习：表达式求值
关键术语
本章小结
测试题
编程练刁题

第21章 规则集和映射
21．1 引言
21．2 规则集
21．2．1 HashSet
21．2．2 LinkedHashSet
21．2．3 TreeSet
21．3 比较规则集和线性表的性能
21．4 不例学习：关键字计数
21．5 映射
21．6 示例学习：单词的出现次数
21．7 单元素与不可变的
集合和映射
关键术语
本章小结
测试题
编程练习题

第22章 开发高效算法
22．1 引言
22．2 使用大D标记来衡量算法效率
22．3 示例：确定大D
22．4 分析算法的时间复杂度
22．4．1 分析二分查找算法
22．4．2 分析选择排序算法
22．4．3 分析汉诺塔问题
22．4．4 常用的递推关系
22．4．5 比较常用的增长函数
22．5 使用动态编程寻找斐波那契数
22．6 使用欧几里得算法求最大公约数
22．7 寻找素数的高效算法
22．8 使用分而治之法寻找最近点对
22．9 使用回溯法解决八皇后问题
22．10 计算几何：寻找凸包
22．10．1 卷包裹算法
22．10．2 格雷厄姆算法
关键术语
本章小结
测试题
编程练习题

第23章 排序
第24章 实现线性表、栈、队列和优先队列
第25章 二叉搜索树
第26章 AVL树
第27章 散列
第28章 图及其应用
第29章 加权图及其应用
第30章 集合流的聚合操作



第2章　创建和销毁对象 4

第1条：用静态工厂方法代替构造器 4

第2条：遇到多个构造器参数时要考虑使用构建器 8

第3条：用私有构造器或者枚举类型强化Singleton属性 13

public enum StatusCodeEnum {
 // 基础状态码
 SUCCESS(100200, "操作成功"),
 FAIL(100201, "接口调用失败"),
 EXCEPTION(100501, "操作失败，请联系管理员"),
 PARAM_ERROR(100202, "请求参数为空"),

 //版本管理
 TASKNAME_ERROR(101202, "该任务字段名已存在"),
 RUNTASK_ERROR(101203, "任务正在执行"),
 RELOADTASK_ERROR(101204, "任务重跑失败,有上层关联任务正在执行"),
 TASK_NOT_EXIST_ERROR(101205, "任务信息不存在"),

 //流程控制
 TASK_NAME_ERROR(102201,"该任务名错误;"),
 RUN_TASK_ERROR(102202,"任务正在执行;"),
 PROC_DATA_ERROR(102203,"执行数据版本频率字段procData，配置错误;");



 private int code;
 private String msg;

 StatusCodeEnum(int code, String msg){
  this.code = code;
  this.msg = msg;
 }

 public int getCode() {
  return code;
 }
 public void setCode(int code) {
  this.code = code;
 }

 public String getMsg() {
  return msg;
 }
 public void setMsg(String msg) {
  this.msg = msg;
 }

}


第4条：通过私有构造器强化不可实例化的能力 15

第5条：优先考虑依赖注入来引用资源 16

第6条：避免创建不必要的对象 18

第7条：消除过期的对象引用 20

第8条：避免使用终结方法和清除方法 23

第9条：try-with-resources优先于try-f?inally 27

第3章　对于所有对象都通用的方法 30

第10条：覆盖equals时请遵守通用约定 30

第11条：覆盖equals时总要覆盖hashCode 40

第12条：始终要覆盖toString 44

第13条：谨慎地覆盖clone 46

第14条：考虑实现Comparable接口 53

第4章　类和接口 59

第15条：使类和成员的可访问性最小化 59

第16条：要在公有类而非公有域中使用访问方法 62

第17条：使可变性最小化 64

第18条：复合优先于继承 70

第19条：要么设计继承并提供文档说明，要么禁止继承 75

第20条：接口优于抽象类 79

第21条：为后代设计接口 83

第22条：接口只用于定义类型 85

第23条：类层次优于标签类 86

第24条：静态成员类优于非静态成员类 88

第25条：限制源文件为单个顶级类 91

第5章　泛型 93

第26条：请不要使用原生态类型 93

第27条：消除非受检的警告 97

第28条：列表优于数组 99

第29条：优先考虑泛型 102

第30条：优先考虑泛型方法 106

第31条：利用有限制通配符来提升API的灵活性 109

第32条：谨慎并用泛型和可变参数 114

第33条：优先考虑类型安全的异构容器 118

第6章　枚举和注解 123

第34条：用enum代替int常量 123

第35条：用实例域代替序数 131

第36条：用EnumSet代替位域 132

第37条：用EnumMap代替序数索引 134

第38条：用接口模拟可扩展的枚举 138

第39条：注解优先于命名模式 140

第40条：坚持使用Override注解 147

第41条：用标记接口定义类型 149

第7章　Lambda和Stream 151

第42条：Lambda优先于匿名类 151

第43条：方法引用优先于Lambda 154

第44条：坚持使用标准的函数接口 156

第45条：谨慎使用Stream 159

第46条：优先选择Stream中无副作用的函数 164

第47条：Stream要优先用Collection作为返回类型 168

第48条：谨慎使用Stream并行 172

第8章　方法 176

第49条：检查参数的有效性 176

第50条：必要时进行保护性拷贝 179

第51条：谨慎设计方法签名 182

第52条：慎用重载 184

第53条：慎用可变参数 189

第54条：返回零长度的数组或者集合，而不是null 190

第55条：谨慎返回optinal 192

第56条：为所有导出的API元素编写文档注释 196

第9章　通用编程 202

第57条：将局部变量的作用域最小化 202

第58条：for-each循环优先于传统的for循环 204

第59条：了解和使用类库 207

第60条：如果需要精确的答案，请避免使用f?loat和double 209

第61条：基本类型优先于装箱基本类型 211

第62条：如果其他类型更适合，则尽量避免使用字符串 213

第63条：了解字符串连接的性能 215

第64条：通过接口引用对象 216

第65条：接口优先于反射机制 218

第66条：谨慎地使用本地方法 220

第67条：谨慎地进行优化 221

第68条：遵守普遍接受的命名惯例 223

第10章　异常 227

第69条：只针对异常的情况才使用异常 227

第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常 229

第71条：避免不必要地使用受检异常 231

第72条：优先使用标准的异常 232

第73条：抛出与抽象对应的异常 234

第74条：每个方法抛出的所有异常都要建立文档 235

第75条：在细节消息中包含失败-捕获信息 237

第76条：努力使失败保持原子性 238

第77条：不要忽略异常 239

第11章　并发 241

第78条：同步访问共享的可变数据 241

第79条：避免过度同步 245

第80条：executor、task和stream优先于线程 250

第81条：并发工具优先于wait和notify 251

第82条：线程安全性的文档化 256

第83条：慎用延迟初始化 258

第84条：不要依赖于线程调度器 261

第12章　序列化 263

第85条：其他方法优先于Java序列化 263

第86条：谨慎地实现Serializable接口 266

第87条：考虑使用自定义的序列化形式 269

第88条：保护性地编写readObject方法 274

第89条：对于实例控制，枚举类型优先于readResolve 279

第90条：考虑用序列化代理代替序列化实例 282

附录　与第2版中条目的对应关系 286


Chapter 1：Big Data Analytics with Java
Why data analytics on big data?
Big data for analytics
Big data - a bigger pay package for Java developers
Basics of Hadoop - a Java sub-project
Distributed computing on Hadoop
HDFS concepts
Design and architecture of HDFS
Main components of HDFS
HDFS simple commands
Apache Spark
Concepts
Transformations
Actions
Spark Java API
Spark samples using Java 8
Loading data
Data operations - cleansing and munging
Analyzing data - count， projection， grouping， aggregation， and max/min
Actions on RDDs
Paired RDDs
Saving data
Collecting and printing results
Executing Spark programs on Hadoop
Apache Spark sub-projects
Spark machine learning modules
Mahout - a popular Java ML library
Deeplearning4j - a deep learning library
Summary

Chapter 2： First Steps in Data Analysis
Datasets
Data cleaning and munging
Basic analysis of data with Spark SQL
Building SparkConf and context
Dataframe and datasets
Load and parse data
Analyzing data - the Spark-SQL way
Spark SQL for data exploration and analytics
Market basket analysis - Apriori algorithm
Implementation of the Apriori algorithm in Apache Spark
Efficient market basket analysis using FP-Growth algorithm
Running FP-Growth on Apache Spark
Summary

Chapter 3： Data Visualization
Data visualization with Java JFreeChart
Using charts in big data analytics
Time Series chart
All India seasonal and annual average temperature series dataset
Simple single Time Series chart




第1章　计算机与Java引论 1
1.1　计算机基础 1
1.1.1　硬件与内存 2
1.1.2　程序 3
1.1.3　编程语言、编译器和解释器 4
1.1.4　Java字节码 5
1.1.5　类加载器 7
1.2　浅尝Java 8
1.2.1　Java语言的历史 8
1.2.2　应用程序与小应用程序 9
1.2.3　第一个Java应用程序 9
1.2.4　编写、编译和运行Java程序 13
1.3　编程基础 14
1.3.1　面向对象编程 14
1.3.2　算法 17
1.3.3　测试与调试 18
1.3.4　软件复用 19
1.4　图形化编程补充读物 20
1.4.1　一个JavaFX应用程序样例 21
1.4.2　图形的尺寸和位置 23
1.4.3　绘制椭圆和圆 24
1.4.4　绘制弧 25
本章小结 27
练习 28
实践程序 29
编程项目 29
自测问题答案 30
第2章　基本的计算 33
2.1　变量和表达式 33
2.1.1　变量 33
2.1.2　数据类型 35
2.1.3　Java标识符 37
2.1.4　赋值语句 38
2.1.5　简单输入 40
2.1.6　简单屏幕输出 41
2.1.7　常量 42
2.1.8　具名常量 43
2.1.9　赋值兼容性 44
2.1.10　类型强制转换 45
2.1.11　算术运算 48
2.1.12　括号和优先级规则 50
2.1.13　特殊赋值操作符 51
2.1.14　案例研究：售货机找零 52
2.1.15　递增和递减操作符 56
2.1.16　更多有关递增和递减操作符的讨论 57
2.2　String类 57
2.2.1　字符串常量和变量 58
2.2.2　字符串连接 58
2.2.3　字符串方法 59
2.2.4　字符串处理 62
2.2.5　转义字符 63
2.2.6　Unicode字符集 64
2.3　键盘和屏幕I/O 65
2.3.1　屏幕输出 65
2.3.2　键盘输入 67
2.3.3　其他输入界定符（选修） 72
2.3.4　使用printf的格式化输出（选修） 73
2.4　文档和样式 75
2.4.1　有意义的变量名 75
2.4.2　注释 75
2.4.3　缩进 77
2.4.4　使用具名常量 78
2.5　图形化编程补充读物 80
2.5.1　将样式规则应用于JavaFX应用程序 80
2.5.2　介绍JOptionPane类 81
2.5.3　将输入作为其他数字类型读取 87
2.5.4　编程示例：具有窗口化I/O的找零程序 88
本章小结 90
练习 90
实践程序 92
编程项目 93
自测问题答案 94
第3章　流控制—分支 98
3.1　if-else语句 98
3.1.1　基本的if-else语句 98
3.1.2　布尔表达式 104
3.1.3　比较字符串 107
3.1.4　嵌套的if-else语句 111
3.1.5　多重分支的if-else语句 112
3.1.6　编程示例：给出字母等第 114
3.1.7　案例研究：体重指数 116
3.1.8　条件操作符（选修） 118
3.1.9　exit方法 119
3.2　boolean类型 120
3.2.1　布尔变量 120
3.2.2　优先级规则 121
3.2.3　布尔值的输入和输出 123
3.3　switch语句 124
3.4　图形化编程补充读物 130
3.4.1　指定绘图颜色 131
3.4.2　Yes或No问题的对话框 134
本章小结 135
练习 136
实践程序 137
编程项目 138
自测问题答案 140
第4章　流控制—循环 142
4.1　Java循环语句 142
4.1.1　while语句 143
4.1.2　do-while语句 146
4.1.3　编程示例：臭虫侵扰 149
4.1.4　编程示例：嵌套循环 154
4.1.5　for语句 155
4.1.6　在for语句中声明变量 160
4.1.7　在for语句中使用逗号（选修） 160
4.1.8　for-each语句 162
4.2　用循环编程 162
4.2.1　循环体 162
4.2.2　初始化语句 163
4.2.3　控制循环迭代次数 164
4.2.4　案例研究：使用布尔变量来终止循环 166
4.2.5　编程示例：消费热潮 168
4.2.6　循环中的break语句和continue语句（选修） 170
4.2.7　循环缺陷 172
4.2.8　跟踪变量 174
4.2.9　断言检查 175
4.3　图形化编程补充读物 177
4.3.1　编程示例：一个包含多张脸的JavaFX应用程序 177
4.3.2　绘制文本 181
本章小结 182
练习 182
实践程序 184
编程项目 185
自测问题答案 188
第5章　定义类和方法 193
5.1　类和方法定义 193
5.1.1　类文件和单独编译 195
5.1.2　编程示例：实现Dog类 195
5.1.3　实例变量 196
5.1.4　方法 198
5.1.5　定义void方法 200
5.1.6　定义有返回值的方法 201
5.1.7　编程示例：实现Species类的第一次尝试 205
5.1.8　关键词this 208
5.1.9　局部变量 209
5.1.10　块 211
5.1.11　基本类型参数 212
5.2　信息隐藏和封装 216
5.2.1　信息隐藏 217
5.2.2　前置条件和后置条件注释 217
5.2.3　public和private修饰符 218
5.2.4　编程示例：为什么实例变量应该是私有的 220
5.2.5　编程示例：矩形类的另一种实现 221
5.2.6　访问器方法和修改器方法 223
5.2.7　编程示例：Purchase类 225
5.2.8　调用方法的方法 228
5.2.9　封装 233
5.2.10　使用javadoc自动归档 235
5.2.11　UML类图 235
5.3　对象和引用 236
5.3.1　类类型变量 237
5.3.2　定义类的equals方法 242
5.3.3　编程示例：Species类 244
5.3.4　布尔值方法 246
5.3.5　案例研究：单元测试 247
5.3.6　类类型参数 249
5.3.7　编程示例：类类型参数与




=====================================================================

不了解这12个语法糖，别说你会Java！
Hollis  程序员小灰  昨天
本文转载自公众号  Hollis



本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理


语法糖
语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。

有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。

我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。

很多人说Java是一个“低糖语言”，其实从Java 7开始Java语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在Java有人还是认为现在的Java是低糖，未来还会持续向着“高糖”的方向发展。


解语法糖
前面提到过，语法糖的存在主要是方便开发人员使用。但其实，Java虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。

说到编译，大家肯定都知道，Java语言中，javac命令可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。

如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的。

Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。


糖块一、 switch 支持 String 与枚举
前面提到过，从Java 7 开始，Java语言中的语法糖在逐渐丰富，其中一个比较重要的就是Java 7中switch开始支持String。

在开始coding之前先科普下，Java中的swith自身原本就支持基本类型。比如int、char等。

对于int类型，直接进行数值的比较。对于char类型则是比较其ascii码。

所以，对于编译器来说，switch中其实只能使用整型，任何类型的比较都要转换成整型。比如byte。short，char(ackii码是整型)以及int。

那么接下来看下switch对String得支持，有以下代码：

public class switchDemoString {
    public static void main(String[] args) {
        String str = "world";
        switch (str) {
        case "hello":
            System.out.println("hello");
            break;
        case "world":
            System.out.println("world");
            break;
        default:
            break;
        }
    }
}

反编译后内容如下：

public class switchDemoString
{
    public switchDemoString()
    {
    }
    public static void main(String args[])
    {
        String str = "world";
        String s;
        switch((s = str).hashCode())
        {
        default:
            break;
        case 99162322:
            if(s.equals("hello"))
                System.out.println("hello");
            break;
        case 113318802:
            if(s.equals("world"))
                System.out.println("world");
            break;
        }
    }
}

看到这个代码，你知道原来字符串的switch是通过equals()和hashCode()方法来实现的。还好hashCode()方法返回的是int，而不是long。

仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。



糖块二、 泛型
我们都知道，很多语言都是支持泛型的，但是很多人不知道的是，不同的编译器对于泛型的处理方式是不同的。

通常情况下，一个编译器处理泛型有两种方式：Code specialization和Code sharing。

C++和C#是使用Code specialization的处理机制，而Java使用的是Code sharing的机制。

Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。

也就是说，对于Java虚拟机来说，他根本不认识Map<String, String> map这样的语法。需要在编译阶段通过类型擦除的方式进行解语法糖。

类型擦除的主要过程如下：

 1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。

 2.移除所有的类型参数。

以下代码：

Map<String, String> map = new HashMap<String, String>();
map.put("name", "hollis");
map.put("wechat", "Hollis");
map.put("blog", "www.hollischuang.com");

解语法糖之后会变成：

Map map = new HashMap();
map.put("name", "hollis");
map.put("wechat", "Hollis");
map.put("blog", "www.hollischuang.com");

以下代码：

public static <A extends Comparable<A>> A max(Collection<A> xs) {
    Iterator<A> xi = xs.iterator();
    A w = xi.next();
    while (xi.hasNext()) {
        A x = xi.next();
        if (w.compareTo(x) < 0)
            w = x;
    }
    return w;
}

类型擦除后会变成：

 public static Comparable max(Collection xs){
    Iterator xi = xs.iterator();
    Comparable w = (Comparable)xi.next();
    while(xi.hasNext())
    {
        Comparable x = (Comparable)xi.next();
        if(w.compareTo(x) < 0)
            w = x;
    }
    return w;
}

虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。


糖块三、 自动装箱与拆箱
自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。参考：一文读懂什么是Java中的自动拆装箱

因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。

原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。

先来看个自动装箱的代码：

 public static void main(String[] args) {
    int i = 10;
    Integer n = i;
}

反编译后代码如下:

public static void main(String args[])
{
    int i = 10;
    Integer n = Integer.valueOf(i);
}

再来看个自动拆箱的代码：

public static void main(String[] args) {

    Integer i = 10;
    int n = i;
}

反编译后代码如下：

public static void main(String args[])
{
    Integer i = Integer.valueOf(10);
    int n = i.intValue();
}

从反编译得到内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。

所以，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。


糖块四 、 方法变长参数
可变参数(variable arguments)是在Java 1.5中引入的一个特性。它允许一个方法把任意数量的值作为参数。

看下以下可变参数代码，其中print方法接收可变参数：

public static void main(String[] args)
    {
        print("Holis", "公众号:Hollis", "博客：www.hollischuang.com", "QQ：907607222");
    }

public static void print(String... strs)
{
    for (int i = 0; i < strs.length; i++)
    {
        System.out.println(strs[i]);
    }
}

反编译后代码：

 public static void main(String args[])
{
    print(new String[] {
        "Holis", "公众号:Hollis", "博客：www.hollischuang.com", "QQ：907607222"
    });
}

public static transient void print(String strs[])
{
    for(int i = 0; i < strs.length; i++)
        System.out.println(strs[i]);

}

从反编译后代码可以看出，可变参数在被使用的时候，他首先会创建一个数组，数组的长度就是调用该方法是传递的实参的个数，然后再把参数值全部放到这个数组当中，然后再把这个数组作为参数传递到被调用的方法中。


糖块五 、 枚举
Java SE5提供了一种新的类型-Java的枚举类型，关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能。参考：Java的枚举类型用法介绍

要想看源码，首先得有一个类吧，那么枚举类型到底是什么类呢？是enum吗？

答案很明显不是，enum就和class一样，只是一个关键字，他并不是一个类。

那么枚举是由什么类维护的呢，我们简单的写一个枚举：

public enum t {
    SPRING,SUMMER;
}

然后我们使用反编译，看看这段代码到底是怎么实现的，反编译后代码内容如下：

public final class T extends Enum
{
    private T(String s, int i)
    {
        super(s, i);
    }
    public static T[] values()
    {
        T at[];
        int i;
        T at1[];
        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);
        return at1;
    }

    public static T valueOf(String s)
    {
        return (T)Enum.valueOf(demo/T, s);
    }

    public static final T SPRING;
    public static final T SUMMER;
    private static final T ENUM$VALUES[];
    static
    {
        SPRING = new T("SPRING", 0);
        SUMMER = new T("SUMMER", 1);
        ENUM$VALUES = (new T[] {
            SPRING, SUMMER
        });
    }
}

通过反编译后代码我们可以看到，public final class T extends Enum，说明，该类是继承了Enum类的，同时final关键字告诉我们，这个类也是不能被继承的。

当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。


糖块六 、 内部类
内部类又称为嵌套类，可以把内部类理解为外部类的一个普通成员。

内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念。

outer.java里面定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件了，分别是outer.class和outer$inner.class。所以内部类的名字完全可以和它的外部类名字相同。

public class OutterClass {
    private String userName;

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public static void main(String[] args) {

    }

    class InnerClass{
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}

以上代码编译后会生成两个class文件：OutterClass$InnerClass.class 、OutterClass.class 。

当我们尝试使用jad对OutterClass.class文件进行反编译的时候，命令行会打印以下内容：

Parsing OutterClass.class...
Parsing inner class OutterClass$InnerClass.class...
Generating OutterClass.jad
他会把两个文件全部进行反编译，然后一起生成一个OutterClass.jad文件。文件内容如下：

public class OutterClass
{
    class InnerClass
    {
        public String getName()
        {
            return name;
        }
        public void setName(String name)
        {
            this.name = name;
        }
        private String name;
        final OutterClass this$0;

        InnerClass()
        {
            this.this$0 = OutterClass.this;
            super();
        }
    }

    public OutterClass()
    {
    }
    public String getUserName()
    {
        return userName;
    }
    public void setUserName(String userName){
        this.userName = userName;
    }
    public static void main(String args1[])
    {
    }
    private String userName;
}



糖块七 、条件编译
—般情况下，程序中的每一行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。

如在C或CPP中，可以通过预处理语句来实现条件编译。其实在Java中也可实现条件编译。我们先来看一段代码：

public class ConditionalCompilation {
    public static void main(String[] args) {
        final boolean DEBUG = true;
        if(DEBUG) {
            System.out.println("Hello, DEBUG!");
        }

        final boolean ONLINE = false;

        if(ONLINE){
            System.out.println("Hello, ONLINE!");
        }
    }
}

反编译后代码如下：

public class ConditionalCompilation
{

    public ConditionalCompilation()
    {
    }

    public static void main(String args[])
    {
        boolean DEBUG = true;
        System.out.println("Hello, DEBUG!");
        boolean ONLINE = false;
    }
}

首先，我们发现，在反编译后的代码中没有System.out.println("Hello, ONLINE!");，这其实就是条件编译。

当if(ONLINE)为false的时候，编译器就没有对其内的代码进行编译。

所以，Java语法的条件编译，是通过判断条件为常量的if语句实现的。根据if判断条件的真假，编译器直接把分支为false的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个Java类的结构或者类的属性上进行条件编译。

这与C/C++的条件编译相比，确实更有局限性。在Java语言设计之初并没有引入条件编译的功能，虽有局限，但是总比没有更强。


糖块八 、 断言
在Java中，assert关键字是从JAVA SE 1.4 引入的，为了避免和老版本的Java代码中使用了assert关键字导致错误，Java在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！）。

如果要开启断言检查，则需要用开关-enableassertions或-ea来开启。

看一段包含断言的代码：

public class AssertTest {
    public static void main(String args[]) {
        int a = 1;
        int b = 1;
        assert a == b;
        System.out.println("公众号：Hollis");
        assert a != b : "Hollis";
        System.out.println("博客：www.hollischuang.com");
    }
}

反编译后代码如下：

public class AssertTest {
   public AssertTest()
    {
    }
    public static void main(String args[])
{
    int a = 1;
    int b = 1;
    if(!$assertionsDisabled && a != b)
        throw new AssertionError();
    System.out.println("公众号：Hollis");
    if(!$assertionsDisabled && a == b)
    {
        throw new AssertionError("Hollis");
    } else
    {
        System.out.println("博客：www.hollischuang.com");
        return;
    }
}

static final boolean $assertionsDisabled = !com/hollis/suguar/AssertTest.desiredAssertionStatus();


}

很明显，反编译之后的代码要比我们自己的代码复杂的多。所以，使用了assert这个语法糖我们节省了很多代码。

其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行。

-enableassertions会设置$assertionsDisabled字段的值。


糖块九 、 数值字面量
在java 7中，数值字面量，不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读。

比如：

public class Test {
    public static void main(String... args) {
        int i = 10_000;
        System.out.println(i);
    }
}

反编译后：

public class Test
{
  public static void main(String[] args)
  {
    int i = 10000;
    System.out.println(i);
  }
}

反编译后就是把_删除了。也就是说编译器并不认识在数字字面量中的_，需要在编译阶段把他去掉。


糖块十 、 for-each
增强for循环（for-each）相信大家都不陌生，日常开发经常会用到的，他会比for循环要少写很多代码，那么这个语法糖背后是如何实现的呢？

public static void main(String... args) {
    String[] strs = {"Hollis", "公众号：Hollis", "博客：www.hollischuang.com"};
    for (String s : strs) {
        System.out.println(s);
    }
    List<String> strList = ImmutableList.of("Hollis", "公众号：Hollis", "博客：www.hollischuang.com");
    for (String s : strList) {
        System.out.println(s);
    }
}

反编译后代码如下：

public static transient void main(String args[])
{
    String strs[] = {
        "Hollis", "公众号：Hollis", "博客：www.hollischuang.com"
    };
    String args1[] = strs;
    int i = args1.length;
    for(int j = 0; j < i; j++)
    {
        String s = args1[j];
        System.out.println(s);
    }

    List strList = ImmutableList.of("Hollis", "公众号：Hollis", "博客：www.hollischuang.com");
    String s;
    for(Iterator iterator = strList.iterator(); iterator.hasNext(); System.out.println(s))
        s = (String)iterator.next();

}

代码很简单，for-each的实现原理其实就是使用了普通的for循环和迭代器。


糖块十一 、 try-with-resource


Java里，对于文件操作IO流、数据库连接等开销非常昂贵的资源，用完之后必须及时通过close方法将其关闭，否则资源会一直处于打开状态，可能会导致内存泄露等问题。

关闭资源的常用方式就是在finally块里是释放，即调用close方法。比如，我们经常会写这样的代码：

public static void main(String[] args) {
    BufferedReader br = null;
    try {
        String line;
        br = new BufferedReader(new FileReader("d:\hollischuang.xml"));
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    } finally {
        try {
            if (br != null) {
                br.close();
            }
        } catch (IOException ex) {
            // handle exception
        }
    }
}

从Java 7开始，jdk提供了一种更好的方式关闭资源，使用try-with-resources语句，改写一下上面的代码，效果如下：

public static void main(String... args) {
    try (BufferedReader br = new BufferedReader(new FileReader("d:\ hollischuang.xml"))) {
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
    } catch (IOException e) {
        // handle exception
    }
}

看，这简直是一大福音啊，虽然我之前一般使用IOUtils去关闭流，并不会使用在finally中写很多代码的方式，但是这种新的语法糖看上去好像优雅很多呢。

反编译以上代码，看下他的背后原理：

public static transient void main(String args[])
    {
        BufferedReader br;
        Throwable throwable;
        br = new BufferedReader(new FileReader("d:\ hollischuang.xml"));
        throwable = null;
        String line;
        try
        {
            while((line = br.readLine()) != null)
                System.out.println(line);
        }
        catch(Throwable throwable2)
        {
            throwable = throwable2;
            throw throwable2;
        }
        if(br != null)
            if(throwable != null)
                try
                {
                    br.close();
                }
                catch(Throwable throwable1)
                {
                    throwable.addSuppressed(throwable1);
                }
            else
                br.close();
            break MISSING_BLOCK_LABEL_113;
            Exception exception;
            exception;
            if(br != null)
                if(throwable != null)
                    try
                    {
                        br.close();
                    }
                    catch(Throwable throwable3)
                      {
                        throwable.addSuppressed(throwable3);
                    }
                else
                    br.close();
        throw exception;
        IOException ioexception;
        ioexception;
    }
}

其实背后的原理也很简单，那些我们没有做的关闭资源的操作，编译器都帮我们做了。

所以，再次印证了，语法糖的作用就是方便程序员的使用，但最终还是要转成编译器认识的语言。


糖块十二、Lambda表达式
关于lambda表达式，有人可能会有质疑，因为网上有人说他并不是语法糖。其实我想纠正下这个说法。

Labmda表达式不是匿名内部类的语法糖，但是他也是一个语法糖。实现方式其实是依赖了几个JVM底层提供的lambda相关api。

先来看一个简单的lambda表达式。遍历一个list：

public static void main(String... args) {
    List<String> strList = ImmutableList.of("Hollis", "公众号：Hollis", "博客：www.hollischuang.com");

    strList.forEach( s -> { System.out.println(s); } );
}

为啥说他并不是内部类的语法糖呢，前面讲内部类我们说过，内部类在编译之后会有两个class文件，但是，包含lambda表达式的类编译后只有一个文件。

反编译后代码如下:

public static /* varargs */ void main(String ... args) {
    ImmutableList strList = ImmutableList.of((Object)"Hollis", (Object)"公众号：Hollis", (Object)"博客：www.hollischuang.com");
    strList.forEach((Consumer<String>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$0(java.lang.String ), (Ljava/lang/String;)V)());
}

private static /* synthetic */ void lambda$main$0(String s) {
    System.out.println(s);
}

可以看到，在forEach方法中，其实是调用了java.lang.invoke.LambdaMetafactory#metafactory方法，该方法的第四个参数implMethod指定了方法实现。可以看到这里其实是调用了一个lambda$main$0方法进行了输出。

再来看一个稍微复杂一点的，先对List进行过滤，然后再输出：

public static void main(String... args) {
    List<String> strList = ImmutableList.of("Hollis", "公众号：Hollis", "博客：www.hollischuang.com");

    List HollisList = strList.stream().filter(string -> string.contains("Hollis")).collect(Collectors.toList());

    HollisList.forEach( s -> { System.out.println(s); } );
}

反编译后代码如下：

public static /* varargs */ void main(String ... args) {
    ImmutableList strList = ImmutableList.of((Object)"Hollis", (Object)"公众号：Hollis", (Object)"博客：www.hollischuang.com");
    List<Object> HollisList = strList.stream().filter((Predicate<String>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)Z, lambda$main$0(java.lang.String ), (Ljava/lang/String;)Z)()).collect(Collectors.toList());
    HollisList.forEach((Consumer<Object>)LambdaMetafactory.metafactory(null, null, null, (Ljava/lang/Object;)V, lambda$main$1(java.lang.Object ), (Ljava/lang/Object;)V)());
}

private static /* synthetic */ void lambda$main$1(Object s) {
    System.out.println(s);
}

private static /* synthetic */ boolean lambda$main$0(String string) {
    return string.contains("Hollis");
}

两个lambda表达式分别调用了lambda$main$1和lambda$main$0两个方法。

所以，lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，编译器会把lambda表达式进行解糖，转换成调用内部api的方式。


可能遇到的坑
泛型——当泛型遇到重载
public class GenericTypes {

    public static void method(List<String> list) {
        System.out.println("invoke method(List<String> list)");
    }

    public static void method(List<Integer> list) {
        System.out.println("invoke method(List<Integer> list)");
    }
}

上面这段代码，有两个重载的函数，因为他们的参数类型不同，一个是List另一个是List，但是，这段代码是编译通不过的。因为我们前面讲过，参数List和List编译之后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样。

泛型——当泛型遇到catch
泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM是无法区分两个异常类型MyException<String>和MyException<Integer>的

泛型——当泛型内包含静态变量
public class StaticTest{
    public static void main(String[] args){
        GT<Integer> gti = new GT<Integer>();
        gti.var=1;
        GT<String> gts = new GT<String>();
        gts.var=2;
        System.out.println(gti.var);
    }
}
class GT<T>{
    public static int var=0;
    public void nothing(T x){}
}

以上代码输出结果为：2！由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的。

自动装箱与拆箱——对象相等比较
public static void main(String[] args) {
    Integer a = 1000;
    Integer b = 1000;
    Integer c = 100;
    Integer d = 100;
    System.out.println("a == b is " + (a == b));
    System.out.println(("c == d is " + (c == d)));
}

输出结果：

a == b is false
c == d is true

在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。

适用于整数值区间-128 至 +127。

只适用于自动装箱。使用构造函数创建对象不适用。


增强for循环
for (Student stu : students) {
    if (stu.getId() == 2)
        students.remove(stu);
}

会抛出ConcurrentModificationException异常。

Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出java.util.ConcurrentModificationException异常。参考：一不小心就让Java开发者踩坑的fail-fast是个什么鬼？

所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法remove()来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。










=======================================================================================
Java 基础
1. JDK 和 JRE 有什么区别？

 JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。
 JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。
 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。
2. == 和 equals 的区别是什么？

== 解读

对于基本类型和引用类型 == 的作用效果是不同的，如下所示：

 基本类型：比较的是值是否相同；
 引用类型：比较的是引用是否相同；
代码示例：

String x = "string";
String y = "string";
String z = new String("string");
System.out.println(x==y); // true
System.out.println(x==z); // false
System.out.println(x.equals(y)); // true
System.out.println(x.equals(z)); // true

代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。

equals 解读

equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。

首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：

class Cat {
    public Cat(String name) {
        this.name = name;
    }

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

Cat c1 = new Cat("王磊");
Cat c2 = new Cat("王磊");
System.out.println(c1.equals(c2)); // false

输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：


public boolean equals(Object obj) {
    return (this == obj);
}

原来 equals 本质上就是 ==。

那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：

String s1 = new String("老王");
String s2 = new String("老王");
System.out.println(s1.equals(s2)); // true
同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：


public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。

总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。

3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？

不对，两个对象的 hashCode()相同，equals()不一定 true。

代码示例：

String str1 = "通话";
String str2 = "重地";
System.out.println(String.format("str1：%d | str2：%d",  str1.hashCode(),str2.hashCode()));
System.out.println(str1.equals(str2));
1
2
3
4
执行的结果：

str1：1179395 | str2：1179395
false
1
2
代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。

4. final 在 java 中有什么作用？

final 修饰的类叫最终类，该类不能被继承。
final 修饰的方法不能被重写。
final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。
5. java 中的 Math.round(-1.5) 等于多少？

等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。

6. String 属于基础的数据类型吗？

String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。

7. java 中操作字符串都有哪些类？它们之间有什么区别？

操作字符串的类有：String、StringBuffer、StringBuilder。

String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。

StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。

8. String str="i"与 String str=new String(“i”)一样吗？

不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。

9. 如何将字符串反转？

使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。

示例代码：

// StringBuffer reverse
StringBuffer stringBuffer = new StringBuffer();
stringBuffer.append("abcdefg");
System.out.println(stringBuffer.reverse()); // gfedcba
// StringBuilder reverse
StringBuilder stringBuilder = new StringBuilder();
stringBuilder.append("abcdefg");
System.out.println(stringBuilder.reverse()); // gfedcba
1
2
3
4
5
6
7
8
10. String 类的常用方法都有那些？

indexOf()：返回指定字符的索引
charAt()：返回指定索引处的字符。
replace()：字符串替换。
trim()：去除字符串两端空白。
split()：分割字符串，返回一个分割后的字符串数组。
getBytes()：返回字符串的 byte 类型数组。
length()：返回字符串长度。
toLowerCase()：将字符串转成小写字母。
toUpperCase()：将字符串转成大写字符。
substring()：截取字符串。
equals()：字符串比较。
11. 抽象类必须要有抽象方法吗？

不需要，抽象类不一定非要有抽象方法。

示例代码：

abstract class Cat {
    public static void sayHi() {
        System.out.println("hi~");
    }
}
1
2
3
4
5
上面代码，抽象类并没有抽象方法但完全可以正常运行。

12. 普通类和抽象类有哪些区别？

普通类不能包含抽象方法，抽象类可以包含抽象方法。
抽象类不能直接实例化，普通类可以直接实例化。
13. 抽象类能使用 final 修饰吗？

不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：
在这里插入图片描述
14. 接口和抽象类有什么区别？

实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。
构造函数：抽象类可以有构造函数；接口不能有。
main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。
实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。
15. java 中 IO 流分为几种？

按功能来分：输入流（input）、输出流（output）。
按类型来分：字节流和字符流。
字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。

16. BIO、NIO、AIO 有什么区别？

BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。
17. Files的常用方法都有哪些？

Files.exists()：检测文件路径是否存在。
Files.createFile()：创建文件。
Files.createDirectory()：创建文件夹。
Files.delete()：删除一个文件或目录。
Files.copy()：复制文件。
Files.move()：移动文件。
Files.size()：查看文件个数。
Files.read()：读取文件。
Files.write()：写入文件。


18. java 容器都有哪些？

常用容器的图录：
在这里插入图片描述
19. Collection 和 Collections 有什么区别？

java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。
Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。
20. List、Set、Map 之间的区别是什么？

在这里插入图片描述
21. HashMap 和 Hashtable 有什么区别？

hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。
hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。
hashMap允许空键值，而hashTable不允许。
22. 如何决定使用 HashMap 还是 TreeMap？

对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。

23. 说一下 HashMap 的实现原理？

HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。

当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。

需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)

24. 说一下 HashSet 的实现原理？

HashSet底层由HashMap实现
HashSet的值存放于HashMap的key上
HashMap的value统一为PRESENT
25. ArrayList 和 LinkedList 的区别是什么？

最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。

26. 如何实现数组和 List 之间的转换？

List转换成为数组：调用ArrayList的toArray方法。
数组转换成为List：调用Arrays的asList方法。
27. ArrayList 和 Vector 的区别是什么？

Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
ArrayList比Vector快，它因为有同步，不会过载。
ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。
28. Array 和 ArrayList 有何区别？

Array可以容纳基本类型和对象，而ArrayList只能容纳对象。
Array是指定大小的，而ArrayList大小是固定的。
Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。
29. 在 Queue 中 poll()和 remove()有什么区别？

poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。

30. 哪些集合类是线程安全的？

vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。
statck：堆栈类，先进后出。
hashtable：就比hashmap多了个线程安全。
enumeration：枚举，相当于迭代器。
31. 迭代器 Iterator 是什么？

迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。

32. Iterator 怎么使用？有什么特点？

Java中的Iterator功能比较简单，并且只能单向移动：

使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
使用next()获得序列中的下一个元素。
使用hasNext()检查序列中是否还有元素。
使用remove()将迭代器新返回的元素删除
Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。

33. Iterator 和 ListIterator 有什么区别？

Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。


多线程
35. 并行和并发有什么区别？

并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。
所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

36. 线程和进程的区别？

简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。

37. 守护线程是什么？

守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。

38. 创建线程有哪几种方式？

①. 继承Thread类创建线程类

定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
创建Thread子类的实例，即创建了线程对象。
调用线程对象的start()方法来启动该线程。
②. 通过Runnable接口创建线程类

定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
调用线程对象的start()方法来启动该线程。
③. 通过Callable和Future创建线程

创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
使用FutureTask对象作为Thread对象的target创建并启动新线程。
用FutureTask对象的get()方法来获得子线程执行结束后的返回值。
39. 说一下 runnable 和 callable 有什么区别？

有点深的问题了，也看出一个Java程序员学习知识的广度。

Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；
Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。
40. 线程有哪些状态？

线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。

创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。
就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。
运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。
阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。
死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪
41. sleep() 和 wait() 有什么区别？

sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。
wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程
42. notify()和 notifyAll()有什么区别？

如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。
优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。
43. 线程的 run()和 start()有什么区别？

每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。

start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。

run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。

44. 创建线程池有哪几种方式？

①. newFixedThreadPool(int nThreads)

创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。

②. newCachedThreadPool()

创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。

③. newSingleThreadExecutor()

这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。

④. newScheduledThreadPool(int corePoolSize)

创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

45. 线程池都有哪些状态？

线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。

线程池各个状态切换框架图：
在这里插入图片描述
46. 线程池中 submit()和 execute()方法有什么区别？

接收的参数不一样
submit有返回值，而execute没有
submit方便Exception处理
47. 在 java 程序中怎么保证多线程的运行安全？

线程安全在三个方面体现：

原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；
可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；
有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。
48. 多线程锁的升级原理是什么？

在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。

锁升级的图示过程：

在这里插入图片描述

49. 什么是死锁？

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。

50. 怎么防止死锁？

死锁的四个必要条件：

互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。

理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。

所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。

此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。

51. ThreadLocal 是什么？有哪些使用场景？

线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

52.说一下 synchronized 底层实现原理？

synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

普通同步方法，锁是当前实例对象
静态同步方法，锁是当前类的class对象
同步方法块，锁是括号里面的对象
53. synchronized 和 volatile 的区别是什么？

volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。
54. synchronized 和 Lock 有什么区别？

首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；
Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
55. synchronized 和 ReentrantLock 区别是什么？

synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：

ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁
ReentrantLock可以获取各种锁的信息
ReentrantLock可以灵活地实现多路通知
另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。

56. 说一下 atomic 的原理？

Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。

Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。

反射
57. 什么是反射？

反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力

Java反射：在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法。

Java反射机制主要提供了以下功能：

在运行时判断任意一个对象所属的类。
在运行时构造任意一个类的对象。
在运行时判断任意一个类所具有的成员变量和方法。
在运行时调用任意一个对象的方法。
58. 什么是 java 序列化？什么情况下需要序列化？

简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。

什么情况下需要序列化：

当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；
当你想用套接字在网络上传送对象的时候；
当你想通过RMI传输对象的时候；
59. 动态代理是什么？有哪些应用？

动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。

动态代理的应用：

Spring的AOP
加事务
加权限
加日志
60. 怎么实现动态代理？

首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。

转载自：https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA


对象拷贝
61. 为什么要使用克隆？

想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。

62. 如何实现对象克隆？

有两种方式：

实现Cloneable接口并重写Object类中的clone()方法；
实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class MyUtil {

    private MyUtil() {
        throw new AssertionError();
    }

    @SuppressWarnings("unchecked")
    public static <T extends Serializable> T clone(T obj) throws Exception {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bout);
        oos.writeObject(obj);

        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bin);
        return (T) ois.readObject();

        // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义
        // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放
    }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
下面是测试代码：

import java.io.Serializable;

/**
 * 人类
 * @author nnngu
 *
 */
class Person implements Serializable {
    private static final long serialVersionUID = -9102017020286042305L;

    private String name;    // 姓名
    private int age;        // 年龄
    private Car car;        // 座驾

    public Person(String name, int age, Car car) {
        this.name = name;
        this.age = age;
        this.car = car;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        this.car = car;
    }

    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + ", car=" + car + "]";
    }

}
/**
 * 小汽车类
 * @author nnngu
 *
 */
class Car implements Serializable {
    private static final long serialVersionUID = -5713945027627603702L;

    private String brand;       // 品牌
    private int maxSpeed;       // 最高时速

    public Car(String brand, int maxSpeed) {
        this.brand = brand;
        this.maxSpeed = maxSpeed;
    }

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public int getMaxSpeed() {
        return maxSpeed;
    }

    public void setMaxSpeed(int maxSpeed) {
        this.maxSpeed = maxSpeed;
    }

    @Override
    public String toString() {
        return "Car [brand=" + brand + ", maxSpeed=" + maxSpeed + "]";
    }

}
class CloneTest {

    public static void main(String[] args) {
        try {
            Person p1 = new Person("郭靖", 33, new Car("Benz", 300));
            Person p2 = MyUtil.clone(p1);   // 深度克隆
            p2.getCar().setBrand("BYD");
            // 修改克隆的Person对象p2关联的汽车对象的品牌属性
            // 原来的Person对象p1关联的汽车不会受到任何影响
            // 因为在克隆Person对象时其关联的汽车对象也被克隆了
            System.out.println(p1);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。

63. 深拷贝和浅拷贝区别是什么？

浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）
深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）


64. jsp 和 servlet 有什么区别？

jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）
jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。
servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。
Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。
65. jsp 有哪些内置对象？作用分别是什么？

JSP有9个内置对象：

request：封装客户端的请求，其中包含来自GET或POST请求的参数；
response：封装服务器对客户端的响应；
pageContext：通过该对象可以获取其他对象；
session：封装用户会话的对象；
pplication：封装服务器运行环境的对象；
out：输出服务器响应的输出流对象；
config：Web应用的配置对象
page：JSP页面本身（相当于Java程序中的this）；
exception：封装页面抛出异常的对象。
66. 说一下 jsp 的 4 种作用域？

JSP中的四种作用域包括page、request、session和application，具体来说：

page代表与一个页面相关的对象和属性。
request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。
session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。
application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。
67. session 和 cookie 有什么区别？

由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。
思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
68. 说一下 session 的工作原理？

其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。

69. 如果客户端禁止 cookie 能实现 session 还能用吗？

Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。

假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：

设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“–enable-trans-sid”选项，让PHP自动跨页传递Session ID。
手动通过URL传值、隐藏表单传递Session ID。
用文件、数据库等形式保存Session ID，在跨页过程中手动调用。
70. spring mvc 和 struts 的区别是什么？

拦截机制的不同
Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。

SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。

Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。

底层框架的不同
Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。

性能方面
Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。

配置方面
spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。

71. 如何避免 sql 注入？

PreparedStatement（简单又有效的方法）
使用正则表达式过滤传入的参数
字符串过滤
JSP中调用该函数检查是否包函非法字符
JSP页面判断代码
72. 什么是 XSS 攻击，如何避免？

XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。

XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。

73. 什么是 CSRF 攻击，如何避免？

CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。

如何避免：

验证 HTTP Referer 字段
HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF
攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。

使用验证码
关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。

在请求地址中添加token并验证
CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。
对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。
而对于 POST 请求来说，要在 form 的最后加上 ，这样就把token以参数的形式加入请求了。

在HTTP 头中自定义属性并验证
这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。


异常
74. throw 和 throws 的区别？

throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。

75. final、finally、finalize 有什么区别？

final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。
76. try-catch-finally 中哪个部分可以省略？

答：catch 可以省略

原因：

更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。

理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。

至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。

77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

答：会执行，在 return 前执行。

代码示例1：

/*
 * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
 */
public class FinallyDemo2 {
    public static void main(String[] args) {
        System.out.println(getInt());
    }

    public static int getInt() {
        int a = 10;
        try {
            System.out.println(a / 0);
            a = 20;
        } catch (ArithmeticException e) {
            a = 30;
            return a;
            /*
             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
             */
        } finally {
            a = 40;
        }

//      return a;
    }
}

执行结果：30

代码示例2：

package com.java_02;

/*
 * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？
 */
public class FinallyDemo2 {
    public static void main(String[] args) {
        System.out.println(getInt());
    }

    public static int getInt() {
        int a = 10;
        try {
            System.out.println(a / 0);
            a = 20;
        } catch (ArithmeticException e) {
            a = 30;
            return a;
            /*
             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了
             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40
             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30
             */
        } finally {
            a = 40;
            return a; //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40
        }

//      return a;
    }
}
执行结果：40

78. 常见的异常类有哪些？

NullPointerException：当应用程序试图访问空对象时，则抛出该异常。
SQLException：提供关于数据库访问错误或其他错误信息的异常。
IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。
NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。
FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。
IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。
ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。
ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。
IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。
ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。
NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。
NoSuchMethodException：无法找到某一特定方法时，抛出该异常。
SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。
UnsupportedOperationException：当不支持请求的操作时，抛出该异常。
RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。

网络
79. http 响应码 301 和 302 代表的是什么？有什么区别？

答：301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。

区别：

301 redirect: 301 代表永久性转移(Permanently Moved)。
302 redirect: 302 代表暂时性转移(Temporarily Moved )。
80. forward 和 redirect 的区别？

Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。

直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。

间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。

举个通俗的例子：

直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；

间接转发就相当于：“A找B借钱，B说没有，让A去找C借”。

81. 简述 tcp 和 udp的区别？

TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
CP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
cp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。
TCP对系统资源要求较多，UDP对系统资源要求较少。
82. tcp 为什么要三次握手，两次不行吗？为什么？

为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。

如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。

83. 说一下 tcp 粘包是怎么产生的？

①. 发送方产生粘包

采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

在这里插入图片描述
②. 接收方产生粘包

接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度） 在这里插入图片描述
84. OSI 的七层模型都有哪些？

应用层：网络服务与最终用户的一个接口。
表示层：数据的表示、安全、压缩。
会话层：建立、管理、终止会话。
传输层：定义传输数据的协议端口号，以及流控和差错校验。
网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。
数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。
物理层：建立、维护、断开物理连接。
85. get 和 post 请求有哪些区别？

LET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
参数的数据类型，GET只接受ASCII字符，而POST没有限制。
ET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。
86. 如何实现跨域？

方式一：图片ping或script标签跨域

图片ping常用于跟踪用户点击页面或动态广告曝光次数。
script标签可以得到从其他来源数据，这也是JSONP依赖的根据。

方式二：JSONP跨域

JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用

只能使用Get请求
不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败
JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保
方式三：CORS

Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：

Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
1
2
3
4
跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：

"Access-Control-Allow-Credentials": true
// Ajax设置
"withCredentials": true
1
2
3
方式四：window.name+iframe

window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。

iframe标签的跨域能力；
indow.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。
每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回

<!--
 下述用端口
 10000表示：domainA
 10001表示：domainB
-->

<!-- localhost:10000 -->
<script>
  var iframe = document.createElement('iframe');
  iframe.style.display = 'none'; // 隐藏

  var state = 0; // 防止页面无限刷新
  iframe.onload = function() {
      if(state === 1) {
          console.log(JSON.parse(iframe.contentWindow.name));
          // 清除创建的iframe
          iframe.contentWindow.document.write('');
          iframe.contentWindow.close();
          document.body.removeChild(iframe);
      } else if(state === 0) {
          state = 1;
          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)
          // Blocked a frame with origin "http://localhost:10000" from accessing a cross-origin frame.
          iframe.contentWindow.location = 'http://localhost:10000/proxy.html';
      }
  };

  iframe.src = 'http://localhost:10001';
  document.body.appendChild(iframe);
</script>

<!-- localhost:10001 -->
<!DOCTYPE html>
...
<script>
  window.name = JSON.stringify({a: 1, b: 2});
</script>
</html>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
方式五：window.postMessage()

HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。

下述代码实现了跨域存储localStorage

<!--
 下述用端口
 10000表示：domainA
 10001表示：domainB
-->

<!-- localhost:10000 -->
<iframe src="http://localhost:10001/msg.html" name="myPostMessage" style="display:none;">
</iframe>

<script>
  function main() {
      LSsetItem('test', 'Test: ' + new Date());
      LSgetItem('test', function(value) {
          console.log('value: ' + value);
      });
      LSremoveItem('test');
  }

  var callbacks = {};
  window.addEventListener('message', function(event) {
      if (event.source === frames['myPostMessage']) {
          console.log(event)
          var data = /^#localStorage#(\d+)(null)?#([\S\s]*)/.exec(event.data);
          if (data) {
              if (callbacks[data[1]]) {
                  callbacks[data[1]](data[2] === 'null' ? null : data[3]);
              }
              delete callbacks[data[1]];
          }
      }
  }, false);

  var domain = '*';
  // 增加
  function LSsetItem(key, value) {
      var obj = {
          setItem: key,
          value: value
      };
      frames['myPostMessage'].postMessage(JSON.stringify(obj), domain);
  }
  // 获取
  function LSgetItem(key, callback) {
      var identifier = new Date().getTime();
      var obj = {
          identifier: identifier,
          getItem: key
      };
      callbacks[identifier] = callback;
      frames['myPostMessage'].postMessage(JSON.stringify(obj), domain);
  }
  // 删除
  function LSremoveItem(key) {
      var obj = {
          removeItem: key
      };
      frames['myPostMessage'].postMessage(JSON.stringify(obj), domain);
  }
</script>

<!-- localhost:10001 -->
<script>
  window.addEventListener('message', function(event) {
    console.log('Receiver debugging', event);
    if (event.origin == 'http://localhost:10000') {
      var data = JSON.parse(event.data);
      if ('setItem' in data) {
        localStorage.setItem(data.setItem, data.value);
      } else if ('getItem' in data) {
        var gotItem = localStorage.getItem(data.getItem);
        event.source.postMessage(
          '#localStorage#' + data.identifier +
          (gotItem === null ? 'null#' : '#' + gotItem),
          event.origin
        );
      } else if ('removeItem' in data) {
        localStorage.removeItem(data.removeItem);
      }
    }
  }, false);
</script>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
注意Safari一下，会报错：

Blocked a frame with origin “http://localhost:10001” from
accessing a frame with origin “http://localhost:10000“.
Protocols, domains, and ports must match.
1
2
3
避免该错误，可以在Safari浏览器中勾选开发菜单==>停用跨域限制。或者只能使用服务器端转存的方式实现，因为Safari浏览器默认只支持CORS跨域请求。

方式六：修改document.domain跨子域

前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域

在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。

现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，
由于其document.name不一致，无法在aaa下操作bbb的js。
可以在aaa和bbb下通过js将document.name = 'xxx.com';
设置一致，来达到互相访问的作用。
1
2
3
4
方式七：WebSocket

WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。相关文章，请查看：WebSocket、WebSocket-SockJS

需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。

方式八：代理

同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题

DomainA客户端（浏览器） ==> DomainA服务器 ==> DomainB服务器 ==> DomainA客户端（浏览器）

在这里插入图片描述

87.说一下 JSONP 实现原理？

jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。


设计模式
88. 说一下你熟悉的设计模式？
参考：https://blog.csdn.net/li1325169021/article/category/8655228

89. 简单工厂和抽象工厂有什么区别？

这个模式本身很简单而且使用在业务较简单的情况下。一般用于小项目或者具体产品很少扩展的情况（这样工厂类才不用经常更改）。

它由三种角色组成：

厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的Driver类。
象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。如例中的Car接口。
具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现，如例子中的Benz、Bmw类。
来用类图来清晰的表示下的它们之间的关系：

在这里插入图片描述抽象工厂模式：

先来认识下什么是产品族： 位于不同产品等级结构中，功能相关联的产品组成的家族。
在这里插入图片描述图中的BmwCar和BenzCar就是两个产品树（产品层次结构）；而如图所示的BenzSportsCar和BmwSportsCar就是一个产品族。他们都可以放到跑车家族中，因此功能有所关联。同理BmwBussinessCar和BenzBusinessCar也是一个产品族。

可以这么说，它和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。

而且使用抽象工厂模式还要满足一下条件：

系统中有多个产品族，而系统一次只可能消费其中一族产品
同属于同一个产品族的产品以其使用。
来看看抽象工厂模式的各个角色（和工厂方法的如出一辙）：

抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。
具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。
抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。
转载自：https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA



# java面试题及答案
  * [1 面向对象的特征有哪些方面?](#1-面向对象的特征有哪些方面)
  * [2 访问修饰符public,private,protected,以及不写（默认）时的区别？](#2-访问修饰符publicprivateprotected以及不写默认时的区别)
  * [3 String 是最基本的数据类型吗?](#3-string-是最基本的数据类型吗)
  * [4 float f=3.4;是否正确?](#4-float-f34是否正确)
  * [5 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?](#5-short-s1--1-s1--s1--1有错吗short-s1--1-s1--1有错吗)
  * [6 Java 有没有goto?](#6-java-有没有goto)
  * [7 int 和Integer 有什么区别?](#7-int-和integer-有什么区别)
  * [8 &和&&的区别？](#8-和的区别)
  * [9 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。](#9-解释内存中的栈stack堆heap和静态存储区的用法)
  * [10 Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?](#10-mathround115-等于多少-mathround-115等于多少)
  * [11 swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?](#11-swtich-是否能作用在byte-上是否能作用在long-上是否能作用在string上)
  * [12 用最有效率的方法计算2乘以8?](#12-用最有效率的方法计算2乘以8)
  * [13 数组有没有length()方法?String 有没有length()方法](#13-数组有没有length方法string-有没有length方法)
  * [14 在Java 中，如何跳出当前的多重嵌套循环？](#14-在java-中如何跳出当前的多重嵌套循环)
  * [15 构造器（constructor）是否可被重写（override）?](#15-构造器constructor是否可被重写override)
  * [16 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？](#16-两个对象值相同xequalsy--true但却可有不同的hash-code这句话对不对)
  * [17 是否可以继承String 类?](#17-是否可以继承string-类)
  * [18 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?](#18-当一个对象被当作参数传递到一个方法后此方法可改变这个对象的属性并可返回变化后的结果那么这里到底是值传递还是引用传递)
  * [19 String 和StringBuilder、StringBuffer 的区别?](#19-string-和stringbuilderstringbuffer-的区别)
  * [20 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?](#20-重载overload和重写override的区别重载的方法能否根据返回类型进行区分)
  * [21 描述一下JVM 加载class文件的原理机制?](#21-描述一下jvm-加载class文件的原理机制)
  * [22 char型变量中能不能存贮一个中文汉字?为什么?](#22-char-型变量中能不能存贮一个中文汉字为什么)
  * [23 抽象类（abstract class）和接口（interface）有什么异同?](#23-抽象类abstract-class和接口interface有什么异同)
  * [24 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？](#24-静态嵌套类static-nested-class和内部类inner-class的不同)
  * [25 Java 中会存在内存泄漏吗，请简单描述。](#25-java-中会存在内存泄漏吗请简单描述)
  * [26 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?](#26-抽象的abstract方法是否可同时是静态的static是否可同时是本地方法native是否可同时被synchronized修饰)
  * [27 静态变量和实例变量的区别？](#27-静态变量和实例变量的区别)
  * [28 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？](#28-是否可以从一个静态static方法内部发出对非静态non-static方法的调用)
  * [29 如何实现对象克隆](#29-如何实现对象克隆)
  * [30 GC 是什么？为什么要有GC？](#30-gc-是什么为什么要有gc)
  * [31 String s=new String(“xyz”);创建了几个字符串对象？](#31-string-snew-stringxyz创建了几个字符串对象)
  * [32 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?](#32-接口是否可继承extends接口-抽象类是否可实现implements接口-抽象类是否可继承具体类concrete-class)
  * [33 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？](#33-一个java源文件中是否可以包含多个类不是内部类有什么限制)
  * [34 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？](#34-anonymous-inner-class匿名内部类是否可以继承其它类是否可以实现接口)
  * [35 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？](#35-内部类可以引用它的包含类外部类的成员吗有没有什么限制)
  * [36 Java 中的final关键字有哪些用法？](#36-java-中的final关键字有哪些用法)
  * [37 指出下面程序的运行结果:](#37-指出下面程序的运行结果)
  * [38 数据类型之间的转换:](#38-数据类型之间的转换)
  * [39 如何实现字符串的反转及替换？](#39-如何实现字符串的反转及替换)
  * [40 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？](#40-怎样将gb2312编码的字符串转换为iso-8859-1编码的字符串)
  * [41 日期和时间：](#41-日期和时间)
  * [42 打印昨天的当前时刻。](#42-打印昨天的当前时刻)
  * [43 比较一下Java 和JavaSciprt。](#43-比较一下java-和javasciprt)
  * [44 什么时候用assert？](#44-什么时候用assert)
  * [45 Error 和Exception 有什么区别?](#45-error-和exception-有什么区别)
  * [46 try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?](#46-try里有一个return语句那么紧跟在这个try后的finally里的code会不会被执行什么时候被执行在return前还是后)
  * [47 Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？](#47-java-语言如何进行异常处理关键字throwsthrowtrycatchfinally分别如何使用)
  * [48 运行时异常与受检异常有何异同？](#48-运行时异常与受检异常有何异同)
  * [49 列出一些你常见的运行时异常？](#49-列出一些你常见的运行时异常)
  * [50 final, finally, finalize 的区别?](#50-final-finally-finalize-的区别)

  ## java面试题及答案
  2018最新《BAT Java必考面试题集》

  ### 1 面向对象的特征有哪些方面?
  答：面向对象的特征主要有以下几个方面：
  1)抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

  2)继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。

  3)封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。

  4)多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

  ### 2 访问修饰符public,private,protected,以及不写（默认）时的区别？
  答：区别如下：
  作用域    当前类  同包 子类 其他
  public        √        √       √      √
  protected  √        √       √      ×
  default       √       √       ×      ×
  private       √        ×      ×      ×
  类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。
  ### 3 String 是最基本的数据类型吗?
  答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。
  ### 4 float f=3.4;是否正确?
  答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。
  ### 5 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?
  答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。

  ### 6 Java 有没有goto?
  答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）
  ### 7 int 和Integer 有什么区别?
  答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从JDK 1.5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。
  Java 为每个原始类型提供了包装类型：
  原始类型: boolean，char，byte，short，int，long，float，double
  包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

  >  补充：最近还遇到一个面试题，也是和自动装箱和拆箱相关的，代码如下所示：

  如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。

  IntegerCache是Integer的内部类，其代码如下所示：
  简单的说，如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。
  ### 8 &和&&的区别？
  答：&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals(“”)，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。
  补充：如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。
  ### 9 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。
  答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。
  String str = new String(“hello”);
  上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。
  补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。

  ### 10 Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?
  答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。
  ### 11 swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?
  答：早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从JDK 1.7版开始，还可以是字符串（String）。长整型（long）是不可以的。
  ### 12 用最有效率的方法计算2乘以8?
  答： 2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。
  补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num <==> (num << 5) - num，左移5位相当于乘以2的5次方（32）再减去自身就相当于乘以31。现在的VM都能自动完成这个优化。
  ![](http://ww1.sinaimg.cn/large/006DGX4tly1ftt0kmpthpj30fe07qjsi.jpg)
  ![](http://ww1.sinaimg.cn/large/006DGX4tly1ftt0ltusboj30fe0alq4j.jpg)

  ### 13 数组有没有length()方法?String 有没有length()方法？
  答：数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。

  ### 14 在Java 中，如何跳出当前的多重嵌套循环？
  答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）
  ### 15 构造器（constructor）是否可被重写（override）?
  答：构造器不能被继承，因此不能被重写，但可以被重载。
  ### 16 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？
  答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。
  补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查“参数是否为这个对象的引用”；2. 使用instanceof操作符检查“参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。
  ### 17 是否可以继承String 类?
  答：String 类是final类，不可以被继承。
  补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联（HAS-A）而不是继承（IS-A）。

  ### 18 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
  答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。
  补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。
  ### 19 String 和StringBuilder、StringBuffer 的区别?
  答：Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。
  补充1：有一个面试题问：有没有哪种情况用+做字符串连接比调用StringBuffer / StringBuilder对象的append方法性能更好？如果连接后得到的字符串在静态存储区中是早已存在的，那么用+做字符串连接是优于StringBuffer / StringBuilder的append方法的。
  补充2：下面也是一个面试题，问程序的输出，看看自己能不能说出正确答案。
  ![](http://ww1.sinaimg.cn/large/006DGX4tly1ftt0ohnh1bj30fe07275c.jpg)
  ### 20 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分?
  答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。
  补充：华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，说出你的答案吧！

  ### 21 描述一下JVM 加载class文件的原理机制?
  答：JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。
  补充：
  1.由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：1如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2如果类中存在初始化语句，就依次执行这些初始化语句。
  2.类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
  a)Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
  b)Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
  c)System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。
  ### 22 char 型变量中能不能存贮一个中文汉字?为什么?
  答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16bit），所以放一个中文是没问题的。
  补充：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。

  ### 23 抽象类（abstract class）和接口（interface）有什么异同?
  答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。
  ### 24 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？
  答：Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。
  ![](http://ww1.sinaimg.cn/large/006DGX4tly1ftt0qfj0jkj30ey0cjmyl.jpg)
  ![](http://ww1.sinaimg.cn/large/006DGX4tly1ftt0r2ige0j30cz0ce75m.jpg)
  ![](http://ww1.sinaimg.cn/large/006DGX4tly1ftt0ro846pj30dq05cdge.jpg)
  ![](http://ww1.sinaimg.cn/large/006DGX4tly1ftt0s8a34fj30fe06ygmp.jpg)
  ### 25 Java 中会存在内存泄漏吗，请简单描述。
  答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。下面的例子也展示了Java中发生内存泄露的情况：
  ![]()
  上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。

  ### 26 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰?
  答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。
  ### 27 静态变量和实例变量的区别？
  答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。
  ### 28 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？
  答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。
  ### 29 如何实现对象克隆？
  答：有两种方式：
  1.实现Cloneable接口并重写Object类中的clone()方法；
  2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。

  注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。
  ### 30 GC 是什么？为什么要有GC？
  答：GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。
  垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。
  补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：
  •	伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
  •	幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。
  •	终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。
  与垃圾回收相关的JVM参数：
  •	-Xms / -Xmx --- 堆的初始大小 / 堆的最大大小
  •	-Xmn --- 堆中年轻代的大小
  •	-XX:-DisableExplicitGC --- 让System.gc()不产生任何作用
  •	-XX:+PrintGCDetail --- 打印GC的细节
  •	-XX:+PrintGCDateStamps --- 打印GC操作的时间戳

  ### 31 String s=new String(“xyz”);创建了几个字符串对象？
  答：两个对象，一个是静态存储区的"xyz",一个是用new创建在堆上的对象。
  ### 32 接口是否可继承（extends）接口? 抽象类是否可实现（implements）接口? 抽象类是否可继承具体类（concrete class）?
  答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承具体类，但前提是具体类必须有明确的构造函数。
  ### 33 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
  答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。
  ### 34 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？
  答：可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。
  ### 35 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？
  答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。
  ### 36 Java 中的final关键字有哪些用法？
  答：(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。
  ### 37 指出下面程序的运行结果:

  答：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。
  ### 38 数据类型之间的转换:
  1)如何将字符串转换为基本数据类型？
  2)如何将基本数据类型转换为字符串？
  答：
  1)调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；
  2)一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf(…)方法返回相应字符串

  ### 39 如何实现字符串的反转及替换？
  答：方法很多，可以自己写实现也可以使用String或StringBuffer / StringBuilder中的方法。有一道很常见的面试题是用递归实现字符串反转，代码如下所示：

  ### 40 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？
  答：代码如下所示:
  String s1 = "你好";
  String s2 = newString(s1.getBytes("GB2312"), "ISO-8859-1");
  ### 41 日期和时间：
  1)如何取得年月日、小时分钟秒？
  2)如何取得从1970年1月1日0时0分0秒到现在的毫秒数？
  3)如何取得某月的最后一天？
  4)如何格式化日期？
  答：操作方法如下所示：
  1)创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值
  2)以下方法均可获得该毫秒数:

  3)示例代码如下:

  4)利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。
  ### 42 打印昨天的当前时刻。
  答：

  ### 43 比较一下Java 和JavaSciprt。
  答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。
  下面对两种语言间的异同作如下比较：
  1）基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；
  2）解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；
  3）强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；
  4）代码格式不一样。
  补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。

  ### 44 什么时候用assert？
  答：assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。
  断言用于调试目的：
  assert(a > 0); // throws an AssertionError if a <= 0
  断言可以有两种形式：
  assert Expression1;
  assert Expression1 : Expression2 ;
  Expression1 应该总是产生一个布尔值。
  Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。
  断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记：
  javac -source 1.4 Test.java
  要在运行时启用断言，可使用-enableassertions 或者-ea 标记。
  要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。
  要在系统类中启用断言，可使用-esa 或者-dsa 标记。还可以在包的基础上启用或者禁用断言。可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。
  ### 45 Error 和Exception 有什么区别?
  答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。
  补充：2005年摩托罗拉的面试中曾经问过这么一个问题“If a process reports a stack overflow run-time error, what’s the most possible cause?”，给了四个选项a. lack of memory; b. write on an invalid memory space; c. recursive function calling; d. array index out of boundary. Java程序在运行时也可能会遭遇StackOverflowError，这是一个错误无法恢复，只能重新修改代码了，这个面试题的答案是c。如果写了不能迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：

  因此，用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么时候就不再递归而是回溯了）。
  ### 46 try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?
  答：会执行，在方法返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。
  ### 47 Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？
  答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try用来指定一块预防所有“异常”的程序；catch 子句紧跟在try块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处理这种“异常”的try 语句。
  ### 48 运行时异常与受检异常有何异同？
  答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective Java》中对异常的使用给出了以下指导原则：
  •	不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
  •	对可以恢复的情况使用受检异常，对编程错误使用运行时异常
  •	避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）
  •	优先使用标准的异常
  •	每个方法抛出的异常都要有文档
  •	保持异常的原子性
  •	不要在catch中忽略掉捕获到的异常
  ### 49 列出一些你常见的运行时异常？
  答：
  ArithmeticException（算术异常）
  ClassCastException （类转换异常）
  IllegalArgumentException （非法参数异常）
  IndexOutOfBoundsException （下表越界异常）
  NullPointerException （空指针异常）
  SecurityException （安全异常）
  ### 50 final, finally, finalize 的区别?
  答：final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final 的方法也同样只能使用，不能在子类中被重写。finally：通常放在try…catch的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。finalize：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。




1.1 术语说明
在本文档中，除非另有说明：

术语class可表示一个普通类，枚举类，接口或是annotation类型( @interface)

术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。

其他的术语说明会偶尔在后面的文档出现。

1.2 指南说明
本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。

源文件基础
2.1 文件名
源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为 .java。

2.2 文件编码：UTF-8
源文件编码格式为UTF-8。

2.3 特殊字符
2.3.1 空白字符
除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：

所有其它字符串中的空白字符都要进行转义。

制表符不用于缩进。

2.3.2 特殊转义序列
对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, ", '及)，我们使用它的转义序列，而不是相应的八进制(比如 \012)或Unicode(比如 \u000a)转义。

2.3.3 非ASCII字符
对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。

Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。

例如：

String unitAbbrev = "μs";                                 | 赞，即使没有注释也非常清晰String unitAbbrev = "\u03bcs"; // "μs"                    | 允许，但没有理由要这样做String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"    | 允许，但这样做显得笨拙还容易出错String unitAbbrev = "\u03bcs";                            | 很糟，读者根本看不出这是什么return '\ufeff' + content; // byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释
Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)

源文件结构
一个源文件包含(按顺序地)：

许可证或版权信息(如有需要)

package语句

import语句

一个顶级类(只有一个)

以上每个部分之间用一个空行隔开。

3.1 许可证或版权信息
如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。

3.2 package语句
package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)

3.3 import语句
3.3.1 import不要使用通配符
即，不要出现类似这样的import语句：importjava.util.*;

3.3.2 不要换行
import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)

3.3.3 顺序和间距
import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：

所有的静态导入独立成组

com.google imports(仅当这个源文件是在 com.google包下)

第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun

java imports

javax imports

组内不空行，按字典序排列。

3.4 类声明
3.4.1 只有一个顶级类声明
每个顶级类都在一个与它同名的源文件中(当然，还包含 .java后缀)。

例外：package-info.java，该文件中可没有 package-info类。

3.4.2 类成员顺序
类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。

3.4.2.1 重载：永不分离
当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。

格式
术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。

4.1 大括号
4.1.1 使用大括号(即使是可选的)
大括号与 if,else,for,do,while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。

4.1.2 非空块：K & R 风格
对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):

左大括号前不换行

左大括号后换行

右大括号前换行

如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。

示例：

return new MyClass() {  @Override public void method() {    if (condition()) {      try {        something();      } catch (ProblemException e) {        recover();      }    }  }};
4.8.1节给出了enum类的一些例外。

4.1.3 空块：可以用简洁版本
一个空的块状结构里什么也不包含，大括号可以简洁地写成 {}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。

示例：

void doNothing() {}
4.2 块缩进：2个空格
每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)

4.3 一行一个语句
每个语句后要换行。

4.4 列限制：80或100
一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。

例外：

不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。

package和 import语句(见3.2节和3.3节)。

注释中那些可能被剪切并粘贴到shell中的命令行。

4.5 自动换行
术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。

我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。

Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)

4.5.1 从哪里断开
自动换行的基本准则是：更倾向于在更高的语法级别处断开。

如果在 非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&（ )，catch块中的管道符号( catch(FooException|BarExceptione)

如果在 赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于 foreach语句中的分号。

方法名或构造函数名与左括号留在同一行。

逗号(,)与其前面的内容留在同一行。

4.5.2 自动换行时缩进至少+4个空格
自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。

当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。

第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。

4.6 空白
4.6.1 垂直空白
以下情况需要使用一个空行：

类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。

- 例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。

在函数体内，语句的逻辑分组间使用空行。

类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。

要满足本文档中其他节的空行要求(比如3.3节：import语句)

多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。

4.6.2 水平空白
除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：

分隔任何保留字与紧随其后的左括号( ()(如 if,forcatch等)。

分隔任何保留字与其前面的右大括号( })(如 else,catch)。

在任何左大括号前( {)，两个例外：

- @SomeAnnotation({a,b})(不使用空格)。

String[][]x=foo;(大括号间没有空格，见下面的Note)。

在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：

- 类型界限中的&( )。

catch块中的管道符号( catch(FooException|BarExceptione)。

foreach语句中的分号。

在 ,:;及右括号( ))后

如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。

类型和变量之间：List list。

数组初始化中，大括号内的空格是可选的，即 newint[]{5,6}和 newint[]{5,6}都是可以的。

Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。

4.6.3 水平对齐：不做要求
术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。

这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。

以下示例先展示未对齐的代码，然后是对齐的代码：

private int x; // this is fineprivate Color color; // this too
private int   x;      // permitted, but future editsprivate Color color;  // may leave it unaligned
Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。

4.7 用小括号来限定组：推荐
除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个Java运算符优先级表。

4.8 具体结构
4.8.1 枚举类
枚举常量间用逗号隔开，换行可选。

没有方法和文档的枚举类可写成数组初始化的格式：

private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }
由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。

4.8.2 变量声明
4.8.2.1 每次只声明一个变量
不要使用组合声明，比如 inta,b;。

4.8.2.2 需要时才声明，并尽快进行初始化
不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。

4.8.3 数组
4.8.3.1 数组初始化：可写成块状结构
数组初始化可以写成块状结构，比如，下面的写法都是OK的：

new int[] {  0, 1, 2, 3 }
new int[] {  0,  1,  2,  3}
new int[] {  0, 1,  2, 3}
new int[]{0, 1, 2, 3}
4.8.3.2 非C风格的数组声明
中括号是类型的一部分：String[]args， 而非 Stringargs[]。

4.8.4 switch语句
术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签( caseFOO:或 default:)，后面跟着一条或多条语句。

4.8.4.1 缩进
与其它块状结构一致，switch块中的内容缩进为2个空格。

每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。

4.8.4.2 Fall-through：注释
在一个switch块内，每个语句组要么通过 break,continue,return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用 // fall through)。这个特殊的注释并不需要在最后一个语句组(一般是 default)中出现。示例：

switch (input) {  case 1:  case 2:    prepareOneOrTwo();    // fall through  case 3:    handleOneTwoOrThree();    break;  default:    handleLargeNumber(input);}
4.8.4.3 default的情况要写出来
每个switch语句都包含一个 default语句组，即使它什么代码也不包含。

4.8.5 注解(Annotations)
注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：

@Override@Nullablepublic String getNameIfPresent() { ... }
例外：单个的注解可以和签名的第一行出现在同一行。例如：

@Override public int hashCode() { ... }
应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：

@Partial @Mock DataLoader loader;
参数和局部变量注解没有特定规则。

4.8.6 注释
4.8.6.1 块注释风格
块注释与其周围的代码在同一缩进级别。它们可以是 /* ... */风格，也可以是 // ...风格。对于多行的 /* ... */注释，后续行必须从 *开始， 并且与前一行的 *对齐。以下示例注释都是OK的。

/* * This is          // And so           /* Or you can * okay.            // is this.          * even do this. */ */
注释不要封闭在由星号或其它字符绘制的框架里。

Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 /* ... */。

4.8.7 Modifiers
类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。

public protected private abstract static final transient volatile synchronized native strictfp
命名约定
5.1 对所有标识符都通用的规则
标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式 \w+。

在Google其它编程语言风格中使用的特殊前缀或后缀，如 name_, mName, s_name和 kName，在Java编程风格中都不再使用。

5.2 标识符类型的规则
5.2.1 包名
包名全部小写，连续的单词只是简单地连接起来，不使用下划线。

5.2.2 类名
类名都以 UpperCamelCase风格编写。

类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。

测试类的命名以它要测试的类的名称开始，以 Test结束。例如， HashTest或 HashIntegrationTest。

5.2.3 方法名
方法名都以 lowerCamelCase风格编写。

方法名通常是动词或动词短语。

下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test<MethodUnderTest>_<state>，例如 testPop_emptyStack。并不存在唯一正确的方式来命名测试方法。

5.2.4 常量名
常量名命名模式为 CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？

每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。只是永远不 打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。

// Constantsstatic final int NUMBER = 5;static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann");static final Joiner COMMA_JOINER = Joiner.on(',');  // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = {};enum SomeEnum { ENUM_CONSTANT }
// Not constantsstatic String nonFinal = "non-final";final String nonStatic = "non-static";static final Set<String> mutableCollection = new HashSet<String>();static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = {"these", "can", "change"};
这些名字通常是名词或名词短语。

5.2.5 非常量字段名
非常量字段名以 lowerCamelCase风格编写。

这些名字通常是名词或名词短语。

5.2.6 参数名
参数名以 lowerCamelCase风格编写。

参数应该避免用单个字符命名。

5.2.7 局部变量名
局部变量名以 lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。

虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。

即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。

5.2.8 类型变量名
类型变量可用以下两种风格之一进行命名：

单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。

以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。

5.3 驼峰式命名法(CamelCase)
驼峰式命名法分大驼峰式命名法( UpperCamelCase)和小驼峰式命名法( lowerCamelCase)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。

名字从 散文形式(prose form)开始:

把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。

把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。

- 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。

现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：

- 每个单词的第一个字母都大写，来得到大驼峰式命名。

除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。

最后将所有的单词连接起来得到一个标识符。

示例：

Prose form                Correct               Incorrect------------------------------------------------------------------"XML HTTP request"        XmlHttpRequest        XMLHTTPRequest"new customer ID"         newCustomerId         newCustomerID"inner stopwatch"         innerStopwatch        innerStopWatch"supports IPv6 on iOS?"   supportsIpv6OnIos     supportsIPv6OnIOS"YouTube importer"        YouTubeImporter                          YoutubeImporter*
加星号处表示可以，但不推荐。

Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名 checkNonempty和 checkNonEmpty也都是正确的。

编程实践
6.1 @Override：能用则用
只要是合法的，就把 @Override注解给用上。

6.2 捕获的异常：不能忽视
除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 AssertionError重新抛出。)

如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。

try {  int i = Integer.parseInt(response);  return handleNumericResponse(i);} catch (NumberFormatException ok) {  // it's not numeric; that's fine, just continue}return handleTextResponse(response);
例外：在测试中，如果一个捕获的异常被命名为 expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。

try {  emptyStack.pop();  fail();} catch (NoSuchElementException expected) {}
6.3 静态成员：使用类进行调用
使用类名调用静态的类成员，而不是具体某个对象或表达式。

Foo aFoo = ...;Foo.aStaticMethod(); // goodaFoo.aStaticMethod(); // badsomethingThatYieldsAFoo().aStaticMethod(); // very bad
6.4 Finalizers: 禁用
极少会去重写 Object.finalize。

Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。

Javadoc
7.1 格式
7.1.1 一般形式
Javadoc块的基本格式如下所示：

/** * Multiple lines of Javadoc text are written here, * wrapped normally... */public int method(String p1) { ... }
或者是以下单行形式：

/** An especially short bit of Javadoc. */
基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。

7.1.2 段落
空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。除了第一个段落，每个段落第一个单词前都有标签 <p>，并且它和第一个单词间没有空格。

7.1.3 Javadoc标记
标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。当描述无法在一行中容纳，连续行需要至少再缩进4个空格。

7.2 摘要片段
每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。

这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以 A{@codeFoo}isa...或 Thismethod returns...开头, 它也不会是一个完整的祈使句，如 Savethe record...。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。

Tip：一个常见的错误是把简单的Javadoc写成 /** @return the customer ID */，这是不正确的。它应该写成 /** Returns the customer ID. */。

7.3 哪里需要使用Javadoc
至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：

7.3.1 例外：不言自明的方法
对于简单明显的方法如 getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。

单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。

Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名 getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语 canonical name指的是什么。

7.3.2 例外：重写
如果一个方法重写了超类中的方法，那么Javadoc并非必需的。

7.3.3 可选的Javadoc
对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。



JVM 发生 OOM 的 8 种原因、及解决办法
唐尤华  Java基基  前天
点击上方“Java基基”，选择“设为星标”

做积极的人，而不是积极废人！

源码精品专栏


中文详细注释的开源项目

RPC 框架 Dubbo 源码解析

网络应用框架 Netty 源码解析

消息中间件 RocketMQ 源码解析

数据库中间件 Sharding-JDBC 和 MyCAT 源码解析

作业调度中间件 Elastic-Job 源码解析

分布式事务中间件 TCC-Transaction 源码解析

Eureka 和 Hystrix 源码解析

Java 并发源码

来源：http://t.cn/RAxJtbB

1. Java 堆空间

2. GC 开销超过限制

3. 请求的数组大小超过虚拟机限制

发生频率：2颗星

4. Perm gen 空间

5. Metaspace

6. 无法新建本机线程

7. 杀死进程或子进程

8. 发生 stack_trace_with_native_method

1. Java 堆空间
发生频率：5颗星
造成原因
无法在 Java 堆中分配对象

吞吐量增加

应用程序无意中保存了对象引用，对象无法被 GC 回收

应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长

解决方案
使用 -Xmx 增加堆大小

修复应用程序中的内存泄漏

2. GC 开销超过限制
发生频率：5颗星
造成原因
Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。

解决方案
使用 -Xmx 增加堆大小

使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制

修复应用程序中的内存泄漏

3. 请求的数组大小超过虚拟机限制
发生频率：2颗星
造成原因
应用程序试图分配一个超过堆大小的数组

解决方案
使用 -Xmx 增加堆大小

修复应用程序中分配巨大数组的 bug

4. Perm gen 空间
发生频率：3颗星
造成原因
Perm gen 空间包含：

类的名字、字段、方法

与类相关的对象数组和类型数组

JIT 编译器优化

当 Perm gen 空间用尽时，将抛出异常。

解决方案
使用 -XX: MaxPermSize 增加 Permgen 大小

不重启应用部署应用程序可能会导致此问题。重启 JVM 解决

5. Metaspace
发生频率：3颗星
造成原因
从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常

解决方案
通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小

取消 -XX: maxmetsspacedize

减小 Java 堆大小,为 MetaSpace 提供更多的可用空间

为服务器分配更多的内存

可能是应用程序 bug，修复 bug

6. 无法新建本机线程
发生频率：5颗星
造成原因
内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足

解决方案
为机器分配更多的内存

减少 Java 堆空间

修复应用程序中的线程泄漏。

增加操作系统级别的限制

- ulimit -a

用户进程数增大 (-u) 1800

使用 -Xss 减小线程堆栈大小

7. 杀死进程或子进程
发生频率：1颗星
造成原因
内核任务：内存不足结束器，在可用内存极低的情况下会杀死进程

解决方案
将进程迁移到不同的机器上

给机器增加更多内存

与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的。

8. 发生 stack_trace_with_native_method
发生频率：1颗星
造成原因
本机方法（native method）分配失败

打印的堆栈跟踪信息，最顶层的帧是本机方法

解决方案
使用操作系统本地工具进行诊断




 public void closeResourceInFinally() {

     FileInputStream inputStream = null;

     try {

         File file = new File("./tmp.txt");

         inputStream = new FileInputStream(file);

         // use the inputStream to read a file

     } catch (FileNotFoundException e) {

         log.error(e);

     } finally {

         if (inputStream != null) {

             try {

                 inputStream.close();

             } catch (IOException e) {

                 log.error(e);

             }

         }

     }

 }

如果你的资源实现了AutoCloseable接口，就可以使用它，这正是大多数Java标准资源所做的。当你在try子句中打开资源时，它将在try被执行后自动关闭，或者处理一个异常。

 public void automaticallyCloseResource() {

     File file = new File("./tmp.txt");

     try (FileInputStream inputStream = new FileInputStream(file);) {

         // use the inputStream to read a file

     } catch (FileNotFoundException e) {

         log.error(e);

     } catch (IOException e) {

         log.error(e);

     }

 }

 public void doThis() throws NumberFormatException {

     ...

 }
3. 记录你所指定的异常
当你在方法中指定一个异常时，你应该在Javadoc中记录下它。这与前面提到的方法有着相同的目标：为调用者提供尽可能多的信息，这样他们就可以避免异常或者更容易地处理异常。

因此，请确保在Javadoc中添加一个@throws 声明，并描述可能导致的异常情况。

 /**

  \* This method does something extremely useful ...

  *

  \* @param input

  \* @throws MyBusinessException if ... happens

  */

 public void doSomething(String input) throws MyBusinessException {

     ...

 }
4. 使用描述性消息抛出异常
这一最佳实践的理念与前两个相似。但这一次，你不用给调用方法的人提供信息。异常消息会被所有人读取，同时必须了解在日志文件或监视工具中报告异常时发生了什么。

因此，应该尽可能准确地描述问题，并提供相关的信息来了解异常事件。

别误会，你不需要写一段文字，而是应该用1-2个简短的句子解释异常的原因。这可以帮助开发团队理解问题的严重性，同时也使你能够更容易地分析任何服务事件。

如果抛出一个特定的异常，它的类名很可能已经描述了这种类型的错误。所以，你不需要提供很多额外的信息。一个很好的例子就是，当你以错误的格式使用字符串时，如NumberFormatException，它就会被类 java.lang.Long的构造函数抛出。

 try {

     new Long("xyz");

 } catch (NumberFormatException e) {

     log.error(e);

 }
NumberFormatException已经告诉你问题的类型，所以只需要提供导致问题的输入字符串。如果异常类的名称不具有表达性，那么就需要提供必要的解释信息。

17:17:26,386 ERROR TestExceptionHandling:52 - java.lang.NumberFormatException: For input string: "xyz"

5. 最先捕获特定的异常
大多数IDE都可以帮助你做到这点，当你试图捕获不确定的异常时，它会报告一个不可到达的代码块。

问题是只有第一个匹配到异常的catch语句才会被执行，所以，如果你最先发现IllegalArgumentException，你将永远不会到达catch里处理更具体的NumberFormatException，因为它是IllegalArgumentException的一个子类。

所以要首先捕获特定的异常类，并在末尾添加一些处理不是很具体异常的catch语句。

你可以在下面的代码片段中看到这样一个try-catch语句的示例。第一个catch处理所有NumberFormatExceptions异常，第二个catch 处理NumberFormatException异常以外的illegalargumentexception异常。

 public void catchMostSpecificExceptionFirst() {

     try {

         doSomething("A message");

     } catch (NumberFormatException e) {

         log.error(e);

     } catch (IllegalArgumentException e) {

         log.error(e)

     }

 }
6. 不要在catch中使用Throwable
Throwable是exceptions 和 errors的父类。当然，你可以在catch子句中使用它，但其实你不应该这样做。

如果你在catch子句中使用Throwable，它将不仅捕获所有的异常，还会捕获所有错误。JVM会抛出错误，这是应用程序不打算处理的严重问题。典型的例子是OutOfMemoryError或StackOverflowError。这两种情况都是由应用程序控制之外的情况引起的，无法处理。

所以，最好不要在catch中使用Throwable，除非你完全确定自己处于一个特殊的情况下，并且你需要处理一个错误。

 public void doNotCatchThrowable() {

     try {

         // do something

     } catch (Throwable t) {

         // don't do this!

     }

 }
7. 不要忽略Exceptions

 public void logAnException() {

     try {

         // do something

     } catch (NumberFormatException e) {

         log.error("This should never happen: " + e);

     }

 }
8. 不要记录和抛出一个异常
这可能是最常被忽略的。你可以在许多代码片段或者库文件里发现，有异常会被捕获、记录和重新抛出。

 try {

     new Long("xyz");

 } catch (NumberFormatException e) {

     log.error(e);

     throw e;

 }
当它发生时记录一个异常，然后重新抛出它，以便调用者能够适当地处理它，这可能会很直观。但是它会为同一个异常写多个错误消息。

 17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: "xyz"

 Exception in thread "main" java.lang.NumberFormatException: For input string: "xyz"

 at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)

 at java.lang.Long.parseLong(Long.java:589)

 at java.lang.Long.(Long.java:965)

 at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)

 at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58)
不添加任何额外的信息。正如在上述第4个中所解释的那样，异常消息应该描述异常事件。堆栈会告诉你在哪个类、方法和行中异常被抛出。

如果你需要添加额外的信息，应该捕获异常并将其包装在一个自定义的信息中。但要确保遵循下面的第9条。

 public void wrapException(String input) throws MyBusinessException {

     try {

         // do something

     } catch (NumberFormatException e) {

         throw new MyBusinessException("A message that describes the error.", e);

     }

 }
因此，只需要捕获一个你想要处理的异常，在方法中指定它，并让调用者处理它。

9. 包装异常
有时最好捕获一个标准异常并将其封装到一个定制的异常中。此类异常的典型例子是应用程序或框架特定的业务异常。这允许你添加额外的信息，并且也可以为异常类实现一个特殊的处理。

当你这样做时，确保引用原始的异常处理。Exception类提供了一些特定的构造函数方法，这些方法可以接受Throwable作为参数。否则，你将丢失原始异常的堆栈跟踪和消息，这将使你很难分析导致异常的事件。

 public void wrapException(String input) throws MyBusinessException {

     try {

         // do something

     } catch (NumberFormatException e) {

         throw new MyBusinessException("A message that describes the error.", e);

     }

 }
异常通常是一个错误处理机制和一个通信媒介。

===============================================

Java 新建对象过程分析
原创： ImportNew  ImportNew  今天
（给ImportNew加星标，提高Java技能）



编译：ImportNew/唐尤华

shipilev.net/jvm/anatomy-quarks/6-new-object-stages/



1. 写在前面



“[JVM 解剖公园][1]”是一个持续更新的系列迷你博客，阅读每篇文章一般需要5到10分钟。限于篇幅，仅对某个主题按照问题、测试、基准程序、观察结果深入讲解。因此，这里的数据和讨论可以当轶事看，不做写作风格、句法和语义错误、重复或一致性检查。如果选择采信文中内容，风险自负。



Aleksey Shipilёv，JVM 性能极客

推特 [@shipilev][2]

问题、评论、建议发送到 [aleksey@shipilev.net][3]



[1]:https://shipilev.net/jvm-anatomy-park

[2]:http://twitter.com/shipilev

[3]:aleksey@shipilev.net



2. 问题



听说分配与初始化不同。Java 有构造函数，它究竟会执行分配还是做初始化呢？



3. 理论



如果打开 [GC Handbook][4]，它会告诉你创建一个新对象通常包括三个阶段：



> 译注：GC Handbook 中文版《垃圾回收算法手册》



"分配"：从进程空间中分配实例数据。

"系统初始化"：按照 Java 语言规范进行初始化。在 C 语言中，分配新对象不需要初始化；在 Java 中，所有新创建的对象都要进行系统初始化赋默认值，设置完整的对象头等等。

"二次初始化（用户初始化）"：执行与该对象类型关联的所有初始化语句和构造函数。



在前面 [TLAB 分配][5]中我们对此进行过讨论，现在介绍详细的初始化过程。假如你熟悉 Java 字节码，就会知道 `new` 语句对应了几条字节码指令。例如：



```java
public Object t() {
  return new Object();
}
```


会编译为：



```java
  public java.lang.Object t();
    descriptor: ()Ljava/lang/Object;
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: new           #4                  // java/lang/Object 类
         3: dup
         4: invokespecial #1                  // java/lang/Object."<init>":()V 方法
         7: areturn
```


[4]:http://gchandbook.org/

[5]:https://shipilev.net/jvm/anatomy-quarks/4-tlab-allocation/



看起来 `new` 会执行分配和系统初始化，同时调用构造函数（`<init>`）执行用户初始化。然而，智能的 Hotspot 虚拟机会不会优化？比如在构造函数执行完成以前查看对象使用情况，优化可以合并的任务。接下来，让我们做个实验。



4. 实验



要解除这个疑问，可以编写下面这样的测试。初始化两个不同的类，每个类只包含一个 `int` 属性：



```java
import org.openjdk.jmh.annotations.*;
import java.util.concurrent.TimeUnit;

@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Fork(value = 3)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Benchmark)
public class UserInit {

    @Benchmark
    public Object init() {
        return new Init(42);
    }

    @Benchmark
    public Object initLeaky() {
        return new InitLeaky(42);
    }

    static class Init {
        private int x;
        public Init(int x) {
            this.x = x;
        }
    }

    static class InitLeaky {
        private int x;
        public InitLeaky(int x) {
            doSomething();
            this.x = x;
        }

        @CompilerControl(CompilerControl.Mode.DONT_INLINE)
        void doSomething() {
            // 此处留白
        }
    }
}
```


设计测试时，为防止编译器对 `doSomething()` 空方法进行内联优化加上了限制，迫使优化程序认为接下来可能有代码访问 `x`。换句话说，这样就无法判断 `doSomething()` 是否真的泄露了对象，从而可以有效地把对象暴露给某些外部代码。



建议启用 `-XX:+UseParallelGC -XX:-TieredCompilation -XX:-UseBiasedLocking` 参数运行测试，这样生成的代码更容易理解。JMH `-prof perfasm` 参数可以完美地转储测试生成的代码。



下面是 `Init` 测试结果：



```asm
0x00007efdc466d4cc: mov    0x60(%r15),%rax          ; 下面是 TLAB 分配
0x00007efdc466d4d0: mov    %rax,%r10
0x00007efdc466d4d3: add    $0x10,%r10
0x00007efdc466d4d7: cmp    0x70(%r15),%r10
0x00007efdc466d4db: jae    0x00007efdc466d50a
0x00007efdc466d4dd: mov    %r10,0x60(%r15)
0x00007efdc466d4e1: prefetchnta 0xc0(%r10)
                                                  ; ------- /分配 ---------
                                                  ; ------- 系统初始化 ---------
0x00007efdc466d4e9: movq   $0x1,(%rax)              ; header 设置 mark word
0x00007efdc466d4f0: movl   $0xf8021bc4,0x8(%rax)    ; header 设置 class word
                                                  ; ...... 系统/用户初始化 .....
0x00007efdc466d4f7: movl   $0x2a,0xc(%rax)          ; x = 42.
                                                  ; -------- /用户初始化 ---------
```


上面生成的代码中可以看到 TLAB 分配、对象元数据初始化，然后对字段执行系统+用户初始化。`InitLeaky` 的测试结果有很大区别：



```asm
                                                  ; ------- 分配 ----------
0x00007fc69571bf4c: mov    0x60(%r15),%rax
0x00007fc69571bf50: mov    %rax,%r10
0x00007fc69571bf53: add    $0x10,%r10
0x00007fc69571bf57: cmp    0x70(%r15),%r10
0x00007fc69571bf5b: jae    0x00007fc69571bf9e
0x00007fc69571bf5d: mov    %r10,0x60(%r15)
0x00007fc69571bf61: prefetchnta 0xc0(%r10)
                                                  ; ------- /分配 ---------
                                                  ; ------- 系统初始化 ---------
0x00007fc69571bf69: movq   $0x1,(%rax)              ; header 设置 mark word
0x00007fc69571bf70: movl   $0xf8021bc4,0x8(%rax)    ; header 设置 class word
0x00007fc69571bf77: mov    %r12d,0xc(%rax)          ; x = 0 (%r12 的值恰好是 0)
                                                  ; ------- /系统初始化 --------
                                                  ; -------- 用户初始化 ----------
0x00007fc69571bf7b: mov    %rax,%rbp
0x00007fc69571bf7e: mov    %rbp,%rsi
0x00007fc69571bf81: xchg   %ax,%ax
0x00007fc69571bf83: callq  0x00007fc68e269be0       ; call doSomething()
0x00007fc69571bf88: movl   $0x2a,0xc(%rbp)          ; x = 42
                                                  ; ------ /用户初始化 ------
```


由于优化程序无法确定是否需要 `x` 值，因此这里必须假定出现最坏的情况，先执行系统初始化，然后再完成用户初始化。



5. 观察



虽然教科书的定义很完美，而且生成的字节码也提供了佐证，但只要不出现奇怪的结果，优化程序还是会做一些不为人知的优化。从编译器的角度看，这只是一种简单优化。但从概念上说，这个结果已经超出了“阶段”的范畴。



推荐阅读

（点击标题可跳转阅读）

Flink 和 Pulsar 的批流融合
StreamNative  Spark学习技巧  昨天


作者：Sijie Guo

编辑：Irene

转自：StreamNative

Apache Flink 和 Apache Pulsar 的开源数据技术框架可以以不同的方式融合，来提供大规模弹性数据处理。4 月 2 日，我司 CEO 郭斯杰受邀在 Flink Forward San Francisco 2019 大会上发表演讲，介绍了 Flink 和 Pulsar 在批流应用程序的融合情况。这篇文章会简要介绍 Apache Pulsar 及其与其他消息系统的不同之处，并讲解如何融合 Pulsar 和 Flink 协同工作，为大规模弹性数据处理提供无缝的开发人员体验。



Apache Pulsar 简介



Apache Pulsar 是一个开源的分布式发布-订阅消息系统， 由 Apache 软件基金会管理，并于 2018 年 9 月成为 Apache 顶级开源项目。 Pulsar 是一种多租户、高性能解决方案，用于服务器到服务器消息传递，包括多个功能，例如，在一个 Pulsar 实例中对多个集群提供原生支持、集群间消息跨地域的无缝复制、发布和端到端的低延迟、超过一百万个主题的无缝扩展以及由 Apache BookKeeper 提供的持久消息存储保证消息传递。现在我们来讨论 Pulsar 和其他发布-订阅消息传递框架之间的主要区别：



区别一



虽然 Pulsar 提供了灵活的发布-订阅消息传递系统，但它也由持久的日志存储支持——因此需在一个框架下集成消息传递和存储功能。由于 Pulsar 采用了分层架构，它可以即时故障恢复、支持独立可扩展性和无需均衡的集群扩展。

Pulsar 的架构与其他发布-订阅系统类似，框架由主题组成，而主题是主要数据实体。如下图所示，生产者向主题发送数据，消费者从主题接收数据。




区别二



第二个区别是，Pulsar 的框架构建从一开始就考虑到了多租户。这意味着每个 Pulsar 主题都有一个分层的管理结构，使得资源分配、资源管理和团队协作变得高效而容易。由于 Pulsar 提供属性（租户）级、命名空间级和主题级的资源隔离，Pulsar 的多租户特性不仅能使数据平台管理人员轻松扩展新的团队，还能跨集群共享数据，简化团队协作。




区别三



Pulsar 灵活的消息传递框架统一了流式和队列数据消费模型，并提供了更大的灵活性。如下图所示，Pulsar 保存主题中的数据，而多个团队可以根据其工作负载和数据消费模式独立地消费数据。




Pulsar 数据视图：分片数据流



Apache Flink 是一个流式优先计算框架，它将批处理视为流处理的特殊情况。在对数据流的看法上，Flink 区分了有界和无界数据流之间的批处理和流处理，并假设对于批处理工作负载数据流是有限的，具有开始和结束。



在数据层上，Apache Pulsar 与 Apache Flink 的观点相似。该框架也使用流作为所有数据的统一视图，分层架构允许传统发布-订阅消息传递，用于流式工作负载和连续数据处理；并支持分片流（Segmented Streams）和有界数据流的使用，用于批处理和静态工作负载。




如下图所示，为了并行处理数据，生产者向主题发送数据后，Pulsar 根据数据流量对主题进行分区，再在每个分区中进行分片，并使用 Apache BookKeeper 进行分片存储。这一模式允许在同一个框架中集成传统的发布-订阅消息系统和分布式并行计算。




Flink + Pulsar 的融合



Apache Flink 和 Apache Pulsar 已经以多种方式融合。在以下内容中，我会介绍两个框架间未来一些可行的融合方式，并分享一些融合使用两个框架的示例。



未来融合方式：



Pulsar 能以不同的方式与 Apache Flink 融合，一些可行的融合包括，使用流式连接器（Streaming Connectors）支持流式工作负载，或使用批式源连接器（Batch Source Connectors）支持批式工作负载。Pulsar 还提供了对 Schema 的原生支持，可以与 Flink 集成并提供对数据的结构化访问，例如，使用 Flink SQL 在 Pulsar 中查询数据。另外，还能将 Pulsar 作为 Flink 的状态后端。由于 Pulsar 具有分层架构（Apache Bookkeeper 支持下的 Streams 和 Segmented Streams），因此可以将 Pulsar 作为存储层并存储 Flink 状态。



从架构的角度来看，我们可以想象两个框架之间的融合，使用 Apache Pulsar 作为统一的数据层视图，使用 Apache Flink 作为统一的计算、数据处理框架和 API。



现有融合方式



两个框架之间的融合正在进行中，开发人员已经可以通过多种方式融合使用 Pulsar 和 Flink。例如，在 Flink DataStream 应用程序中，Pulsar 可以作为流数据源和流接收器。开发人员能使 Flink 作业从 Pulsar 中获取数据，再进行计算并处理实时数据，最后将数据作为流接收器发送回 Pulsar 主题。示例如下：

PulsarSourceBuilder<String>builder = PulsarSourceBuilder.builder(new SimpleStringSchema())

   .serviceUrl(serviceUrl)

   .topic(inputTopic)

   .subscriptionName(subscription);

SourceFunction<String> src = builder.build();

DataStream<String> input = env.addSource(src);



DataStream<WordWithCount> wc = input

   .flatMap((FlatMapFunction<String, WordWithCount>) (line, collector) -> {

       for (String word : line.split("\\s")) {

           collector.collect(new WordWithCount(word, 1));

       }

   })

   .returns(WordWithCount.class)

   .keyBy("word")

   .timeWindow(Time.seconds(5))

   .reduce((ReduceFunction<WordWithCount>) (c1, c2) ->

       new WordWithCount(c1.word, c1.count + c2.count));



if (null != outputTopic) {

   wc.addSink(new FlinkPulsarProducer<>(

       serviceUrl,

       outputTopic,

       new AuthenticationDisabled(),

       wordWithCount -> wordWithCount.toString().getBytes(UTF_8),

       wordWithCount -> wordWithCount.word

   )).setParallelism(parallelism);

} else {

   // print the results with a single thread, rather than in parallel

   wc.print().setParallelism(1);

}



另一个开发人员可利用的框架间的融合，已经包括将 Pulsar 用作 Flink 应用程序的流式源和流式表接收器，代码示例如下：

PulsarSourceBuilder<String> builder = PulsarSourceBuilder.builder(new SimpleStringSchema())

       .serviceUrl(serviceUrl)

       .topic(inputTopic)

       .subscriptionName(subscription);

SourceFunction<String> src = builder.build();

DataStream<String> input = env.addSource(src);





DataStream<WordWithCount> wc = input

       .flatMap((FlatMapFunction<String, WordWithCount>) (line, collector) -> {

           for (String word : line.split("\\s")) {

               collector.collect(

                   new WordWithCount(word, 1)

               );

           }

       })

       .returns(WordWithCount.class)

       .keyBy(ROUTING_KEY)

       .timeWindow(Time.seconds(5))

       .reduce((ReduceFunction<WordWithCount>) (c1, c2) ->

               new WordWithCount(c1.word, c1.count + c2.count));



tableEnvironment.registerDataStream("wc",wc);

Table table = tableEnvironment.sqlQuery("select word, `count` from wc");

table.printSchema();

TableSink sink = null;

if (null != outputTopic) {

   sink = new PulsarJsonTableSink(serviceUrl, outputTopic, new AuthenticationDisabled(), ROUTING_KEY);

} else {

   // print the results with a csv file

   sink = new CsvTableSink("./examples/file",  "|");

}

table.writeToSink(sink);



最后，Flink 融合 Pulsar 作为批处理接收器，负责完成批处理工作负载。Flink 在静态数据集完成计算之后，批处理接收器将结果发送至 Pulsar。示例如下：

// create PulsarOutputFormat instance

final OutputFormat pulsarOutputFormat =

       new PulsarOutputFormat(serviceUrl, topic, new AuthenticationDisabled(), wordWithCount -> wordWithCount.toString().getBytes());



// create DataSet

DataSet<String> textDS = env.fromElements(EINSTEIN_QUOTE);



// convert sentences to words

textDS.flatMap(new FlatMapFunction<String, WordWithCount>() {

   @Override

   public void flatMap(String value, Collector<WordWithCount> out) throws Exception {

       String[] words = value.toLowerCase().split(" ");

       for(String word: words) {

           out.collect(new WordWithCount(word.replace(".", ""), 1));

       }

   }

})



// filter words which length is bigger than 4

.filter(wordWithCount -> wordWithCount.word.length() > 4)



// group the words

.groupBy(new KeySelector<WordWithCount, String>() {

   @Override

   public String getKey(WordWithCount wordWithCount) throws Exception {

       return wordWithCount.word;

   }

})



// sum the word counts

.reduce(new ReduceFunction<WordWithCount>() {

   @Override

   public WordWithCount reduce(WordWithCount wordWithCount1, WordWithCount wordWithCount2) throws Exception {

       return  new WordWithCount(wordWithCount1.word, wordWithCount1.count + wordWithCount2.count);

   }

})



// write batch data to Pulsar

.output(pulsarOutputFormat);



总结



Pulsar 和 Flink 对应用程序在数据和计算级别如何处理数据的视图基本一致，将“批”作为“流”的特殊情况进行“流式优先”处理。通过 Pulsar 的 Segmented Streams 方法和 Flink 在一个框架下统一批处理和流处理工作负载的几个步骤，可以应用多种方法融合两种技术，提供大规模的弹性数据处理。欢迎订阅 Apache Flink 和 Apache Pulsar 邮件，及时了解领域最新发展，或在社区分享您的想法和建议。



更多 Pulsar 干货和动态分享，请关注微信公众号StreamNative，我们将在后续文章中推送更多优质内容。