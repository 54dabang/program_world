第１章　Actor模型和企业级软件概述 1



为什么企业级软件难以开发1

响应式应用程序简介4

响应性 5

韧性 6

灵活性 6

消息驱动 7

企业级应用程序8

Actor模型 9

Actor模型的起源 10

了解 Actor模型 11

Actor模型的明晰性 20

下章提要21



第２章　使用Scala语言和Akka框架实现Actor模型 22



怎样获取Scala语言和Akka框架 23

使用 Typesafe Activator编辑器 23

使用 sbt 23

使用 Maven 24

使用 Gradle 25

使用Scala语言编写程序 26

Scala概要教程 27

使用Akka框架编写程序39

Actor系统 40

实现 Actor对象 46

监督 52

远程处理 55

集群功能 68

测试 Actor对象 94

CompletableApp类 98

小结100



第３章　性能情结 101

晶体管101

时钟频率103

核心和高速缓存104

可伸缩性106

多线程技术的难点109

Actor模型的作用 114

处理伪共享 116

设计模式 117



第４章　通过Actor对象传递消息 119

消息通道120

消息121

管道和过滤器126

消息路由器131

消息译码器134

消息端点135

小结137



第５章　消息通道 138

点对点通道140

发布―订阅通道143

本地事件流 143

分布式发布―订阅通道 149

数据类型通道157

非法消息通道159

死信通道161

确保送达机制164

通道适配器172

消息桥174

消息总线180

小结189



第６章　消息结构 190



命令消息191

文档消息192

管理处理流程和处理过程 194

事件消息195

请求―回复模式197

返回地址199

相关标识符203

消息序列204

消息有效期206

格式标识符209

小结213



第７章　消息路由 214

基于内容的路由器215

消息过滤器219

动态路由器223

接收者列表232

分离器241

聚合器245

重新定序器252

组合消息处理器259

分散―聚集路由器260

传送名单274

处理过程管理器282

消息经纪人路由器298

小结301



第８章　消息转换 302

封装器303

内容丰富器305

不可变的 DoctorVisitCompleted消息309

是否应在本地系统中创建 AccountingEnricherDispatcher对象 309

内容过滤器310

存放证313

标准化器321

规范化消息模型322

Actor系统需要标准 323

小结324



第９章　消息端点 325



消息传输网关326

消息传输映射332

事务型客户端/ Actor对象 339

事务型客户端 341

事务型 Actor对象 342

轮询消费者350

资源轮询 354

由事件驱动的消费者358

具有竞争性的消费者359

消息调度器361

选择性消费者364

持久订阅者367

幂等接收者370

避免处理消息副本 370

使消息具有相同的效果 371

使状态切换操作不受收到消息副本的影响 372

服务激活剂378

小结379



第10章　系统管理和基础结构 380



控制总线380

改道器382

窃听器384

消息元数据/历史记录 385

消息日志/存储器 389

智能代理392

测试消息397

通道净化器399

小结401



附录A　NET平台上的Akka工具集：Dotsero 402



Dotsero的Actor系统 402

通过C#和NET使用Actor对象 405

Dotsero实现 410