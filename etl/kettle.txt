第一部分：开始
第1章　ETL入门 2
第2章　Kettle基本概念 18
第3章　安装和配置 39
第4章　ETL示例解决方案——Sakila 54
第二部分：ETL
第5章　ETL子系统 82
第6章　数据抽取 92
第7章　清洗和校验 119
第8章　处理维度表 147
第9章　加载事实表 172
第10章　处理OLAP数据 188
第三部分：管理和部署
第11章　ETL开发生命期 206
第12章　调度和监控 224
第13章　版本和移植 238
第14章　血统和审计 249
第四部分：性能和扩展性
第15章　性能调优 264
第16章　并行、集群和分区 283
第17章　云计算中的动态集群 303
第18章　实时数据整合 315
第五部分：高级主题
第19章　Data Vault管理 326
第20章　处理复杂数据格式 350
第21章　Web Services 363
第22章　Kettle集成 404
第23章　扩展Kettle 424


Kettle简介：Kettle是一款国外开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，数据抽取高效稳定。Kettle 中文名称叫水壶，该项目的主程序员MATT 希望把各种数据放到一个壶里，然后以一种指定的格式流出。Kettle这个ETL工具集，它允许你管理来自不同数据库的数据，通过提供一个图形化的用户环境来描述你想做什么，而不是你想怎么做。Kettle中有两种脚本文件，transformation和job，transformation完成针对数据的基础转换，job则完成整个工作流的控制。（引用百度百科）

1、Kettle的下载与安装（在本文中使用的kettle版本为6.1.0.1-196）

2、打开kettle。

　　首先解压下载下来的压缩包如:pdi-ce-6.1.0.1-196.zip

　　然后打开Spoon.bat，如图所示：

　　

　　打开后请耐心等待一会儿时间。

3、建立转换。

　　在文件->新建装换。

　　新建转换后在左边的主对象树中建立DB连接用以连接数据库。如图所示：

　　

　　建立数据库连接的过程与其他数据库管理软件连接数据库类似。

　　注意：在数据库链接的过程中，可能会报某个数据库连接找不到的异常。那是因为你没有对应的数据库链接驱动，请下载对应驱动后，放入kettle的lib文件夹。

4、简单的数据表插入\更新

　　（1）新建表插入

　　在左边的面板中选择“核心对象”，在核心对象里面选择“输入->表输入”,用鼠标拖动到右边面板。如图所示：







　　双击拖过来的表，可以编辑表输入。

　　选择数据库连接和编辑sql语句，在这一步可以点击预览，查看自己是否连接正确。





　　（2）通过插入\更新输出到表。

　　在左边面板中选择核心对象、选择“输出->插入\更新”如图所示：





　　编辑插入更新：

　　首先：表输入连接插入更新。

　　　　选中表输入，按住shift键，拖向插入更新。



　　然后：双击插入更新，编辑它。





　　到这里基本上，这个转换就要做完了，可以点击运行查看效果，看是否有误，这个要先保存了才能运行，可以随意保存到任何一个地方。

5、使用作业控制上面装换执行。

　　使用作业可以定时或周期性的执行转换，新建一个作业。并从左边面板拖入start 和转换。

　　

　　双击start可以编辑，可以设置执行时间等等



　　点开装换，可以设置需要执行的转换任务，比如可以执行上面我们做的转换，XXX.ktr



　　最后点击运行即可。



　　到这里，一个简单的通过作业调度的kettle就算做完了。


【Kettle】kettle增量同步变动数据
2018年11月07日 00:15:56 MaiXiaochai 阅读数：1205
需求：

最近在用kettle同步数据的时候，有增量同步的需求。

之前也遇到过这个需求，查阅了很多文章，也试了很多方法，都没有实现我所需的简洁的方式。

这回在我一次次尝试无果的情况下，突然间的灵光一闪，让我豁然开朗，原来你就在我眼前。

写下这篇文章，让更多的人的时间得到节省。

时间是最稀缺的资源，更多的时间应该花在更有意义的事情上。



软件相关：

使用软件	kettle
软件版本	7.1
实现功能	使用kettle增量同步数据
修改日期	2018年11月6日




具体过程：

有TEST_A （左图）和TEST_B（右图）两张数据表，两张表结构相同（抱歉，图没截取规整，但不影响内容表达）。



ID字段均为唯一主键，TEST_A中自增，NUMBER类型，LASTUPDATEON字段表示该行数据最近插入或者修改的时间，DATE类型非空。

假设TEST_A为源数据表，TEST_B为目标表。

TEST_A中的历史数据变更时相应行的LASTUPDATEON字段值会变为数据更新时的时间。



根据以上信息，总结出如下增量更新步骤：

1）取TEST_B中LASTUPDATEON字段的最大值,这里为了方便起见，假设这个最大值为max_date_a；

2）取TEST_A中LASTUPDATEON字段大于max_date_a的所有数据行 rows；

3）以rows 数据的ID做对比同步到TEST_B表，如果ID值在TEST_B中存在，则更新除ID字段外的所有字段；

     如果ID值在TEST_B中不存在，则插入整行数据（类似 Oracle中的 MERGE INTO）。



kettle操作（这里假设读者已经会基本的kettle操作）：

最终效果图





1）如上图所示，需要两个表输入和一个插入/更新，并将三个步骤间的线连接好。

2）MAX_DATE步骤中，配置好数据库连接，连接到TEST_B，SQL如下（注意结尾没有分号 ';'）

SELECT MAX(LASTUPDATEDON) FROM TEST_B
其他配置默认，点击预览，看到类似下图数据表示这一步成功。然后点 “确定”。



3）在select_a步骤中，同样配置好数据库连接，连接到TEST_A表，SQL如下（同样结尾没有分号 ';'，大于号后边写问号'?'替换上一步的值）

SELECT * FROM TEST_A WHERE LASTUPDATEDON > ?
然后在“从步骤输入数据”中选择上一个步骤的名称，如此可将上一个步骤获取的最大时间作为问号位置的值，数据类型仍然为时间类型。

4）然后勾选“执行每一行”，这是为了select_a步骤在MAX_DATE执行完后才执行，从而获取时间大值。点击“确定”，此时前两 个步骤间的连线上会多出一个感叹号图案，正常。





5）在insert_b中，首先配置好“数据库连接”，连接到“目标表”test_b。

6）在下图中的①区域，点击“获取更新字段”，然后在出现的很多行字段中，只留下ID字段行，删除其余字段行（因为根据文章描述该步骤应该比较ID字段来进行同步数据）。①区域作用是配置比较的字段。

7）在②区域点击“获取和更新字段”，然后找到在①区域中被比较的字段，将其“更新”下的值改为“N”，表示更新时不更新该字段，但会在满足插入条件（前文“增量更新步骤”中已描述清楚本文的插入条件）时插入该字段，其他字段也会被插入。点击“确定”。





8）一切设置好之后，点击①的运行三角形，然后点击②的“启动”，执行增量同步。





9）执行结果，如图三个步骤都有绿色对号，并且“步骤度量”表格中有相应的数值表示数据变动则说明增量更新成功。





增量同步结果验证：

以下三张表分别为 同步前TEST_A、同步前TEST_B和同步后TEST_B ,分别对应于图test_a、test_b和test_b_res。

同步前TEST_A和同步前TEST_B数据作比较，

1）ID为1和2的数据是完全相同的；

2）ID为3的数据的LASTUPDATEDON字段，在test_a中秒数为16，在test_b中秒数为06，两者不同；

3）test_a比test_b多出一行ID为4的数据。



同步前TEST_A和同步后TEST_B比较，

1）ID为1和2的数据是完全相同的；

2）ID为3的数据的LASTUPDATEDON字段，在test_a中秒数为16，在test_b_res中秒数为16，两者相同；

3）test_a和test_b_res都有ID为4的数据完全相同的数据行。



结论：

增量同步后，TEST_A的数据与TEST_B的数据完全相同，增量同步成功。

test_a
test_a​​​​



test​​​_b



test_b_res




The end.