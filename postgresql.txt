第1章PostgreSQL简介2
1.1什么是PostgreSQL2
1.1.1PostgreSQL概述2
1.1.2PostgreSQL的发展历史2
1.1.3　PostgreSQL数据库的优势3
1.1.4　PostgreSQL应用现状和发展趋势4
1.2　PostgreSQL数据库与其他数据库的对比4
1.2.1PostgreSQL与MySQL数据库的对比4
1.2.2　PostgreSQL与Oracle数据库的对比6
1.3　小结6
第2章PostgreSQL安装与配置7
2.1　从发行版本安装7
2.1.1　在Debian或Ubuntu下的安装7
2.1.2在Redhat、CentOS或Fedora下的安装9
2.1.3　在Windows下的安装12
2.1.4　发行版安装总结16
2.2　从源码安装16
2.2.1　编译安装过程介绍16
2.2.2　下载源代码17
2.2.3　编译及安装18
2.2.4　安装后的配置20
2.2.5　创建数据库簇21
2.2.6　安装contrib目录下的工具21
2.2.7　启动和停止数据库21
2.2.8　编译安装时的常见问题及解决方法22
2.3　安装技巧介绍24
2.3.1　在Redhat、CentOS下使用二进制包安装较新版本的方法24
2.3.2　如何使用较大的数据块提高I/O性能25
2.4　PostgreSQL的简单配置25
2.4.1　修改监听的IP和端口25
2.4.2　与数据库log相关的参数25
2.4.3　内存参数的设置26
2.5　小结26
第3章SQL语言入门27
3.1　SQL语句语法简介27
3.1.1　语句的分类27
3.1.2　词法结构27
3.2　DDL语句28
3.2.1　建表语句28
3.2.2　删除表语句30
3.3　DML语句30
3.3.1　插入语句30
3.3.2　更新语句31
3.3.3　删除语句31
3.4　查询语句31
3.4.1　单表查询语句31
3.4.2　过滤条件的查询32
3.4.3　排序32
3.4.4　分组查询33
3.4.5　表join34
3.5　其他SQL语句36
3.5.1　INSERT INTO... SELECT语句36
3.5.2　UNION语句36
3.5.3　TRUNCATE TABLE语句37
3.6　小结37
第二篇基础篇
第4章psql工具的使用介绍40
4.1　psql介绍40
4.2　psql的简单使用40
4.3　psql的常用命令42
4.3.1　\d命令42
4.3.2　指定字符集编译的命令45
4.3.3　\pset命令46
4.3.4　\x命令46
4.3.5　执行存储在外部文件中的SQL命令47
4.3.6　显示信息的命令48
4.3.7　更多的命令49
4.4　psql的使用技巧和注意事项50
4.4.1　历史命令与补全的功能50
4.4.2　自动提交方面的技巧50
4.4.3　如何得到psql中命令实际执行的SQL51
4.5　小结53
第5章数据类型54
5.1　类型介绍54
5.1.1　类型的分类54
5.1.2　类型输入与转换55
5.2　布尔类型56
5.2.1　布尔类型解释56
5.2.2　布尔类型的操作符58
5.3　数值类型59
5.3.1　数值类型解释59
5.3.2　整数类型 59
5.3.3　精确的小数类型59
5.3.4　浮点数类型60
5.3.5　序列类型61
5.3.6　货币类型61
5.3.7　数学函数和操作符62
5.4　字符串类型64
5.4.1　类型解释64
5.4.2　字符串函数和操作符65
5.5　二进制数据类型67
5.5.1　二进制数据类型解释67
5.5.2　二进制数据类型转义表示67
5.5.3　二进制数据类型的函数68
5.6　位串类型69
5.6.1　位串类型解释69
5.6.2　位串类型的使用69
5.6.3　位串的操作符及函数70
5.7　日期/时间类型71
5.7.1　日期/时间类型详解71
5.7.2　日期输入72
5.7.3　时间输入73
5.7.4　特殊值75
5.7.5　函数和操作符列表75
5.7.6　时间函数77
5.7.7　extract和date_part函数80
5.8　枚举类型81
5.8.1　枚举类型的使用81
5.8.2　枚举类型的说明82
5.8.3　枚举类型的函数83
5.9　几何类型84
5.9.1　几何类型概况84
5.9.2　几何类型的输入84
5.9.3　几何类型的操作符89
5.9.4　几何类型的函数97
5.10　网络地址类型98
5.10.1　网络地址类型概况98
5.10.2　inet与cidr类型98
5.10.3　macaddr类型101
5.10.4　网络地址类型的操作符101
5.10.5　网络地址类型的函数102
5.11　复合类型103
5.11.1　复合类型的定义103
5.11.2　复合类型的输入104
5.11.3　访问复合类型105
5.11.4　修改复合类型105
5.11.5　复合类型的输入与输出106
5.12　XML类型107
5.12.1　XML类型的输入107
5.12.2　字符集的问题108
5.12.3　XML类型的函数109
5.13　JSON类型114
5.13.1　JSON类型简介115
5.13.2　JSON类型的输入与输出115
5.13.3　JSON类型的操作符116
5.13.4　JSON类型的函数118
5.13.5　JSON类型的索引121
5.14　Range类型125
5.14.1　Range类型简介125
5.14.2　创建Range类型126
5.14.3　Range类型的输入与输出127
5.14.4　Range类型的操作符130
5.14.5　Range类型的函数130
5.14.6　Range类型的索引和约束131
5.15　数组类型132
5.15.1　数组类型的声明132
5.15.2　如何输入数组值133
5.15.3　访问数组135
5.15.4　修改数组137
5.15.5　数组的操作符138
5.15.6　数组的函数139
5.16　伪类型142
5.17　其他类型143
5.17.1　UUID类型143
5.17.2　pg_lsn 类型143
第6章逻辑结构管理145
6.1　数据库逻辑结构介绍145
6.2　数据库基本操作145
6.2.1　创建数据库145
6.2.2　修改数据库146
6.2.3　删除数据库147
6.2.4　常见问题及解答147
6.3　模式148
6.3.1　模式的定义148
6.3.2　模式的使用148
6.3.3　公共模式150
6.3.4　模式的搜索路径150
6.3.5　模式的权限151
6.3.6　模式的移植性151
6.4　表152
6.4.1　创建表152
6.4.2　表的存储属性154
6.4.3　临时表156
6.4.4　默认值158
6.4.5　约束159
6.4.6　修改表163
6.4.7　表继承及分区表167
6.4.8　分区表168
6.5　触发器173
6.5.1　创建触发器173
6.5.2　语句级触发器与行级触发器175
6.5.3　BEFORE触发器与AFTER触发器177
6.5.4　删除触发器178
6.5.5　触发器的行为179
6.5.6　触发器函数中的特殊变量180
6.6　事件触发器180
6.6.1　创建事件触发器183
6.6.2　修改事件触发器186
6.7　表空间186
6.7.1　表空间的定义186
6.7.2　表空间的使用186
6.8　视图187
6.8.1　视图的定义187
6.8.2　创建视图188
6.8.3　可更新视图189
6.9　索引191
6.9.1　索引简介191
6.9.2　索引的分类192
6.9.3　创建索引192
6.9.4　并发创建索引193
6.9.5　修改索引196
6.9.6　删除索引196
6.10　用户及权限管理197
6.10.1　用户和角色197
6.10.2　创建用户和角色198
6.10.3　权限的管理199
6.10.4　函数和触发器的权限202
6.10.5　权限的总结202
6.10.6　权限的示例202
6.11　事务、并发、锁203
6.11.1　ACID203
6.11.2　DDL事务204
6.11.3　事务的使用204
6.11.4　SAVEPOINT205
6.11.5　事务隔离级别206
6.11.6　两阶段提交207
6.11.7　锁机制209
6.11.8　死锁及防范212
6.11.9　表级锁命令LOCK TABLE213
6.11.10　行级锁命令213
6.11.11　锁的查看214
第7章PostgreSQL的核心架构221
7.1　应用程序的访问接口221
7.1.1　访问接口总体图221
7.1.2　不同编辑语言的PostgreSQL驱动介绍222
7.2　进程及内存结构223
7.2.1　进程和内存架构图223
7.2.2　主进程Postmaster224
7.2.3　SysLogger（系统日志）进程224
7.2.4　BgWriter（后台写）进程225
7.2.5　WalWriter（预写式日志写）进程225
7.2.6　PgArch（归档）进程225
7.2.7　AutoVacuum（自动清理）进程225
7.2.8　PgStat（统计数据收集）进程226
7.2.9　共享内存226
7.2.10　本地内存226
7.3　目录结构227
7.3.1　安装目录的结构227
7.3.2　数据目录的结构227
7.3.3　表空间的目录228
第8章服务管理229
8.1　服务的启停和创建229
8.1.1　启停方法229
8.1.2　pg_ctl230
8.1.3　信号234
8.1.4　postgres及单用户模式234
8.2　服务配置介绍235
8.2.1　配置参数235
8.2.2　连接配置项237
8.2.3　内存配置项240
8.2.4　预写式日志的配置项241
8.2.5　错误报告和日志项243
8.3　访问控制配置文件246
8.3.1　pg_hba.conf 文件247
8.3.2　认证方法介绍248
8.3.3　认证方法实战249
8.4　备份和还原249
8.4.1　逻辑备份249
8.4.2　pg_dump命令250
8.4.3　pg_restore命令254
8.4.4　pg_dump和pg_restore使用举例257
8.4.5　物理备份258
8.4.6　使用LVM快照进行热备份259
8.5　常用的管理命令261
8.5.1　查看系统信息的常用命令261
8.5.2　系统维护常用命令267
第三篇提高篇
第9章PostgreSQL中执行计划270
9.1　执行计划的解释270
9.1.1　EXPLAIN命令270
9.1.2　EXPLAIN输出结果解释271
9.1.3　EXPLAIN使用示例272
9.1.4　全表扫描275
9.1.5　索引扫描275
9.1.6　位图扫描275
9.1.7　条件过滤276
9.1.8　Nestloop Join277
9.1.9　Hash Join277
9.1.10　Merge Join278
9.2　与执行计划相关的配置项279
9.2.1　ENABLE_*参数 279
9.2.2　COST基准值参数279
9.2.3　基因查询优化的参数280
9.2.4　其他执行计划配置项281
9.3　统计信息的收集282
9.3.1　统计信息收集器的配置项282
9.3.2　SQL执行的统计信息输出283
9.3.3　手工收集统计信息283
第10章PostgreSQL中的技术内幕285
10.1　表中的系统字段285
10.1.1　oid286
10.1.2　ctid288
10.1.3　xmin、xmax、cmin、cmax289
10.2　多版本并发控制290
10.2.1　多版本并发控制的原理290
10.2.2　PostgreSQL中的多版本并发控制291
10.2.3　PostgreSQL多版本的优劣分析293
10.3　物理存储结构293
10.3.1　PostgreSQL中的术语293
10.3.2　数据块结构293
10.3.3　Tuple结构294
10.3.4　数据块空闲空间管理296
10.3.5　可见性映射表文件298
10.4　技术解密298
10.4.1　Index-only scans298
10.4.2　Heap-Only Tuples300
第11章PostgreSQL的特色功能302
11.1　规则系统302
11.1.1　SELECT规则302
11.1.2　更新规则303
11.1.3　规则和权限306
11.1.4　规则和命令状态307
11.1.5　规则与触发器的比较308
11.2　模式匹配和正则表达式308
11.2.1　PostgreSQL中的模式匹配和正则表达式介绍308
11.2.2　传统SQL的LIKE 操作符309
11.2.3　SIMILAR TO 正则表达式310
11.2.4　POSIX 正则表达式312
11.2.5　模式匹配函数 substring313
11.3　listen与notify315
11.3.1　listen与notify的简单示例315
11.3.2listen与notify的相关命令316
11.3.3　listen与notify的使用详解317
11.4　索引的特色320
11.4.1　表达式上的索引320
11.4.2　部分索引320
11.4.3　GiST索引323
11.4.4　SP-GiST索引325
11.4.5　GIN索引326
11.5　序列的使用328
11.5.1　序列的创建328
11.5.2　序列的使用及相关的函数329
11.5.3　常见问题及解答331
11.6　咨询锁的使用333
11.6.1　咨询锁的定义333
11.6.2　咨询锁的函数及使用333
11.6.3　常见问题及解答337
11.7　SQL/MED338
11.7.1　SQL/MED的介绍338
11.7.2　外部数据包装器对象339
11.7.3　外部服务器对象340
11.7.4　用户映射对象341
11.7.5　外部表对象341
11.7.6　file_fdw使用实例342
11.7.7　postgres_fdw使用实例345
第12章数据库优化347
12.1　优化准则和方法347
12.1.1　优化准则347
12.1.2　优化方法348
12.2　硬件知识348
12.2.1　CPU及服务器体系结构348
12.2.2　内存349
12.2.3　硬盘350
12.3　文件系统及I/O调优352
12.3.1　文件系统的崩溃恢复352
12.3.2　Ext2文件系统353
12.3.3　Ext3文件系统353
12.3.4　Ext4文件系统354
12.3.5　XFS文件系统355
12.3.6　Barriers I/O355
12.3.7　I/O调优的方法356
12.4　性能监控359
12.4.1　数据库性能视图359
12.4.2　Linux监控工具362
12.5数据库配置优化364
12.5.1内存配置优化364
12.5.2　关于双缓存的优化366
12.5.3　vacuum中的优化367
12.5.4　预写式日志写优化369
第13章Standby数据库的搭建371
13.1　Standby数据库原理371
13.1.1PITR原理371
13.1.2WAL日志归档372
13.1.3流复制372
13.1.4Standby的运行原理373
13.1.5　创建Standby的步骤373
13.2　pg_basebackup命令行工具374
13.2.1　pg_basebackup介绍374
13.2.2　pg_basebackup的命令行参数375
13.2.3　pg_basebackup使用示例376
13.3　异步流复制Hot Standby的示例377
13.3.1　配置环境377
13.3.2　主数据库的配置378
13.3.3　在Standby上生成基础备份378
13.3.4　启动Standby379
13.4　同步流复制的Standby数据库380
13.4.1　同步流复制的架构380
13.4.2　同步复制的配置381
13.4.3　配置实例381
13.5　检查备库及流复制情况383
13.5.1　检查异步流复制的情况383
13.5.2　检查同步流复制的情况384
13.5.3　视图pg_stat_replication详解385
13.5.4　查看备库的状态385
13.6　Hot Standby的限制387
13.6.1　Hot Standby的查询限制387
13.6.2　Hot Standby的查询冲突处理389
13.7　恢复配置详解390
13.7.1　归档恢复配置的配置项390
13.7.2　Recovery Target配置391
13.7.3　Standby Server配置 391
13.8　流复制的注意事项392
13.8.1　wal_keep_segments参数的配置392
13.8.2　vacuum_defer_cleanup_age参数的配置392
第四篇第三方开源软件及架构篇
第14章PgBouncer394
14.1　PgBouncer 介绍394
14.2　PgBouncer中的概念395
14.3　PgBouncer的安装方法395
14.4　PgBouncer的简单使用395
14.5　PgBouncer的配置文件详解399
第15章Slony-I的使用404
15.1Slony-I中的概念404
15.2　Slony-I复制的限制405
15.3　在Windows下使用pgAdminIII安装配置Slony-I406
15.4在Linux下安装配置Slony-I419
第16章Bucardo的使用426
16.1Bucardo中的概念426
16.2Bucardo的安装方法427
16.3Bucardo同步配置429
16.4Bucardo的日常维护434
第17章PL/Proxy的使用436
17.1PL/Proxy中的概念436
17.2PL/Proxy安装及配置438
17.3PL/Proxy的集群配置详解443
17.4PL/Proxy语言详解446
17.5PL/Proxy的一个高可用方案448
17.5.3具体实施步骤449
第18章pgpool-II的使用458
18.1　pgpool-II中的概念458
18.2　pgpool-II安装方法462
18.3　pgpool-II配置快速入门463
18.4　pgpool-II高可用配置方法471
18.5　pgpool-II的总结492
第19章Postgres-XC的使用493
19.1　Postgres-XC中的概念493
19.2　Postgres-XC的安装495
19.3　配置Postgres-XC集群497
19.4　Postgres-XC的使用503
第20章高可用性方案设计516
20.1　高可用架构基础516
20.2　基于共享存储的高可用方案517
20.3　WAL日志同步或流复制同步的方案519
20.4　基于触发器的同步方案520
20.5　基于语句中间件的高可用方案520

1.1 查询优化的简介 1

1.2 逻辑优化 3

1.2.1 关系模型 3

1.2.2 逻辑优化示例 8

1.3 物理优化 10

1.3.1 物理优化的4个“法宝” 12

1.3.2 物理路径的生成过程 14

1.4 文件介绍 17

1.5 示例的约定 18

1.6 小结 19



第2章 查询树 20

2.1 Node的结构 20

2.2 Var结构体 21

2.3 RangeTblEntry结构体 23

2.4 RangeTblRef结构体 25

2.5 JoinExpr结构体 26

2.6 FromExpr结构体 27

2.7 Query结构体 27

2.8 查询树的展示 31

2.9 查询树的遍历 31

2.10 执行计划的展示 32

2.11 小结 33



第3章 逻辑重写优化 34

3.1 通用表达式 35

3.2 子查询提升 36

3.2.1 提升子连接 37

3.2.2 提升子查询 51

3.3 UNION ALL优化 68

3.4 展开继承表 69

3.5 预处理表达式 71

3.5.1 连接Var的溯源 71

3.5.2 常量化简 72

3.5.3 谓词规范 73

3.5.4 子连接处理 79

3.6 处理HAVING子句 80

3.7 Group By键值消除 81

3.8 外连接消除 82

3.9 grouping_planner的说明 91

3.10 小结 92



第4章 逻辑分解优化 93

4.1 创建RelOptInfo 94

4.1.1 RelOptInfo结构体 94

4.1.2 IndexOptInfo结构体 97

4.1.3 创建RelOptInfo 100

4.2 初识等价类 102

4.3 谓词下推 106

4.3.1 连接条件的下推 106

4.3.2 过滤条件的下推 112

4.3.3 连接顺序 113

4.3.4 deconstruct_recurse函数 118

4.3.5 make_outerjoininfo函数 124

4.3.6 distribute_qual_to_rels函数 132

4.3.7 reconsider_outer_join_clauses函数 151

4.3.8 generate_base_implied_equalities函数 156

4.3.9 记录表之间的等价关系 157

4.4 PlaceHolderVar的作用 158

4.5 Lateral语法的支持 161

4.5.1 Lateral的语义分析 162

4.5.2 收集Lateral变量 164

4.5.3 收集Lateral信息 164

4.6 消除无用连接项 166

4.7 Semi Join消除 171

4.8 提取新的约束条件 172

4.8.1 提取需要满足的条件 173

4.8.2 提取流程 174

4.8.3 选择率修正 176

4.9 小结 177



第5章 统计信息和选择率 178

5.1 统计信息 178

5.1.1 PG_STATISTIC系统表 181

5.1.2 PG_STATISTIC_EXT系统表 185

5.1.3 单列统计信息生成 187

5.1.4 多列统计信息生成 196

5.2 选择率 200

5.2.1 使用函数依赖计算选择率 204

5.2.2 子约束条件的选择率 208

5.2.3 基于范围的约束条件的选择率修正 211

5.3 OpExpr的选择率 213

5.3.1 eqsel函数 215

5.3.2 scalargtsel函数 217

5.3.3 eqjoinsel函数 220

5.4 小结 226



第6章 扫描路径 227

6.1 代价（Cost） 228

6.1.1 代价基准单位 228

6.1.2 启动代价和整体代价 231

6.1.3 表达式代价的计算 233

6.2 路径（Path） 236

6.2.1 Path结构体 236

6.2.2 并行参数 237

6.2.3 参数化路径 239

6.2.4 PathKey 242

6.3 make_one_rel函数 244

6.4 普通表的扫描路径 245

6.4.1 顺序扫描 246

6.4.2 索引扫描 248

6.4.3 位图扫描 281

6.5 小结 291



第7章 动态规划和遗传算法 292

7.1 动态规划 293

7.1.1 make_rel_from_joinlist函数 297

7.1.2 standard_join_search函数 298

7.1.3 join_search_one_level函数 298

7.2 遗传算法 301

7.2.1 种群初始化 303

7.2.2 选择算子 308

7.2.3 交叉算子 310

7.2.4 适应度计算 311

7.3 小结 312



第8章 连接路径 313

8.1 检查 314

8.1.1 初步检查 314

8.1.2 精确检查 316

8.1.3 “合法”连接 318

8.2 生成新的RelOptInfo 324

8.3 虚表 327

8.4 Semi Join和唯一化路径 328

8.5 建立连接路径 331

8.5.1 sort_inner_and_outer函数 334

8.5.2 match_unsorted_outer函数 345

8.5.3 hash_inner_and_outer函数 350

8.6 路径的筛选 355

8.7 小结 360



第9章 Non-SPJ优化 361

9.1 集合操作处理 361

9.2 Non-SPJ路径 367

9.2.1 Non-SPJ预处理 368

9.2.2 Non-SPJ路径生成 376

9.3 小结 382



第10章 生成执行计划 383

10.1 转换流程 383

10.1.1 扫描计划 384

10.1.2 连接计划 390

10.2 执行计划树清理 391

10.3 小结 395

1．1　为什么应该选择PostgreSQL 　　1
1．2　不适用PostgreSQL 的场景 　　3
1．3　如何获得PostgreSQL 　　3
1．4　管理工具 　　4
1．4．1　psql 　　4
1．4．2　pgAdmin 　　4
1．4．3　phpPgAdmin 　　6
1．4．4　Adminer 　　6
1．5　PostgreSQL 数据库对象 　　7
1．6　最新版本的PostgreSQL 中引入的新特性 　　12
1．6．1　为什么要升级 　　12
1．6．2　PostgreSQL 10 中引入的新特性 　　12
1．6．3　PostgreSQL 9．6 中引入的新特性 　　13
1．6．4　PostgreSQL 9．5 中引入的新特性 　　14
1．6．5　PostgreSQL 9．4 中引入的新特性 　　15
1．7　数据库驱动程序 　　17
1．8　如何获得帮助 　　18
1．9　PostgreSQL 的主要衍生版本 　　18
第 2 章　数据库管理 　　19
2．1　配置文件 　　19
2．1．1　让配置文件生效 　　20
2．1．2　postgresql．conf 　　21
2．1．3　pg_hba．conf　　25
2．2　连接管理 　　27
2．3　角色 　　29
2．3．1　创建可登录角色 　　30
2．3．2　创建组角色 　　30
2．4　创建database 　　33
2．4．1　模板数据库 　　33
2．4．2　schema 的使用 　　34
2．5　权限管理 　　36
2．5．1　权限的类型 　　36
2．5．2　入门介绍 　　36
2．5．3　GRANT 　　37
2．5．4　默认权限 　　38
2．5．5　PostgreSQL 权限体系中一些与众不同的特点 　　39
2．6　扩展包机制 　　39
2．6．1　扩展包的安装 　　40
2．6．2　通用扩展包 　　42
2．7　备份与恢复 　　44
2．7．1　使用pg_dump 进行有选择性的备份 　　45
2．7．2　使用pg_dumpall 进行全局备份 　　46
2．7．3　数据恢复 　　47
2．8　基于表空间机制进行存储管理 　　48
2．8．1　表空间的创建 　　49
2．8．2　在表空间之间迁移对象 　　49
2．9　禁止的行为 　　49
2．9．1　切记不要删除PostgreSQL 系统文件 　　50
2．9．2　不要把操作系统管理员权限授予PostgreSQL 的系统账号 　　50
2．9．3　不要把shared_buffers 缓存区设置得过大 　　51
2．9．4　不要将PostgreSQL 服务器的侦听端口设为一个已被其他程序占用的端口 　　51
第3 章　psql 工具 　　52
3．1　环境变量 　　52
3．2　psql 的两种操作模式：交互模式与非交互模式 　　 53
3．3　定制psql 操作环境 　　54
3．3．1　自定义psql 界面提示符 　　55
3．3．2　语句执行时间统计 　　56
3．3．3　事务自动提交 　　56
3．3．4　命令别名 　　56
3．3．5　取出前面执行过的命令行 　　57
3．4　psql 使用技巧 　　57
3．4．1　执行shell 命令 　　57
3．4．2　用watch 命令重复执行语句 　　57
3．4．3　显示对象信息 　　58
3．4．4　行转列视图 　　59
3．4．5　执行动态SQL 　　59
3．5　使用psql 实现数据的导入和导出 　　60
3．5．1　使用psql 进行数据导入 　　60
3．5．2　使用psql 进行数据导出 　　61
3．5．3　从外部程序复制数据以及将数据复制到外部程序 　　62
3．6　使用psql 制作简单的报表 　　62
第4 章　pgAdmin 的使用　　65
4．1　pgAdmin 入门 　　65
4．1．1　功能概览 　　66
4．1．2　如何连接到PostgreSQL 服务器 　　67
4．1．3　pgAdmin 界面导航 　　68
4．2　pgAdmin 功能特性介绍 　　68
4．2．1　根据表定义自动生成SQL 语句 　　69
4．2．2　在pgAdmin3 中调用psql 　　69
4．2．3　在pgAdmin3 中编辑postgresql．conf 和pg_hba．conf 文件 　　70
4．2．4　创建数据库对象并设置权限 　　70
4．2．5　数据导入和导出 　　73
4．2．6　备份与恢复 　　74
4．3　pgScript 脚本机制 　　78
4．4　以图形化方式解释执行计划 　　80
4．5　使用pgAgent 执行定时任务 　　81
4．5．1　安装pgAgent 　　81
4．5．2　规划定时任务 　　82
4．5．3　一些有用的pgAgent 相关查询语句 　　84
第5 章　数据类型 　　85
5．1　数值类型 　　85
5．1．1　serial 类型 　　85
5．1．2　生成数组序列的函数 　　86
5．2　文本类型 　　87
5．2．1　字符串函数 　　87
5．2．2　将字符串拆分为数组、表或者子字符串 　　88
5．2．3　正则表达式和模式匹配 　　89
5．3　时间类型 　　90
5．3．1　时区详解 　　92
5．3．2　日期时间类型的运算符和函数 　　93
5．4　数组类型 　　95
5．4．1　数组构造函数 　　96
5．4．2　将数组元素展开为记录行 　　97
5．4．3　数组的拆分与连接 　　98
5．4．4　引用数组中的元素 　　99
5．4．5　数组包含性检查 　　99
5．5　区间类型 　　100
5．5．1　离散区间和连续区间 　　100
5．5．2　原生支持的区间类型 　　100
5．5．3　定义区间的方法 　　101
5．5．4　定义含区间类型字段的表 　　102
5．5．5　适用于区间类型的运算符 　　102
5．6　JSON 数据类型 　　103
5．6．1　插入JSON 数据 　　103
5．6．2　查询JSON 数据 　　104
5．6．3　输出JSON 数据 　　105
5．6．4　JSON 类型的二进制版本：jsonb 　　106
5．6．5　编辑JSONB 类型的数据 　　108
5．7　XML 数据类型 　　109
5．7．1　插入XML 数据　　110
5．7．2　查询XML 数据　　110
5．8　全文检索 　　112
5．8．1　FTS 配置库　　113
5．8．2　TSVector 原始文本向量 　　115
5．8．3　TSQueries 检索条件向量 　　117
5．8．4　使用全文检索 　　119
5．8．5　对检索结果进行排序 　　120
5．8．6　全文检索向量信息的裁减 　　121
5．8．7　全文检索机制对JSON 和JSONB 数据类型的支持 　　122
5．9　自定义数据类型和复合数据类型 　　122
5．9．1　所有表都有一个对应的自定义数据类型 　　123
5．9．2　构建自定义数据类型 　　124
5．9．3　复合类型中的空值处理 　　124
5．9．4　为自定义数据类型构建运算符和函数 　　125
第6 章　表、约束和索引 　　126
6．1　表 　　126
6．1．1　基本的建表操作 　　126
6．1．2　继承表 　　128
6．1．3　原生分区表支持 　　128
6．1．4　无日志表 　　130
6．1．5　TYPE OF 　　131
6．2　约束机制 　　132
6．2．1　外键约束 　　132
6．2．2　唯一性约束 　　133
6．2．3　check 约束 　　133
6．2．4　排他性约束 　　133
6．3　索引 　　134
6．3．1　PostgreSQL 原生支持的索引类型 　　135
6．3．2　运算符类 　　137
6．3．3　函数索引 　　138
6．3．4　基于部分记录的索引 　　138
6．3．5　多列索引 　　140
第7 章　PostgreSQL 的特色SQL 语法 　　141
7．1　视图 　　141
7．1．1　单表视图 　　142
7．1．2　使用触发器来更新视图 　　143
7．1．3　物化视图 　　145
7．2　灵活易用的PostgreSQL 专有SQL 语法 　　146
7．2．1　DISTINCT ON 　　147
7．2．2　LIMIT 和OFFSET 关键字 　　147
7．2．3　简化的类型转换语法 　　148
7．2．4　一次性插入多条记录 　　148
7．2．5　使用ILIKE 实现不区分大小写的查询 　　148
7．2．6　使用ANY 运算符进行数组搜索 　　149
7．2．7　可以返回结果集的函数 　　149
7．2．8　限制对继承表的DELETE、UPDATE、INSERT 操作的影响范围 　　150
7．2．9　DELETE USING 语法 　　150
7．2．10　将修改影响到的记录行返回给用户 　　150
7．2．11　UPSERT：INSERT 时如果主键冲突则进行UPDATE 　　151
7．2．12　在查询中使用复合数据类型 　　152
7．2．13　使用$ 文本引用符 　　153
7．2．14　DO 　　154
7．2．15　适用于聚合操作的FILTER 子句 　　155
7．2．16　查询百分位数与最高出现频率数 　　157
7．3　窗口函数 　　158
7．3．1　PARTITION BY 子句 　　159
7．3．2　ORDER BY 子句 　　160
7．4　CTE 表达式 　　162
7．4．1　基本CTE 用法介绍 　　162
7．4．2　可写CTE 用法介绍 　　163
7．4．3　递归CTE 用法介绍 　　163
7．5　LATERAL 横向关联语法 　　165
7．6　WITH ORDINALITY 子句 　　166
7．7　GROUPING SETS、CUBE 和ROLLUP 语法 　　168
第8 章　函数编写 　　171
8．1　PostgreSQL 函数功能剖析 　　171
8．1．1　函数功能基础知识介绍 　　171
8．1．2　触发器和触发器函数 　　174
8．1．3　聚合操作 　　175
8．1．4　受信与非受信语言 　　176
8．2　使用SQL 语言来编写函数 　　177
8．2．1　编写基本的SQL 函数 　　177
8．2．2　使用SQL 语言编写聚合函数 　　179
8．3　使用PL/pgSQL 语言编写函数　　181
8．3．1　编写基础的PL/pgSQL 函数 　　181
8．3．2　使用PL/pgSQL 编写触发器函数 　　181
8．4　使用PL/Python 语言编写函数 　　182
8．5　使用PL/V8、PL/CoffeeScript 以及PL/LiveScript 语言来编写函数 　　184
8．5．1　编写基本的函数 　　185
8．5．2　使用PL/V8 来编写聚合函数 　　186
8．5．3　使用PL/V8 编写窗口函数 　　187
第9 章　查询性能调优 　　190
9．1　通过EXPLAIN 命令查看语句执行计划 　　190
9．1．1　EXPLAIN 选项 　　190
9．1．2　运行示例以及输出内容解释 　　191
9．1．3　图形化展示执行计划 　　193
9．2　搜集语句的执行统计信息 　　195
9．3　编写更好的SQL 语句 　　196
9．3．1　在SELECT 语句中滥用子查询 　　196
9．3．2　尽量避免使用SELECT * 语法 　　198
9．3．3　善用CASE 语法 　　199
9．3．4　使用Filter 语法替代CASE 语法 　　200
9．4　并行化语句执行 　　201
9．4．1　并行化的执行计划是什么样子 　　201
9．4．2　并行化扫描 　　204
9．4．3　并行化关联操作 　　205
9．5　人工干预规划器生成执行计划的过程 　　205
9．5．1　策略设置 　　205
9．5．2　你的索引被用到了吗 　　206
9．5．3　表的统计信息 　　207
9．5．4　磁盘页的随机访问成本以及磁盘驱动器的性能 　　209
9．6　数据缓存机制 　　209
第 10 章　复制与外部数据 　　211
10．1　复制功能概览 　　211
10．1．1　复制功能涉及的术语 　　212
10．1．2　复制机制的演进 　　214
10．1．3　第三方复制解决方案 　　214
10．2　复制环境的搭建 　　215
10．2．1　主服务器的配置 　　215
10．2．2　为从属服务器配置全量复制环境 　　216
10．2．3　启动流复制进程 　　217
10．2．4　使用逻辑复制实现部分表或者部分database 的复制 　　218
10．3　外部数据封装器 　　219
10．3．1　查询平面文件 　　220
10．3．2　以不规则数组的形式查询不规范的平面文件 　　220
10．3．3　查询其他PostgreSQL 服务实例上的数据 　　222
10．3．4　使用ogr_fdw 查询其他二维表形式的数据源 　　224
10．3．5　查询非传统数据源 　　226
附录A　PostgreSQL 的安装 　　228
附录B　PostgreSQL 自带的命令行工具 　　233

1．1 PostgreSQL 9．6 中有什么新技术
1．1．1 理解新的数据库管理功能
1．1．2 探究新的SQL和开发者相关的功能
1．1．3 使用新的备份和复制功能
1．1．4 理解性能相关的特性
1．2 总结

第2章 理解事务和锁定
2．1 使用PostgreSQL事务
2．1．1 在事务内处理错误
2．1．2 使用保存点
2．1．3 事务性DDL
2．2 理解基本的锁定
2．3 使用FOR SHARE和FOR UPDATE
2．4 理解事务隔离级别
2．5 观察死锁和类似的问题
2．6 利用咨询锁
2．7 优化存储以及控制清理
2．7．1 配置VACUUM和autovacuum
2．7．2 观察工作中的VACUUM
2．7．3 利用snapshot too old
2．8 总结

第3章 使用索引
3．1 理解简单查询和代价模型
3．1．1 使用EXPLAIN
3．1．2 深究PostgreSQL代价模型
3．1．3 部署简单的索引
3．1．4 使用排序输出
3．1．5 一次使用多个索引
3．1．6 以一种聪明的方式使用索引
3．2 使用聚簇表改善速度
3．2．1 聚簇表
3．2．2 使用只用索引的扫描
3．3 理解另外的B-树特性
3．3．1 组合索引
3．3．2 增加函数索引
3．3．3 减少空间消耗
3．3．4 在建立索引时添加数据
3．4 引入操作符类
3．5 理解PostgreSQL索引类型
3．5．1 Hash索引
3．5．2 GiST索引
3．5．3 GIN索引
3．5．4 SP-GiST索引
3．5．5 BRIN索引
3．5．6 增加额外索引
3．6 用模糊搜索实现更好的回答
3．6．1 利用pg_trgm
3．6．2 加速LIKE查询
3．6．3 处理正则表达式
3．7 理解全文搜索-FTS
3．7．1 比较字符串
3．7．2 定义GIN索引
3．7．3 调试用户的搜索
3．7．4 收集词统计信息
3．7．5 利用排除操作符
3．8 总结

第4章 处理高级SQL
4．1 引入分组集
4．1．1 装载一些案例数据
4．1．2 应用分组集
4．1．3 组合分组集和FILTER子句
4．2 使用有序集
4．3 理解假想聚集
4．4 利用窗口函数和分析
4．4．1 划分数据
4．4．2 在窗口中排序数据
4．4．3 使用滑动窗口
4．4．4 提取窗口子句
4．4．5 使用内建窗口函数
4．5 编写自己的聚集
4．5．1 创建简单的聚集
4．5．2 为并行查询增加支持
4．5．3 改进效率
4．5．4 编写假想聚集
4．6 总结

第5章 日志文件和系统统计信息
5．1 收集运行时统计信息
5．2 创建日志文件
5．3 总结

第6章 优化查询获得良好性能
6．1 学习优化器的行为
6．2 理解执行计划
6．2．1 系统地处理计划
6．2．2 发现问题
6．3 理解并且固定连接
6．3．1 正确使用连接
6．3．2 处理外连接
6．3．3 理解join_collapse_limit变量
6．4 启用和禁用优化器设置
6．5 分区数据
6．5．1 创建分区
6．5．2 应用表约束
6．5．3 修改继承的结构
6．5．4 在分区结构中移进和移出表
6．5．5 清理数据
6．6 为好的查询性能调整参数
6．6．1 加速排序
6．6．2 加速管理任务
6．7 总结

第7章 编写存储过程
7．1 理解存储过程语言
7．2 理解各种存储过程语言
7．2．1 引入PL/pgSQL
7．2．2 引入PL/Perl
7．2．3 引入PL/Python
7．3 改进存储过程的性能
7．4 使用存储过程
7．5 总结

第8章 管理PostgreSQL安全性
8．1 管理网络安全性
8．1．1 理解绑定地址和连接
8．1．2 管理pg_hba．conf
8．1．3 处理实例级安全性
8．1．4 定义数据库级安全性
8．1．5 调整方案级权限
8．1．6 使用表
8．1．7 处理列级安全性
8．1．8 配置默认特权
8．2 深入行级安全性-RLS
8．3 检查权限
8．4 再分配对象和删除用户
8．5 总结

第9章 处理备份和恢复
9．1 执行简单转储
9．1．1 运行pg_dump
9．1．2 传递口令和连接信息
9．1．3 提取数据的子集
9．1．4 处理多种数据格式
9．2 重放备份
9．3 处理全局数据
9．4 总结

第10章 理解备份和复制
10．1 理解事务日志
10．1．1 察看事务日志
10．1．2 理解检查点
10．1．3 优化事务日志
10．2 事务日志归档和恢复
10．2．1 为归档进行配置
10．2．2 配置pg_hba．conf文件
10．2．3 创建基础备份
10．2．4 重放事务日志
10．2．5 清理事务日志归档
10．3 设置异步复制
10．3．1 执行基本设置
10．3．2 停止和继续复制
10．3．3 检查复制以确保可用性
10．3．4 执行故障转移以及理解时间线
10．3．5 管理冲突
10．3．6 让复制更可靠
10．4 升级到同步复制
10．5 利用复制槽
10．5．1 处理物理复制槽
10．5．2 处理逻辑复制槽
10．6 总结

第11章 选定有用的扩展
11．1 理解扩展如何工作
11．2 利用contrib模块
11．2．1 使用adminpack
11．2．2 应用布隆过滤器
11．2．3 部署btree_gist和btree_gin
11．2．4 Dblink-考虑逐步淘汰
11．2．5 用file_fdw取得文件数据
11．2．6 使用pageinspect检查存储
11．2．7 用pg_buffercache研究缓冲
11．2．8 用pgcrypto加密数据
11．2．9 用pg_prewarm预热缓冲
11．2．1 0用pg_stat_statements检查性能
11．2．1 1用pgstattuple检查存储
11．2．1 2用pg_trgm进行模糊搜索
11．2．1 3使用postgres_fdw连接到远程服务器
11．3 其他有用的扩展
11．4 总结

第12章 在PostgreSQL中排查错误
12．1 着手处理一个陌生的数据库
12．2 检查pg_stat_activity
12．3 检查慢查询
12．3．1 检查个体查询
12．3．2 用perf深入研究
12．4 检查日志
12．5 检查缺失的索引
12．6 检查内存和I/O
12．7 了解值得注意的错误场景
12．7．1 面对clog损坏
12．7．2 理解检查点消息
12．7．3 管理损坏的数据页面
12．7．4 粗心的连接管理
12．7．5 与表膨胀斗争
12．8 总结

第13章 迁移到PostgreSQL
13．1 迁移SQL语句到PostgreSQL
13．1．1 使用侧连接
13．1．2 使用分组集
13．1．3 使用WITH子句-公共表表达式
13．1．4 使用WITH RECURSIVE子句
13．1．5 使用FILTER子句
13．1．6 使用窗口函数
13．1．7 使用有序集——WITHIN GROUP子句
13．1．8 使用TABLESAMPLE子句
13．1．9 使用limit/offset
13．1．1 0使用OFFSET
13．1．1 1使用临时表
13．1．1 2匹配时间序列中的模式
13．2 从Oracle转移到PostgreSQL
13．2．1 使用oracle_fdw扩展转移数据
13．2．2 使用ora2pg从Oracle迁移
13．2．3 常见的陷阱
13．3 从MySQL或MariaDB转移到PostgreSQL
13．3．1 处理MySQL和MariaDB中的数据
13．3．2 迁移数据和模式

