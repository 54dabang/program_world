第1章 MySQL 架构与历史

1.1 MySQL 逻辑架构
1.1.1 连接管理与安全性
1.1.2 优化与执行
1.2 并发控制
1.2.1 读写锁
1.2.2 锁粒度
1.3 事务
1.3.1 隔离级别
1.3.2 死锁
1.3.3 事务日志
1.3.4 MySQL 中的事务
1.4 多版本并发控制
1.5 MySQL 的存储引擎
1.5.1 InnoDB 存储引擎
1.5.2 MyISAM 存储引擎
1.5.3 MySQL 内建的其他存储引擎
1.5.4 第三方存储引擎
1.5.5 选择合适的引擎
1.5.6 转换表的引擎
1.6 MySQL 时间线（Timeline）
1.7 MySQL 的开发模式
1.8 总结

第2章 MySQL 基准测试
2.1 为什么需要基准测试
2.2 基准测试的策略
2.2.1 测试何种指标
2.3 基准测试方法
2.3.1 设计和规划基准测试
2.3.2 基准测试应该运行多长时间
2.3.3 获取系统性能和状态
2.3.4 获得准确的测试结果
2.3.5 运行基准测试并分析结果
2.3.6 绘图的重要性
2.4 基准测试工具
2.4.1 集成式测试工具
2.4.2 单组件式测试工具
2.5 基准测试案例
2.5.1 http_load
2.5.2 MySQL 基准测试套件 .
2.5.3 sysbench
2.5.4 数据库测试套件中的dbt2 TPC-C 测试
2.5.5 Percona 的TPCC-MySQL 测试工具
2.6 总结

第3章 服务器性能剖析
3.1 性能优化简介
3.1.1 通过性能剖析进行优化
3.1.2 理解性能剖析
3.2 对应用程序进行性能剖析
3.2.1 测量PHP 应用程序
3.3 剖析MySQL 查询
3.3.1 剖析服务器负载
3.3.2 剖析单条查询
3.3.3 使用性能剖析
3.4 诊断间歇性问题
3.4.1 单条查询问题还是服务器问题
3.4.2 捕获诊断数据
3.4.3 一个诊断案例
3.5 其他剖析工具
3.5.1 使用USER_STATISTICS 表
3.5.2 使用strace
3.6 总结

第4章 Schema 与数据类型优化
4.1 选择优化的数据类型
4.1.1 整数类型
4.1.2 实数类型
4.1.3 字符串类型
4.1.4 日期和时间类型
4.1.5 位数据类型
4.1.6 选择标识符（identifier）
4.1.7 特殊类型数据
4.2 MySQL schema 设计中的陷阱
4.3 范式和反范式
4.3.1 范式的优点和缺点
4.3.2 反范式的优点和缺点 .
4.3.3 混用范式化和反范式化
4.4 缓存表和汇总表
4.4.1 物化视图
4.4.2 计数器表
4.5 加快ALTER TABLE 操作的速度
4.5.1 只修改.frm 文件
4.5.2 快速创建MyISAM 索引
4.6 总结

第5章 创建高性能的索引
5.1 索引基础
5.1.1 索引的类型
5.2 索引的优点
5.3 高性能的索引策略
5.3.1 独立的列
5.3.2 前缀索引和索引选择性
5.3.3 多列索引
5.3.4 选择合适的索引列顺序
5.3.5 聚簇索引
5.3.6 覆盖索引
5.3.7 使用索引扫描来做排序
5.3.8 压缩（前缀压缩）索引
5.3.9 冗余和重复索引
5.3.10 未使用的索引
5.3.11 索引和锁
5.4 索引案例学习
5.4.1 支持多种过滤条件
5.4.2 避免多个范围条件
5.4.3 优化排序
5.5 维护索引和表
5.5.1 找到并修复损坏的表 .
5.5.2 更新索引统计信息
5.5.3 减少索引和数据的碎片
5.6 总结

第6章 查询性能优化
6.1 为什么查询速度会慢
6.2 慢查询基础：优化数据访问
6.2.1 是否向服务器请求了不需要的数据
6.2.2 MySQL 是否在扫描额外的记录
6.3 重构查询的方式
6.3.1 一个复杂查询还是多个简单查询
6.3.2 切分查询
6.3.3 分解关联查询
6.4 查询执行的基础
6.4.1 MySQL 客户端/ 服务器通信协议
6.4.2 查询缓存
6.4.3 查询优化处理
6.4.4 查询执行引擎
6.4.5 返回结果给客户端
6.5 MySQL 查询优化器的局限性
6.5.1 关联子查询
6.5.2 UNION 的限制
6.5.3 索引合并优化
6.5.4 等值传递
6.5.5 并行执行
6.5.6 哈希关联
6.5.7 松散索引扫描
6.5.8 最大值和最小值优化 .
6.5.9 在同一个表上查询和更新
6.6 查询优化器的提示（hint）
6.7 优化特定类型的查询
6.7.1 优化COUNT（） 查询
6.7.2 优化关联查询
6.7.3 优化子查询
6.7.4 优化GROUP BY 和DISTINCT
6.7.5 优化LIMIT 分页
6.7.6 优化SQL_CALC_FOUND_ROWS
6.7.7 优化UNION 查询
6.7.8 静态查询分析
6.7.9 使用用户自定义变量 .
6.8 案例学习
6.8.1 使用MySQL 构建一个队列表
6.8.2 计算两点之间的距离 .
6.8.3 使用用户自定义函数 .
6.9 总结

第7章 MySQL 高级特性
7.1 分区表
7.1.1 分区表的原理
7.1.2 分区表的类型
7.1.3 如何使用分区表
7.1.4 什么情况下会出问题 .
7.1.5 查询优化
7.1.6 合并表
7.2 视图
7.2.1 可更新视图
7.2.2 视图对性能的影响
7.2.3 视图的限制
7.3 外键约束
7.4 在MySQL 内部存储代码
7.4.1 存储过程和函数
7.4.2 触发器
7.4.3 事件
7.4.4 在存储程序中保留注释
7.5 游标
7.6 绑定变量
7.6.1 绑定变量的优化
7.6.2 SQL 接口的绑定变量
7.6.3 绑定变量的限制
7.7 用户自定义函数
7.8 插件
7.9 字符集和校对
7.9.1 MySQL 如何使用字符集
7.9.2 选择字符集和校对规则
7.9.3 字符集和校对规则如何影响查询
7.10 全文索引
7.10.1 自然语言的全文索引
7.10.2 布尔全文索引
7.10.3 MySQL5.1 中全文索引的变化
7.10.4 全文索引的限制和替代方案
7.10.5 全文索引的配置和优化
7.11 分布式（XA）事务
7.11.1 内部XA 事务
7.11.2 外部XA 事务
7.12 查询缓存
7.12.1 MySQL 如何判断缓存命中
7.12.2 查询缓存如何使用内存
7.12.3 什么情况下查询缓存能发挥作用
7.12.4 如何配置和维护查询缓存
7.12.5 InnoDB 和查询缓存 .
7.12.6 通用查询缓存优化
7.12.7 查询缓存的替代方案
7.13 总结

第8章 优化服务器设置
8.1 MySQL 配置的工作原理
8.1.1 语法、作用域和动态性
8.1.2 设置变量的副作用
8.1.3 入门
8.1.4 通过基准测试迭代优化
8.2 什么不该做
8.3 创建MySQL 配置文件
8.3.1 检查MySQL 服务器状态变量
8.4 配置内存使用
8.4.1 MySQL 可以使用多少内存？
8.4.2 每个连接需要的内存 .
8.4.3 为操作系统保留内存 .
8.4.4 为缓存分配内存
8.4.5 InnoDB 缓冲池（Buffer Pool）
8.4.6 MyISAM 键缓存（Key Caches）
8.4.7 线程缓存
8.4.8 表缓存（Table Cache）
8.4.9 InnoDB 数据字典（Data Dictionary）
8.5 配置MySQL 的I/O 行为
8.5.1 InnoDB I/O 配置
8.5.2 MyISAM 的I/O 配置 .
8.6 配置MySQL 并发 .
8.6.1 InnoDB 并发配置
8.6.2 MyISAM 并发配置
8.7 基于工作负载的配置
8.7.1 优化BLOB 和TEXT 的场景
8.7.2 优化排序（Filesorts）.
8.8 完成基本配置
8.9 安全和稳定的设置
8.10 高级InnoDB 设置
8.11 总结

第9章 操作系统和硬件优化
9.1 什么限制了MySQL 的性能
9.2 如何为MySQL 选择CPU
9.2.1 哪个更好：更快的CPU 还是更多的CPU
9.2.2 CPU 架构
9.2.3 扩展到多个CPU 和核心
9.3 平衡内存和磁盘资源
9.3.1 随机I/O 和顺序I/O
9.3.2 缓存，读和写
9.3.3 工作集是什么
9.3.4 找到有效的内存/ 磁盘比例
9.3.5 选择硬盘
9.4 固态存储
9.4.1 闪存概述
9.4.2 闪存技术
9.4.3 闪存的基准测试
9.4.4 固态硬盘驱动器（SSD）
9.4.5 PCIe 存储设备
9.4.6 其他类型的固态存储 .
9.4.7 什么时候应该使用闪存
9.4.8 使用Flashcache
9.4.9 优化固态存储上的MySQL
9.5 为备库选择硬件
9.6 RAID 性能优化
9.6.1 RAID 的故障转移、恢复和镜像
9.6.2 平衡硬件RAID 和软件RAID
9.6.3 RAID 配置和缓存
9.7 SAN 和NAS
9.7.1 SAN 基准测试
9.7.2 使用基于NFS 或SMB 的SAN
9.7.3 MySQL 在SAN 上的性能
9.7.4 应该用SAN 吗
9.8 使用多磁盘卷
9.9 网络配置
9.10 选择操作系统
9.11 选择文件系统
9.12 选择磁盘队列调度策略
9.13 线程
9.14 内存交换区
9.15 操作系统状态
9.15.1 如何阅读vmstat 的输出
9.15.2 如何阅读iostat 的输出
9.15.3 其他有用的工具
9.15.4 CPU 密集型的机器
9.15.5 I/O 密集型的机器
9.15.6 发生内存交换的机器
9.15.7 空闲的机器
9.16 总结

第10章 复制
10.1 复制概述
10.1.1 复制解决的问题
10.1.2 复制如何工作
10.2 配置复制
10.2.1 创建复制账号
10.2.2 配置主库和备库
10.2.3 启动复制
10.2.4 从另一个服务器开始复制
10.2.5 推荐的复制配置
10.3 复制的原理
10.3.1 基于语句的复制
10.3.2 基于行的复制
10.3.3 基于行或基于语句：哪种更优
10.3.4 复制文件
10.3.5 发送复制事件到其他备库
10.3.6 复制过滤器
10.4 复制拓扑
10.4.1 一主库多备库
10.4.2 主动- 主动模式下的主- 主复制
10.4.3 主动- 被动模式下的主- 主复制
10.4.4 拥有备库的主- 主结构
10.4.5 环形复制
10.4.6 主库、分发主库以及备库
10.4.7 树或金字塔形
10.4.8 定制的复制方案
10.5 复制和容量规划
10.5.1 为什么复制无法扩展写操作
10.5.2 备库什么时候开始延迟
10.5.3 规划冗余容量
10.6 复制管理和维护
10.6.1 监控复制
10.6.2 测量备库延迟
10.6.3 确定主备是否一致
10.6.4 从主库重新同步备库
10.6.5 改变主库
10.6.6 在一个主- 主配置中交换角色
10.7 复制的问题和解决方案
10.7.1 数据损坏或丢失的错误
10.7.2 使用非事务型表
10.7.3 混合事务型和非事务型表
10.7.4 不确定语句
10.7.5 主库和备库使用不同的存储引擎
10.7.6 备库发生数据改变
10.7.7 不唯一的服务器ID .
10.7.8 未定义的服务器ID .
10.7.9 对未复制数据的依赖性
10.7.10 丢失的临时表
10.7.11 不复制所有的更新 .
10.7.12 InnoDB 加锁读引起的锁争用
10.7.13 在主- 主复制结构中写入两台主库
10.7.14 过大的复制延迟
10.7.15 来自主库的过大的包
10.7.16 受限制的复制带宽 .
10.7.17 磁盘空间不足
10.7.18 复制的局限性
10.8 复制有多快
10.9 MySQL 复制的高级特性
10.10 其他复制技术
10.11 总结

第11章 可扩展的MySQL
11.1 什么是可扩展性
11.1.1 正式的可扩展性定义
11.2 扩展MySQL
11.2.1 规划可扩展性
11.2.2 为扩展赢得时间
11.2.3 向上扩展
11.2.4 向外扩展
11.2.5 通过多实例扩展
11.2.6 通过集群扩展
11.2.7 向内扩展
11.3 负载均衡
11.3.1 直接连接
11.3.2 引入中间件
11.3.3 一主多备间的负载均衡
11.4 总结

第12章 高可用性
12.1 什么是高可用性
12.2 导致宕机的原因
12.3 如何实现高可用性
12.3.1 提升平均失效时间（MTBF）
12.3.2 降低平均恢复时间（MTTR）
12.4 避免单点失效
12.4.1 共享存储或磁盘复制
12.4.2 MySQL 同步复制
12.4.3 基于复制的冗余
12.5 故障转移和故障恢复
12.5.1 提升备库或切换角色
12.5.2 虚拟IP 地址或IP 接管
12.5.3 中间件解决方案
12.5.4 在应用中处理故障转移
12.6 总结

第13章 云端的MySQL
13.1 云的优点、缺点和相关误解
13.2 MySQL 在云端的经济价值
13.3 云中的MySQL 的可扩展性和高可用性
13.4 四种基础资源
13.5 MySQL 在云主机上的性能
13.5.1 在云端的MySQL 基准测试
13.6 MySQL 数据库即服务（DBaaS）
13.6.1 Amazon RDS
13.6.2 其他DBaaS 解决方案
13.7 总结

第14章 应用层优化
14.1 常见问题
14.2 Web 服务器问题
14.2.1 寻找最优并发度
14.3 缓存
14.3.1 应用层以下的缓存
14.3.2 应用层缓存
14.3.3 缓存控制策略
14.3.4 缓存对象分层
14.3.5 预生成内容
14.3.6 作为基础组件的缓存
14.3.7 使用HandlerSocket 和memcached
14.4 拓展MySQL
14.5 MySQL 的替代品
14.6 总结

第15章 备份与恢复
15.1 为什么要备份
15.2 定义恢复需求
15.3 设计MySQL 备份方案
15.3.1 在线备份还是离线备份
15.3.2 逻辑备份还是物理备份
15.3.3 备份什么
15.3.4 存储引擎和一致性
15.4 管理和备份二进制日志
15.4.1 二进制日志格式
15.4.2 安全地清除老的二进制日志
15.5 备份数据
15.5.1 生成逻辑备份
15.5.2 文件系统快照
15.6 从备份中恢复
15.6.1 恢复物理备份
15.6.2 还原逻辑备份
15.6.3 基于时间点的恢复
15.6.4 更高级的恢复技术
15.6.5 InnoDB 崩溃恢复
15.7 备份和恢复工具
15.7.1 MySQL Enterprise Backup
15.7.2 Percona XtraBackup .
15.7.3 mylvmbackup
15.7.4 Zmanda Recovery Manager
15.7.5 mydumper
15.7.6 mysqldump.
15.8 备份脚本化
15.9 总结

第16章 MySQL 用户工具
16.1 接口工具
16.2 命令行工具集
16.3 SQL 实用集
16.4 监测工具
16.4.1 开源的监控工具
16.4.2 商业监控系统
16.4.3 Innotop 的命令行监控
16.5 总结

附录A MySQL 分支与变种
附录B MySQL 服务器状态
附录C 大文件传输
附录D EXPLAIN
附录E 锁的调试
附录F 在MySQL 上使用Sphinx
索引




第1章　了解SQL
1.1　数据库基础
1.1.1　什么是数据库
1.1.2　表
1.1.3　列和数据类型
1.1.4　行
1.1.5　主键
1.2　什么是SQL
1.3　动手实践
1.4　小结

第2章　MySQL简介
2.1　什么是MySQL
2.1.1　客户机-服务器软件
2.1.2　MySQL版本
2.2　MySQL工具
2.2.1　mysql命令行实用程序
2.2.2　MySQL Adminis-trator
2.2.3　MySQL Query Browser
2.3　小结

第3章　使用MySQL
3.1　连接
3.2　选择数据库
3.3　了解数据库和表
3.4　小结

第4章　检索数据
4.1　SELECT语句
4.2　检索单个列
4.3　检索多个列
4.4　检索所有列
4.5　检索不同的行
4.6　限制结果
4.7　使用完全限定的表名
4.8　小结

第5章　排序检索数据
5.1　排序数据
5.2　按多个列排序
5.3　指定排序方向
5.4　小结

第6章　过滤数据
6.1　使用WHERE子句
6.2　WHERE子句操作符
6.2.1　检查单个值
6.2.2　不匹配检查
6.2.3　范围值检查
6.2.4　空值检查
6.3　小结

第7章　数据过滤
7.1　组合WHERE子句
7.1.1　AND操作符
7.1.2　OR操作符
7.1.3　计算次序
7.2　IN操作符
7.3　NOT操作符
7.4　小结

第8章　用通配符进行过滤
8.1　LIKE操作符
8.1.1　百分号（%）通配符
8.1.2　下划线（_）通配符
8.2　使用通配符的技巧
8.3　小结

第9章　用正则表达式进行搜索
9.1　正则表达式介绍
9.2　使用MySQL正则表达式
9.2.1　基本字符匹配
9.2.2　进行OR匹配
9.2.3　匹配几个字符之一
9.2.4　匹配范围
9.2.5　匹配特殊字符
9.2.6　匹配字符类
9.2.7　匹配多个实例
9.2.8　定位符
9.3　小结

第10章　创建计算字段
10.1　计算字段
10.2　拼接字段
10.3　执行算术计算
10.4　小结

第11章　使用数据处理函数
11.1　函数
11.2　使用函数
11.2.1　文本处理函数
11.2.2　日期和时间处理函数
11.2.3　数值处理函数
11.3　小结

第12章　汇总数据
12.1　聚集函数
12.1.1　AVG（）函数
12.1.2　COUNT（）函数
12.1.3　MAX（）函数
12.1.4　MIN（）函数
12.1.5　SUM（）函数
12.2　聚集不同值
12.3　组合聚集函数
12.4　小结

第13章　分组数据
13.1　数据分组
13.2　创建分组
13.3　过滤分组
13.4　分组和排序
13.5　SELECT子句顺序
13.6　小结

第14章　使用子查询
14.1　子查询
14.2　利用子查询进行过滤
14.3　作为计算字段使用子查询
14.4　小结

第15章　联结表
15.1　联结
15.1.1　关系表
15.1.2　为什么要使用联结
15.2　创建联结
15.2.1　WHERE子句的重要性
15.2.2　内部联结
15.2.3　联结多个表
15.3　小结

第16章　创建高级联结
16.1　使用表别名
16.2　使用不同类型的联结
16.2.1　自联结
16.2.2　自然联结
16.2.3　外部联结
16.3　使用带聚集函数的联结
16.4　使用联结和联结条件
16.5　小结

第17章　组合查询
17.1　组合查询
17.2　创建组合查询
17.2.1　使用UNION
17.2.2　UNION规则
17.2.3　包含或取消重复的行
17.2.4　对组合查询结果排序
17.3　小结

第18章　全文本搜索
18.1　理解全文本搜索
18.2　使用全文本搜索
18.2.1　启用全文本搜索支持
18.2.2　进行全文本搜索
18.2.3　使用查询扩展
18.2.4　布尔文本搜索
18.2.5　全文本搜索的使用说明
18.3　小结

第19章　插入数据
19.1　数据插入
19.2　插入完整的行
19.3　插入多个行
19.4　插入检索出的数据
19.5　小结

第20章　更新和删除数据
20.1　更新数据
20.2　删除数据
20.3　更新和删除的指导原则
20.4　小结

第21章　创建和操纵表
21.1　创建表
21.1.1　表创建基础
21.1.2　使用NULL值
21.1.3　主键再介绍
21.1.4　使用AUTO_　INCREMENT
21.1.5　指定默认值
21.1.6　引擎类型
21.2　更新表
21.3　删除表
21.4　重命名表
21.5　小结

第22章　使用视图
22.1　视图
22.1.1　为什么使用视图
22.1.2　视图的规则和限制
22.2　使用视图
22.2.1　利用视图简化复杂的联结
22.2.2　用视图重新格式化检索出的数据
22.2.3　用视图过滤不想要的数据
22.2.4　使用视图与计算字段
22.2.5　更新视图
22.3　小结

第23章　使用存储过程
23.1　存储过程
23.2　为什么要使用存储过程
23.3　使用存储过程
23.3.1　执行存储过程
23.3.2　创建存储过程
23.3.3　删除存储过程
23.3.4　使用参数
23.3.5　建立智能存储过程
23.3.6　检查存储过程
23.4　小结

第24章　使用游标
24.1　游标
24.2　使用游标
24.2.1　创建游标
24.2.2　打开和关闭游标
24.2.3　使用游标数据
24.3　小结

第25章　使用触发器
25.1　触发器
25.2　创建触发器
25.3　删除触发器
25.4　使用触发器
25.4.1　INSERT触发器
25.4.2　DELETE触发器
25.4.3　UPDATE触发器
25.4.4　关于触发器的进一步介绍
25.5　小结

第26章　管理事务处理
26.1　事务处理
26.2　控制事务处理
26.2.1　使用ROLLBACK
26.2.2　使用COMMIT
26.2.3　使用保留点
26.2.4　更改默认的提交行为
26.3　小结

第27章　全球化和本地化
27.1　字符集和校对顺序
27.2　使用字符集和校对顺序
27.3　小结

第28章　安全管理
28.1　访问控制
28.2　管理用户
28.2.1　创建用户账号
28.2.2　删除用户账号
28.2.3　设置访问权限
28.2.4　更改口令
28.3　小结

第29章　数据库维护
29.1　备份数据
29.2　进行数据库维护
29.3　诊断启动问题
29.4　查看日志文件
29.5　小结

第30章　改善性能
30.1　改善性能
30.2　小结
附录A　MySQL入门
附录B　样例表
附录C　MySQL语句的语法
附录D　MySQL数据类型
附录E　MySQL保留字






推荐序
前言
第1章　MySQL体系结构和存储引擎
1.1　定义数据库和实例
1.2　MySQL体系结构
1.3　MySQL存储引擎
1.3.1　InnoDB存储引擎
1.3.2　MyISAM存储引擎
1.3.3　NDB存储引擎
1.3.4　Memory存储引擎
1.3.5　Archive存储引擎
1.3.6　Federated存储引擎
1.3.7　Maria存储引擎
1.3.8　其他存储引擎
1.4　各存储引擎之间的比较
1.5　连接MySQL
1.5.1　TCP/IP
1.5.2　命名管道和共享内存
1.5.3　UNIX域套接字
1.6　小结
第2章　InnoDB存储引擎
2.1　InnoDB存储引擎概述
2.2　InnoDB存储引擎的版本
2.3　InnoDB体系架构
2.3.1　后台线程
2.3.2　内存
2.4　Checkpoint技术
2.5　Master Thread工作方式
2.5.1　InnoDB 1.0.x版本之前的Master Thread
2.5.2　InnoDB1.2.x版本之前的Master Thread
2.5.3　InnoDB1.2.x版本的Master Thread
2.6　InnoDB关键特性
2.6.1　插入缓冲
2.6.2　两次写
2.6.3　自适应哈希索引
2.6.4　异步IO
2.6.5　刷新邻接页
2.7　启动、关闭与恢复
2.8　小结
第3章　文件
3.1　参数文件
3.1.1　什么是参数
3.1.2　参数类型
3.2　日志文件
3.2.1　错误日志
3.2.2　慢查询日志
3.2.3　查询日志
3.2.4　二进制日志
3.3　套接字文件
3.4　pid文件
3.5　表结构定义文件
3.6　InnoDB存储引擎文件
3.6.1　表空间文件
3.6.2　重做日志文件
3.7　小结
第4章　表
4.1　索引组织表
4.2　InnoDB逻辑存储结构
4.2.1　表空间
4.2.2　段
4.2.3　区
4.2.4　页
4.2.5　行
4.3　InnoDB行记录格式
4.3.1　Compact行记录格式
4.3.2　Redundant行记录格式
4.3.3　行溢出数据
4.3.4　Compressed和Dynamic行记录格式
4.3.5　CHAR的行结构存储
4.4　InnoDB数据页结构
4.4.1　File Header
4.4.2　Page Header
4.4.3　Infimum和Supremum Records
4.4.4　User Records和Free Space
4.4.5　Page Directory
4.4.6　File Trailer
4.4.7　InnoDB数据页结构示例分析
4.5　Named File Formats机制
4.6　约束
4.6.1　数据完整性
4.6.2　约束的创建和查找
4.6.3　约束和索引的区别
4.6.4　对错误数据的约束
4.6.5　ENUM和SET约束
4.6.6　触发器与约束
4.6.7　外键约束
4.7　视图
4.7.1　视图的作用
4.7.2　物化视图
4.8　分区表
4.8.1　分区概述
4.8.2　分区类型
4.8.3　子分区
4.8.4　分区中的NULL值
4.8.5　分区和性能
4.8.6　在表和分区间交换数据
4.9　小结
第5章　索引与算法
5.1　InnoDB存储引擎索引概述
5.2　数据结构与算法
5.2.1　二分查找法
5.2.2　二叉查找树和平衡二叉树
5.3　B+树
5.3.1　B+树的插入操作
5.3.2　B+树的删除操作
5.4　B+树索引
5.4.1　聚集索引
5.4.2　辅助索引
5.4.3　B+树索引的分裂
5.4.4　B+树索引的管理
5.5　Cardinality值
5.5.1　什么是Cardinality
5.5.2　InnoDB存储引擎的Cardinality统计
5.6　B+树索引的使用
5.6.1　不同应用中B+树索引的使用
5.6.2　联合索引
5.6.3　覆盖索引
5.6.4　优化器选择不使用索引的情况
5.6.5　索引提示
5.6.6　Multi-Range Read优化
5.6.7　Index Condition Pushdown（ICP）优化
5.7　哈希算法
5.7.1　哈希表
5.7.2　InnoDB存储引擎中的哈希算法
5.7.3　自适应哈希索引
5.8　全文检索
5.8.1　概述
5.8.2　倒排索引
5.8.3　InnoDB全文检索
5.8.4　全文检索
5.9　小结
第6章　锁
6.1　什么是锁
6.2　lock与latch
6.3　InnoDB存储引擎中的锁
6.3.1　锁的类型
6.3.2　一致性非锁定读
6.3.3　一致性锁定读
6.3.4　自增长与锁
6.3.5　外键和锁
6.4　锁的算法
6.4.1　行锁的3种算法
6.4.2　解决Phantom Problem
6.5　锁问题
6.5.1　脏读
6.5.2　不可重复读
6.5.3　丢失更新
6.6　阻塞
6.7　死锁
6.7.1　死锁的概念
6.7.2　死锁概率
6.7.3　死锁的示例
6.8　锁升级
6.9　小结
第7章　事务
7.1　认识事务
7.1.1　概述
7.1.2　分类
7.2　事务的实现
7.2.1　redo
7.2.2　undo
7.2.3　purge
7.2.4　group commit
7.3　事务控制语句
7.4　隐式提交的SQL语句
7.5　对于事务操作的统计
7.6　事务的隔离级别
7.7　分布式事务
7.7.1　MySQL数据库分布式事务
7.7.2　内部XA事务
7.8　不好的事务习惯
7.8.1　在循环中提交
7.8.2　使用自动提交
7.8.3　使用自动回滚
7.9　长事务
7.10　小结
第8章　备份与恢复
8.1　备份与恢复概述
8.2　冷备
8.3　逻辑备份
8.3.1　mysqldump
8.3.2　SELECT...INTO OUTFILE
8.3.3　逻辑备份的恢复
8.3.4　LOAD DATA INFILE
8.3.5　mysqlimport
8.4　二进制日志备份与恢复
8.5　热备
8.5.1　ibbackup
8.5.2　XtraBackup
8.5.3　XtraBackup实现增量备份
8.6　快照备份
8.7　复制
8.7.1　复制的工作原理
8.7.2　快照+复制的备份架构
8.8　小结
第9章　性能调优
9.1　选择合适的CPU
9.2　内存的重要性
9.3　硬盘对数据库性能的影响
9.3.1　传统机械硬盘
9.3.2　固态硬盘
9.4　合理地设置RAID
9.4.1　RAID类型
9.4.2　RAID Write Back功能
9.4.3　RAID配置工具
9.5　操作系统的选择
9.6　不同的文件系统对数据库性能的影响
9.7　选择合适的基准测试工具
9.7.1　sysbench
9.7.2　mysql-tpcc
9.8　小结
第10章　InnoDB存储引擎源代码的编译和调试
10.1　获取InnoDB存储引擎源代码
10.2　InnoDB源代码结构
10.3　MySQL 5.1版本编译和调试InnoDB源代码
10.3.1　Windows下的调试
10.3.2　Linux下的调试
10.4　cmake方式编译和调试InnoDB存储引擎

第1篇 基 础 知 识

第1章 数据库基础

视频讲解：25分钟

1.1 数据库系统概述

1.1.1 数据库技术的发展

1.1.2 数据库系统的组成

1.2 数据模型

1.2.1 数据模型的概念

1.2.2 常见的数据模型

1.2.3 关系数据库的规范化

1.2.4 关系数据库的设计原则

1.2.5 实体与关系

1.3 数据库的体系结构

1.3.1 数据库三级模式结构

1.3.2 三级模式之间的映射

1.4 小结

1.5 实践与练习



第2章 初识MySQL

视频讲解：12分钟

2.1 了解MySQL

2.1.1 MySQL数据库的概念

2.1.2 MySQL的优势

2.1.3 MySQL的发展史

2.2 MySQL的特性

2.3 MySQL的应用环境

2.4 MySQL服务器的安装和配置

2.4.1 MySQL服务器下载

2.4.2 MySQL服务器安装

2.4.3 启动、连接、断开和停止MySQL服务器

2.4.4 打开MySQL 5.6 Command Line Client

2.5 如何学好MySQL

2.6 小结

2.7 实践与练习



第3章 使用MySQL图形化管理工具

视频讲解：25分钟

3.1 MySQL Workbench图形化管理工具

3.1.1 了解MySQL Workbench

3.1.2 创建数据库和数据表

3.1.3 添加数据

3.1.4 数据的导出和导入

3.2 phpMyAdmin图形化管理工具

3.2.1 配置phpMyAdmin

3.2.2 数据库操作管理

3.2.3 管理数据表

3.2.4 管理数据记录

3.2.5 导出导入数据

3.2.6 phpMyAdmin设置编码格式

3.2.7 phpMyAdmin添加服务器新用户

3.2.8 phpMyAdmin中重置MySQL服务器登录密码

3.3 小结

3.4 实践与练习



第4章 数据库操作

视频讲解：6分钟

4.1 认识数据库

4.1.1 数据库基本概念

4.1.2 数据库常用对象

4.1.3 系统数据库

4.2 创建数据库

4.2.1 通过CREATE DATABASE语句创建基本数据库

4.2.2 通过CREATE SCHEMA语句创建基本数据库

4.2.3 创建指定字符集的数据库

4.2.4 创建数据库前判断是否存在同名数据库

4.3 查看数据库

4.4 选择数据库

4.5 修改数据库

4.6 删除数据库

4.7 小结

4.8 实践与练习



第5章 存储引擎及数据类型

视频讲解：12分钟

5.1 MySQL存储引擎

5.1.1 MySQL存储引擎的概念

5.1.2 查询MySQL中支持的存储引擎

5.1.3 InnoDB存储引擎

5.1.4 MyISAM存储引擎

5.1.5 MEMORY存储引擎

5.1.6 如何选择存储引擎

5.1.7 设置数据表的存储引擎

5.2 MySQL数据类型

5.2.1 数字类型

5.2.2 字符串类型

5.2.3 日期和时间类型

5.3 小结

5.4 实践与练习



第6章 操作数据表

视频讲解：12分钟

6.1 创建数据表

6.2 查看表结构

6.2.1 使用SHOW COLUMNS语句查看

6.2.2 使用DESCRIBE语句查看

6.3 修改表结构

6.3.1 添加新字段及修改字段定义

6.3.2 修改字段名

6.3.3 删除字段

6.3.4 修改表名

6.4 重命名表

6.5 复制表

6.6 删除表

6.7 小结

6.8 实践与练习

第2篇 核 心 技 术

第7章 MySQL基础

视频讲解：24分钟

7.1 运算符

7.1.1 算术运算符

7.1.2 比较运算符

7.1.3 逻辑运算符

7.1.4 位运算符

7.1.5 运算符的优先级

7.2 流程控制语句

7.2.1 IF语句

7.2.2 CASE语句

7.2.3 WHILE循环语句

7.2.4 LOOP循环语句

7.2.5 REPEAT循环语句

7.3 小结

7.4 实践与练习



第8章 表数据的增、删、改操作

视频讲解：20分钟

8.1 插入数据

8.1.1 使用INSERT...VALUES语句插入数据

8.1.2 使用INSERT...SET语句插入数据

8.1.3 插入查询结果

8.2 修改数据

8.3 删除数据

8.3.1 通过DELETE语句删除数据

8.3.2 通过TRUNCATE TABLE语句删除数据

8.4 小结

8.5 实践与练习



第9章 数据查询

视频讲解：52分钟

9.1 基本查询语句

9.2 单表查询

9.2.1 查询所有字段

9.2.2 查询指定字段

9.2.3 查询指定数据

9.2.4 带关键字IN的查询

9.2.5 带关键字BETWEEN AND的范围查询

9.2.6 带LIKE的字符匹配查询

9.2.7 用关键字IS NULL查询空值

9.2.8 带关键字AND的多条件查询

9.2.9 带关键字OR的多条件查询

9.2.10 用关键字DISTINCT去除结果中的重复行

9.2.11 用关键字ORDER BY对查询结果排序

9.2.12 用关键字GROUP BY分组查询

9.2.13 用关键字LIMIT限制查询结果的数量

9.3 聚合函数查询

9.3.1 COUNT()函数

9.3.2 SUM()函数

9.3.3 AVG()函数

9.3.4 MAX()函数

9.3.5 MIN()函数

9.4 连接查询

9.4.1 内连接查询

9.4.2 外连接查询

9.4.3 复合条件连接查询

9.5 子查询

9.5.1 带关键字IN的子查询

9.5.2 带比较运算符的子查询

9.5.3 带关键字EXISTS的子查询

9.5.4 带关键字ANY的子查询

9.5.5 带关键字ALL的子查询

9.6 合并查询结果

9.7 定义表和字段的别名

9.7.1 为表取别名

9.7.2 为字段取别名

9.8 使用正则表达式查询

9.8.1 匹配指定字符中的任意一个

9.8.2 使用“*”和“+”来匹配多个字符

9.8.3 匹配以指定的字符开头和结束的记录

9.9 小结

9.10 实践与练习



第10章 常用函数

视频讲解：36分钟

10.1 MySQL函数

10.2 数学函数

10.2.1 ABS(x)函数

10.2.2 FLOOR(x)函数

10.2.3 RAND()函数

10.2.4 PI()函数

10.2.5 TRUNCATE(x,y)函数

10.2.6 ROUND(x)函数和ROUND(x,y)函数

10.2.7 SQRT(x)函数

10.3 字符串函数

10.3.1 INSERT(s1,x,len,s2)函数

10.3.2 UPPER(s)函数和UCASE(s)函数

10.3.3 LEFT(s,n)函数

10.3.4 RTRIM(s)函数

10.3.5 SUBSTRING(s,n,len)函数

10.3.6 REVERSE(s)函数

10.3.7 FIELD(s,s1,s2,…)函数

10.3.8 LOCATE(s1,s)函数、POSITION(s1 IN s)函数和INSTR(s,s1)函数

10.4 日期和时间函数

10.4.1 CURDATE()函数和CURRENT_DATE()函数

10.4.2 CURTIME()函数和CURRENT_TIME()函数

10.4.3 NOW()函数

10.4.4 DATEDIFF(d1,d2)函数

10.4.5 ADDDATE(d,n)函数

10.4.6 ADDDATE(d,INTERVAL expr type)函数

10.4.7 SUBDATE(d,n)函数

10.5 条件判断函数

10.6 系统信息函数

10.6.1 获取MySQL版本号、连接数和数据库名的函数

10.6.2 获取用户名的函数

10.6.3 获取字符串的字符集和排序方式的函数

10.7 加密函数

10.7.1 加密函数PASSWORD(str)

10.7.2 加密函数MD5(str)

10.8 其他函数

10.8.1 格式化函数FORMAT(x,n)

10.8.2 改变字符集的函数

10.8.3 改变字段数据类型的函数

10.9 小结

10.10 实践与练习



第11章 索引

视频讲解：22分钟

11.1 索引概述

11.1.1 MySQL索引概述

11.1.2 MySQL索引分类

11.2 创建索引

11.2.1 在建立数据表时创建索引

11.2.2 在已建立的数据表中创建索引

11.2.3 修改数据表结构添加索引

11.3 删除索引

11.4 小结

11.5 实践与练习



第12章 视图

视频讲解：22分钟

12.1 视图概述

12.1.1 视图的概念

12.1.2 视图的作用

12.2 创建视图

12.2.1 查看创建视图的权限

12.2.2 创建视图的步骤

12.2.3 创建视图的注意事项

12.3 视图操作

12.3.1 查看视图

12.3.2 修改视图

12.3.3 更新视图

12.3.4 删除视图

12.4 小结

12.5 实践与练习

第一部分 基础篇
第1章 MySQL的安装与配置
1.1 MySQL的下载
1.1.1 在Windows平台下下载MySQL
1.1.2 在Linux平台下下载MySQL
1.2 MySQL的安装
1.2.1 在Windows平台下安装MySQL
1.2.2 在Linux平台下安装MySQL
1.3 MySQL的配置
1.3.1 Windows平台下配置MySQL
1.3.2 Linux平台下配置MySQL
1.4 启动和关闭MySQL服务
1.4.1 在Windows平台下启动和关闭MySQL服务
1.4.2 在Linux平台下启动和关闭MySQL服务
1.5 小结
第2章 SQL基础
2.1 SQL简介
2.2 （My）SQL使用入门
2.2.1 SQL分类
2.2.2 DDL语句
2.2.3 DML语句
2.2.4 DCL语句
2.3 帮助的使用
2.3.1 按照层次看帮助
2.3.2 快速查阅帮助
2.3.3 常用的网络资源
2.4 查询元数据信息
2.5 小结
第3章 MySQL支持的数据类型
3.1 数值类型
3.2 日期时间类型
3.3 字符串类型
3.3.1 CHAR和VARCHAR类
3.3.2 BINARY和VARBINARY类型
3.3.3 ENUM类型
3.3.4 SET类型
3.4 小结
第4章 MySQL中的运算符
4.1 算术运算符
4.2 比较运算符
4.3 逻辑运算符
4.4 位运算符
4.5 运算符的优先级
4.6 小结
第5章 常用函数
5.1 字符串函数
5.2 数值函数
5.3 日期和时间函数
5.4 流程函数
5.5 其他常用函数
5.6 小结
第6章 图形化工具的使用
6.1 MySQL Workbench
6.1.1 SQL开发
6.1.2 数据建模
6.1.3 服务器管理
6.1.4 MySQL Utilities
6.2 phpMyAdmin
6.2.1 数据库管理
6.2.2 数据库对象管理
6.2.3 权限管理
6.2.4 导入导出数据
6.3 小结

第二部分 开发篇
第7章 表类型（存储引擎）的选择
7.1 MySQL存储引擎概述
7.2 各种存储引擎的特性
7.2.1 MyISAM
7.2.2 InnoDB
7.2.3 MEMORY
7.2.4 MERGE
7.2.5 TokuDB
7.3 如何选择合适的存储引擎
7.4 小结
第8章 选择合适的数据类型
8.1 CHAR与VARCHAR
8.2 TEXT与BLOB
8.3 浮点数与定点数
8.4 日期类型选择
8.5 小结
第9章 字符集
9.1 字符集概述
9.2 Unicode简述
9.3 汉字及一些常见字符集
9.4 怎样选择合适的字符集
9.5 MySQL支持的字符集简介
9.6 MySQL字符集的设置
9.6.1 服务器字符集和校对规则
9.6.2 数据库字符集和校对规则
9.6.3 表字符集和校对规则
9.6.4 列字符集和校对规则
9.6.5 连接字符集和校对规则
9.7 字符集的修改步骤
9.8 小结
第10章 索引的设计和使用
10.1 索引概述
10.2 设计索引的原则
10.3 BTREE索引与HASH索引
10.4 小结
第11章 视图
11.1 什么是视图
11.2 视图操作
11.2.1 创建或者修改视图
11.2.2 删除视图
11.2.3 查看视图
11.3 小结
第12章 存储过程和函数
12.1 什么是存储过程和函数
12.2 存储过程和函数的相关操作
12.2.1 创建、修改存储过程或者函数
12.2.2 删除存储过程或者函数
12.2.3 查看存储过程或者函数
12.2.4 变量的使用
12.2.5 定义条件和处理
12.2.6 光标的使用
12.2.7 流程控制
12.2.8 事件调度器
12.3 小结
第13章 触发器
13.1 创建触发器
13.2 删除触发器
13.3 查看触发器
13.4 触发器的使用
13.5 小结
第14章 事务控制和锁定语句
14.1 LOCK TABLE和UNLOCK TABLE
14.2 事务控制
14.3 分布式事务的使用
14.3.1 分布式事务的原理
14.3.2 分布式事务的语法
14.3.3 存在的问题
14.4 小结
第15章 SQL中的安全问题
15.1 SQL注入简介
15.2 应用开发中可以采取的应对措施
15.2.1 PrepareStatement+Bind-Variable
15.2.2 使用应用程序提供的转换函数
15.2.3 自己定义函数进行校验
15.3 小结
第16章 SQL Mode及相关问题
16.1 MySQL SQL Mode简介
16.2 SQL Mode的常见功能
16.3 常用的SQL Mode
16.4 SQL Mode在迁移中如何使用
16.5 小结
第17章 MySQL分区
17.1 分区概述
17.2 分区类型
17.2.1 Range分区
17.2.2 List分区
17.2.3 Columns分区
17.2.4 Hash分区
17.2.5 Key分区
17.2.6 子分区
17.2.7 MySQL分区处理NULL值的方式
17.3 分区管理
17.3.1 RANGE&LIST分区管理
17.3.2 HASH&KEY分区管理
17.4 小结

第三部分 优化篇
第四部分 管理维护篇
第五部分 架构篇




第1章 安装或升级到MySQL 8 1

1.1 引言 1

1.2 使用YUM / APT安装MySQL 2

1.3 使用RPM或DEB文件安装MySQL 8.0 9

1.4 使用通用二进制文件在Linux系统上安装MySQL 12

1.5 启动或停止MySQL 8的运行 16

1.6 卸载MySQL 8 20

1.7 用systemd管理MySQL服务器 22

1.8 从MySQL 8.0降级 24

1.9 升级到MySQL 8.0 29

1.10 安装MySQL工具集 35

第2章 使用MySQL 37

2.1 引言 38

2.2 使用命令行客户端连接到MySQL 38

2.3 创建数据库 40

2.4 创建表 44

2.5 插入、更新和删除行 49

2.6 加载示例数据 52

2.7 查询数据 55

2.8 对结果排序 63

2.9 对结果分组（聚合函数） 64

2.10 创建用户 68

2.11 授予和撤销用户的访问权限 70

2.12 查询数据并保存到文件和表中 78

2.13 将数据加载到表中 81

2.14 表关联 82

2.15 存储过程 90

2.16 函数 95

2.17 触发器 98

2.18 视图 100

2.19 事件 102

2.20 获取有关数据库和表的信息 104

第3章 使用MySQL（进阶） 110

3.1 引言 110

3.2 使用JSON 110

3.3 公用表表达式（CTE） 116

3.4 生成列（generated column） 122

3.5 窗口函数 124

第4章 配置MySQL 129

4.1 引言 129

4.2 使用配置文件 130

4.3 使用全局变量和会话变量 131

4.4 在启动脚本中使用参数 132

4.5 配置参数 132

4.6 更改数据目录 135

第5章 事务 137

5.1 引言 137

5.2 执行事务 138

5.3 使用保存点 140

5.4 隔离级别 142

5.5 锁 147

第6章 二进制日志 153

6.1 引言 153

6.2 使用二进制日志 154

6.3 二进制日志的格式 159

6.4 从二进制日志中提取语句 161

6.5 忽略要写入二进制日志的数据库 173

6.6 迁移二进制日志 174

第7章 备份 177

7.1 引言 177

7.2 使用mysqldump进行备份 178

7.3 使用mysqlpump进行备份 182

7.4 使用mydumper进行备份 185

7.5 使用普通文件进行备份 191

7.6 使用XtraBackup进行备份 192

7.7 锁定实例进行备份 195

7.8 使用二进制日志进行备份 195

第8章 恢复数据 197

8.1 引言 197

8.2 从mysqldump和mysqlpump中恢复 197

8.3 使用myloader从mydumper中恢复 198

8.4 从普通文件备份中恢复 200

8.5 执行时间点恢复 201

第9章 复制 204

9.1 引言 204

9.2 准备复制 205

9.3 设置主主复制 212

9.4 设置多源复制 213

9.5 设置复制筛选器 220

9.6 将从库由主从复制切换到链式复制 222

9.7 将从库由链式复制切换到主从复制 227

9.8 设置延迟复制 231

9.9 设置GTID复制 234

9.10 设置半同步复制 238

第10章 表维护 243

10.1 引言 243

10.2 安装Percona工具包 244

10.3 修改表结构 246

10.4 在数据库之间移动表 248

10.5 使用在线模式更改工具修改表 250

10.6 归档表 255

10.7 克隆表 257

10.8 分区修剪和指定 269

10.9 管理分区 273

10.10 分区信息 276

10.11 有效地管理生存时间和软删除行 281

第11章 管理表空间 289

11.1 引言 289

11.2 更改InnoDB REDO日志文件的数量或大小 292

11.3 调整InnoDB系统的表空间大小 294

11.4 在数据目录之外创建独立表空间 298

11.5 将独立表空间复制到另一个实例 299

11.6 管理UNDO表空间 307

11.7 管理通用表空间 311

11.8 压缩InnoDB表 315

第12章 日志管理 320

12.1 引言 320

12.2 管理错误日志 320

12.3 管理通用查询日志和慢查询日志 328

12.4 管理二进制日志 335

第13章 性能调优 338

13.1 引言 338

13.2 explain计划 339

13.3 基准查询和服务器 345

13.4 添加索引 347

13.5 不可见索引 353

13.6 降序索引 355

13.7 使用pt-query-digest分析慢查询 358

13.8 优化数据类型 364

13.9 删除重复和冗余索引 366

13.10 检查索引的使用情况 374

13.11 控制查询优化器 375

13.12 使用索引提示（hint） 389

13.13 使用生成列为JSON建立索引 392

13.14 使用资源组 395

13.15 使用performance_schema 398

13.16 使用sys schema 405

第14章 安全 413

14.1 引言 413

14.2 安全安装 413

14.3 限定网络和用户 417

14.4 使用mysql_config_editor进行无密码认证 418

14.5 重置root密码 421

14.6 使用X509设置加密连接 425

14.7 设置SSL复制 428


第1篇　基础知识

第1章　步入MySQL数据库世界

——Hello MySQL 2

◎ 本章教学微视频：10个　29分钟 2

1.1 认识MySQL数据库 2

1.1.1 MySQL系统特性 2

1.1.2 MySQL的版本 3

1.2 下载MySQL软件 4

1.3 在Windows系统环境下安装MySQL 6

1.4 在Linux系统环境下安装MySQL 12

1.4.1 下载MySQL的RPM包 12

1.4.2 安装MySQL的RPM包 12

1.5 测试安装环境 14

1.5.1 检查MySQL服务是否启动 14

1.5.2 登录MySQL数据库 15

1.6 合理配置环境变量 16

1.7 卸载MySQL数据库 18

1.8 就业面试技巧与解析 19

1.8.1 面试技巧与解析（一） 19

1.8.2 面试技巧与解析（二） 19

1.8.3 面试技巧与解析（三） 19

第2章　数据库初探 20

◎ 本章教学微视频：14个　38分钟 20

2.1 快速认识数据库 20

2.1.1 什么是数据库 20

2.1.2 数据库的原理 21

2.1.3 数据表 22

2.1.4 数据类型 22

2.1.5 主键 22

2.2 数据库技术构成 22

2.2.1 数据库系统 22

2.2.2 SQL语言 23

2.2.3 数据库访问技术 23

2.3 关系型数据模型 24

2.3.1 关系型数据模型的结构 24

2.3.2 关系型数据模型的操作与完整性 25

2.3.3 关系型数据模型的存储结构 27

2.4 关系型数据模型中的数据依赖与范式 27

2.5 常见的关系型数据库管理系统 28

2.6 MySQL体系结构 29

2.7 就业面试技巧与解析 31

2.7.1 面试技巧与解析（一） 31

2.7.2 面试技巧与解析（二） 31

第3章　MySQL常用管理工具的使用 32

◎ 本章教学微视频：11个　40分钟 32

3.1 phpMyAdmin 32

3.1.1 基本功能介绍 32

3.1.2 管理数据库 34

3.2 Navicat for MySQL 40

3.2.1 基本功能介绍 40

3.2.2 基本应用 40

3.3 MySQL Workbench 51

3.3.1 MySQL Workbench的概述 51

3.3.2 MySQL Workbench的优势 51

3.3.3 SQL Development的基本操作 51

3.4 MySQL用户账户管理 57

3.5 MySQL权限系统 60

3.6 MySQL的安全性问题 64

3.6.1 加强MySQL数据库的安全 64

3.6.2 为MySQL管理账号加上密码 64

3.7 就业面试技巧与解析 65

3.7.1 面试技巧与解析（一） 65

3.7.2 面试技巧与解析（二） 66

第4章　MySQL数据库的基本操作 67

◎ 本章教学微视频：11个　21分钟 67

4.1 创建数据库 67

4.1.1 创建数据库的语法形式 67

4.1.2 创建数据库实例 67

4.2 查看与选择数据库 69

4.2.1 查看数据库 69

4.2.2 选择数据库 69

4.3 删除数据库 69

4.3.1 删除数据库的语法形式 70

4.3.2 删除数据库实例 70

4.4 数据库存储引擎 70

4.4.1 MySQL存储引擎简介 70

4.4.2 InnoDB存储引擎 72

4.4.3 MyISAM存储引擎 72

4.4.4 MEMORY存储引擎 73

4.4.5 存储引擎的选择 73

4.5 就业面试技巧与解析 74

4.5.1 面试技巧与解析（一） 74

4.5.2 面试技巧与解析（二） 74




164. 数据库的三范式是什么？

第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。

第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在
仅依赖主关键字一部分的属性。

第三范式：任何非主属性不依赖于其它非主属性。
165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？

表类型如果是 InnoDB，那 id 就是 6。
表类型如果是 MyISAM ，那 id 就是 8。
一张表里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把mysql重启，再insert一条记录，这条记录的ID是18还是15 ？

一般情况下，我们创建的表的类型是InnoDB，如果新增一条记录（不重启mysql的情况下），这条记录的id是18；但是如果重启（文中提到的）MySQL的话，这条记录的ID是15。因为InnoDB表只把自增主键的最大ID记录到内存中，所以重启数据库或者对表OPTIMIZE操作，都会使最大ID丢失。

但是，如果我们使用表的类型是MylSAM，那么这条记录的ID就是18。因为MylSAM表会把自增主键的最大ID记录到数据文件里面，重启MYSQL后，自增主键的最大ID也不会丢失。

注：如果在这17条记录里面删除的是中间的几个记录（比如删除的是10,11,12三条记录），重启MySQL数据库后，insert一条记录后，ID都是18。因为内存或者数据库文件存储都是自增主键最大ID

166. 如何获取当前数据库版本？

使用 select version() 获取当前 MySQL 数据库版本。

167. 说一下 ACID 是什么？

Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
168. char 和 varchar 的区别是什么？

char(n) ：固定长度类型，比如订阅 char(10)，当你输入"abc"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。
chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。
varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。
所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。
169. float 和 double 的区别是什么？

float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。

double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。
170. mysql 的内连接、左连接、右连接有什么区别？

内连接关键字：inner join；左连接：left join；右连接：right join。

内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。

171. mysql 索引是怎么实现的？

索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。

具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。

172. 怎么验证 mysql 的索引是否满足需求？

使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。

explain 语法：explain select * from table where type=1。

173. 说一下数据库的事务隔离？

MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ

可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。

READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。
READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。
REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。
SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。
脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。

不可重复读 ：是指在一个事务内，多次读同一数据。

幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。

174. 说一下 mysql 常用的引擎？

InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。

MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。

175. 说一下 mysql 的行锁和表锁？

MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。

表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。

行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。
176. 说一下乐观锁和悲观锁？

乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。
悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。
数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。

177. mysql 问题排查都有哪些手段？

使用 show processlist 命令查看当前所有连接信息。

使用 explain 命令查询 SQL 语句执行计划。

开启慢查询日志，查看慢查询的 SQL。


178. 如何做 mysql 的性能优化？

为搜索字段创建索引。

避免使用 select *，列出需要查询的字段。

垂直分割分表。

选择正确的存储引擎。

============

本篇文章会分析下一个sql语句在mysql中的执行流程，包括sql的查询在mysql内部会怎么流转，sql语句的更新是怎么完成的。

mysql主要分为Server层和存储引擎层

Server层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog日志模块。

存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，其中InnoDB引擎有自有的日志模块redolog 模块。

InnoDB 5.5.5版本作为默认引擎。

连接器

主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。

查询缓存

连接建立后，执行查询语句的时候，会先查询缓存，Mysql会先校验这个sql是否执行过，以Key-Value的形式缓存在内存中，Key是查询预计，Value是结果集。如果缓存key被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。

Mysql 查询不建议使用缓存，因为对于经常更新的数据来说，缓存的有效时间太短了，往往带来的效果并不好，对于不经常更新的数据来说，使用缓存还是可以的，Mysql 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。

分析器

mysql 没有命中缓存，那么就会进入分析器，分析器主要是用来分析SQL语句是来干嘛的，分析器也会分为几步：

第一步，词法分析，一条SQL语句有多个字符串组成，首先要提取关键字，比如select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。

第二步，语法分析，主要就是判断你输入的sql是否正确，是否符合mysql的语法。

完成这2步之后，mysql就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。

优化器

优化器的作用就是它认为的最优的执行方案去执行（虽然有时候也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。

执行器

当选择了执行方案后，mysql就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。

二、语句分析
2.1 查询语句
说了以上这么多，那么究竟一条sql语句是如何执行的呢？其实我们的sql可以分为2中，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：

select * from tb_student  A where A.age='18' and A.name='张三';
结合上面的说明，我们分析下这个语句的执行流程：

先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在mysql8.0版本以前，会先查询缓存，以这条sql语句为key在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。

通过分析器进行词法分析，提取sql语句的关键元素，比如提取上面这个语句是查询select，提取需要查询的表名为tb_student,需要查询所有的列，查询条件是这个表的id='1'。然后判断这个sql语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。

接下来就是优化器进行确定执行方案，上面的sql语句，可以有两种执行方案：

  a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是18。
  b.先找出学生中年龄18岁的学生，然后再查询姓名为“张三”的学生。
那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。

进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

2.2 更新语句
以上就是一条查询sql的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql语句如下：

update tb_student A set A.age='19' where A.name='张三';
我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，mysql 自带的日志模块式binlog（归档日志），所有的存储引擎都可以使用，我们常用的InnoDB引擎还自带了一个日志模块redo log，我们就以InnoDB模式下来探讨这个语句的执行流程。流程如下：

先查询到张三这一条数据，如果有缓存，也是会用到缓存。

然后拿到查询的语句，把 age 改为19，然后调用引擎API接口，写入这一行数据，InnoDB引擎把数据保存在内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成了，随时可以提交。

执行器收到通知后记录binlog，然后调用引擎接口，提交redo log 为提交状态。

更新完成。

这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗？这就是之前mysql的模式了，MyISAM引擎是没有redo log的，那么我们知道它是不支持事务的，所以并不是说只用一个日志模块不可以，只是InnoDB引擎就是通过redo log来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么redo log 要引入prepare预提交状态？这里我们用反证法来说明下为什么要这么做？

先写redo log 直接提交，然后写 binlog，假设写完redo log 后，机器挂了，binlog日志没有被写入，那么机器重启后，这台机器会通过redo log恢复数据，但是这个时候bingog并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。

先写binlog，然后写redo log，假设写完了binlog，机器异常重启了，由于没有redo log，本机是无法恢复这一条记录的，但是binlog又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

如果采用redo log 两阶段提交的方式就不一样了，写完binglog后，然后再提交redo log就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设redo log 处于预提交状态，binglog也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于mysql的处理机制了，mysql的处理过程如下：

判断redo log 是否完整，如果判断是完整的，就立即提交。

如果redo log 只是预提交但不是commit状态，这个时候就会去判断binlog是否完整，如果完整就提交 redo log, 不完整就回滚事务。

这样就解决了数据一致性的问题。

三、总结
Mysql 主要分为Server曾和引擎层，Server层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用。

引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory等。

sql等执行过程分为两类，

一类对于查询等过程如下：权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎

对于更新等语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit

MySQL作为最流行的关系型数据库管理系统，重要性不言而喻。面试时它也是重点考察对象之一，估计大家都有过被MySQL相关问题支配的经历：

如何理解MySQL中加锁原理以及最终死锁形成的原因 ？

介绍一下连接池的工作方式，为什么 mysql 的连接数说爆就爆了？

简洁描述下 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？
说一下隔离级别的语义，必须使用事务的话绕不开，为什么同样的代码，迁移到 RDS 后行为会不一致？

上面几个问题，你能全部答出来吗？

其实，无论是后端程序员、前端程序员，还是架构师，数据库是所有开发人员需要面对的共性部分。大家工作项目中的性能问题，容易出现瓶颈的地方常常是MySQL这块，用好它对于整体项目性能提升会有很大帮助。可以说MySQL掌握的越深入，你能做的事情就越多。

有些人觉得自己花了不少精力去学如何做MySQL性能优化，但进展不快，很可能忽视了这点：有了性能分析的技术储备，才能更好掌握性能优化。最近我整理了一套MySQL视频，由浅及深讲了MySQL性能分析 + 性能优化，内容很细，基本覆盖了大家日常工作中经常碰到的一些问题，有必要共享给读者。

具体有哪些细节内容？

【 MySQL执行计划查看、索引失效分析、加锁分析 】

1. 索引优化之组合索引的使用技巧

组合索引、最左前缀原则

2. explain执行计划重要参数select_type讲解

MySQL优化器、子查询、联合查询、临时表

3. explain执行计划重要参数type讲解

MySQL优化器、主键索引、唯一索引、非唯一索引、组合索引、索引覆盖

4. explain执行计划重要参数extra讲解

MySQL优化器、索引覆盖、文件排序、ICP

5. 索引失效案例分析

组合索引、最左前缀原则、索引覆盖



【 MySQL锁和事务篇 】

1. InnoDB存储引擎内存结构之Buffer Pool

InnoDB的架构图、InnoDB内存结构和物理文件之间的工作关系、数据页、索引页

2. InnoDB存储引擎内存结构之Redo Log Buffer

InnoDB的架构图、Redo log工作原理和落盘原理

3. InnoDB存储引擎物理文件之系统表空间和用户表空间文件

InnoDB的架构图、系统表空间文件和用户表空间文件

4. InnoDB存储引擎物理文件之重做日志文件和归档文件

InnoDB的架构图、重做日志文件、重做日志缓冲

5. InnoDB存储引擎之重做日志落盘机制

InnoDB的架构图、落盘机制、WAL(Write ahead redo log)、Force-log-at-commit、checkpoint机制

6. InnoDB存储引擎事务原理之原子性、持久性和一致性实现

redo log、undo log和Force Log at Commit机制、checkpoint机制

7. InnoDB存储引擎事务原理之隔离性实现

MVCC、Lock-based CC、一致性非锁定读(consistent nonlocking read)、快照读&当前读

8. InnoDB存储引擎之一条简单SQL的行锁加锁实现分析

record lock、gap lock、next key lock、RR和RC隔离级别、MVCC机制、主键索引、辅助索引

9. InnoDB存储引擎之一条复杂SQL的行锁加锁实现分析

record lock、gap lock、next key lock、RR和RC隔离级别、MVCC机制、主键索引、辅助索引

10. InnoDB存储引擎之死锁原理分析

主键索引、辅助索引、死锁


1、一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？
1.如果表的类型是MyISAM，那么是18.因为MyISAM会把自己增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。
2.如果表的类型是InnoDB，那么是15.InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。

2、Mysql的技术特点是什么？
Mysql数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程SQL服务器、不同的后端、广泛的应用程序编程接口和管理工具。

3、Heap表是什么？
HEAP表存在于内存中，用于临时高速存储。

BLOB或TEXT字段是不允许的

只能使用比较运算符=，<，>，=>，= <

HEAP表不支持AUTO_INCREMENT

索引不可为NULL

4、Mysql服务器默认端口是什么？
Mysql服务器的默认端口是3306。

5、与Oracle相比，Mysql有什么优势？
Mysql是开源软件，随时可用，无需付费。

Mysql是便携式的

带有命令提示符的GUI。

使用Mysql查询浏览器支持管理

6、如何区分FLOAT和DOUBLE？
以下是FLOAT和DOUBLE的区别：

浮点数以8位精度存储在FLOAT中，并且有四个字节。

浮点数存储在DOUBLE中，精度为18位，有八个字节。

7、区分CHAR_LENGTH和LENGTH？
CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。

8、请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？
SQL标准定义的四个隔离级别为：

read uncommited ：读到未提交数据

read committed：脏读，不可重复读

repeatable read：可重读

serializable ：串行事物 详细解释如下： Read Uncommitted（读取未提交内容） 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。 Read Committed（读取提交内容） 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。 Repeatable Read（可重读） 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。 Serializable（可串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在： 1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。 2、非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。 3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。 不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：

9、在Mysql中ENUM的用法是什么？
ENUM是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。

Create table size(name ENUM('Smail,'Medium','Large');

10、如何定义REGEXP？
REGEXP是模式匹配，其中匹配模式在搜索值的任何位置。

11、CHAR和VARCHAR的区别？
以下是CHAR和VARCHAR的区别：

CHAR和VARCHAR类型在存储和检索方面有所不同

CHAR列长度固定为创建表时声明的长度，长度值范围是1到255

当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。

12、列的字符串类型可以是什么？
字符串类型是：

SET

BLOB

ENUM

CHAR

TEXT

VARCHAR

13、如何获取当前的Mysql版本？
SELECT VERSION();用于获取当前Mysql的版本。

14、Mysql中使用什么存储引擎？
存储引擎称为表类型，数据使用各种技术存储在文件中。

技术涉及：

Storage mechanism

Locking levels

Indexing

Capabilities and functions.

15、Mysql驱动程序是什么？
以下是Mysql中可用的驱动程序：

PHP驱动程序

JDBC驱动程序

ODBC驱动程序

CWRAPPER

PYTHON驱动程序

PERL驱动程序

RUBY驱动程序

CAP11PHP驱动程序

Ado.net5.mxj

16、TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？
创建表时TIMESTAMP列用Zero更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP修饰符就将时间戳字段更新为当前时间。

17、主键和候选键有什么区别？
表格的每一行都由主键唯一标识,一个表只有一个主键。

主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。

18、如何使用Unix shell登录Mysql？
我们可以通过以下命令登录：

# [mysql dir]/bin/mysql -h hostname -u -p
19、 myisamchk是用来做什么的？
它用来压缩MyISAM表，这减少了磁盘或内存使用。

20、MYSQL数据库服务器性能分析的方法命令有哪些?
Show status

一些值得监控的变量值：

Bytes_received和Bytes_sent

和服务器之间来往的流量。

Com_*服务器正在执行的命令。

Created_*在查询执行期限间创建的临时表和文件。

Handler_*存储引擎操作。

Select_*不同类型的联接执行计划。

Sort_*几种排序信息。

Show session status like ‘Select’;

Show profiles

SET profiling=1;

Show profiles \G

Show profile;

21、如何控制HEAP表的最大尺寸？
Heal表的大小可通过称为max_heap_table_size的Mysql配置变量来控制。

22、MyISAM Static和MyISAM Dynamic有什么区别？
在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。

MyISAM Static在受损情况下更容易恢复。

23、federated表是什么？
federated表，允许访问位于其他服务器数据库上的表。

24、如果一个表有一列定义为TIMESTAMP，将发生什么？
每当行被更改时，时间戳字段将获取当前时间戳。

25、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？
它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

26、怎样才能找出最后一次插入时分配了哪个自动增量？
LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。

27、你怎么看到为表格定义的所有索引？
索引是通过以下方式为表格定义的：

SHOW INDEX FROM ;

28.、LIKE声明中的％和_是什么意思？
％对应于0个或更多字符，_ 只是LIKE语句中的一个字符。

29、如何在Unix和Mysql时间戳之间进行转换？
UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令

FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令

30、列对比运算符是什么？
在SELECT语句的列比较中使用=，<>，<=，<，> =，>，<<，>>，<=>，AND，OR或LIKE运算符。

31、我们如何得到受查询影响的行数？
行数可以通过以下代码获得：

SELECT COUNT(user_id)FROM users;

32、Mysql查询是否区分大小写？
不区分

SELECT VERSION(), CURRENT_DATE;

SeLect version(), current_date;

seleCt vErSiOn(), current_DATE;
所有这些例子都是一样的，Mysql不区分大小写。

33.、LIKE和REGEXP操作有什么区别？
LIKE和REGEXP运算符用于表示^和％。

SELECT * FROM employee WHERE emp_name LIKE "%b";

SELECT * FROM employee WHERE emp_name REGEXP "^b";
34.、BLOB和TEXT有什么区别？
BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB -

TINYBLOB

BLOB

MEDIUMBLOB和

LONGBLOB

它们只能在所能容纳价值的最大长度上有所不同。

TEXT是一个不区分大小写的BLOB。四种TEXT类型

TINYTEXT

TEXT

MEDIUMTEXT和

LONGTEXT

它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。

BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。

35、mysql_fetch_array和mysql_fetch_object的区别是什么？
以下是mysql_fetch_array和mysql_fetch_object的区别：

mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。

mysql_fetch_object - 从数据库返回结果行作为对象。

36、我们如何在mysql中运行批处理模式？
以下命令用于在批处理模式下运行：

mysql;

mysql mysql.out
37、MyISAM表格将在哪里存储，并且还提供其存储格式？
每个MyISAM表格以三种格式存储在磁盘上：

·“.frm”文件存储表定义

·数据文件具有“.MYD”（MYData）扩展名

索引文件具有“.MYI”（MYIndex）扩展名

38、Mysql中有哪些不同的表格？
共有5种类型的表格：

MyISAM

Heap

Merge

INNODB

ISAM
MyISAM是Mysql的默认存储引擎。

39、ISAM是什么？
ISAM简称为索引顺序访问方法。它是由IBM开发的，用于在磁带等辅助存储系统上存储和检索数据。

40、InnoDB是什么？
lnnoDB是一个由Oracle公司开发的Innobase Oy事务安全存储引擎。

41、Mysql如何优化DISTINCT？
DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。

SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
42、如何输入字符为十六进制数字？
如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。

如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。

43、如何显示前50行？
在Mysql中，使用以下代码查询显示前50行：

SELECT*FROM

LIMIT 0,50;
44、可以使用多少列创建索引？
任何标准表最多可以创建16个索引列。

45、NOW（）和CURRENT_DATE（）有什么区别？
NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。

CURRENT_DATE（）仅显示当前年份，月份和日期。

46、什么样的对象可以使用CREATE语句创建？
以下对象是使用CREATE语句创建的：

DATABASE

EVENT

FUNCTION

INDEX

PROCEDURE

TABLE

TRIGGER

USER

VIEW
47、Mysql表中允许有多少个TRIGGERS？
在Mysql表中允许有六个触发器，如下：

BEFORE INSERT

AFTER INSERT

BEFORE UPDATE

AFTER UPDATE

BEFORE DELETE

AFTER DELETE
48、什么是非标准字符串类型？
以下是非标准字符串类型：

TINYTEXT

TEXT

MEDIUMTEXT

LONGTEXT
49、什么是通用SQL函数？
CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。

FORMAT(X, D)- 格式化数字X到D有效数字。

CURRDATE(), CURRTIME()- 返回当前日期或时间。

NOW（） - 将当前日期和时间作为一个值返回。

MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中提取给定数据。

HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。

DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄

SUBTIMES（A，B） - 确定两次之间的差异。

FROMDAYS（INT） - 将整数天数转换为日期值。
50、解释访问控制列表
ACL（访问控制列表）是与对象关联的权限列表。这个列表是Mysql服务器安全模型的基础，它有助于排除用户无法连接的问题。

Mysql将ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql会按照预定的顺序检查ACL的认证信息和权限。

51、MYSQL支持事务吗？
在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。

但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。

示例如下：

一

START TRANSACTION;

SELECT @A:=SUM(salary) FROM table1 WHERE type=1;

UPDATE table2 SET summmary=@A WHERE type=1;

COMMIT;
52、 mysql里记录货币用什么字段类型好
NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。

例如：

salary DECIMAL(9,2)

在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。

因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI/ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。

同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。Mysql当前不支持DECIMAL/NUMERIC数据类型的这些变种形式的任一种。

这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。

DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。

一个字符用于值的每一位、小数点(如果scale>0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。

DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。

当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。

当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，Mysql存储表示那个范围的相应的端点值。

我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。

53、MYSQL数据表在什么情况下容易损坏？
服务器突然断电导致数据文件损坏。

强制关机，没有先关闭 mysql 服务等。

54、mysql有关权限的表都有哪几个？
Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。

55、Mysql中有哪几种锁？
MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁。

表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低

行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高


### 1、一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？

1.如果表的类型是MyISAM，那么是18.因为MyISAM会把自己增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。
2.如果表的类型是InnoDB，那么是15.InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。

### 2、Mysql的技术特点是什么？

Mysql数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程SQL服务器、不同的后端、广泛的应用程序编程接口和管理工具。

### 3、Heap表是什么？

HEAP表存在于内存中，用于临时高速存储。

BLOB或TEXT字段是不允许的

只能使用比较运算符=，<，>，=>，= <

HEAP表不支持AUTO_INCREMENT

索引不可为NULL

### 4、Mysql服务器默认端口是什么？

Mysql服务器的默认端口是3306。

### 5、与Oracle相比，Mysql有什么优势？

Mysql是开源软件，随时可用，无需付费。

Mysql是便携式的

带有命令提示符的GUI。

使用Mysql查询浏览器支持管理

### 6、如何区分FLOAT和DOUBLE？

以下是FLOAT和DOUBLE的区别：

浮点数以8位精度存储在FLOAT中，并且有四个字节。

浮点数存储在DOUBLE中，精度为18位，有八个字节。

### 7、区分CHAR_LENGTH和LENGTH？

CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。

### 8、请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？

SQL标准定义的四个隔离级别为：

read uncommited ：读到未提交数据

read committed：脏读，不可重复读

repeatable read：可重读

serializable ：串行事物
详细解释如下：
Read Uncommitted（读取未提交内容）
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
Read Committed（读取提交内容）
这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
Repeatable Read（可重读）
这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。
Serializable（可串行化）
这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在：
1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。
2、非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。
3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。
不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：
![](https://ws1.sinaimg.cn/large/006DGX4tly1fvjufj9m9gj30h704it8n.jpg)

### 9、在Mysql中ENUM的用法是什么？

ENUM是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。

Create table size(name ENUM('Smail,'Medium','Large');

### 10、如何定义REGEXP？

REGEXP是模式匹配，其中匹配模式在搜索值的任何位置。

### 11、CHAR和VARCHAR的区别？

以下是CHAR和VARCHAR的区别：

CHAR和VARCHAR类型在存储和检索方面有所不同

CHAR列长度固定为创建表时声明的长度，长度值范围是1到255

当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。

### 12、列的字符串类型可以是什么？

字符串类型是：

SET

BLOB

ENUM

CHAR

TEXT

VARCHAR

### 13、如何获取当前的Mysql版本？

SELECT VERSION();用于获取当前Mysql的版本。

### 14、Mysql中使用什么存储引擎？

存储引擎称为表类型，数据使用各种技术存储在文件中。

技术涉及：

Storage mechanism

Locking levels

Indexing

Capabilities and functions.

### 15、Mysql驱动程序是什么？

以下是Mysql中可用的驱动程序：

PHP驱动程序

JDBC驱动程序

ODBC驱动程序

CWRAPPER

PYTHON驱动程序

PERL驱动程序

RUBY驱动程序

CAP11PHP驱动程序

Ado.net5.mxj

### 16、TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？

创建表时TIMESTAMP列用Zero更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP修饰符就将时间戳字段更新为当前时间。

### 17、主键和候选键有什么区别？

表格的每一行都由主键唯一标识,一个表只有一个主键。

主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。

### 18、如何使用Unix shell登录Mysql？

我们可以通过以下命令登录：
``` sql
# [mysql dir]/bin/mysql -h hostname -u -p
```

### 19、 myisamchk是用来做什么的？

它用来压缩MyISAM表，这减少了磁盘或内存使用。

### 20、MYSQL数据库服务器性能分析的方法命令有哪些?

Show status

一些值得监控的变量值：

Bytes_received和Bytes_sent

和服务器之间来往的流量。

Com_*服务器正在执行的命令。

Created_*在查询执行期限间创建的临时表和文件。

Handler_*存储引擎操作。

Select_*不同类型的联接执行计划。

Sort_*几种排序信息。

Show session status like ‘Select’;

Show profiles

SET profiling=1;

Show profiles \G

Show profile;

### 21、如何控制HEAP表的最大尺寸？

Heal表的大小可通过称为max_heap_table_size的Mysql配置变量来控制。

### 22、MyISAM Static和MyISAM Dynamic有什么区别？

在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。

MyISAM Static在受损情况下更容易恢复。

### 23、federated表是什么？

federated表，允许访问位于其他服务器数据库上的表。

### 24、如果一个表有一列定义为TIMESTAMP，将发生什么？

每当行被更改时，时间戳字段将获取当前时间戳。

### 25、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？

它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

### 26、怎样才能找出最后一次插入时分配了哪个自动增量？

LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。

### 27、你怎么看到为表格定义的所有索引？

索引是通过以下方式为表格定义的：

SHOW INDEX FROM ;

### 28.、LIKE声明中的％和_是什么意思？

％对应于0个或更多字符，_ 只是LIKE语句中的一个字符。

### 29、如何在Unix和Mysql时间戳之间进行转换？

UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令

FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令

### 30、列对比运算符是什么？

在SELECT语句的列比较中使用=，<>，<=，<，> =，>，<<，>>，<=>，AND，OR或LIKE运算符。

### 31、我们如何得到受查询影响的行数？

行数可以通过以下代码获得：

SELECT COUNT(user_id)FROM users;

### 32、Mysql查询是否区分大小写？

不区分
``` sql
SELECT VERSION(), CURRENT_DATE;

SeLect version(), current_date;

seleCt vErSiOn(), current_DATE;
```
所有这些例子都是一样的，Mysql不区分大小写。

### 33.、LIKE和REGEXP操作有什么区别？

LIKE和REGEXP运算符用于表示^和％。
``` sql
SELECT * FROM employee WHERE emp_name LIKE "%b";

SELECT * FROM employee WHERE emp_name REGEXP "^b";
```

### 34.、BLOB和TEXT有什么区别？

BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB -

TINYBLOB

BLOB

MEDIUMBLOB和

LONGBLOB

它们只能在所能容纳价值的最大长度上有所不同。

TEXT是一个不区分大小写的BLOB。四种TEXT类型

TINYTEXT

TEXT

MEDIUMTEXT和

LONGTEXT

它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。

BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。

### 35、mysql_fetch_array和mysql_fetch_object的区别是什么？

以下是mysql_fetch_array和mysql_fetch_object的区别：

- mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。

- mysql_fetch_object - 从数据库返回结果行作为对象。

### 36、我们如何在mysql中运行批处理模式？

以下命令用于在批处理模式下运行：
``` sql
mysql;

mysql mysql.out
```

### 37、MyISAM表格将在哪里存储，并且还提供其存储格式？

每个MyISAM表格以三种格式存储在磁盘上：

·“.frm”文件存储表定义

·数据文件具有“.MYD”（MYData）扩展名

索引文件具有“.MYI”（MYIndex）扩展名

### 38、Mysql中有哪些不同的表格？

共有5种类型的表格：
```
MyISAM

Heap

Merge

INNODB

ISAM
```

MyISAM是Mysql的默认存储引擎。

### 39、ISAM是什么？

ISAM简称为索引顺序访问方法。它是由IBM开发的，用于在磁带等辅助存储系统上存储和检索数据。

### 40、InnoDB是什么？

lnnoDB是一个由Oracle公司开发的Innobase Oy事务安全存储引擎。

### 41、Mysql如何优化DISTINCT？

DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。
``` sql
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
```

### 42、如何输入字符为十六进制数字？

如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。

如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。

### 43、如何显示前50行？

在Mysql中，使用以下代码查询显示前50行：
``` sql
SELECT*FROM

LIMIT 0,50;
```

### 44、可以使用多少列创建索引？

任何标准表最多可以创建16个索引列。

### 45、NOW（）和CURRENT_DATE（）有什么区别？

NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。

CURRENT_DATE（）仅显示当前年份，月份和日期。

### 46、什么样的对象可以使用CREATE语句创建？

以下对象是使用CREATE语句创建的：
```
DATABASE

EVENT

FUNCTION

INDEX

PROCEDURE

TABLE

TRIGGER

USER

VIEW
```

### 47、Mysql表中允许有多少个TRIGGERS？

在Mysql表中允许有六个触发器，如下：
```
BEFORE INSERT

AFTER INSERT

BEFORE UPDATE

AFTER UPDATE

BEFORE DELETE

AFTER DELETE
```

### 48、什么是非标准字符串类型？

以下是非标准字符串类型：
```
TINYTEXT

TEXT

MEDIUMTEXT

LONGTEXT
```

### 49、什么是通用SQL函数？

```
CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。

FORMAT(X, D)- 格式化数字X到D有效数字。

CURRDATE(), CURRTIME()- 返回当前日期或时间。

NOW（） - 将当前日期和时间作为一个值返回。

MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中提取给定数据。

HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。

DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄

SUBTIMES（A，B） - 确定两次之间的差异。

FROMDAYS（INT） - 将整数天数转换为日期值。
```

### 50、解释访问控制列表

ACL（访问控制列表）是与对象关联的权限列表。这个列表是Mysql服务器安全模型的基础，它有助于排除用户无法连接的问题。

Mysql将ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql会按照预定的顺序检查ACL的认证信息和权限。

### 51、MYSQL支持事务吗？

在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。

但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。

示例如下：
```
一

START TRANSACTION;

SELECT @A:=SUM(salary) FROM table1 WHERE type=1;

UPDATE table2 SET summmary=@A WHERE type=1;

COMMIT;
```

### 52、 mysql里记录货币用什么字段类型好

NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。

例如：

salary DECIMAL(9,2)

在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。

因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI/ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。

同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。Mysql当前不支持DECIMAL/NUMERIC数据类型的这些变种形式的任一种。

这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。

DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。

一个字符用于值的每一位、小数点(如果scale>0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。

DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。

当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。

当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，Mysql存储表示那个范围的相应的端点值。

我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。

### 53、MYSQL数据表在什么情况下容易损坏？

服务器突然断电导致数据文件损坏。

强制关机，没有先关闭 mysql 服务等。

### 54、mysql有关权限的表都有哪几个？

Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。

### 55、Mysql中有哪几种锁？

MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁。

- 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低

- 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高

一条查询SQL执行流程图如下



本文改编自《高性能Mysql》，烟哥用小说的形式来讲这个内容。
序章 自我介绍
我是一条sql，就是一条长长的字符串，不要问我长什么样，因为我比较傲娇。




额~~不是我不说啊，因为细说起来，我可以细分为DML(Update、Insert、Delete),DDL(表结构修改),DCL(权限操作),DQL(Select)操作,一个个去介绍，我怕大家嫌我烦！
嗯，大家没什么意见，我继续往下自我介绍了~
由于种类太多，这里我只是一条查询SQL，也就是一句DQL。
客户端按照Mysql通信协议，把我发送到服务端。
当我到达服务端后，我会在一个单独的线程里进行执行。服务端要先…



万万没想到，我又被打断了~好吧，因为我在一个线程里执行，总要有办法能看到线程的执行状态吧。Mysql提供了下面的命令，给大家查看
SHOW [FULL] PROCESSLIST
出来的结果是长下面这样的



图里Command这一列，反应的就是这个线程当前的执行状态啦。我在这个线程的执行过程中，状态是会变化很多次。
你看图里，有一个Sleep，这是在告诉你线程正在等待客户端发送新的请求。还有一个为Query,这代表线程正在执行查询或者正在将结果发送给客户端。
至于其他的，还有Locked、Sending data等等，分别代表…



额，好吧，唠唠叨叨了一大堆，大家居然木有嫌我烦，嗯，至于其他状态的含义大家可以去Mysql官网查询哦。
嗯，回到刚才的话题。我到达服务端后，Mysql要判断我的前6个字符是否为select。并且，语句中不带有SQL_NO_CACHE关键字，如果符合条件，就进入查询缓存。
第一章 我和查询缓存的那些事
说到查询缓存，它其实是一个哈希表，它将执行过的语句及其结果会以 key-value 对的形式，被直接缓存在内存中。
它的key是一个哈希值，是通过查询SQL(也就是我)、当前要查询的数据库、客户端协议版本等，生成的一个哈希值，而它的value自然就是查询结果啦。

当然，如果我要绕过查询缓存，也很简单。我可以像下面这么写:

Select SQL_NO_CACHE * from table
也可以将参数query_cache_type设置成DEMAND来绕过查询缓存。

可是，有一天查询缓存悲伤的对我说:"你将来再也看不到我了，我已经被历史淘汰了，Mysql8.0版本开始就没有我了！"
听到这个消息后，我表面上故作坚强的对查询缓存说:"不要方，大家会想你的！"
然而，实际上心里想的是:"嘿嘿嘿，你个坑爹的，终于不存在了！"大家不要觉得我太邪恶，毕竟查询缓存实在是太不好用了。接下来我们来说说解析器…




万万没想到，本来想糊弄过去的。结果…好吧，回到正题，因为
只要有对一个表的更新，这个表上所有的查询缓存都会被清空

SQL任何字符上的不同,如空格,注释,都会导致缓存不命中

因此，我能想到用查询缓存的表，只有一种情况，那就是配置表。其他的业务表，根本是无法利用查询缓存的特性，或许Mysql团队也是觉得查询缓存的使用场景过于局限，就无情的将它剔除。

第二章 我和分析器的爱恨情仇
(本文将解析器和预处理器统一称为分析器)
话说，我离开查询缓存后，进入解析器。
解析器:"来来来，我先对你进行词法分析，告诉我你长啥样？"
我是下面这样的

select username from userinfo
解析器:"好，好，好。我有两个阶段，我先对你进行词法分析，我将你从左到右一个字符、一个字符地输入，然后根据构词规则识别单词。你将会生成4个Token,如下所示。"



解析器:"接下来呢，进行语法解析，判断你输入的这个 SQL 语句是否满足 MySQL 语法。然后生成下面这样一颗语法树。"



我："如果语法不对呢？"
解析器:"那你会收到一个提示如下！"
You have an error in your SQL syntax
解析器:"顺利生成语法树以后，我就将你送往预处理器！"
预处理器:"老弟，你来拉!"
我:"嗯！"
预处理器:"老弟，我来帮你看看你的列名对不对，数据库的这张表里是不是真的有这个列。再看看表名对不对，如果不对，你会看到下面的错误！"

Unknown column xxx in ‘where clause’
预处理器:"最后我再给你送去做权限验证，如果你没有操作这个表的权限，会报下面这个错误!"

ERROR 1142 (42000): SELECT command denied to user 'root'@'localhost' for table 'xxx'
（这个地方，大家可能有疑问，因为有些文章说是执行器做的权限验证，可以直接拉到本文底部看说明）

最后，这颗语法树会传递给优化器。

第三章 我和优化器的动人过往
在告别了解析器后，我进入了优化器。
优化器大哥:"告诉我，你长什么样啊？"
我说道:"大哥不要捉急，我是长这样的~"(这里优化的其实应该是语法树，我只是为了便于说明，才用SQL当例子，实际上是针对语法树进行优化)

select t1.*
from Table1 t1
inner join Table2 t2
on t1.CommonID = t2.CommonID
优化器大哥:"我的任务就是帮你判断一下怎么样执行更快，比如先查Table1再查Table2，还是先查Table2再查Table1呢？判断完如何执行以后，生成执行计划就好啦！"
我很不信任的说道：“哼，你就不会判断失误么！”
优化器大哥:"那就要对SQL进行改写啦，比如你带了STRAIGHT_JOIN关键字，长下面这样"

select t1.*
from Table1 t1
STRAIGHT_JOIN  Table2 t2
on t1.CommonID = t2.CommonID
"那我就知道强制先找Table1再关联找Table2啦，类似的例子还有很多，我就不一一列举了！"
(STRAIGHT_JOIN功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。)

我说道:"哇塞，如何编写一个高效的SQL，真是一门学问啊！"
于是，优化器大哥将我变身为一个执行计划，然后交给执行器啦~

第四章 我和执行器的悲情经历
我:"执行器大哥，你是用来做什么的？"
执行器:"就是根据执行计划来进行执行查询啦。我就根据你的指令，逐条调用底层存储引擎，逐步执行。"
MySQL定义了一系列抽象存储引擎API，以支持插件式存储引擎架构。Mysql实现了一个抽象接口层，叫做 handler(sql/handler.h)，其中定义了接口函数，比如：ha_open, ha_index_end, ha_create等等，存储引擎需要实现这些接口才能被系统使用。

末章 一些感慨
最后一个阶段，Mysql会将查询结果返回客户端。
唯一需要说明的是，如果是SELECT类型的SQL，Mysql会将查询结果缓存起来。至于其他的SQL，就将该表涉及到的查询缓存清空。

一些疑问
这里关于权限验证究竟在哪个阶段执行，大家可能会有一些疑问。
之前有一个大牛的文章说是权限验证是在执行阶段，去执行前验证权限，大家如果看过他的文章，可能会有疑问。我也不是乱质疑人家，毕竟我只是一个小咖。我在这里只是发表一下我自己的论点，欢迎大家拍砖。

论点一:权限验证在执行器中判断从逻辑上说不通
一条查询SQL经过查询缓存、分析器、优化器，执行器。如果到最后一个阶段执行器中才发现权限不足、那不是前面一系列流程白做了，Mysql应该不至于这么傻吧~

论点二:同《高性能Mysql》一书内容不符
该书209页有一句话如下图所示




该书也指明权限验证是在预处理器中执行。本文中将预处理和解析器统一划分为分析器的范畴。
论点三:同源码不符
我翻看了Mysql5.7.25这个版本的源码，其在处理查询这段的核心代码如下
在sql_parse.cc文件中，有这么一段代码如下

case SQLCOM_SELECT:
 {
    //省略
    res= select_precheck(thd, lex, all_tables, first_table);
    if (!res)
      res= execute_sqlcom_select(thd, all_tables);
    //省略
  }
其中select_precheck是进行权限校验。而优化器和执行器是在execute_sqlcom_select这个方法中。



SQL开发规范
更新时间：2019-04-29 15:51:33


本页目录
总则
常见SQL优化细节
总则
分析型数据库MySQL版是一个分布式、列存数据库，在编写和优化SQL时，需要充分考虑其分布式特性。

在分析型数据库MySQL版中，编写和优化SQL的要求和经验总结如下：

SQL编写原则：追求简单

一般情况下，数据库性能会随SQL复杂度而下降。例如，单表查询（冗余设计）优于表关联查询。

SQL优化核心方法：减少I/O

尽可能少的进行列扫描，返回最小数据量，减少I/O同时也减少内存开销。

分布式计算：本地计算&并行计算 大数据计算情况下，本地计算时充分利用分布式多计算资源的能力，避免数据跨节点。

高QPS：分区裁剪 业务系统要求高QPS、毫秒级RT时，表和SQL必须设计为分区裁剪模式。

常见SQL优化细节
去掉不必要的列
分析型数据库MySQL版是列存数据库，返回的列的数量直接影响性能，在编写SQL时一定要确认业务需要返回的列，不要直接使用*。

典型错误SQL写法

  select * from tab1 where c1>100 and c1<1000;
正确SQL写法

  select col1, col2 from table_name where c1>100 and c1<1000;
索引&扫描
当SQL包含多个查询条件时，优先选择高筛选条件，其他条件可以通过扫描实现。

原理
分析型数据库MySQL版内部采用列存方式，通过单列高效过滤后，可直接通过内部记录指针扫描其他列值，减少其他列的索引查询开销。

示例
time条件通过内部扫描

以下SQL通过条件c1=3可快速查询到少量记录（假设10000），单独使用time>'2010-01-01 00:00:00'时返回的记录数又非常大。

select c1,c2 from tab1 where c1=3 and time >='2010-01-01 00:00:00';
此时可只通过c1进行索引，time通过内部扫描方式执行，查询更快，返回更多有效记录数。SQL示例如下：

/* +no-index=[tab1.time] */
select c1,c2 from tab1
where c1=3 and time>='2010-01-01 00:00:00';
/* +no-index=[tab1.time] */
Hint表示强制time>='2010-01-01 00:00:00'条件走扫描。

在上述SQL中，计算引擎首先检索列c1的索引，得出满足条件c1=3的行集合，然后读取每行所对应的time列数据。如果满足time>='2010-01-01 00:00:00'，则将该行数据加入返回结果。

不等于条件通过内部扫描

不等于条件查询，例如：c2<>100，不通过索引扫描时，c2<>100无法有效过滤掉无效记录。例如：

select c1,c2 from tab1 where c1=3 and c2<>100;
增加no-indexHint，使不等于条件通过内部扫描执行，SQL示例如下：

/* +no-index=[tab1.c2] */
select c1,c2 from tab1 where c1=3 and c2<>100;
like条件通过内部扫描

中缀或后缀查询，例如：like '%abc'或like '%abc%'。

增加no-indexHint，使like条件通过内部扫描执行，更加快速地查询有效记录，SQL示例如下：

/* +no-index=[tab1.c3] */
select c1,c2 from tab1 where c1=3 and c3 like '%abc%';
索引失效
索引失效时，SQL语句直接以扫描的方式进行查询，如果表记录数非常大，会导致查询缓慢。

以下情形容易引起索引失效：

• 函数转换（列）；

• 类型转换；

• like条件，例如：like '%abc%'。

以下SQL中的函数转换导致索引失效。time为timestamp类型，存储时间2017-12-10 10:00:23。

select c1,c2 from tab1 where substr(cast(time as varchar),1,10)='2017-
10-12';
正确SQL：

select c1,c2 from tab1 where time>='2017-10-12 00:00:00' and time<='2017-10-12 23:59:59';
is not null
去掉不必要的is not null过滤条件。

示例
Select c1, c2 from tab1 where c1>100 and c1<1000 and c1 is not null;
示例SQL中的and c1 is not null为多余条件，优化后SQL如下：

Select c1,c2 from tab1 where c1>100 and c1<1000;
多表关联
普通表join普通表，尽量包含分区列join条件，如果不包含则，尽量通过where条件过滤掉多余的数据。

维度表join普通表，没有限制。

多表关联查询where条件中，需要明确写明每一个表的过滤条件。通常我们在传统数据库中，都是通过索引字段关联来快速检索数据。如下SQL:

Select count(*)
from customer_table C join
order_table O on C.customer_id= O.customer_id
where O.order_time between'2018-07-20 10:00:11'
and '2018-09-30 10:00:11'
and O.order_amount=100;
在明确t2与t1表都有同样的time和type过滤条件情况下，建议修改为如下SQL：

Select count(*)
from t1 join t2 on t1.id=t2.id
where t1.time between '2017-12-10 00:00:00' and '2017-12-10 23:59:59'
and t1.type= 100
and t2.time between '2017-12-10 00:00:00' and '2017-12-10 23:59:59'
and t2.type=100

=====================

本章节以简化的业务场景来介绍电子商务的最佳实践。

业务场景和要求
本例中简化的业务场景包含三个数据表：客户信息表、订单表、商品类型表（维度表）。

业务场景要求如下：

统计不同客户群体在不同时间段的数据。

RT<60秒。

每秒查询率QPS（ Query Per Second ）：偶尔查询。

表的逻辑设计
客户信息表（t_fact_customers）

数据量：约有五亿客户

字段名	数据类型	说明
customer_id	varchar	客户编号
customer_name	varchar	客户姓名
phone_number	varchar	电话
address	varchar	地址
last_login_time	timestamp	最近登录时间
age	int	年龄
订单表（t_fact_orders）

数据量：每日订单量5000万，需要存储三年的数据，总数据量约550亿。

字段名	数据类型	说明
order_id	varchar	订单编号
customer_id	varchar	客户编号
goods_id	bigint	商品编号
numbers	bigint	数量
total_price	double	总价
order_time	timestamp	订单时间
order_date	bigint	订单日期（二级分区）
商品类型表（t_dim_goods）

商品总数约100万

字段名	数据类型	说明
goods_id	bigint	商品id
price	double	单价
class	bigint	类型
name	varchar	名称
update_time	timestamp	更新时间
表的物理设计
物理设计的目的是获得最佳性能，在进行表的物理设计前，必须了解表的查询SQL，才能决策表的最佳分片策略。假设本例中大部分查询都需要关联查询客户表+订单表，那么我们优先考虑以customer_id进行一级分区，每个节点的计算都是本地数据。

创建表组ads_demo
表组为ads_demo，两个副本，SQL查询超时为30秒。创建表组的SQL语句如下：

create tablegroup ads_demo;
创建表
创建t_fact_customers表
每个分区数据量390万=5亿/128个一级分区。创建t_fact_customers表的SQL语句如下。

CREATE TABLE t_fact_customers (
customer_id varchar COMMENT '',
customer_name varchar COMMENT '',
phone_number varchar COMMENT '',
address varchar COMMENT '',
last_login_time timestamp COMMENT '',
age int COMMENT '',
PRIMARY KEY (customer_id)
)
PARTITION BY HASH KEY (customer_id) PARTITION NUM 128
TABLEGROUP ads_demo
OPTIONS (UPDATETYPE='realtime')
COMMENT '';
创建t_fact_orders表
二级分区键order_date为bigint数据类型。根据数据量和存储总时间，按月（201712）间隔，每月一个二级分区，每个二级分区数据量为：1193万 = 550亿/（128个一级分区）/(3年*12个月)。创建表的SQL语句如下：

CREATE TABLE t_fact_orders (
order_id varchar COMMENT '',
customer_id varchar COMMENT '',
goods_id bigint COMMENT '',
numbers bigint COMMENT '',
total_price double COMMENT '',
order_time timestamp COMMENT '',
order_date bigint COMMENT '',
PRIMARY KEY (order_id,customer_id,order_date)
)
PARTITION BY HASH KEY (customer_id) PARTITION NUM 128
SUBPARTITION BY LIST KEY (order_date)
SUBPARTITION OPTIONS (available_partition_num = 90)
TABLEGROUP ads_demo
OPTIONS (UPDATETYPE='realtime')
COMMENT '';
创建t_dim_goods商品信息表（维度表）
CREATE DIMENSION TABLE t_dim_goods (
goods_id bigint comment '',
price double comment '',
class bigint comment '',
name VARCHAR comment '',
update_time TIMESTAMP comment '',
primary key (goods_id)
)
OPTIONS (UPDATETYPE='realtime');
查询SQL
按年龄段统计在一段时间内订单的客户数量、订单销售总额。

SELECT
case when cus.age <= 30 then '<20' when cus.age>20
and cus.age <= 30 then '20-30' when cus.age>30
and cus.age <= 40 then '30-40' else '>40' end as age_range,
COUNT(distinct cus.customer_id),
SUM(total_price)
FROM
t_fact_customers cus LEFT JOIN t_fact_orders ord ON cus.customer_id =ord.customer_id
WHERE ord.order_time >= '2017-10-01 00:00:00' AND ord.order_time < '
2017-11-01 00:00:00'
AND ord.order_date = 201710
GROUP BY age_range;
可以增加二级分区条件，进行二级分区裁剪，提高查询效率。

==============
物流快递
更新时间：2018-12-02 20:40:16


本页目录
业务场景和要求
表的逻辑设计
表的物理设计
查询SQL
本章节以简化的业务场景来介绍物流快递的最佳实践。

业务场景和要求
本例中简化的业务场景：仅包括邮件状态表用于实时监控和更新邮件包裹状态，包裹从订单、收单、装车、…、投递分为不同的状态。

业务要求：每个机构实时统计当前不同状态的邮件数量。

业务性能要求：

实时统计新增数据，且要求一秒以内返回结果（即RT<1s）。

查询并发量：QPS>300 。

表的逻辑设计
邮件状态表（t_fact_mail_status）
要求：

单日数据量约一亿记录；
有15万机构或快递员，每个机构的邮件量为100到3000不等；
存储30天的数据。
为满足高QPS，从设计上采用大宽表、冗余字段，并且避免表关联。

字段名	字段类型	说明
mail_id	varchar	邮件订单唯一码
scan_timestamp	timestamp	收件时间
biz_date	bigint	日期（二级分区）
org_code	varchar	机构编码
org_name	varchar	机构名称
dlv_person_name	varchar	投递员名称
receiver_name	varchar	收件人名
receiver_phone	varchar	收件人电话
receiver_addr 收件人地址	varchar	收件人地址
product_no 产品编码	varchar	产品编码
mag_no	varchar	包裹编号
op_1_timestamp	bigint	状态1操作时间
op_2_timestamp	bigint	状态2操作时间
op_3_timestamp	bigint	状态3操作时间
op_4_timestamp	bigint	状态4操作时间
op_5_timestamp	bigint	状态5操作时间
表的物理设计
创建邮件状态表 t_fact_mail_status ，需要规划表的一级分区、二级分区。业务查询主要按机构进行查询，QPS要求高。综上所述， 我们选择按org_code进行一级分区。

CREATE TABLE t_fact_mail_status (
mail_id varchar COMMENT '',
scan_timestamp timestamp COMMENT '',
biz_date bigint COMMENT '',
org_code varchar COMMENT '',
org_name varchar COMMENT '',
dlv_person_name varchar COMMENT '',
receiver_name varchar COMMENT '',
receiver_phone varchar COMMENT '',
receiver_addr varchar COMMENT '',
product_no varchar COMMENT '',
mag_no varchar COMMENT '',
op_1_timestamp bigint COMMENT '',
op_2_timestamp bigint COMMENT '',
op_3_timestamp bigint COMMENT '',
op_4_timestamp bigint COMMENT '',
op_5_timestamp bigint COMMENT '',
PRIMARY KEY (mail_id,org_code,biz_date)
)
PARTITION BY HASH KEY (org_code) PARTITION NUM 128
SUBPARTITION BY LIST KEY (biz_date)
SUBPARTITION OPTIONS (available_partition_num = 30)
TABLEGROUP ads_demo
OPTIONS (UPDATETYPE='realtime')
COMMENT '';
查询SQL
要求：

查询当天某机构号

不同状态的邮件数据量

核查需要操作的邮件量

RT<1s 并且高QPS

综上所述，须利用分区裁剪，使单个查询在不同的节点上运行。SQL语句示例如下：

select sum(case when t.op_1_timestamp >= 20171128000000 and t.
op_1_timestamp <= 20171128235900
and(( t.op_2_timestamp is null or t.op_2_timestamp >
20171128235900 or t.op_2_timestamp < 20171128000000)
and( t.op_3_timestamp is null or t.op_3_timestamp >
20171128235900 or t.op_3_timestamp < 20171128000000)
and( t.op_4_timestamp is null or t.op_4_timestamp >
20171128235900 or t.op_4_timestamp < 20171128000000))
then 1 else 0 end ) as cn
from t_fact_mail_status t
where t.org_code = '21111101' and t.biz_date = 20171128;

交通
更新时间：2018-12-02 20:40:16


本章节以简化的业务场景来介绍车辆通行的最佳实践。

业务场景和要求
本例中简化的业务场景：记录主要交通路口（卡口）的车辆通行信息。要求：

每日有一亿的实时增量数据，数据需要存储五年。

可实时查询每个路口车辆通行情况。例如：某一时间段通过该路口的车辆总数、车辆详单信息等。

可按车辆拍照号码查询一段时间内的车辆的详单信息。

表的逻辑设计
车辆信息表（t_fact_vehicle_info）
字段名	字段类型	说明
uuid	varchar	唯一标识
access_time	varchar	接收时间
gate_number	varchar	卡口编码
device_num	varchar
pass_time	varchar	过车时间
vehicle_number	varchar	号牌号码
vehicle_num_type	varchar	号牌种类
speed	double	行驶速度
picture_url	varchar
pt_month
表的物理设计
按车辆拍照进行HASH一级分区，可均匀的将数据分布到所有分区上。

按卡口编号设置聚集列。

二级分区按月存储，存储五年（60个月的数据），设置二级分区数为61。

创建表组
根据业务场景和要求，创建以下表组和表：

create tablegroup app_group;
创建t_fact_vehicle_info表
CREATE TABLE t_fact_vehicle_info (
uuid varchar NOT NULL COMMENT '唯一标识',
access_time varchar DEFAULT '0' COMMENT '接收时间',
gate_number varchar DEFAULT '0' COMMENT '卡口编码',
device_num varchar DEFAULT '0' COMMENT '',
pass_time varchar DEFAULT '0' COMMENT '过车时间',
vehicle_number varchar DEFAULT '' COMMENT '号牌号码',
vehicle_num_type varchar DEFAULT '' COMMENT '号牌种类',
speed double DEFAULT 0 COMMENT '行驶速度',
picture_url varchar DEFAULT '' COMMENT '',
pt_month bigint COMMENT '',
PRIMARY KEY (uuid,vehicle_number,pt_month)
)
PARTITION BY HASH KEY (vehicle_number) PARTITION NUM 256
SUBPARTITION BY LIST KEY (pt_month)
SUBPARTITION OPTIONS (available_partition_num = 61)
CLUSTERED BY (gate_number)
TABLEGROUP app_group
OPTIONS (UPDATETYPE='realtime')
COMMENT '过车信息';
查询SQL
查询某车牌号码某一段时间内的详单数据：

select * from t_fact_vehicle_info
where vehicle_number='xxxxx'
and pass_time between '2017-10-10 09:00:00'
and '2018-03-01 10:00:00'
and pt_month between 20171010 and 20180301;
查询30分钟内某一路口通过车辆总数信息：

select count(*) from t_fact_vehicle_info
where gate_number='xxxxx'
and pass_time between '2018-03-01 09:00:00' and '2018-03-01 09:30:00'
and pt_month =20180301;
 上一篇：物流快递
下一篇：产品和业务限制

全文检索最佳实践
更新时间：2019-04-29 15:51:48


本页目录
按近似度排序
结果集过滤
多列查询
短语查询、精确匹配
逻辑操作符 AND OR NOT
结构化、非结构化联合检索
高级SQL语法：结构化、非结构化融合GROUP BY, JOIN, UNION
分析型数据库MySQL版除了支持基本的全文检索方式还支持以下方式

按近似度排序
结果集过滤
多列查询
短语查询、精确匹配
逻辑操作符AND OR NOT
结构化、非结构化联合检索
高级SQL语法：结构化、非结构化GROUP BY, JOIN, UNION
按近似度排序
SQL语义规定在不带ORDER BY的情况下不会按照近似度排序。如果需要将所有命中结果按照近似度从高到低排序，则使用如下SQL语法。

如果需要将结果按照近似度从高到低排序，则加上ORDER BY DESC

SELECT id, title, author, body
FROM articles_test
WHERE match(title) against ('浙江省杭州市')
ORDER BY match(title) against ('浙江省杭州市') DESC
LIMIT 100;
结果集过滤
全文检索会召回所有跟关键词近似的结果。在某些数据量很大的场景中，命中关键词的结果集可能也很大，但是往往只需要取出近似度较高的部分结果。

分析型数据库MySQL版提供了结果集过滤的功能，如下列子中where match() against() > 0.9 表示只取近似度排在前10%的结果，过滤掉了90%的低近似度结果。

SELECT id, title, author, body
FROM articles_test
WHERE match(title) against ('浙江省杭州市') > 0.9
ORDER BY match(title) against ('浙江省杭州市') DESC
LIMIT 100;
多列查询
在title，body两列中同时检索”浙江省杭州市”关键字，返回近似度排在前10%的结果行，并且将结果行按照近似度逆序排列。

SELECT id, title, author, body
FROM articles_test
WHERE match(title,body) against ('浙江省杭州市') > 0.9
ORDER BY match(title, body) against ('浙江省杭州市') DESC
LIMIT 100;
短语查询、精确匹配
默认情况下，分析型数据库MySQL版全文检索会对词语进行分词后，再进行检索。比如检索”中华人民共和国”会被分词为”中华”、”人民”、”共和国”三个词分别检索。但是某些特殊情况下，可能需要完全精确的短语匹配。比如只希望返回完全精确匹配”中华人民共和国”的结果，而不希望返回分词后的检索结果，则使用短语查询语法。语法格式为：在检索关键词上加双引号。

基本查询：分词后再检索。注意关键词的写法：没有双引号。

SELECT id, title, author, body
FROM articles_test
WHERE match(body) against ('中华人民共和国') > 0.9
ORDER BY match(body) against ('中华人民共和国') DESC
LIMIT 100;
短语查询：精确匹配，不会做分词处理。注意关键词的写法，有双引号。

SELECT id, title, author, body
FROM articles_test
WHERE match(body) against ('"中华人民共和国"') > 0.9
ORDER BY match(body) against ('"中华人民共和国"') DESC
LIMIT 100;
逻辑操作符 AND OR NOT
分析型数据库MySQL版支持利用逻辑操作符对结果进行控制。目前支持的逻辑操作符包括：AND OR NOT。

其中AND表示要求操作符两边的关键词都必须出现。OR表示操作符两边的关键词出现一个即可。NOT表示右侧的关键词不能出现。

语法为：<word1> AND/OR/NOT <word2>

注意：1）AND/OR/NOT必须大写；2）AND/OR/NOT两边必须有空格。

要求 “浙江省”和”杭州市”都必须出现。

SELECT id, title, author, body
FROM articles_test
WHERE match(body) against ('浙江省 AND 杭州市') > 0.9
ORDER BY match(body) against ('浙江省 AND 杭州市') DESC
LIMIT 100;
— 要求 “浙江省”，”杭州市”出现一个即可。效果等同于如 “浙江省杭州市”, “浙江省 杭州市”

SELECT id, title, author, body
FROM articles_test
WHERE match(body) against ('浙江省 OR 杭州市') > 0.9
ORDER BY match(body) against ('浙江省 OR 杭州市') DESC
LIMIT 100;
要求 “浙江省”一定不能出现

SELECT id, title, author, body
FROM articles_test
WHERE match(body) against ('杭州市 NOT 浙江省') > 0.9
ORDER BY match(body) against ('杭州市 NOT 浙江省') DESC
LIMIT 100;
结构化、非结构化联合检索
分析型数据库MySQL版支持对结构化列、非结构化列进行联合条件检索。

要求查询create_time在20180201-20180930之间的、body命中“浙江省杭州市”、且comment不为空的数据行。

SELECT id, title, author, body
FROM articles_test
WHERE create_time > '2018-02-01 00:00:00'
        AND create_time < '2018-09-30 00:00:00'
        AND match(body) against ('浙江省杭州市') > 0.9
        AND comment is not null
ORDER BY match(body) against ('浙江省杭州市') DESC
LIMIT 100;
要求在body中检索“浙江省杭州市”, 且在author中检索“张三”。

SELECT id, author, body
FROM articles_test
WHERE match(body) against ('浙江省杭州市') > 0.9
        AND match(author) against('张三') > 0.9
ORDER BY match(body) against ('浙江省杭州市') DESC, match(author) against('张三') DESC
LIMIT 100;
高级SQL语法：结构化、非结构化融合GROUP BY, JOIN, UNION
分组

SELECT author, body, max(match(body) against ('浙江省杭州市')) as score
FROM articles_test
WHERE match(body) against ('浙江省杭州市') > 0.9
GROUP BY author, body
ORDER BY score DESC
LIMIT 100;
表连接: 在文章表articles_test中检索“浙江省杭州市”， 在作者信息表author_info中检索“张三”，并且利用id列将两表进行join。

CREATE TABLE author_info (
  id bigint COMMENT '',
  name varchar COMMENT '',
  addr varchar COMMENT '',
  FULLTEXT INDEX name_fulltext (name),
  FULLTEXT INDEX addr_fulltext (addr),
  PRIMARY KEY (id)
)
PARTITION BY HASH KEY(id)
PARTITION NUM 8
CLUSTERED BY (id)
TABLEGROUP test_group
OPTIONS (UPDATETYPE='realtime')
COMMENT '';
insert into author_info(id, name, addr) values(0, '张三', '湖南省张家界市武陵源区');
SELECT articles_test.id, articles_test.title, author_info.name, author_info.addr
FROM articles_test
    JOIN author_info
    ON articles_test.id = author_info.id
WHERE
    match (articles_test.body) against ('浙江省杭州市')
    AND match(author_info.name) against ('张三')
    AND articles_test.create_time between '2018-01-01 00:00:00' and '2018-09-30 00:00:00';
合并

SELECT id, title
FROM articles_test
WHERE
    match (articles_test.body) against ('浙江省杭州市')
UNION ALL
SELECT id, addr
FROM author_info
WHERE
    match(author_info.name) against ('张三');



一级分区的规划和设计
更新时间：2019-04-29 15:52:24


本页目录
一级分区列选择
数据倾斜带来的影响
如何评估表数据是否倾斜
本章节介绍一级分区表的规划和设计，其中主要是一级分区列的选取。

一级分区列选择
分析型数据库MySQL版一级分区表采用HASH分区，可指定任意一列（不支持多列）作为分区列。HASH分区通过标准CRC算法计算出CRC值，并将CRC值与分区数作模计算，得出每条记录的分区号。空值的HASH值与字符串-1相同。以下按照优先级从高到底列出一级分区列的选择依据。

选择值分布均匀的列作为分区列，请勿选择分布不均匀的列作为分区列。

建议选择一级分区列的数据类型为tinyint、smallint、int、bigint或者varchar。

如果是多个普通表（不包括维度表）JOIN，则选择参与JOIN的列作为分区列。

如果是多列JOIN ，则根据查询重要程度或查询性能要求（例如：某SQL的查询频率特别高）来选择分区列，以保证基于分区列的JOIN具有较好的查询性能。

选择GROUP BY或DISTINCT包含的列作为分区列。

如果常用的SQL包含某列的等值或IN查询条件，则选择该列作为分区列。以下列子则选择id作为分区列。

 select * from table where id=123 and …;
 select * from table where user in(1, 2,3);
数据倾斜带来的影响
如果一级分区列选择不合理会导致用户表数据倾斜，带来如SQL查询长尾、后台数据上线超时和单节点资源不足等诸多问题，对查询性能影响非常大也会给用户带来资源的浪费。

如何评估表数据是否倾斜
登录分析型数据库MySQL版控制台，单击监控管理>DB概览，查看表明细部分，对于存在数据倾斜的表已经标红处理，需要用户及时更换分区列。名字没有标红的表，用户也可以单击表名来查看数据分布。




列的最佳实践

分析型数据库MySQL版处理数值类型的性能远好于处理字符串类型。原因在于：

数值类型定长，占用内存少，存储空间小。

数值类型计算更快，尤其是join时。

从内部索引机制上，字符串类型适合等值查询和范围查询情况，而时间，数值类型性能更高，建议用户尽可能使用数值类型，减少使用字符串类型。

方法
常见将字符串转换为数值类型方法：

包含字符前缀或后缀，例如E12345，E12346等。可以直接去掉前缀或者将前缀映射为数字。

该列只有少数几个值，例如国家名。可以对每个国家编码，每个国家对应一个唯一数字。

时间/日期类型数据，避免使用varchar字符类型存储，尽量使用date，timestamp或者int类型存储时间类型。

对于地理经度维度的使用，需要通过地理函数查询情况，数据类型采用double数据类型。

查询报错问题
KB: 97347 ·
更新时间：2019-04-29 15:52:24


本页目录
查询报错QUERY_EXCEED_LIMIT ErrMsg:groups 100000001 exceed limit => 10000000
查询时遇到memory is not enough
查询时报错，提示scanRows exceed limit
查询提示错误META_COLUMN_NOT_EXIST
查询刚刚创建的新表时报错table is not ready
查询报错NO_NODES_AVAILABLE
查询性能不稳定
查询报错IN expr values execeed limit
查询报错QUERY_EXCEED_LIMIT ErrMsg:groups 100000001 exceed limit => 10000000
用户在执行SQL查询用limit处理分页时，如果start值限制10000无法获取10000以后的数据，如：LIMIT 1000000,20

分析型数据库MySQL版对分页数量有限制，即查询返回结果集限制10000行。分析型数据库MySQL版会对select语句查询的返回结果集做全局最大限制，如果不加limit或limit函数超过10000，则只能返回10000行。

可以在查询中添加注解/*+limitmax=<最大值>*/，例如/+limitmax=2000000/select * from ar_express3 limit 1000000,20`。
提工单申请调整默认返回限制。
查询时遇到memory is not enough
由于分析型数据库MySQL版查询时，大量数据存在内存中。当SQL所需处理单表或者多表join时的结果较大时，计算节点内存会成为系统瓶颈。分析型数据库MySQL版CN节点为避免SQL压垮系统，会进行自我保护，自动将查询消耗内存较大的SQL fail掉，保证其它查询正常。

因此当查询分析型数据库MySQL版报错提示memory is not enough，有以下2种建议：

优化SQL，尽量不返回可有可无的结果集，同时尽量对不关心的数据添加过滤条件。若没有很好的处理方法，请联系分析型数据库MySQL版技术支持。

若在现有业务基础上无法进行SQL优化，可考虑DB资源扩容，甚至是调整资源模型规格。

查询时报错，提示scanRows exceed limit
分析型数据库MySQL版查询时报错，错误信息为：ErrMsg:ErrCode:2001 ErrType:QUERY_EXCEED_LIMIT ErrMsg:scanRows exceed limit: xxx > xxx

其中xxx为数值，具体报错如下图所示：

s2

为避免用户输入的SQL误写或性能较差，从而导致扫描表的大量数据集，分析型数据库MySQL版会进行scan限制。当SQL scan的行数达到一定数量时，会fail掉SQL的执行并提示用户scanRows exceed limit错误信息。

当遇到该错误时，建议进行以下改进：

从SQL本身进行优化，尽量添加更多的过滤条件，筛选出需要关注的数据进行计算。

判断select的列是否都有必要获取，因为一个SQL可scan的数据条数=系统默认值/select的列数，若列数减少则可scan的数据条数更多。

若SQL自身无法进行优化，但依旧触发该错误，可联系分析型数据库MySQL版技术支持对单个分析型数据库MySQL版的系统默认值进行调整，此操作可能会造成数据库性能下降。

查询提示错误META_COLUMN_NOT_EXIST
在分析型数据库MySQL版表新增字段后，查询提示找不到新添加的列，具体是什么原因？表正在上线，但是上线失败或者CN副本在重启，都有可能出现META_COLUMN_NOT_EXIST。

对于实时表

一级普通表：新增字段且执行optimize成功后可查询到新增字段(老数据为null)。

二级普通表：新增字段且需触发最大二级分区的optimize，待optimize成功后可查询到新增字段。

对于未上线或者CN副本重启导致的报错，请检查上线情况或者重启情况。

optimize操作为异步后台操作（目前未开放接口给用户，可联系分析型数据库MySQL版技术支持），需等待任务完成后再做查询。

查询刚刚创建的新表时报错table is not ready
新创建的表，可以INSERT数据，但查询该表报错table is not ready。

ERROR 30007 (HY000): ProcessId=2017113014015101015416910909999087231 RT_ROUTER_ERROR tableId=28 DBId=1405 message=real time table is not ready.
一般表建好以后，还需分配相应的资源，需等待几分钟表才能正常使用，否则就会报not ready错误。

查询报错NO_NODES_AVAILABLE
报错关键字： NO_NODES_AVAILABLE

报错信息

ERROR 1105 (HY000): MPP_QUERY_FAILED Retry_time=1 message=MPP engine error code: 30101, message: QueryError{message=Node for bucket is offline: [], sqlState=null, errorCode=65541, errorName=NO_NODES_AVAILABLE, errorType=INTERNAL_ERROR, errorLocation=null, failureInfo=mpp.client.FailureInfo@13887b2e}
一般是数据库内部某个计算节点压力较大导致该节点暂时离线，系统能够自动修复。请用户过5~10分钟后重试。如果长时间出现该报错，请联系分析型数据库MySQL版技术支持。

查询性能不稳定
在分析型数据库MySQL版中执行SQL查询语句时，时慢时快。引起分析型数据库MySQL版查询不稳定的因素一般有以下几种：

用户执行SQL时首次较慢，之后查询明显比第一次快，这是因为分析型数据库MySQL版自身带有缓存。第一次查询时会将数据缓存到内存中，若下次查询所需要的数据依然在内存中时，此时不用再次读磁盘，因此访问速度很快。

用户使用的是实时表，且写入大量数据后未执行optimize操作，此时执行SQL会随着插入数据多而变得越来越慢。这是因为分析型数据库MySQL版的实时数据增量部分默认未建索引，因此执行查询时会频繁访问磁盘。为保证查询速度，建议当用户执行过大量INSERT或DELETE语句后，立即触发一次optimize table操作。

用户对实时表执行大量的DELETE语句，而这些DELETE的条件中没有指定分区键，导致系统在所有分区上执行DELETE，耗费CN上大量CPU和内存资源。此时其他查询也有可能变慢或超时。

按上述排查后还存在问题，请联系分析型数据库MySQL版技术支持。

查询报错IN expr values execeed limit
带有IN ()条件的查询报错IN expr values execeed limit

默认情况下，如果IN ()中的值的个数大于50，则会报该错误。如果要修改此限制，请提工单联系分析型数据库MySQL版技术支持。



当用户在使用HybridDB for MySQL进行数据库设计和实践的过程中，我们有如下建议：

分区键的选择

分区键是数据库控制数据分布的维度，以该条件进行等值查询，查询范围只会限制在一个存储分区上，通常选择查询最频繁的列，或数据分布最均匀的列。

批量插入

写入数据时，建议以insert into tb (f1, f2, …) values (v11, v12, …),(v21, v22, …)…语法批量写入，这样会提升性能，减少更新事务中网络的开销。

创建适当的索引

HybridDB for MySQL的索引设计与MySQL一样，需要在最常用的查询维度上创建索引，索引包含的列从左到右依次为等值条件列、范围条件列或join列、排序列、投影列，尽量提前设计索引，表数据量加大时索引会变慢。

大小表分开

为提升系统整体的性能和稳定性，用户应合理地将大表和小表拆分到不同的数据库中，HybridDB for MySQL适合存储大表，而将小表交给RDS for MySQL存储，大表可以使用sharding分区技术合理利用资源，而不影响小表。

分区键高并发执行

在某些场景下，用户期望拥有更高的吞吐和并发，进行快速的数据批量存取。HybridDB for MySQL支持查询force partition语法，用户可直接查询存储分区的数据，独立并行地查询多个存储分区，这样可以大幅提升整体性能。


  Mysql查询优化器

1 定义
   Mysql查询优化器的工作是为查询语句选择合适的执行路径。查询优化器的代码一般是经常变动的，这和存储引擎不太一样。因此，需要理解最新版本的查询优化器是如何组织的，请参考相应的源代码。

   整体而言，优化器有很多相同性，对mysql一个版本的优化器做到整体掌握，理解起mysql新版本以及其他数据库的优化器都是类似的。


  优化器会对查询语句进行转化，转化等价的查询语句。

  举个例子，优化器会将下面语句进行转化：



SELECT … WHERE 5=a;
转化后的等价语句为：
SELECT … WHERE a=5;
因为这两个语句的结果集是一致的，所以这两个语句是等价的。
这里我需要提出一点需要注意的，如果查询语句没带order by。查询语句1出现的结果为(1,1),(2,2)，查询语句2出现的结果为(2,2),(1,1)，我们会认为这是等价的，因为不带order by的查询语句是无序的，怎么排序都行。

2 代码组织
 在内核当中handle_select()函数是处理查询语句的顶层函数，里面有两个分支，一个是处理带union的情况，另外一个是处理不带union的情况，这里我们只是列出一个简单的路径便于说明，调用层次见下图。
handle_select()
   mysql_select()
     JOIN::prepare()
       setup_fields()
     JOIN::optimize()            /* optimizer is from here ... */
       optimize_cond()
       opt_sum_query()
       make_join_statistics()
         get_quick_record_count()
         choose_plan()
           /* Find the best way to access tables */
           /* as specified by the user.          */
           optimize_straight_join()
             best_access_path()
           /* Find a (sub-)optimal plan among all or subset */
           /* of all possible query plans where the user    */
           /* controlls the exhaustiveness of the search.   */
           greedy_search()
             best_extension_by_limited_search()
               best_access_path()
           /* Perform an exhaustive search for an optimal plan */
           find_best()
       make_join_select()        /* ... to here */
     JOIN::exec()
 上面的缩进表示函数的相互调用关系，因此可以看出handle_select()调用函数mysql_select(),mysql_select()调用JOIN::prepare()，等等。
   mysql_select()首先调用函数JOIN::prepare()进行语句分析、元数据设置、子查询转化等等。然后调用函数JOIN::optimize()进行优化，选出最后的执行计划。最后调用函数JOIN::exec()执行该执行计划。
   尽管出现了单词“JOIN”，这些优化函数是为所有的查询语句服务的，不管你是什么查询类型。
   函数optimize_cond()和函数opt_sum_query()是执行一些转化操作。函数make_join_statistics()对所有可用索引统计信息进行分析。

3 常量转化
 对类似下面的表达式可以进行转化：
WHERE column1 = column2 AND column2 = 'x';
 因为我们知道：如果A=B and B=C，那么A=C。所以上面的表达式可以转化为：
WHERE column1 = 'x'  AND column2 = 'x';
 对于column1 <operator> column2，只要<operator>是属于下面的操作符之一就可以进行类似的转化：
=,<,>,<=,>=,<>,<=>,LIKE
 从中我们也可以看出，对于BETWEEN的情况是不进行转换的。

4 无效代码的排除
 见如下表达式：
WHERE 0=0 AND column1='y'
 因为第一个条件是始终为true的，所以可以移除该条件，变为：
WHERE column1='y'

 再见如下表达式：
WHERE (0=1 AND s1=5) OR s1=7
 因为前一个括号内的表达式始终为false，因此可以移除该表达式，变为：
WHERE s1=7

 一些情况下甚至可以将整个WHERE子句去掉，见下面的表达式：
WHERE (0=1 AND s1=5)
 我们可以看到，WHERE子句始终为FALASE，那么WHERE条件是不可能发生的。当然我们也可以讲，WHERE条件被优化掉了。

  如果一个列的定义是不允许为NULL，那么：
WHERE not_null_column IS NULL
 该条件是始终为false的，再看：
WHERE not_null_column IS NOT NULL
 该条件是始终为true的，因此这样的表达式也是可以从条件表达式中删除的。
 当然，也是有特殊情况的，比如在out join中，被定义为NOT NULL的列也可能包含NULL值。在这种情况下，IS NULL条件是被保留的。

 当然优化器没有对所有的情况进行检测，因为这实在太复杂了。举个例子：
CREATE TABLE Table1(column1 CHAR(1));
…
SELECT * FROM Table1 WHERE column1 = 'Canada';
 尽管该条件是无效条件，优化器也不会将它移除。

5 常量计算
 如下表达式：
WHERE columb1 = 1 + 2
 转化为：
WHERE columb1 = 3


6 常量以及常量表
 常量表的定义如下：
1)        一个表只有0行或者1行数据。
2)        在WHERE子句中包含条件column = constant，并且这些列是primary key，或者这些列是UNIQUE（假设该UNIQUE同时被定义为NOT NULL）。这样生成的查询结果也可以成为常量表。

 如果表Table0定义中包含：
… PRIMARY KEY(column1,column2)
  再看下面的语法：
FROM Table0 … WHERE column1=5 AND column2=7 …
 那么该语句返回的就是常量表。
 举个更简单的情况，建设Table1定义中包含:
… unique_not_null_column INT NOT NULL UNIQUE
 再看下面的语法：
FROM Table1 ... WHERE unique_not_null_column=5
 该语句返回的也是常量表。

 从例子中我们可以看出常量表最多只有1个行值。MySQL会预先评估常量表，找出这个值，然后将这个值引入到查询语句中进行优化，举例如下：
SELECT Table1.unique_not_null_column, Table2.any_column
    FROM Table1, Table2
    WHERE Table1.unique_not_null_column = Table2.any_column
    AND Table1.unique_not_null_column = 5;
 在评估这个查询语句时，MySQL首先发现通过Table1.unique_not_null_column条件的限制，Table1会变成一个常量表。然后，取回该值。
 如果取回操作失败（Table1中没有行满足条件unique_not_null_column = 5），那么该常量表就包含0行，那么如果对该语句执行EXPLAIN操作，会得到提示信息：
Impossible WHERE noticed after reading const tables
 另外一种情况是取回操作成功（Table1中严格只有一行满足条件unique_not_null_column = 5），那么常量表中包含一条数据，并且MySQL会将查询语句转化为：
SELECT 5, Table2.any_column
    FROM Table1, Table2
    WHERE 5 = Table2.any_column
    AND 5 = 5;
 实际上，这个例子是个复杂的例子，这里面也用到了上文所说的常量转化


7 存取类型
 当我们评估一个条件表达式，MySQL判断该表达式的存取类型。下面是一些存取类型，按照从最优到最差的顺序进行排列：
system      … 系统表，并且是常量表
const       … 常量表
eq_ref      …   unique/primary索引，并且使用的是'='进行存取
ref         … 索引使用'='进行存取
ref_or_null … 索引使用'='进行存取，并且有可能为NULL
range       … 索引使用BETWEEN、IN、>=、LIKE等进行存取
index       …   索引全扫描
ALL        … 表全扫描
 优化器根据存取类型选择合适的驱动表达式。考虑如下的查询语句：
SELECT *
FROM Table1
WHERE indexed_column = 5 AND unindexed_column = 6
 因为indexed_column拥有更好的存取类型，所以更有可能使用该表达式做为驱动表达式。这里只考虑简单的情况，不考虑特殊的情况。
 那么驱动表达式的意思是什么呢？考虑到这个查询语句有两种可能的执行方法:
1)      不好的执行路径：读取表的每一行（称为“全表扫描”），对于读取到的每一行，检查相应的值是否满足indexed_column以及unindexed_column对应的条件。
2)      好的执行路径：通过键值indexed_column=5查找B树，对于符合该条件的每一行，判断是否满足unindexed_column对应的条件。

 一般情况下，索引查找比全表扫描需要更少的存取路径，尤其当表数据量很大，并且索引的类型是UNIQUE的时候。因此称它为好的执行路径，使用indexed_column列作为驱动表达式。


8 范围存取类型
 一些表达式可以使用索引，但是属于索引的范围查找。这些表达式通常对应的操作符是：>、>=、<、<=、IN、LIKE、BETWEEN。
 对优化器而言，如下表达式：
column1 IN (1,2,3)
该表达式与下面的表达式是等价的：
column1 = 1 OR column1 = 2 OR column1 = 3
 并且MySQL也是认为它们是等价的，所以没必要手动将IN改成OR,或者把OR改成IN。

 优化器将会对下面的表达式使用索引范围查找：
column1 LIKE 'x%'
 但对下面的表达式就不会使用到索引了：
column1 LIKE '%x'
 这是因为当首字符是通配符的时候，没办法使用到索引进行范围查找。

 对优化器而言，如下表达式：
column1 BETWEEN 5 AND 7
 该表达式与下面的表达式是等价的：
column1 >= 5 AND column1 <= 7
 同样，MySQL也认为它们是等价的。

 如果需要检查过多的索引键值，优化器将放弃使用索引范围查找，而是使用全表扫描的方式。这样的情况经常出现如下的情况下：索引是多层次的二级索引，查询条件是'<'以及是'>'的情况。


9 索引存取类型
 考虑如下的查询语句：
SELECT column1 FROM Table1;
 如果column1是索引列，优化器更有可能选择索引全扫描，而不是采用表全扫描。这是因为该索引覆盖了我们所需要查询的列。

 再考虑如下的查询语句：
SELECT column1,column2 FROM Table1;
 如果索引的定义如下，那么就可以使用索引全扫描：
CREATE INDEX … ON Table1(column1,column2);
 也就是说，所有需要查询的列必须在索引中出现。


10转换
 MySQL对简单的表达式支持转换。比如下面的语法：
WHERE -5 = column1
 转换为：
WHERE column1 = -5
 尽管如此，对于有数学运算存在的情况不会进行转换。比如下面的语法：
WHERE 5 = -column1
 不会转换为：
WHERE column1 = -5


11 AND
 带AND的查询的格式为：<condition> AND <condition>，考虑如下的查询语句：
WHERE column1='x' AND column2='y'
 优化的步骤：
1)        如果两个列都没有索引，那么使用全表扫描。
2)        否则，如果其中一个列拥有更好的存取类型（比如，一个具有索引，另外一个没有索引；再或者，一个是唯一索引，另外一个是非唯一索引），那么使用该列作为驱动表达式。
3)        否则，如果两个列都分别拥有索引，并且两个条件对应的存取类型是一致的，那么选择定义索引时的先定义的索引。

举例如下：
CREATE TABLE Table1 (s1 INT,s2 INT);
CREATE INDEX Index1 ON Table1(s2);
CREATE INDEX Index2 ON Table1(s1);
…
SELECT * FROM Table1 WHERE s1=5 AND s2=5;
 优化器选择s2=5作为驱动表达式，因为s2上的索引是新建的。


12 OR
 带OR的查询格式为：<condition> OR <condition>，考虑如下的查询语句：
WHERE column1='x' OR column2='y'
 优化器做出的选择是采用全表扫描。
 当然，在一些特定的情况，可以使用索引合并，这里不做阐述。

 如果两个条件里面设计的列是同一列，那么又是另外一种情况，考虑如下的查询语句：
WHERE column1='x' OR column1='y'
 在这种情况下，该查询语句采用索引范围查找。


13 UNION
 所有带UNION的查询语句都是单独优化的，考虑如下的查询语句：
SELECT * FROM Table1 WHERE column1='x'
UNION ALL
SELECT * FROM Table1 WHERE column2='y'
 如果column1与column2都是拥有索引的，每个查询都是使用索引查询，然后合并结果集。


14 NOT,<>
 考虑如下的表达式：
Column1<> 5
 从逻辑上讲，该表达式等价于下面的表达式：
Column1<5 OR column1>5
 然而，MySQL不会进行这样的转换。如果你觉得使用范围查找会更好一些，应该手动地进行转换。

 考虑如下的表达式：
WHERE NOT (column1!=5)
 从逻辑上讲，该表达式等价于下面的表达式：
WHERE column1=5
 同样地，MySQL也不会进行这样的转换。


15 ORDER BY
 一般而言，ORDER BY的作用是使结果集按照一定的顺序排序，如果可以不经过此操作就能产生顺序的结果，可以跳过该ORDER BY操作。
 考虑如下的查询语句：
SELECT column1 FROM Table1 ORDER BY 'x';
 优化器将去除该ORDER BY子句，因为此处的ORDER BY子句没有意义。

 再考虑另外的一个查询语句：
SELECT column1 FROM Table1 ORDER BY column1;
 在这种情况下，如果column1类上存在索引，优化器将使用该索引进行全扫描，这样产生的结果集是有序的，从而不需要进行ORDER BY操作。

 再考虑另外的一个查询语句：
SELECT column1 FROM Table1 ORDER BY column1+1;
 假设column1上存在索引，我们也许会觉得优化器会对column1索引进行全扫描，并且不进行ORDER BY操作。实际上，情况并不是这样，优化器是使用column1列上的索引进行全扫表，仅仅是因为索引全扫描的效率高于表全扫描。对于索引全扫描的结果集仍然进行ORDER BY排序操作。


16 GROUP BY
 这里列出对GROUP BY子句以及相关集函数进行优化的方法：
1)        如果存在索引，GROUP BY将使用索引。
2)        如果没有索引，优化器将需要进行排序，一般情况下会使用HASH表的方法。
3)        如果情况类似于“GROUP BY x ORDER BY x”,优化器将会发现ORDER BY子句是没有必要的，因为GROUP BY产生的结果集是按照x进行排序的。
4)        尽量将HAVING子句中的条件提升中WHERE子句中。
5)        对于MyISAM表，“SELECT COUNT(*) FROM Table1;”直接返回结果，而不需要进行表全扫描。但是对于InnoDB表，则不适合该规则。补充一点，如果column1的定义是NOT NULL的，那么语句“SELECT COUNT(column1) FROM Table1;”等价于“SELECT COUNT(*) FROM Table1;”。
6)        考虑MAX()以及MIN()的优化情况。考虑下面的查询语句：
SELECT MAX(column1)
FROM Table1
WHERE column1 < 'a';
  如果column1列上存在索引，优化器使用'a'进行索引定位，然后返回前一条记录。
7)        考虑如下的查询语句:
SELECT DISTINCT column1 FROM Table1;
 在特定的情况下，语句可以转化为：
SELECT column1 FROM Table1 GROUP BY column1;
 该转换的前提条件是：column1上存在索引，FROM上只有一个单表，没有WHERE条件并且没有LIMIT条件。





MySQL 中 update 修改数据与原数据相同会再次执行吗？
数据分析与开发  4天前
（给数据分析与开发加星标，提升数据技能）




yq.aliyun.com/articles/694162



一、背景


本文主要测试MySQL执行update语句时，针对与原数据（即未修改）相同的update语句会在MySQL内部重新执行吗？



二、测试环境


MySQL5.7.25

Centos 7.4



三、binlog_format为ROW


1、参数






2、测试步骤


session1







session2







session1






3、总结


在binlog_format=row和binlog_row_image=FULL时，由于MySQL 需要在 binlog 里面记录所有的字段，所以在读数据的时候就会把所有数据都读出来，那么重复数据的update不会执行。即MySQL 调用了 InnoDB 引擎提供的“修改为 (1,55)”这个接口，但是引擎发现值与原来相同，不更新，直接返回。



四、binlog_format为STATEMENT


1、参数






2、测试步骤


session1







session2







session1






3、总结


在binlog_format=statement和binlog_row_image=FULL时，InnoDB内部认真执行了update语句，即“把这个值修改成 (1,999)“这个操作，该加锁的加锁，该更新的更新。


==========

好文推荐 | MySQL binlog应用场景与原理深度剖析


本文深入介绍Mysql Binlog的应用场景，以及如何与MQ、elasticsearch、redis等组件的保持数据最终一致。最后通过案例深入分析binlog中几乎所有event是如何产生的，作用是什么。



1 基于binlog的主从复制

Mysql 5.0以后，支持通过binary log(二进制日志)以支持主从复制。复制允许将来自一个MySQL数据库服务器（master) 的数据复制到一个或多个其他MySQL数据库服务器（slave)，以实现灾难恢复、水平扩展、统计分析、远程数据分发等功能。

二进制日志中存储的内容称之为事件，每一个数据库更新操作(Insert、Update、Delete，不包括Select)等都对应一个事件。

注意：本文不是讲解mysql主从复制，而是讲解binlog的应用场景，binlog中包含哪些类型的event，这些event的作用是什么。你可以理解为，是对主从复制中关于binlog解析的细节进行深度剖析。而讲解主从复制主要是为了理解binlog的工作流程。

下面以mysql主从复制为例，讲解一个从库是如何从主库拉取binlog，并回放其中的event的完整流程。mysql主从复制的流程如下图所示：





主要分为3个步骤：

第一步：master在每次准备提交事务完成数据更新前，将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log event，简称event)

第二步：slave启动一个I/O线程来读取主库上binary log中的事件，并记录到slave自己的中继日志(relay log)中。

第三步：slave还会起动一个SQL线程，该线程从relay log中读取事件并在备库执行，从而实现备库数据的更新。

2 binlog的应用场景

binlog本身就像一个螺丝刀，它能发挥什么样的作用，完全取决你怎么使用。就像你可以使用螺丝刀来修电器，也可以用其来固定家具。

2.1 读写分离

最典型的场景就是通过Mysql主从之间通过binlog复制来实现横向扩展，来实现读写分离。如下图所示：







   在这种场景下：

有一个主库Master，所有的更新操作都在master上进行

同时会有多个Slave，每个Slave都连接到Master上，获取binlog在本地回放，实现数据复制。

在应用层面，需要对执行的sql进行判断。所有的更新操作都通过Master(Insert、Update、Delete等)，而查询操作(Select等)都在Slave上进行。由于存在多个slave，所以我们可以在slave之间做负载均衡。通常业务都会借助一些数据库中间件，如tddl、sharding-jdbc等来完成读写分离功能。

因为工作性质的原因，笔者见过最多的一个业务，一个master，后面挂了20多个slave。笔者之前写过一篇关于数据库中间件实现原理的文章，感兴趣的读者可以参考：数据库中间件详解

2.2 数据恢复

一些同学可能有误删除数据库记录的经历，或者因为误操作导致数据库存在大量脏数据的情况。例如笔者，曾经因为误操作污染了业务方几十万数据记录。

如何将脏数据恢复成原来的样子？如果恢复已经被删除的记录？

这些都可以通过反解binlog来完成，笔者也是通过这个手段，来恢复业务方的记录。

2.3 数据最终一致性

在实际开发中，我们经常会遇到一些需求，在数据库操作成功后，需要进行一些其他操作，如：发送一条消息到MQ中、更新缓存或者更新搜索引擎中的索引等。

如何保证数据库操作与这些行为的一致性，就成为一个难题。以数据库与redis缓存的一致性为例：操作数据库成功了，可能会更新redis失败；反之亦然。很难保证二者的完全一致。

遇到这种看似无解的问题，最好的办法是换一种思路去解决它：不要同时去更新数据库和其他组件，只是简单的更新数据库即可。

如果数据库操作成功，必然会产生binlog。之后，我们通过一个组件，来模拟的mysql的slave，拉取并解析binlog中的信息。通过解析binlog的信息，去异步的更新缓存、索引或者发送MQ消息，保证数据库与其他组件中数据的最终一致。

在这里，我们将模拟slave的组件，统一称之为binlog同步组件。你并不需要自己编写这样的一个组件，已经有很多开源的实现，例如linkedin的databus，阿里巴巴的canal，美团点评的puma等。

当我们通过binlog同步组件完成数据一致性时，此时架构可能如下图所示：







增量索引

通常索引分为全量索引和增量索引。对于增量索引的部分，可以通过监听binlog变化，根据binlog中包含的信息，转换成es语法，进行实时索引更新。当然，你可能并没有使用es，而是solr，这里只是以es举例。

可靠消息

可靠消息是指的是：保证本地事务与发送消息到MQ行为的一致性。一些业务使用本地事务表或者独立消息服务，来保证二者的最终一致。Apache RocketMQ在4.3版本开源了事务消息，也是用于完成此功能。事实上，这两种方案，都有一定侵入性，对业务不透明。通过订阅binlog来发送可靠消息，则是一种解耦、无侵入的方案。关于可靠消息，笔者最近写了一篇文章， 感兴趣的读者可以参考：可靠消息一致性的奇淫技巧。

缓存一致性

业务经常遇到的一个问题是，如何保证数据库中记录和缓存中数据的一致性。不妨换一种思路，只更新数据库，数据库更新成功后，通过拉取binlog来异步的更新缓存(通常是删除，让业务回源到数据库)。如果数据库更新失败，没有对应binlog，那么也不会去更新缓存，从而实现最终一致性。

可以看到，binlog是一把利器，可以保证数据库与与其他任何组件(es、mq、redis等)的最终一致。这是一种优雅的、通用的、无业务入侵的、彻底的解决方案。我们没有必要再单独的研究某一种其他组件如何与数据库保持最终一致，可以通过binlog来实现统一的解决方案。

在实际开发中，你可以简单的像上图那样，每个应用场景都模拟一个slave，各自连接到Mysql上去拉取binlog，master会给每个连接上来的slave一份完整的binlog拷贝，业务拿到各自的binlog之后进行消费，彼此之间互不影响。但是这样，有一些弊端，多个slave会给master带来一些额外管理上的开销，网卡流量也将翻倍的增长。

我们可以进行一些优化，之所以不同场景模拟多个slave来连接master获取同一份binlog，本质上要满足的是：一份binlog数据，同时提供给多个不同业务场景使用，彼此之间互不影响。

显然，消息中间件是一个很好的解决方案。现在很多主流的消息中间件，都支持consumer group的概念，如kafka、rocketmq等。同一个topic中的数据，可以由多个不同consumer group来消费，且不同的consumer group之间是相互隔离的，例如：当前消费到的位置(offset)。

因此，我们完全可以将binlog，统一都发送到MQ中，不同的应用场景使用不同的consumer group来消费，彼此之间互不影响。此时架构如下图所示：







通过这样方式，我们巧妙的达到了一份数据多个应用场景来使用。一般，一个Mysql实例中可能会创建多个库(Database)，通常我们会将一个库的binlog放到一个对应的MQ中的Topic中。

当将binlog发送到MQ中后，我们就可以利用MQ的一些高级特性了。例如binlog发送到MQ过快，消费方来不及消费，可以利用MQ的消息堆积能力进行流量削峰。还可以利用MQ的消息回溯功能，例如一个业务需要消费历史的binlog，此时MQ中如果还有保存，那么就可以直接进行回溯。

当然，有一些binlog同步组件可能实现了类似于MQ的功能，此时你就无序再单独的使用MQ。



2.4 异地多活

一个更大的应用场景，异地多活场景下，跨数据中心之间的数据同步。这种场景的下，多个数据中心都需要写入数据，并且往对方同步。以下是一个简化的示意图：







这里有一些特殊的问题需要处理。典型的包括：

数据冲突：双方同时插入了一个相同主键的值，那么往对方同步时，就会出现主键冲突的错误。

数据回环：一个库A中插入的数据，通过binlog同步到另外一个库B中，依然会产生binlog。此时库B的数据再次同步回库A，如此反复，就形成了一个死循环。

如何解决数据冲突、数据回环，就变成了binlog同步组件要解决的问题。同样，业界也有了成熟的实现，比较知名的有阿里开源的otter，以及摩拜(已经属于美团)的DRC等。

笔者之前写过一篇文章，介绍如何在多机房进行数据同步，感兴趣的读者可以参考以下文章：异地多活场景下的数据同步之道



2.5 小结

如前所属，binlog的作用如此强大。因此，你可能想知道binlog文件中到底包含了哪些内容，为什么具有如此的魔力？在进行一些数据库操作时，例如：Insert、Update、Delete等，到底会对binlog产生什么样的影响？这正是本文要下来要讲解的内容。



3 Binlog事件详解

Mysql已经经历了多个版本的发布，最新已经到8.x，然而目前企业中主流使用的还是Mysql 5.6或5.7。不同版本的Mysql中，binlog的格式和事件类型可能会有些细微的变化，不过暂时我们并不讨论这些细节。

总的来说，binlog文件中存储的内容称之为二进制事件，简称事件。我们的每一个数据库更新操作(Insert、Update、Delete等)，都会对应的一个事件。

从大的方面来说，binlog主要分为2种格式：

Statement模式：binlog中记录的就是我们执行的SQL；

Row模式：binlog记录的是每一行记录的每个字段变化前后得到值。

熟悉主从复制的同学，应该知道，还有第三种模式Mixed(即混合模式)，从严格意义上来说，这并不是一种新的binlog格式，只是结合了Statement和Row两种模式而已。

当我们选择不同的binlog模式时，在binlog文件包含的事件类型也不相同，如: 1)在Statement模式下，我们就看不到Row模式下独有的事件类型。2)有一些类型的event，必须在我们开启某些特定配置的情况下，才会出现；3)当然也会有一些公共的event类型，在任何模式下都会出现。

Mysql中定义了30多个event类型，这里并不打算将所有的事件类型提前列出，这样没有意义，只会让读者茫然不知所措。笔者将会在必要的地方，介绍遇到的每一种event类型的作用。

目前我们先从宏观的角度对binlog有一个感性的认知。



3.1 多文件存储

mysql 将数据库更新操作对应的event记录到本地的binlog文件中，显然在一个文件中记录所有的event是不可能的，过大的文件会给我们的运维带来麻烦，如删除一个大文件，在I/O调度方面会给我们带来不可忽视的资源开销。

因此，目前基本上所有支持本地文件存储的组件，如MQ、Mysql等，都会控制一个文件的大小。在数据量较多的情况下，就分配到多个文件进行存储。

在mysql中，我们可以通过"show binary logs"语句，来查看当前有多少个binlog文件，以及每个binlog文件的大小，如下：



另外，mysql提供了：

max_binlog_size配置项，用于控制一个binlog文件的大小，默认是1G

expire_logs_days配置项，可以控制binlog文件保留天数，默认是0，也就是永久保留。

在实际生产环境中，一般无法保留所有的历史binlog。因为一条记录可能会变更多次，记录依然是一条，但是对应的binlog事件就会有多个。在数据变更比较频繁的情况下，就会产生大量的binlog文件。此时，则无法保留所有的历史binlog文件。

在mysql的percona分支上，还提供了max_binlog_files配置项，用于设置可以保留的binlog文件数量，以便我们更精确的控制binlog文件占用的磁盘空间。这是一个非常有用的配置，笔者曾经遇到一个库，大约10分钟就会产生一个binlog文件，也就是1G，按照这种增长速度，1天下来产生的binlog文件，就会占用大概144G左右的空间，磁盘空间可能很快就会被使用完。通过此配置，我们可以显示的控制binlog文件的数量，例如指定50，binlog文件最多只会占用50G左右的磁盘空间。

在更高版本的mysql中，支持按照秒级精度，来控制binlog文件的保留时间。下面我们将对binlog文件中的内容进行详细的讲解。



3.2 Binlog管理事件

所谓binlog管理事件，官方称之为binlog managent events，你可以认为是一些在任何模式下都有可能会出现的事件，不管你的配置binlog_format是Row、Statement还是Mixed。

以下通过"show binlog events"语法进行查看一个空的binlog文件，也就是只包含(部分)管理事件，没有其他数据更新操作对应的事件。如下：



在当前binlog v4版本中，每个binlog文件总是以Format Description Event作为开始，以Rotate Event结束作为结束。如果你使用的是很古老的Mysql版本中，开始事件也有可能是START EVENT V3，而结束事件是Stop Event。在开始和结束之间，穿插着其他各种事件。

在Event_Type列中，我们看到了三个事件类型：

Format_desc：也就是我们所说的Format Description Event，是binlog文件的第一个事件。在Info列，我们可以看到，其标明了Mysql Server的版本是5.7.10，Binlog版本是4。

Previous_gtids：该事件完整名称为，PREVIOUS_GTIDS_LOG_EVENT。熟悉Mysql 基于GTID复制的同学应该知道，这是表示之前的binlog文件中，已经执行过的GTID。需要我们开启GTID选项，这个事件才会有值，在后文中，将会详细的进行介绍。

Rotate：Rotate Event是每个binlog文件的结束事件。在Info列中，我们看到了其指定了下一个binlog文件的名称是mysql-bin.000004。



关于"show binlog events"语法显示的每一列的作用说明如下：

Log_name：当前事件所在的binlog文件名称

Pos：当前事件的开始位置，每个事件都占用固定的字节大小，结束位置(End_log_position)减去Pos，就是这个事件占用的字节数。细心的读者可以看到了，第一个事件位置并不是从0开始，而是从4。Mysql通过文件中的前4个字节，来判断这是不是一个binlog文件。这种方式很常见，很多格式的文件，如pdf、doc、jpg等，都会通常前几个特定字符判断是否是合法文件。

Event_type：表示事件的类型

Server_id：表示产生这个事件的mysql server_id，通过设置my.cnf中的server-id选项进行配置。

End_log_position：下一个事件的开始位置

Info：当前事件的描述信息



3.3 Statement模式下的事件

mysql5.0及之前的版本只支持基于语句的复制，也称之为逻辑复制，也就是binary log文件中，直接记录的就是数据更新对应的sql。

假设有名为test库中有一张user表，如下：



现在，我们往user表中插入一条数据



insert into user(name) values("tianbowen");


之后，可以使用"show binlog events" 语法查看binary log中的内容，如下：



       红色框架中Event，是我们执行上面Insert语句产生的4个Event。下面进行详细的说明：

(划重点)首先，需要说明的是，每个事务都是以Query Event作为开始，其INFO列内容为"BEGIN"，以Xid Event表示结束，其INFO列内容为COMMIT。即使对于单条更新SQL我们没有开启事务，Mysql也会默认的帮我们开启事务。因此在上面的红色框中，尽管我们只是执行了一个INSERT语句，没有开启事务，但是Mysql 默认帮我们开启了事务，所以第一个Event是Query Event，最后一个是Xid Event。

接着，是一个Intvar Event，因为我们的Insert语句插入的表中，主键是自增的(AUTO_INCREMENT)列，Mysql首先会自增一个值，这就是Intvar Event的作用，这里我们看到INFO列的值为INSERT_ID=1，也就是说，这次的自增主键id为1。需要注意的是，这个事件，只会在Statement模式下出现。

然后，还是一个Query Event，这里记录的就是我们插入的SQL。这也体现了Statement模式的作用，就是记录我们执行的SQL。

Statement模式下还有一些不常用的Event，如USER_VAR_EVENT，这是用于记录用户设置的变量，仅仅在Statement模式起作用。如：

执行以下SQL：



set @name = 'tianshouzhi';
insert into user(name) values(@name);


这里，我们插入sql的时候，通过引用一个变量。此时查看binlog变化，这里为了易于观察，在执行show binlog events时，指定了binlog文件和from的位置，即只查看指定binlog文件中从指定位置开始的event。如下：



可以看到，依然符合我们所说的，对于这个插入语句，依然默认开启了事务。主键自曾值INSERT_ID=2。

当然，我们也看到了User var这个事件，其记录了我们的设置的变量值，只不过以16进制显示。



3.4 Row模式下的事件

mysql5.1开始支持基于行的复制，这种方式记录的某条sql影响的所有行记录变更前和变更后的值。Row模式下主要有以下10个事件：



很直观的，我们看到了INSERT、DELETE、UPDATE操作都有3个版本(v0、v1、v2)，v0和v1已经过时，我们只需要关注V2版本。

此外，还有一个TABLE_MAP_EVENT，这个event我们需要特别关注，可以理解其作用就是记录了INSERT、DELETE、UPDATE操作的表结构。

下面，我们通过案例演示，ROW模式是如何记录变更前后记录的值，而不是记录SQL。这里只演示UPDATE，INSERT和DELETE也是类似。

在前面的操作步骤中，我们已经插入了2条记录，如下：



现在需要从Statement模式切换到Row模式，重启Mysql之后，执行以下SQL更新这两条记录：



update user set name='wangxiaoxiao';


在binary log中，会把这2条记录变更前后的值都记录下来，以下是一个逻辑示意图：





该逻辑示意图显示了，在默认情况下，受到影响的记录行，每个字段变更前的和变更后的值，都会被记录下来，即使这个字段的值没有发生变化。

接着，我们还是通过"show binlog events"语法来验证：



首先我们可以看到的是，在Row模式下，单条SQL依然会默认开启事务，通过Query Event(值为BEGIN)开始，以Xid Event结束。

接着，我们看到了一个Table_map 事件，就是前面提到的TABLE_MAP_EVENT，在INFO列，我们可以看到其记录table_id为108，操作的是test库中user表。

最后，是一个Update_rows事件，然而其INFO，并没有像Statement模式那样，显示一条SQL，我们无法直接看到其变更前后的值是什么。

由于存储的都是二进制内容，直接vim无法查看，我们需要借助另外一个工具mysqlbinlog来查看其内容。如下：



截图中显示了2个event，第一个红色框就是Table_map事件，第二个是Update_rows事件。

在第二个红色框架中，显示了两个Update sql，这是只是mysqlbinlog工具为了方便我们查看，反解成SQL而已。我们看到了WHERE以及SET子句中，并没有直接列出字段名，而是以@1、@2这样的表示字段位于数据库表中的顺序。事实上，这里显示的内容，WHERE部分就是每个字段修改前的值，而SET部分，则是每个字段修改后的值，也就是变更前后的值都会记录。

这里我们思考以下mysqlbinlog工具的工作原理，其可以将二进制数据反解成SQL进行展示。那么，如果我们可以自己解析binlog，就可以做数据恢复，这并非是什么难事。例如用户误删除的数据，执行的是DETELE语句，由于Row模式下会记录变更之前的字段的值，我们可以将其反解成一个INSERT语句，重新插入，从而实现数据恢复。

3.4.1 binlog_row_image参数

我们经常会看到一些Row模式和Statement模式的比较。ROW模式下，即使我们只更新了一条记录的其中某个字段，也会记录每个字段变更前后的值，binlog日志就会变大，带来磁盘IO上的开销，以及网络开销。

事实上，这个行为可以通过binlog_row_image控制其有3个值，默认为FULL：

FULL : 记录列的所有修改，即使字段没有发生变更也会记录。

MINIMAL ：只记录修改的列。

NOBLOB :如果是text类型或clob字段，不记录这些日志。





我们可以将其修改为MINIMAL，则可以只记录修改的列的值。

3.4.2 binlog_rows_query_log_events参数

在Statement模式下，直接记录SQL比较直观，事实上，在Row模式下，也可以记录。mysql提供了一个binlog_rows_query_log_events参数，默认为值为FALSE，如果为true的情况下，会通过Rows Query Event来记录SQL。





 可以在my.cnf中添加以下配置，来开启row模式下的原始sql记录(需要重启)：



binlog-rows-query-log_events=1


之后，再插入数据数据时



insert into user(name) values("maoxinyi");


在binlog文件中，我们将看到Rows Query Event



3.5 GTID相关事件

从MySQL 5.6开始支持GTID复制。要开启GTID，修改my.cnf文件，添加以下配置



gtid-mode=on
enforce-gtid-consistency=true


在这种情况下，每当我们执行一个事务之前，都会记录一个GTID Event



insert into user("name") values("zhuyihan");


此时binlog内容如下：



而当我们切换到下一个binlog文件时，会记录之前的已经执行过的GTID。这里我们通过执行以下sql手工切换到一个新的binlog文件。



mysql> flush logs;
Query OK, 0 rows affected (0.00 sec)


之后在新的binlog文件中，我们看到之前执行过的GTID在下一个文件中出现了。



本文不是专门讲解GTID的文章，感兴趣的读者，可以自行查看相关资料。



4 总结

本文对mysql binlog的应用场景进行了深入的讲解，并介绍了mysql中大部分binlog event的作用。

如果读者想更加深入的去学习，例如如何模拟mysql的slave去解析binlog，可以参考一些开源的实现，不过这些生产级别的组件，因此通常代码比较复杂。笔者自己也造过类似的轮子，仅仅模拟slave去拉取mysql的binlog，并对事件进行解析，对于理解binlog解析的核心原理应该有一些帮助。

