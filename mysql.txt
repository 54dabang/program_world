164. 数据库的三范式是什么？

第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。

第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在
仅依赖主关键字一部分的属性。

第三范式：任何非主属性不依赖于其它非主属性。
165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？

表类型如果是 InnoDB，那 id 就是 6。
表类型如果是 MyISAM ，那 id 就是 8。
一张表里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把mysql重启，再insert一条记录，这条记录的ID是18还是15 ？

一般情况下，我们创建的表的类型是InnoDB，如果新增一条记录（不重启mysql的情况下），这条记录的id是18；但是如果重启（文中提到的）MySQL的话，这条记录的ID是15。因为InnoDB表只把自增主键的最大ID记录到内存中，所以重启数据库或者对表OPTIMIZE操作，都会使最大ID丢失。

但是，如果我们使用表的类型是MylSAM，那么这条记录的ID就是18。因为MylSAM表会把自增主键的最大ID记录到数据文件里面，重启MYSQL后，自增主键的最大ID也不会丢失。

注：如果在这17条记录里面删除的是中间的几个记录（比如删除的是10,11,12三条记录），重启MySQL数据库后，insert一条记录后，ID都是18。因为内存或者数据库文件存储都是自增主键最大ID

166. 如何获取当前数据库版本？

使用 select version() 获取当前 MySQL 数据库版本。

167. 说一下 ACID 是什么？

Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
168. char 和 varchar 的区别是什么？

char(n) ：固定长度类型，比如订阅 char(10)，当你输入"abc"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。
chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。
varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。
所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。
169. float 和 double 的区别是什么？

float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。

double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。
170. mysql 的内连接、左连接、右连接有什么区别？

内连接关键字：inner join；左连接：left join；右连接：right join。

内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。

171. mysql 索引是怎么实现的？

索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。

具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。

172. 怎么验证 mysql 的索引是否满足需求？

使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。

explain 语法：explain select * from table where type=1。

173. 说一下数据库的事务隔离？

MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ

可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。

READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。
READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。
REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。
SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。
脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。

不可重复读 ：是指在一个事务内，多次读同一数据。

幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。

174. 说一下 mysql 常用的引擎？

InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。

MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。

175. 说一下 mysql 的行锁和表锁？

MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。

表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。

行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。
176. 说一下乐观锁和悲观锁？

乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。
悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。
数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。

177. mysql 问题排查都有哪些手段？

使用 show processlist 命令查看当前所有连接信息。

使用 explain 命令查询 SQL 语句执行计划。

开启慢查询日志，查看慢查询的 SQL。


178. 如何做 mysql 的性能优化？

为搜索字段创建索引。

避免使用 select *，列出需要查询的字段。

垂直分割分表。

选择正确的存储引擎。

============

本篇文章会分析下一个sql语句在mysql中的执行流程，包括sql的查询在mysql内部会怎么流转，sql语句的更新是怎么完成的。

mysql主要分为Server层和存储引擎层

Server层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog日志模块。

存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，其中InnoDB引擎有自有的日志模块redolog 模块。

InnoDB 5.5.5版本作为默认引擎。

连接器

主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。

查询缓存

连接建立后，执行查询语句的时候，会先查询缓存，Mysql会先校验这个sql是否执行过，以Key-Value的形式缓存在内存中，Key是查询预计，Value是结果集。如果缓存key被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。

Mysql 查询不建议使用缓存，因为对于经常更新的数据来说，缓存的有效时间太短了，往往带来的效果并不好，对于不经常更新的数据来说，使用缓存还是可以的，Mysql 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。

分析器

mysql 没有命中缓存，那么就会进入分析器，分析器主要是用来分析SQL语句是来干嘛的，分析器也会分为几步：

第一步，词法分析，一条SQL语句有多个字符串组成，首先要提取关键字，比如select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。

第二步，语法分析，主要就是判断你输入的sql是否正确，是否符合mysql的语法。

完成这2步之后，mysql就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。

优化器

优化器的作用就是它认为的最优的执行方案去执行（虽然有时候也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。

执行器

当选择了执行方案后，mysql就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。

二、语句分析
2.1 查询语句
说了以上这么多，那么究竟一条sql语句是如何执行的呢？其实我们的sql可以分为2中，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：

select * from tb_student  A where A.age='18' and A.name='张三';
结合上面的说明，我们分析下这个语句的执行流程：

先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在mysql8.0版本以前，会先查询缓存，以这条sql语句为key在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。

通过分析器进行词法分析，提取sql语句的关键元素，比如提取上面这个语句是查询select，提取需要查询的表名为tb_student,需要查询所有的列，查询条件是这个表的id='1'。然后判断这个sql语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。

接下来就是优化器进行确定执行方案，上面的sql语句，可以有两种执行方案：

  a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是18。
  b.先找出学生中年龄18岁的学生，然后再查询姓名为“张三”的学生。
那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。

进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

2.2 更新语句
以上就是一条查询sql的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql语句如下：

update tb_student A set A.age='19' where A.name='张三';
我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，mysql 自带的日志模块式binlog（归档日志），所有的存储引擎都可以使用，我们常用的InnoDB引擎还自带了一个日志模块redo log，我们就以InnoDB模式下来探讨这个语句的执行流程。流程如下：

先查询到张三这一条数据，如果有缓存，也是会用到缓存。

然后拿到查询的语句，把 age 改为19，然后调用引擎API接口，写入这一行数据，InnoDB引擎把数据保存在内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成了，随时可以提交。

执行器收到通知后记录binlog，然后调用引擎接口，提交redo log 为提交状态。

更新完成。

这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗？这就是之前mysql的模式了，MyISAM引擎是没有redo log的，那么我们知道它是不支持事务的，所以并不是说只用一个日志模块不可以，只是InnoDB引擎就是通过redo log来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么redo log 要引入prepare预提交状态？这里我们用反证法来说明下为什么要这么做？

先写redo log 直接提交，然后写 binlog，假设写完redo log 后，机器挂了，binlog日志没有被写入，那么机器重启后，这台机器会通过redo log恢复数据，但是这个时候bingog并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。

先写binlog，然后写redo log，假设写完了binlog，机器异常重启了，由于没有redo log，本机是无法恢复这一条记录的，但是binlog又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

如果采用redo log 两阶段提交的方式就不一样了，写完binglog后，然后再提交redo log就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设redo log 处于预提交状态，binglog也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于mysql的处理机制了，mysql的处理过程如下：

判断redo log 是否完整，如果判断是完整的，就立即提交。

如果redo log 只是预提交但不是commit状态，这个时候就会去判断binlog是否完整，如果完整就提交 redo log, 不完整就回滚事务。

这样就解决了数据一致性的问题。

三、总结
Mysql 主要分为Server曾和引擎层，Server层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用。

引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory等。

sql等执行过程分为两类，

一类对于查询等过程如下：权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎

对于更新等语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit

MySQL作为最流行的关系型数据库管理系统，重要性不言而喻。面试时它也是重点考察对象之一，估计大家都有过被MySQL相关问题支配的经历：

如何理解MySQL中加锁原理以及最终死锁形成的原因 ？

介绍一下连接池的工作方式，为什么 mysql 的连接数说爆就爆了？

简洁描述下 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？
说一下隔离级别的语义，必须使用事务的话绕不开，为什么同样的代码，迁移到 RDS 后行为会不一致？

上面几个问题，你能全部答出来吗？

其实，无论是后端程序员、前端程序员，还是架构师，数据库是所有开发人员需要面对的共性部分。大家工作项目中的性能问题，容易出现瓶颈的地方常常是MySQL这块，用好它对于整体项目性能提升会有很大帮助。可以说MySQL掌握的越深入，你能做的事情就越多。

有些人觉得自己花了不少精力去学如何做MySQL性能优化，但进展不快，很可能忽视了这点：有了性能分析的技术储备，才能更好掌握性能优化。最近我整理了一套MySQL视频，由浅及深讲了MySQL性能分析 + 性能优化，内容很细，基本覆盖了大家日常工作中经常碰到的一些问题，有必要共享给读者。

具体有哪些细节内容？

【 MySQL执行计划查看、索引失效分析、加锁分析 】

1. 索引优化之组合索引的使用技巧

组合索引、最左前缀原则

2. explain执行计划重要参数select_type讲解

MySQL优化器、子查询、联合查询、临时表

3. explain执行计划重要参数type讲解

MySQL优化器、主键索引、唯一索引、非唯一索引、组合索引、索引覆盖

4. explain执行计划重要参数extra讲解

MySQL优化器、索引覆盖、文件排序、ICP

5. 索引失效案例分析

组合索引、最左前缀原则、索引覆盖



【 MySQL锁和事务篇 】

1. InnoDB存储引擎内存结构之Buffer Pool

InnoDB的架构图、InnoDB内存结构和物理文件之间的工作关系、数据页、索引页

2. InnoDB存储引擎内存结构之Redo Log Buffer

InnoDB的架构图、Redo log工作原理和落盘原理

3. InnoDB存储引擎物理文件之系统表空间和用户表空间文件

InnoDB的架构图、系统表空间文件和用户表空间文件

4. InnoDB存储引擎物理文件之重做日志文件和归档文件

InnoDB的架构图、重做日志文件、重做日志缓冲

5. InnoDB存储引擎之重做日志落盘机制

InnoDB的架构图、落盘机制、WAL(Write ahead redo log)、Force-log-at-commit、checkpoint机制

6. InnoDB存储引擎事务原理之原子性、持久性和一致性实现

redo log、undo log和Force Log at Commit机制、checkpoint机制

7. InnoDB存储引擎事务原理之隔离性实现

MVCC、Lock-based CC、一致性非锁定读(consistent nonlocking read)、快照读&当前读

8. InnoDB存储引擎之一条简单SQL的行锁加锁实现分析

record lock、gap lock、next key lock、RR和RC隔离级别、MVCC机制、主键索引、辅助索引

9. InnoDB存储引擎之一条复杂SQL的行锁加锁实现分析

record lock、gap lock、next key lock、RR和RC隔离级别、MVCC机制、主键索引、辅助索引

10. InnoDB存储引擎之死锁原理分析

主键索引、辅助索引、死锁


1、一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？
1.如果表的类型是MyISAM，那么是18.因为MyISAM会把自己增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。
2.如果表的类型是InnoDB，那么是15.InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。

2、Mysql的技术特点是什么？
Mysql数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程SQL服务器、不同的后端、广泛的应用程序编程接口和管理工具。

3、Heap表是什么？
HEAP表存在于内存中，用于临时高速存储。

BLOB或TEXT字段是不允许的

只能使用比较运算符=，<，>，=>，= <

HEAP表不支持AUTO_INCREMENT

索引不可为NULL

4、Mysql服务器默认端口是什么？
Mysql服务器的默认端口是3306。

5、与Oracle相比，Mysql有什么优势？
Mysql是开源软件，随时可用，无需付费。

Mysql是便携式的

带有命令提示符的GUI。

使用Mysql查询浏览器支持管理

6、如何区分FLOAT和DOUBLE？
以下是FLOAT和DOUBLE的区别：

浮点数以8位精度存储在FLOAT中，并且有四个字节。

浮点数存储在DOUBLE中，精度为18位，有八个字节。

7、区分CHAR_LENGTH和LENGTH？
CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。

8、请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？
SQL标准定义的四个隔离级别为：

read uncommited ：读到未提交数据

read committed：脏读，不可重复读

repeatable read：可重读

serializable ：串行事物 详细解释如下： Read Uncommitted（读取未提交内容） 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。 Read Committed（读取提交内容） 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。 Repeatable Read（可重读） 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。 Serializable（可串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在： 1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。 2、非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。 3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。 不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：

9、在Mysql中ENUM的用法是什么？
ENUM是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。

Create table size(name ENUM('Smail,'Medium','Large');

10、如何定义REGEXP？
REGEXP是模式匹配，其中匹配模式在搜索值的任何位置。

11、CHAR和VARCHAR的区别？
以下是CHAR和VARCHAR的区别：

CHAR和VARCHAR类型在存储和检索方面有所不同

CHAR列长度固定为创建表时声明的长度，长度值范围是1到255

当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。

12、列的字符串类型可以是什么？
字符串类型是：

SET

BLOB

ENUM

CHAR

TEXT

VARCHAR

13、如何获取当前的Mysql版本？
SELECT VERSION();用于获取当前Mysql的版本。

14、Mysql中使用什么存储引擎？
存储引擎称为表类型，数据使用各种技术存储在文件中。

技术涉及：

Storage mechanism

Locking levels

Indexing

Capabilities and functions.

15、Mysql驱动程序是什么？
以下是Mysql中可用的驱动程序：

PHP驱动程序

JDBC驱动程序

ODBC驱动程序

CWRAPPER

PYTHON驱动程序

PERL驱动程序

RUBY驱动程序

CAP11PHP驱动程序

Ado.net5.mxj

16、TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？
创建表时TIMESTAMP列用Zero更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP修饰符就将时间戳字段更新为当前时间。

17、主键和候选键有什么区别？
表格的每一行都由主键唯一标识,一个表只有一个主键。

主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。

18、如何使用Unix shell登录Mysql？
我们可以通过以下命令登录：

# [mysql dir]/bin/mysql -h hostname -u -p
19、 myisamchk是用来做什么的？
它用来压缩MyISAM表，这减少了磁盘或内存使用。

20、MYSQL数据库服务器性能分析的方法命令有哪些?
Show status

一些值得监控的变量值：

Bytes_received和Bytes_sent

和服务器之间来往的流量。

Com_*服务器正在执行的命令。

Created_*在查询执行期限间创建的临时表和文件。

Handler_*存储引擎操作。

Select_*不同类型的联接执行计划。

Sort_*几种排序信息。

Show session status like ‘Select’;

Show profiles

SET profiling=1;

Show profiles \G

Show profile;

21、如何控制HEAP表的最大尺寸？
Heal表的大小可通过称为max_heap_table_size的Mysql配置变量来控制。

22、MyISAM Static和MyISAM Dynamic有什么区别？
在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。

MyISAM Static在受损情况下更容易恢复。

23、federated表是什么？
federated表，允许访问位于其他服务器数据库上的表。

24、如果一个表有一列定义为TIMESTAMP，将发生什么？
每当行被更改时，时间戳字段将获取当前时间戳。

25、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？
它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

26、怎样才能找出最后一次插入时分配了哪个自动增量？
LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。

27、你怎么看到为表格定义的所有索引？
索引是通过以下方式为表格定义的：

SHOW INDEX FROM ;

28.、LIKE声明中的％和_是什么意思？
％对应于0个或更多字符，_ 只是LIKE语句中的一个字符。

29、如何在Unix和Mysql时间戳之间进行转换？
UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令

FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令

30、列对比运算符是什么？
在SELECT语句的列比较中使用=，<>，<=，<，> =，>，<<，>>，<=>，AND，OR或LIKE运算符。

31、我们如何得到受查询影响的行数？
行数可以通过以下代码获得：

SELECT COUNT(user_id)FROM users;

32、Mysql查询是否区分大小写？
不区分

SELECT VERSION(), CURRENT_DATE;

SeLect version(), current_date;

seleCt vErSiOn(), current_DATE;
所有这些例子都是一样的，Mysql不区分大小写。

33.、LIKE和REGEXP操作有什么区别？
LIKE和REGEXP运算符用于表示^和％。

SELECT * FROM employee WHERE emp_name LIKE "%b";

SELECT * FROM employee WHERE emp_name REGEXP "^b";
34.、BLOB和TEXT有什么区别？
BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB -

TINYBLOB

BLOB

MEDIUMBLOB和

LONGBLOB

它们只能在所能容纳价值的最大长度上有所不同。

TEXT是一个不区分大小写的BLOB。四种TEXT类型

TINYTEXT

TEXT

MEDIUMTEXT和

LONGTEXT

它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。

BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。

35、mysql_fetch_array和mysql_fetch_object的区别是什么？
以下是mysql_fetch_array和mysql_fetch_object的区别：

mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。

mysql_fetch_object - 从数据库返回结果行作为对象。

36、我们如何在mysql中运行批处理模式？
以下命令用于在批处理模式下运行：

mysql;

mysql mysql.out
37、MyISAM表格将在哪里存储，并且还提供其存储格式？
每个MyISAM表格以三种格式存储在磁盘上：

·“.frm”文件存储表定义

·数据文件具有“.MYD”（MYData）扩展名

索引文件具有“.MYI”（MYIndex）扩展名

38、Mysql中有哪些不同的表格？
共有5种类型的表格：

MyISAM

Heap

Merge

INNODB

ISAM
MyISAM是Mysql的默认存储引擎。

39、ISAM是什么？
ISAM简称为索引顺序访问方法。它是由IBM开发的，用于在磁带等辅助存储系统上存储和检索数据。

40、InnoDB是什么？
lnnoDB是一个由Oracle公司开发的Innobase Oy事务安全存储引擎。

41、Mysql如何优化DISTINCT？
DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。

SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
42、如何输入字符为十六进制数字？
如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。

如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。

43、如何显示前50行？
在Mysql中，使用以下代码查询显示前50行：

SELECT*FROM

LIMIT 0,50;
44、可以使用多少列创建索引？
任何标准表最多可以创建16个索引列。

45、NOW（）和CURRENT_DATE（）有什么区别？
NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。

CURRENT_DATE（）仅显示当前年份，月份和日期。

46、什么样的对象可以使用CREATE语句创建？
以下对象是使用CREATE语句创建的：

DATABASE

EVENT

FUNCTION

INDEX

PROCEDURE

TABLE

TRIGGER

USER

VIEW
47、Mysql表中允许有多少个TRIGGERS？
在Mysql表中允许有六个触发器，如下：

BEFORE INSERT

AFTER INSERT

BEFORE UPDATE

AFTER UPDATE

BEFORE DELETE

AFTER DELETE
48、什么是非标准字符串类型？
以下是非标准字符串类型：

TINYTEXT

TEXT

MEDIUMTEXT

LONGTEXT
49、什么是通用SQL函数？
CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。

FORMAT(X, D)- 格式化数字X到D有效数字。

CURRDATE(), CURRTIME()- 返回当前日期或时间。

NOW（） - 将当前日期和时间作为一个值返回。

MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中提取给定数据。

HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。

DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄

SUBTIMES（A，B） - 确定两次之间的差异。

FROMDAYS（INT） - 将整数天数转换为日期值。
50、解释访问控制列表
ACL（访问控制列表）是与对象关联的权限列表。这个列表是Mysql服务器安全模型的基础，它有助于排除用户无法连接的问题。

Mysql将ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql会按照预定的顺序检查ACL的认证信息和权限。

51、MYSQL支持事务吗？
在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。

但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。

示例如下：

一

START TRANSACTION;

SELECT @A:=SUM(salary) FROM table1 WHERE type=1;

UPDATE table2 SET summmary=@A WHERE type=1;

COMMIT;
52、 mysql里记录货币用什么字段类型好
NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。

例如：

salary DECIMAL(9,2)

在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。

因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI/ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。

同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。Mysql当前不支持DECIMAL/NUMERIC数据类型的这些变种形式的任一种。

这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。

DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。

一个字符用于值的每一位、小数点(如果scale>0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。

DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。

当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。

当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，Mysql存储表示那个范围的相应的端点值。

我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。

53、MYSQL数据表在什么情况下容易损坏？
服务器突然断电导致数据文件损坏。

强制关机，没有先关闭 mysql 服务等。

54、mysql有关权限的表都有哪几个？
Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。

55、Mysql中有哪几种锁？
MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁。

表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低

行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高


### 1、一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？

1.如果表的类型是MyISAM，那么是18.因为MyISAM会把自己增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。
2.如果表的类型是InnoDB，那么是15.InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。

### 2、Mysql的技术特点是什么？

Mysql数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程SQL服务器、不同的后端、广泛的应用程序编程接口和管理工具。

### 3、Heap表是什么？

HEAP表存在于内存中，用于临时高速存储。

BLOB或TEXT字段是不允许的

只能使用比较运算符=，<，>，=>，= <

HEAP表不支持AUTO_INCREMENT

索引不可为NULL

### 4、Mysql服务器默认端口是什么？

Mysql服务器的默认端口是3306。

### 5、与Oracle相比，Mysql有什么优势？

Mysql是开源软件，随时可用，无需付费。

Mysql是便携式的

带有命令提示符的GUI。

使用Mysql查询浏览器支持管理

### 6、如何区分FLOAT和DOUBLE？

以下是FLOAT和DOUBLE的区别：

浮点数以8位精度存储在FLOAT中，并且有四个字节。

浮点数存储在DOUBLE中，精度为18位，有八个字节。

### 7、区分CHAR_LENGTH和LENGTH？

CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。

### 8、请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？

SQL标准定义的四个隔离级别为：

read uncommited ：读到未提交数据

read committed：脏读，不可重复读

repeatable read：可重读

serializable ：串行事物
详细解释如下：
Read Uncommitted（读取未提交内容）
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
Read Committed（读取提交内容）
这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
Repeatable Read（可重读）
这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。
Serializable（可串行化）
这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在：
1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。
2、非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。
3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。
不同的隔离级别有不同的现象，并有不同的锁定/并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：
![](https://ws1.sinaimg.cn/large/006DGX4tly1fvjufj9m9gj30h704it8n.jpg)

### 9、在Mysql中ENUM的用法是什么？

ENUM是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。

Create table size(name ENUM('Smail,'Medium','Large');

### 10、如何定义REGEXP？

REGEXP是模式匹配，其中匹配模式在搜索值的任何位置。

### 11、CHAR和VARCHAR的区别？

以下是CHAR和VARCHAR的区别：

CHAR和VARCHAR类型在存储和检索方面有所不同

CHAR列长度固定为创建表时声明的长度，长度值范围是1到255

当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。

### 12、列的字符串类型可以是什么？

字符串类型是：

SET

BLOB

ENUM

CHAR

TEXT

VARCHAR

### 13、如何获取当前的Mysql版本？

SELECT VERSION();用于获取当前Mysql的版本。

### 14、Mysql中使用什么存储引擎？

存储引擎称为表类型，数据使用各种技术存储在文件中。

技术涉及：

Storage mechanism

Locking levels

Indexing

Capabilities and functions.

### 15、Mysql驱动程序是什么？

以下是Mysql中可用的驱动程序：

PHP驱动程序

JDBC驱动程序

ODBC驱动程序

CWRAPPER

PYTHON驱动程序

PERL驱动程序

RUBY驱动程序

CAP11PHP驱动程序

Ado.net5.mxj

### 16、TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？

创建表时TIMESTAMP列用Zero更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP修饰符就将时间戳字段更新为当前时间。

### 17、主键和候选键有什么区别？

表格的每一行都由主键唯一标识,一个表只有一个主键。

主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。

### 18、如何使用Unix shell登录Mysql？

我们可以通过以下命令登录：
``` sql
# [mysql dir]/bin/mysql -h hostname -u -p
```

### 19、 myisamchk是用来做什么的？

它用来压缩MyISAM表，这减少了磁盘或内存使用。

### 20、MYSQL数据库服务器性能分析的方法命令有哪些?

Show status

一些值得监控的变量值：

Bytes_received和Bytes_sent

和服务器之间来往的流量。

Com_*服务器正在执行的命令。

Created_*在查询执行期限间创建的临时表和文件。

Handler_*存储引擎操作。

Select_*不同类型的联接执行计划。

Sort_*几种排序信息。

Show session status like ‘Select’;

Show profiles

SET profiling=1;

Show profiles \G

Show profile;

### 21、如何控制HEAP表的最大尺寸？

Heal表的大小可通过称为max_heap_table_size的Mysql配置变量来控制。

### 22、MyISAM Static和MyISAM Dynamic有什么区别？

在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。

MyISAM Static在受损情况下更容易恢复。

### 23、federated表是什么？

federated表，允许访问位于其他服务器数据库上的表。

### 24、如果一个表有一列定义为TIMESTAMP，将发生什么？

每当行被更改时，时间戳字段将获取当前时间戳。

### 25、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？

它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

### 26、怎样才能找出最后一次插入时分配了哪个自动增量？

LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。

### 27、你怎么看到为表格定义的所有索引？

索引是通过以下方式为表格定义的：

SHOW INDEX FROM ;

### 28.、LIKE声明中的％和_是什么意思？

％对应于0个或更多字符，_ 只是LIKE语句中的一个字符。

### 29、如何在Unix和Mysql时间戳之间进行转换？

UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令

FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令

### 30、列对比运算符是什么？

在SELECT语句的列比较中使用=，<>，<=，<，> =，>，<<，>>，<=>，AND，OR或LIKE运算符。

### 31、我们如何得到受查询影响的行数？

行数可以通过以下代码获得：

SELECT COUNT(user_id)FROM users;

### 32、Mysql查询是否区分大小写？

不区分
``` sql
SELECT VERSION(), CURRENT_DATE;

SeLect version(), current_date;

seleCt vErSiOn(), current_DATE;
```
所有这些例子都是一样的，Mysql不区分大小写。

### 33.、LIKE和REGEXP操作有什么区别？

LIKE和REGEXP运算符用于表示^和％。
``` sql
SELECT * FROM employee WHERE emp_name LIKE "%b";

SELECT * FROM employee WHERE emp_name REGEXP "^b";
```

### 34.、BLOB和TEXT有什么区别？

BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB -

TINYBLOB

BLOB

MEDIUMBLOB和

LONGBLOB

它们只能在所能容纳价值的最大长度上有所不同。

TEXT是一个不区分大小写的BLOB。四种TEXT类型

TINYTEXT

TEXT

MEDIUMTEXT和

LONGTEXT

它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。

BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。

### 35、mysql_fetch_array和mysql_fetch_object的区别是什么？

以下是mysql_fetch_array和mysql_fetch_object的区别：

- mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。

- mysql_fetch_object - 从数据库返回结果行作为对象。

### 36、我们如何在mysql中运行批处理模式？

以下命令用于在批处理模式下运行：
``` sql
mysql;

mysql mysql.out
```

### 37、MyISAM表格将在哪里存储，并且还提供其存储格式？

每个MyISAM表格以三种格式存储在磁盘上：

·“.frm”文件存储表定义

·数据文件具有“.MYD”（MYData）扩展名

索引文件具有“.MYI”（MYIndex）扩展名

### 38、Mysql中有哪些不同的表格？

共有5种类型的表格：
```
MyISAM

Heap

Merge

INNODB

ISAM
```

MyISAM是Mysql的默认存储引擎。

### 39、ISAM是什么？

ISAM简称为索引顺序访问方法。它是由IBM开发的，用于在磁带等辅助存储系统上存储和检索数据。

### 40、InnoDB是什么？

lnnoDB是一个由Oracle公司开发的Innobase Oy事务安全存储引擎。

### 41、Mysql如何优化DISTINCT？

DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。
``` sql
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
```

### 42、如何输入字符为十六进制数字？

如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。

如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。

### 43、如何显示前50行？

在Mysql中，使用以下代码查询显示前50行：
``` sql
SELECT*FROM

LIMIT 0,50;
```

### 44、可以使用多少列创建索引？

任何标准表最多可以创建16个索引列。

### 45、NOW（）和CURRENT_DATE（）有什么区别？

NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。

CURRENT_DATE（）仅显示当前年份，月份和日期。

### 46、什么样的对象可以使用CREATE语句创建？

以下对象是使用CREATE语句创建的：
```
DATABASE

EVENT

FUNCTION

INDEX

PROCEDURE

TABLE

TRIGGER

USER

VIEW
```

### 47、Mysql表中允许有多少个TRIGGERS？

在Mysql表中允许有六个触发器，如下：
```
BEFORE INSERT

AFTER INSERT

BEFORE UPDATE

AFTER UPDATE

BEFORE DELETE

AFTER DELETE
```

### 48、什么是非标准字符串类型？

以下是非标准字符串类型：
```
TINYTEXT

TEXT

MEDIUMTEXT

LONGTEXT
```

### 49、什么是通用SQL函数？

```
CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。

FORMAT(X, D)- 格式化数字X到D有效数字。

CURRDATE(), CURRTIME()- 返回当前日期或时间。

NOW（） - 将当前日期和时间作为一个值返回。

MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） - 从日期值中提取给定数据。

HOUR（），MINUTE（），SECOND（） - 从时间值中提取给定数据。

DATEDIFF（A，B） - 确定两个日期之间的差异，通常用于计算年龄

SUBTIMES（A，B） - 确定两次之间的差异。

FROMDAYS（INT） - 将整数天数转换为日期值。
```

### 50、解释访问控制列表

ACL（访问控制列表）是与对象关联的权限列表。这个列表是Mysql服务器安全模型的基础，它有助于排除用户无法连接的问题。

Mysql将ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql会按照预定的顺序检查ACL的认证信息和权限。

### 51、MYSQL支持事务吗？

在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。

但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。

示例如下：
```
一

START TRANSACTION;

SELECT @A:=SUM(salary) FROM table1 WHERE type=1;

UPDATE table2 SET summmary=@A WHERE type=1;

COMMIT;
```

### 52、 mysql里记录货币用什么字段类型好

NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。

例如：

salary DECIMAL(9,2)

在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。

因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI/ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。

同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。Mysql当前不支持DECIMAL/NUMERIC数据类型的这些变种形式的任一种。

这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。

DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。

一个字符用于值的每一位、小数点(如果scale>0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。

DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。

当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。

当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，Mysql存储表示那个范围的相应的端点值。

我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。

### 53、MYSQL数据表在什么情况下容易损坏？

服务器突然断电导致数据文件损坏。

强制关机，没有先关闭 mysql 服务等。

### 54、mysql有关权限的表都有哪几个？

Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。

### 55、Mysql中有哪几种锁？

MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁。

- 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低

- 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高

一条查询SQL执行流程图如下



本文改编自《高性能Mysql》，烟哥用小说的形式来讲这个内容。
序章 自我介绍
我是一条sql，就是一条长长的字符串，不要问我长什么样，因为我比较傲娇。




额~~不是我不说啊，因为细说起来，我可以细分为DML(Update、Insert、Delete),DDL(表结构修改),DCL(权限操作),DQL(Select)操作,一个个去介绍，我怕大家嫌我烦！
嗯，大家没什么意见，我继续往下自我介绍了~
由于种类太多，这里我只是一条查询SQL，也就是一句DQL。
客户端按照Mysql通信协议，把我发送到服务端。
当我到达服务端后，我会在一个单独的线程里进行执行。服务端要先…



万万没想到，我又被打断了~好吧，因为我在一个线程里执行，总要有办法能看到线程的执行状态吧。Mysql提供了下面的命令，给大家查看
SHOW [FULL] PROCESSLIST
出来的结果是长下面这样的



图里Command这一列，反应的就是这个线程当前的执行状态啦。我在这个线程的执行过程中，状态是会变化很多次。
你看图里，有一个Sleep，这是在告诉你线程正在等待客户端发送新的请求。还有一个为Query,这代表线程正在执行查询或者正在将结果发送给客户端。
至于其他的，还有Locked、Sending data等等，分别代表…



额，好吧，唠唠叨叨了一大堆，大家居然木有嫌我烦，嗯，至于其他状态的含义大家可以去Mysql官网查询哦。
嗯，回到刚才的话题。我到达服务端后，Mysql要判断我的前6个字符是否为select。并且，语句中不带有SQL_NO_CACHE关键字，如果符合条件，就进入查询缓存。
第一章 我和查询缓存的那些事
说到查询缓存，它其实是一个哈希表，它将执行过的语句及其结果会以 key-value 对的形式，被直接缓存在内存中。
它的key是一个哈希值，是通过查询SQL(也就是我)、当前要查询的数据库、客户端协议版本等，生成的一个哈希值，而它的value自然就是查询结果啦。

当然，如果我要绕过查询缓存，也很简单。我可以像下面这么写:

Select SQL_NO_CACHE * from table
也可以将参数query_cache_type设置成DEMAND来绕过查询缓存。

可是，有一天查询缓存悲伤的对我说:"你将来再也看不到我了，我已经被历史淘汰了，Mysql8.0版本开始就没有我了！"
听到这个消息后，我表面上故作坚强的对查询缓存说:"不要方，大家会想你的！"
然而，实际上心里想的是:"嘿嘿嘿，你个坑爹的，终于不存在了！"大家不要觉得我太邪恶，毕竟查询缓存实在是太不好用了。接下来我们来说说解析器…




万万没想到，本来想糊弄过去的。结果…好吧，回到正题，因为
只要有对一个表的更新，这个表上所有的查询缓存都会被清空

SQL任何字符上的不同,如空格,注释,都会导致缓存不命中

因此，我能想到用查询缓存的表，只有一种情况，那就是配置表。其他的业务表，根本是无法利用查询缓存的特性，或许Mysql团队也是觉得查询缓存的使用场景过于局限，就无情的将它剔除。

第二章 我和分析器的爱恨情仇
(本文将解析器和预处理器统一称为分析器)
话说，我离开查询缓存后，进入解析器。
解析器:"来来来，我先对你进行词法分析，告诉我你长啥样？"
我是下面这样的

select username from userinfo
解析器:"好，好，好。我有两个阶段，我先对你进行词法分析，我将你从左到右一个字符、一个字符地输入，然后根据构词规则识别单词。你将会生成4个Token,如下所示。"



解析器:"接下来呢，进行语法解析，判断你输入的这个 SQL 语句是否满足 MySQL 语法。然后生成下面这样一颗语法树。"



我："如果语法不对呢？"
解析器:"那你会收到一个提示如下！"
You have an error in your SQL syntax
解析器:"顺利生成语法树以后，我就将你送往预处理器！"
预处理器:"老弟，你来拉!"
我:"嗯！"
预处理器:"老弟，我来帮你看看你的列名对不对，数据库的这张表里是不是真的有这个列。再看看表名对不对，如果不对，你会看到下面的错误！"

Unknown column xxx in ‘where clause’
预处理器:"最后我再给你送去做权限验证，如果你没有操作这个表的权限，会报下面这个错误!"

ERROR 1142 (42000): SELECT command denied to user 'root'@'localhost' for table 'xxx'
（这个地方，大家可能有疑问，因为有些文章说是执行器做的权限验证，可以直接拉到本文底部看说明）

最后，这颗语法树会传递给优化器。

第三章 我和优化器的动人过往
在告别了解析器后，我进入了优化器。
优化器大哥:"告诉我，你长什么样啊？"
我说道:"大哥不要捉急，我是长这样的~"(这里优化的其实应该是语法树，我只是为了便于说明，才用SQL当例子，实际上是针对语法树进行优化)

select t1.*
from Table1 t1
inner join Table2 t2
on t1.CommonID = t2.CommonID
优化器大哥:"我的任务就是帮你判断一下怎么样执行更快，比如先查Table1再查Table2，还是先查Table2再查Table1呢？判断完如何执行以后，生成执行计划就好啦！"
我很不信任的说道：“哼，你就不会判断失误么！”
优化器大哥:"那就要对SQL进行改写啦，比如你带了STRAIGHT_JOIN关键字，长下面这样"

select t1.*
from Table1 t1
STRAIGHT_JOIN  Table2 t2
on t1.CommonID = t2.CommonID
"那我就知道强制先找Table1再关联找Table2啦，类似的例子还有很多，我就不一一列举了！"
(STRAIGHT_JOIN功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。)

我说道:"哇塞，如何编写一个高效的SQL，真是一门学问啊！"
于是，优化器大哥将我变身为一个执行计划，然后交给执行器啦~

第四章 我和执行器的悲情经历
我:"执行器大哥，你是用来做什么的？"
执行器:"就是根据执行计划来进行执行查询啦。我就根据你的指令，逐条调用底层存储引擎，逐步执行。"
MySQL定义了一系列抽象存储引擎API，以支持插件式存储引擎架构。Mysql实现了一个抽象接口层，叫做 handler(sql/handler.h)，其中定义了接口函数，比如：ha_open, ha_index_end, ha_create等等，存储引擎需要实现这些接口才能被系统使用。

末章 一些感慨
最后一个阶段，Mysql会将查询结果返回客户端。
唯一需要说明的是，如果是SELECT类型的SQL，Mysql会将查询结果缓存起来。至于其他的SQL，就将该表涉及到的查询缓存清空。

一些疑问
这里关于权限验证究竟在哪个阶段执行，大家可能会有一些疑问。
之前有一个大牛的文章说是权限验证是在执行阶段，去执行前验证权限，大家如果看过他的文章，可能会有疑问。我也不是乱质疑人家，毕竟我只是一个小咖。我在这里只是发表一下我自己的论点，欢迎大家拍砖。

论点一:权限验证在执行器中判断从逻辑上说不通
一条查询SQL经过查询缓存、分析器、优化器，执行器。如果到最后一个阶段执行器中才发现权限不足、那不是前面一系列流程白做了，Mysql应该不至于这么傻吧~

论点二:同《高性能Mysql》一书内容不符
该书209页有一句话如下图所示




该书也指明权限验证是在预处理器中执行。本文中将预处理和解析器统一划分为分析器的范畴。
论点三:同源码不符
我翻看了Mysql5.7.25这个版本的源码，其在处理查询这段的核心代码如下
在sql_parse.cc文件中，有这么一段代码如下

case SQLCOM_SELECT:
 {
    //省略
    res= select_precheck(thd, lex, all_tables, first_table);
    if (!res)
      res= execute_sqlcom_select(thd, all_tables);
    //省略
  }
其中select_precheck是进行权限校验。而优化器和执行器是在execute_sqlcom_select这个方法中。