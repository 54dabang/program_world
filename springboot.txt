第1部分 总览Spring Boot
第1章 初览Spring Boot 2
1.1 Spring Framework时代 2
1.2 Spring Boot简介 3
1.3 Spring Boot的特性 5
1.4 准备运行环境 5
1.4.1 装配JDK 8 5
1.4.2 装配Maven 6
1.4.3 装配IDE（集成开发环境） 8
第2章 理解独立的Spring应用 9
2.1 创建Spring Boot应用 10
2.1.1 命令行方式创建Spring Boot应用 11
2.1.2 图形化界面创建Spring Boot应用 21
2.1.3 创建Spring Boot应用可执行JAR 29
2.2 运行Spring Boot应用 31
2.2.1 执行Spring Boot应用可执行JAR 32
2.2.2 Spring Boot应用可执行JAR资源结构 32
2.2.3 FAT JAR和WAR执行模块——spring-boot-loader 36
2.2.4 JarLauncher的实现原理 40
第3章 理解固化的Maven依赖 58
3.1 spring-boot-starter-parent与spring-boot-dependencies简介 58
3.2 理解spring-boot-starter-parent与spring-boot- dependencies 61
第4章 理解嵌入式Web容器 70
4.1 嵌入式Servlet Web容器 71
4.1.1 Tomcat作为嵌入式Servlet Web容器 72
4.1.2 Jetty作为嵌入式Servlet Web容器 77
4.1.3 Undertow作为嵌入式Servlet Web容器 80
4.2 嵌入式Reactive Web容器 82
4.2.1 UndertowServletWebServer作为嵌入式Reactive Web容器 82
4.2.2 UndertowWebServer作为嵌入式Reactive Web容器 84
4.2.3 WebServerInitializedEvent 91
4.2.4 Jetty作为嵌入式Reactive Web容器 93
4.2.5 Tomcat作为嵌入式Reactive Web容器 94
第5章 理解自动装配 96
5.1 理解@SpringBootApplication注解语义 97
5.2 @SpringBootApplication属性别名 103
5.3 @SpringBootApplication标注非引导类 107
5.4 @EnableAutoConfiguration激活自动装配 108
5.5 @SpringBootApplication“继承”@Configuration CGLIB提升特性 110
5.6 理解自动配置机制 112
5.7 创建自动配置类 116
第6章 理解Production- Ready特性 119
6.1 理解Production-Ready一般性定义 120
6.2 理解Spring Boot Actuator 123
6.3 Spring Boot Actuator Endpoints 124
6.4 理解“外部化配置 129
6.5 理解“规约大于配置” 132
6.6 小马哥有话说 134
6.6.1 Spring Boot作为微服务中间件 134
6.6.2 Spring Boot作为Spring Cloud基础设施 135
6.7 下一站：走向自动装配 135
第2部分 走向自动装配
第7章 走向注解驱动编程（Annotation-Driven） 138
7.1 注解驱动发展史 138
7.1.1 注解驱动启蒙时代：Spring Framework 1.x 138
7.1.2 注解驱动过渡时代：Spring Framework 2.x 139
7.1.3 注解驱动黄金时代：Spring Framework 3.x 142
7.1.4 注解驱动完善时代：Spring Framework 4.x 146
7.1.5 注解驱动当下时代：Spring Framework 5.x 151
7.2 Spring核心注解场景分类 152
7.3 Spring注解编程模型 154
7.3.1 元注解（Meta-Annotations） 154
7.3.2 Spring模式注解（Stereotype Annotations） 155
7.3.3 Spring组合注解（Composed Annotations） 187
7.3.4 Spring注解属性别名和覆盖（Attribute Aliases and Overrides） 195
第8章 Spring注解驱动设计模式 225
8.1 Spring @Enable模块驱动 225
8.1.1 理解@Enable模块驱动 225
8.1.2 自定义@Enable模块驱动 226
8.1.3 @Enable模块驱动原理 236
8.2 Spring Web自动装配 250
8.2.1 理解Web自动装配 250
8.2.2 自定义Web自动装配 254
8.2.3 Web自动装配原理 258
8.3 Spring条件装配 270
8.3.1 理解配置条件装配 271
8.3.2 自定义配置条件装配 274
8.3.3 配置条件装配原理 277
第9章 Spring Boot自动装配 292
9.1 理解Spring Boot自动装配 295
9.1.1 理解@EnableAutoConfiguration 296
9.1.2 优雅地替换自动装配 298
9.1.3 失效自动装配 298
9.2 Spring Boot自动装配原理 299
9.2.1 @EnableAutoConfiguration读取候选装配组件 301
9.2.2 @EnableAutoConfiguration排除自动装配组件 305
9.2.3 @EnableAutoConfiguration过滤自动装配组件 307
9.2.4 @EnableAutoConfiguration自动装配事件 313
9.2.5 @EnableAutoConfiguration自动装配生命周期 317
9.2.6 @EnableAutoConfiguration排序自动装配组件 324
9.2.7 @EnableAutoConfiguration自动装配BasePackages 332
9.3 自定义Spring Boot自动装配 337
9.3.1 自动装配Class命名的潜规则 338
9.3.2 自动装配package命名的潜规则 338
9.3.3 自定义Spring Boot Starter 340
9.4 Spring Boot条件化自动装配 346
9.4.1 Class条件注解 347
9.4.2 Bean条件注解 358
9.4.3 属性条件注解 370
9.4.4 Resource条件注解 376
9.4.5 Web应用条件注解 391
9.4.6 Spring表达式条件注解 397
9.5 小马哥有话说 401
9.6 下一站：理解SpringApplication 402
第3部分 理解SpringApplication
第10章 SpringApplication初始化阶段 405
10.1 SpringApplication构造阶段 405
10.1.1 理解SpringApplication主配置类 406
10.1.2 SpringApplication的构造过程 410
10.1.3 推断Web应用类型 411
10.1.4 加载Spring应用上下文初始化器（ApplicationContextInitializer） 412
10.1.5 加载Spring应用事件监听器（ApplicationListener） 415
10.1.6 推断应用引导类 416
10.2 SpringApplication配置阶段 417
10.2.1 自定义SpringApplication 417
10.2.2 调整SpringApplication设置 417
10.2.3 增加SpringApplication配置源 420
10.2.4 调整Spring Boot外部化配置 423
第11章 SpringApplication运行阶段 425
11.1 SpringApplication准备阶段 425
11.1.1 理解SpringApplicationRunListeners 426
11.1.2 理解SpringApplicationRunListener 428
11.1.3 理解Spring Boot事件 431
11.1.4 理解Spring事件/监听机制 432
11.1.5 理解Spring Boot事件/监听机制 492
11.1.6 装配ApplicationArguments 509
11.1.7 准备ConfigurableEnvironment 512
11.1.8 创建Spring应用上下文（ConfigurableApplicationContext） 512
11.1.9 Spring应用上下文运行前准备 516
11.2 Spring应用上下文启动阶段 537
11.3 Spring应用上下文启动后阶段 539
11.3.1 afterRefresh方法签名的变化 540
11.3.2 afterRefresh方法语义的变化 541
11.3.3 Spring Boot事件ApplicationStartedEvent语义的变化 543
11.3.4 执行CommandLineRunner和ApplicationRunner 548
第12章 SpringApplication结束阶段 550
12.1 SpringApplication正常结束 550
12.2 SpringApplication异常结束 555
12.2.1 Spring Boot异常处理 556
12.2.2 错误分析报告器——FailureAnalysisReporter 562
12.2.3 自定义实现FailureAnalyzer和FailureAnalysisReporter 564
12.2.4 Spring Boot 2.0重构handleRunFailure和reportFailure方法 566
12.2.5 Spring Boot 2.0的SpringBootExceptionReporter接口 567
第13章 Spring Boot应用退出 571
13.1 Spring Boot应用正常退出 572
13.1.1 ExitCodeGenerator Bean生成退出码 572
13.1.2 ExitCodeGenerator Bean退出码使用场景 576
13.2 Spring Boot应用异常退出 580
13.2.1 ExitCodeGenerator异常使用场景 582
13.2.2 ExitCodeExceptionMapper Bean映射异常与退出码 587
13.2.3 退出码用于SpringApplication异常结束 589
13.3 小马哥有话说 594
13.4 下一站：运维篇 596





Spring Boot / Spring Cloud
104. 什么是 spring boot？

在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。

SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。

105. 为什么要用 spring boot？
Spring Boot使编码变简单

Spring Boot使配置变简单

Spring Boot使部署变简单

Spring Boot使监控变简单

Spring的不足
106. spring boot 核心配置文件是什么？

Spring Boot提供了两种常用的配置文件：

properties文件
yml文件
107. spring boot 配置文件有哪几种类型？它们有什么区别？

Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。

108. spring boot 有哪些方式可以实现热部署？

SpringBoot热部署实现有两种方式：

①. 使用spring loaded

在项目中添加如下代码：

<build>
        <plugins>
            <plugin>
                <!-- springBoot编译插件-->
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <dependencies>
                    <!-- spring热部署 -->
                    <!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 -->
                    <dependency>
                        <groupId>org.springframework</groupId>
                        <artifactId>springloaded</artifactId>
                        <version>1.2.6.RELEASE</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
添加完毕后需要使用mvn指令运行：

首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的"+",然后选择maven将出现右侧面板，在红色划线部位输入如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）

在这里插入图片描述点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可
在这里插入图片描述
②. 使用spring-boot-devtools

在项目的pom文件中添加依赖：

 <!--热部署jar-->
 <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-devtools</artifactId>
 </dependency>
1
2
3
4
5
然后：使用 shift+ctrl+alt+"/" （IDEA中的快捷键） 选择"Registry" 然后勾选 compiler.automake.allow.when.app.running

109. jpa 和 hibernate 有什么区别？

JPA Java Persistence API，是Java EE 5的标准ORM接口，也是ejb3规范的一部分。
Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。
JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。
ibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。
hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。
hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。
110. 什么是 spring cloud？

从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。

Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。

Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：
在这里插入图片描述
使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。

111. spring cloud 断路器的作用是什么？

在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。

断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。

112. spring cloud 的核心组件有哪些？

①. 服务发现——Netflix Eureka

一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。

②. 客服端负载均衡——Netflix Ribbon

Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。

③. 断路器——Netflix Hystrix

断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。

④. 服务网关——Netflix Zuul

类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。

⑤. 分布式配置——Spring Cloud Config

这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。

转载自：https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA