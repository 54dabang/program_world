第1章　Java EE简介
1．1　Java EE
1．1．1　Java EE架构
1．1．2　Java EE的缺点
1．2　Spring
1．2．1　Spring IoC容器和AOP
1．2．2　Spring的缺点
1．3　Spring Boot
1．4　Hello，Spring Boot
1．4．1　创建一个Maven工程
1．4．2　增加Web支持
1．4．3　Hello Spring Boot示例
1．4．4　使用热部署
1．4．5　添加REST支持
第2章　Spring Boot基础
2．1　检查Java环境与安装Java
2．2　安装和配置Maven
2．2．1　Maven介绍
2．2．2　安装Maven
2．2．3　设置Maven
2．2．4　使用IDE设置Maven
2．2．5　Maven的常用命令
2．3　Spring核心技术
2．3．1　Spring的历史
2．3．2　Spring容器介绍
2．3．3　Spring AOP介绍
第3章　MVC框架
3．1　集成MVC框架
3．1．1　引入依赖
3．1．2　Web应用目录结构
3．1．3　Java包名结构
3．2　使用Controller
3．3　URL映射到方法
3．3．1　@RequestMapping
3．3．2　URL路径匹配
3．3．3　HTTP method匹配
3．3．4　consumes和produces
3．3．5　params和header匹配
3．4　方法参数
3．4．1　PathVariable
3．4．2　Model＆ModelAndView
3．4．3　JavaBean接受HTTP参数
3．4．4　@RequsetBody接受JSON
3．4．5　MultipartFile
3．4．6　@ModelAttribute
3．4．7　@InitBinder
3．5　验证框架
3．5．1　JSR-303
3．5．2　MVC中使用@Validated
3．5．3　自定义校验
3．6　WebMvcConfigurer
3．6．1　拦截器
3．6．2　跨域访问
3．6．3　格式化
3．6．4　注册Controller
3．7　视图技术
3．7．1　使用Freemarker
3．7．2　使用Beetl
3．7．3　使用Jackson
3．7．4　Redirect和Forward
3．8　通用错误处理
3．9　@Service和@Transactional
3．9．1　声明一个Service类
3．9．2　事务管理
3．10　curl命令
第4章　视图技术
4．1　Beetl模板引擎
4．1．1　安装Beetl
4．1．2　设置定界符号和占位符
4．1．3　配置Beetl
4．1．4　groupTemplate
4．2　使用变量
4．2．1　全局变量
4．2．2　局部变量
4．2．3　共享变量
4．2．4　模板变量
4．3　表达式
4．3．1　计算表达式
4．3．2　逻辑表达式
4．4　控制语句
4．4．1　循环语句
4．4．2　条件语句
4．4．3　try catch
4．5　函数调用
4．6　格式化函数
4．7　直接调用Java
4．8　标签函数
4．9　HTML标签
4．10　安全输出
4．11　高级功能
4．11．1　配置Beetl
4．11．2　自定义函数
4．11．3　自定义格式化函数
4．11．4　自定义标签函数
4．11．5　自定义HTML标签
4．11．6　布局
4．11．7　AJAX局部渲染
4．12　脚本引擎
4．13　JSON技术
4．13．1　在Spring Boot中使用Jackson
4．13．2　自定义ObjectMapper
4．13．3　Jackson的三种使用方式
4．13．4　Jackson树遍历
4．13．5　对象绑定
4．13．6　流式操作
4．13．7　Jackson注解
4．13．8　集合的反序列化
4．14　MVC分离开发
4．14．1　集成WebSimulate
4．14．2　模拟JSON响应
4．14．3　模拟模板渲染
第5章　数据库访问
5．1　配置数据源
5．2　Spring JDBC Template
5．2．1　查询
5．2．2　修改
5．2．3　JdbcTemplate增强
5．3　BeetlSQL介绍
5．3．1　BeetlSQL功能概览
5．3．2　添加Maven依赖
5．3．3　配置BeetlSQL
5．3．4　SQLManager
5．3．5　使用SQL文件
5．3．6　Mapper
5．3．7　使用实体
5．4　SQLManager内置CRUD
5．4．1　内置的插入API
5．4．2　内置的更新（删除）API
5．4．3　内置的查询API
5．4．4　代码生成方法
5．5　使用sqlId
5．5．1　md文件命名
5．5．2　md文件构成
5．5．3　调用sqlId
5．5．4　翻页查询
5．5．5　TailBean
5．5．6　ORM查询
5．5．7　其他API
5．5．8　Mapper详解
5．6　BeetlSQL的其他功能
5．6．1　常用函数和标签
5．6．2　主键设置
5．6．3　BeetlSQL注解
5．6．4　NameConversion
5．6．5　锁
第6章　Spring Data JPA
6．1　集成Spring Data JPA
6．1．1　集成数据源
6．1．2　配置JPA支持
6．1．3　创建Entity
6．1．4　简化Entity
6．2　Repository
6．2．1　CrudRepository
6．2．2　PagingAndSortingRepository
6．2．3　JpaRepository
6．2．4　持久化Entity
6．2．5　Sort
6．2．6　Pageable和Page
6．2．7　基于方法名字查询
6．2．8　@Query查询
6．2．9　使用JPA Query
6．2．10　Example查询
第7章　Spring Boot配置
7．1　配置Spring Boot
7．1．1　服务器配置
7．1．2　使用其他Web服务器
7．1．3　配置启动信息
7．1．4　配置浏览器显示ico
7．2　日志配置
7．3　读取应用配置
7．3．1　Environment
7．3．2　@Value
7．3．3　@ConfigurationProperties
7．4　Spring Boot自动装配
7．4．1　@Configuration和@Bean
7．4．2　Bean条件装配
7．4．3　Class条件装配
7．4．4　Environment装配
7．4．5　其他条件装配
7．4．6　联合多个条件
7．4．7　Condition接口
7．4．8　制作Starter
第8章　部署Spring Boot应用
8．1　以jar文件运行
8．2　以war方式部署
8．3　多环境部署
8．4　@Profile注解
第9章　Testing单元测试
9．1　JUnit介绍
9．1．1　JUnit的相关概念
9．1．2　JUnit测试
9．1．3　Assert
9．1．4　Suite
9．2　Spring Boot单元测试
9．2．1　测试范围依赖
9．2．2　Spring Boot测试脚手架
9．2．3　测试Service
9．2．4　测试MVC
9．2．5　完成MVC请求模拟
9．2．6　比较MVC的返回结果
9．2．7　JSON比较
9．3　Mockito
9．3．1　模拟对象
9．3．2　模拟方法参数
9．3．3　模拟方法返回值
9．4　面向数据库应用的单元测试
9．4．1　@Sql
9．4．2　XLSUnit
9．4．3　XLSUnit的基本用法
第10章　REST
10．1　REST简介
10．1．1　REST风格的架构
10．1．2　使用“api”作为上下文
10．1．3　增加一个版本标识
10．1．4　标识资源
10．1．5　确定HTTP Method
10．1．6　确定HTTP Status
10．1．7　REST VS． WebService
10．2　Spring Boot集成REST
10．2．1　集成REST
10．2．2　@RestController
10．2．3　REST Client
10．3　Swagger UI
10．3．1　集成Swagger
10．3．2　Swagger规范
10．3．3　接口描述
10．3．4　查询参数描述
10．3．5　URI中的参数
10．3．6　HTTP头参数
10．3．7　表单参数
10．3．8　文件上传参数
10．3．9　整个请求体作为参数
10．4　模拟REST服务
第11章　MongoDB
11．1　安装MongoDB
11．2　使用shell
11．2．1　指定数据库
11．2．2　插入文档
11．2．3　查询文档
11．2．4　更新操作
11．2．5　删除操作
11．3　Spring Boot集成MongoDB
11．4　增删改查
11．4．1　增加API
11．4．2　根据主键查询API
11．4．3　查询API
11．4．4　修改API
11．4．5　删除API
11．4．6　使用MongoDatabase
11．4．7　打印日志
第12章　Redis
12．1　安装Redis
12．2　使用redis-cli
12．2．1　安全设置
12．2．2　基本操作
12．2．3　keys
12．2．4　Redis List
12．2．5　Redis Hash
12．2．6　Set
12．2．7　Pub/Sub
12．3　Spring Boot集成Redis
12．4　使用StringRedisTemplate
12．4．1　opsFor
12．4．2　绑定Key的操作
12．4．3　RedisConnection
12．4．4　Pub/Sub
12．5　序列化策略
12．5．1　默认序列化策略
12．5．2　自定义序列化策略
第13章　Elasticsearch
13．1　Elasticsearch介绍
13．1．1　安装Elasticsearch
13．1．2　Elasticsearch的基本概念
13．2　使用REST访问Elasticsearch
13．2．1　添加文档
13．2．2　根据主键查询
13．2．3　根据主键更新
13．2．4　根据主键删除
13．2．5　搜索文档
13．2．6　联合多个索引搜索
13．3　使用RestTemplate访问ES
13．3．1　创建Book
13．3．2　使用RestTemplate获取搜索结果
13．4　Spring Data Elastic
13．4．1　安装Spring Data
13．4．2　编写Entity
13．4．3　编写Dao
13．4．4　编写Controller
第14章　Cache
14．1　关于Cache
14．1．1　Cache的组件和概念
14．1．2　Cache的单体应用
14．1．3　使用专有的Cache服务器
14．1．4　使用一二级缓存服务器
14．2　Spring Boot Cache
14．3　注释驱动缓存
14．3．1　@Cacheable
14．3．2　Key生成器
14．3．3　@CachePut
14．3．4　@CacheEvict
14．3．5　@Caching
14．3．6　@CacheConfig
14．4　使用Redis Cache
14．4．1　集成Redis缓存
14．4．2　禁止缓存
14．4．3　定制缓存
14．5　Redis缓存原理
14．6　实现Redis两级缓存
14．6．1　实现TwoLevelCacheManager
14．6．2　创建RedisAndLocalCache
14．6．3　缓存同步说明
14．6．4　将代码组合在一起
第15章　Spring Session
15．1　水平扩展实现
15．2　Nginx的安装和配置
15．2．1　安装Nginx
15．2．2　配置Nginx
15．3　Spring Session
15．3．1　Spring Session介绍
15．3．2　使用Redis
15．3．3　Nginx+Redis
第16章　Spring Boot和ZooKeeper
16．1　ZooKeeper
16．1．1　ZooKeeper的数据结构
16．1．2　安装ZooKeeper
16．1．3　ZooKeeper的基本命令
16．1．4　领导选取演示
16．1．5　分布式锁演示
16．1．6　服务注册演示
16．2　Spring Boot集成ZooKeeper
16．2．1　集成Curator
16．2．2　Curator API
16．3　实现分布式锁
16．4　服务注册
16．4．1　通过ServiceDiscovery注册服务
16．4．2　获取服务
16．5　领导选取
第17章　监控Spring Boot应用
17．1　安装Acutator
17．2　HTTP跟踪
17．3　日志查看
17．4　线程栈信息
17．5　内存信息
17．6　查看URL映射
17．7　查看Spring容器管理的Bean
17．8　其他监控
17．9　编写自己的监控信息
17．9．1　编写HealthIndicator
17．9．2　自定义监控

第Ⅰ部分　基础知识

第1 章　云原生应用程序 3

第2 章　训练营：Spring Boot 和Cloud Foundry 21

第3 章　符合十二要素程序风格的配置 67

第４章　测试 85

第5 章　迁移遗留的应用程序 115

第Ⅱ部分　Web 服务

第6 章　REST API 137

第7 章　路由 179

第8 章　边缘服务 197

第Ⅲ部分　数据整合

第9 章　数据管理 251

第10 章　消息系统 303

第11 章　批处理和任务 325

第12 章　数据集成 363

第IV 部分　生产

第13 章　可观测的系统 411

第14 章　服务代理 469

第15 章　持续交付 497

第V 部分　附录

附录A　在Java EE 中使用Spring Boot 527


第1章 初览Spring Boot 2
1.1 Spring Framework时代 2
1.2 Spring Boot简介 3
1.3 Spring Boot的特性 5
1.4 准备运行环境 5
1.4.1 装配JDK 8 5
1.4.2 装配Maven 6
1.4.3 装配IDE（集成开发环境） 8
第2章 理解独立的Spring应用 9
2.1 创建Spring Boot应用 10
2.1.1 命令行方式创建Spring Boot应用 11
2.1.2 图形化界面创建Spring Boot应用 21
2.1.3 创建Spring Boot应用可执行JAR 29
2.2 运行Spring Boot应用 31
2.2.1 执行Spring Boot应用可执行JAR 32
2.2.2 Spring Boot应用可执行JAR资源结构 32
2.2.3 FAT JAR和WAR执行模块——spring-boot-loader 36
2.2.4 JarLauncher的实现原理 40
第3章 理解固化的Maven依赖 58
3.1 spring-boot-starter-parent与spring-boot-dependencies简介 58
3.2 理解spring-boot-starter-parent与spring-boot- dependencies 61
第4章 理解嵌入式Web容器 70
4.1 嵌入式Servlet Web容器 71
4.1.1 Tomcat作为嵌入式Servlet Web容器 72
4.1.2 Jetty作为嵌入式Servlet Web容器 77
4.1.3 Undertow作为嵌入式Servlet Web容器 80
4.2 嵌入式Reactive Web容器 82
4.2.1 UndertowServletWebServer作为嵌入式Reactive Web容器 82
4.2.2 UndertowWebServer作为嵌入式Reactive Web容器 84
4.2.3 WebServerInitializedEvent 91
4.2.4 Jetty作为嵌入式Reactive Web容器 93
4.2.5 Tomcat作为嵌入式Reactive Web容器 94
第5章 理解自动装配 96
5.1 理解@SpringBootApplication注解语义 97
5.2 @SpringBootApplication属性别名 103
5.3 @SpringBootApplication标注非引导类 107
5.4 @EnableAutoConfiguration激活自动装配 108
5.5 @SpringBootApplication“继承”@Configuration CGLIB提升特性 110
5.6 理解自动配置机制 112
5.7 创建自动配置类 116
第6章 理解Production- Ready特性 119
6.1 理解Production-Ready一般性定义 120
6.2 理解Spring Boot Actuator 123
6.3 Spring Boot Actuator Endpoints 124
6.4 理解“外部化配置 129
6.5 理解“规约大于配置” 132
6.6 小马哥有话说 134
6.6.1 Spring Boot作为微服务中间件 134
6.6.2 Spring Boot作为Spring Cloud基础设施 135
6.7 下一站：走向自动装配 135
第2部分 走向自动装配
第7章 走向注解驱动编程（Annotation-Driven） 138
7.1 注解驱动发展史 138
7.1.1 注解驱动启蒙时代：Spring Framework 1.x 138
7.1.2 注解驱动过渡时代：Spring Framework 2.x 139
7.1.3 注解驱动黄金时代：Spring Framework 3.x 142
7.1.4 注解驱动完善时代：Spring Framework 4.x 146
7.1.5 注解驱动当下时代：Spring Framework 5.x 151
7.2 Spring核心注解场景分类 152
7.3 Spring注解编程模型 154
7.3.1 元注解（Meta-Annotations） 154
7.3.2 Spring模式注解（Stereotype Annotations） 155
7.3.3 Spring组合注解（Composed Annotations） 187
7.3.4 Spring注解属性别名和覆盖（Attribute Aliases and Overrides） 195
第8章 Spring注解驱动设计模式 225
8.1 Spring @Enable模块驱动 225
8.1.1 理解@Enable模块驱动 225
8.1.2 自定义@Enable模块驱动 226
8.1.3 @Enable模块驱动原理 236
8.2 Spring Web自动装配 250
8.2.1 理解Web自动装配 250
8.2.2 自定义Web自动装配 254
8.2.3 Web自动装配原理 258
8.3 Spring条件装配 270
8.3.1 理解配置条件装配 271
8.3.2 自定义配置条件装配 274
8.3.3 配置条件装配原理 277
第9章 Spring Boot自动装配 292
9.1 理解Spring Boot自动装配 295
9.1.1 理解@EnableAutoConfiguration 296
9.1.2 优雅地替换自动装配 298
9.1.3 失效自动装配 298
9.2 Spring Boot自动装配原理 299
9.2.1 @EnableAutoConfiguration读取候选装配组件 301
9.2.2 @EnableAutoConfiguration排除自动装配组件 305
9.2.3 @EnableAutoConfiguration过滤自动装配组件 307
9.2.4 @EnableAutoConfiguration自动装配事件 313
9.2.5 @EnableAutoConfiguration自动装配生命周期 317
9.2.6 @EnableAutoConfiguration排序自动装配组件 324
9.2.7 @EnableAutoConfiguration自动装配BasePackages 332
9.3 自定义Spring Boot自动装配 337
9.3.1 自动装配Class命名的潜规则 338
9.3.2 自动装配package命名的潜规则 338
9.3.3 自定义Spring Boot Starter 340
9.4 Spring Boot条件化自动装配 346
9.4.1 Class条件注解 347
9.4.2 Bean条件注解 358
9.4.3 属性条件注解 370
9.4.4 Resource条件注解 376
9.4.5 Web应用条件注解 391
9.4.6 Spring表达式条件注解 397
9.5 小马哥有话说 401
9.6 下一站：理解SpringApplication 402
第3部分 理解SpringApplication
第10章 SpringApplication初始化阶段 405
10.1 SpringApplication构造阶段 405
10.1.1 理解SpringApplication主配置类 406
10.1.2 SpringApplication的构造过程 410
10.1.3 推断Web应用类型 411
10.1.4 加载Spring应用上下文初始化器（ApplicationContextInitializer） 412
10.1.5 加载Spring应用事件监听器（ApplicationListener） 415
10.1.6 推断应用引导类 416
10.2 SpringApplication配置阶段 417
10.2.1 自定义SpringApplication 417
10.2.2 调整SpringApplication设置 417
10.2.3 增加SpringApplication配置源 420
10.2.4 调整Spring Boot外部化配置 423
第11章 SpringApplication运行阶段 425
11.1 SpringApplication准备阶段 425
11.1.1 理解SpringApplicationRunListeners 426
11.1.2 理解SpringApplicationRunListener 428
11.1.3 理解Spring Boot事件 431
11.1.4 理解Spring事件/监听机制 432
11.1.5 理解Spring Boot事件/监听机制 492
11.1.6 装配ApplicationArguments 509
11.1.7 准备ConfigurableEnvironment 512
11.1.8 创建Spring应用上下文（ConfigurableApplicationContext） 512
11.1.9 Spring应用上下文运行前准备 516
11.2 Spring应用上下文启动阶段 537
11.3 Spring应用上下文启动后阶段 539
11.3.1 afterRefresh方法签名的变化 540
11.3.2 afterRefresh方法语义的变化 541
11.3.3 Spring Boot事件ApplicationStartedEvent语义的变化 543
11.3.4 执行CommandLineRunner和ApplicationRunner 548
第12章 SpringApplication结束阶段 550
12.1 SpringApplication正常结束 550
12.2 SpringApplication异常结束 555
12.2.1 Spring Boot异常处理 556
12.2.2 错误分析报告器——FailureAnalysisReporter 562
12.2.3 自定义实现FailureAnalyzer和FailureAnalysisReporter 564
12.2.4 Spring Boot 2.0重构handleRunFailure和reportFailure方法 566
12.2.5 Spring Boot 2.0的SpringBootExceptionReporter接口 567
第13章 Spring Boot应用退出 571
13.1 Spring Boot应用正常退出 572
13.1.1 ExitCodeGenerator Bean生成退出码 572
13.1.2 ExitCodeGenerator Bean退出码使用场景 576
13.2 Spring Boot应用异常退出 580
13.2.1 ExitCodeGenerator异常使用场景 582
13.2.2 ExitCodeExceptionMapper Bean映射异常与退出码 587
13.2.3 退出码用于SpringApplication异常结束 589
13.3 小马哥有话说 594
13.4 下一站：运维篇 596

第1章 Spring Boot来临　1



1.1　Spring的历史　1



1.2　注解还是XML　2



1.3　Spring Boot的优点　3



1.4　传统Spring MVC和Spring Boot的对比　4



第　2章 聊聊开发环境搭建和基本开发　10



2.1　搭建Spring Boot开发环境　10



2.1.1　搭建Eclipse开发环境　10



2.1.2　搭建IntelliJ IDEA开发环境　13



2.2　Spring Boot的依赖和自动配置　15



2.3　使用自定义配置　19



2.4　开发自己的Spring Boot项目　21



第3章　全注解下的Spring IoC　23



3.1　IoC容器简介　23



3.2　装配你的Bean　27



3.2.1　通过扫描装配你的Bean　27



3.2.2　自定义第三方Bean　31



3.3　依赖注入　32



3.3.1　注解@Autowired　34



3.3.2　消除歧义性——@Primary和@Quelifier　35



3.3.3　带有参数的构造方法类的装配　36



3.4　生命周期　37



3.5　使用属性文件　42



3.6　条件装配Bean　45



3.7　Bean的作用域　46



3.8　使用@Profile　48



3.9　引入XML配置Bean　50



3.10　使用Spring EL　51



第4章　开始约定编程——Spring AOP　53



4.1　约定编程　53



4.1.1　约定　53



4.1.2　ProxyBean的实现　57



4.1.3　总结　60



4.2　AOP的概念　61



4.2.1　为什么使用AOP　61



4.2.2　AOP 术语和流程　64



4.3　AOP开发详解　65



4.3.1　确定连接点　65



4.3.2　开发切面　66



4.3.3　切点定义　67



4.3.4　测试AOP　68



4.3.5　环绕通知　71



4.3.6　引入　72



4.3.7　通知获取参数　74



4.3.8　织入　75



4.4　多个切面　77



第5章　访问数据库　82



5.1　配置数据源　83



5.1.1　启动默认数据源　83



5.1.2　配置自定义数据源　83



5.2　使用JdbcTemplate操作数据库　86



5.3　使用JPA（Hibernate）操作数据　90



5.3.1　概述　90



5.3.2　开发JPA　90



5.4　整合MyBatis框架　96



5.4.1　MyBatis简介　96



5.4.2　MyBatis的配置　97



5.4.3　Spring Boot整合MyBatis　101



5.4.4　MyBatis的其他配置　104



第6章　聊聊数据库事务处理　107



6.1　JDBC的数据库事务　108



6.2　Spring声明式事务的使用　110



6.2.1　Spring声明式数据库事务约定　110



6.2.2　@Transactional的配置项　111



6.2.3　Spring事务管理器　113



6.2.4　测试数据库事务　114



6.3　隔离级别　118



6.3.1　数据库事务的知识　118



6.3.2　详解隔离级别　120



6.4　传播行为　124



6.4.1　传播行为的定义　125



6.4.2　测试传播行为　126



6.5　@Transactional自调用失效问题　130



第7章　使用性能利器——Redis　134



7.1　spring-data-redis项目简介　135



7.1.1　spring-data-redis项目的设计　135



7.1.2　RedisTemplate　137



7.1.3　Spring对Redis数据类型操作的封装　139



7.1.4　SessionCallback和RedisCallback接口　141



7.2　在Spring Boot中配置和使用Redis　142



7.2.1　在Spring Boot中配置Redis　142



7.2.2　操作Redis数据类型　143



7.3　Redis的一些特殊用法　148



7.3.1　使用Redis事务　148



7.3.2　使用Redis流水线　149



7.3.3　使用Redis发布订阅　150



7.3.4　使用Lua脚本　153



7.4　使用Spring缓存注解操作Redis　156



7.4.1　缓存管理器和缓存的启用　156



7.4.2　开发缓存注解　157



7.4.3　测试缓存注解　163



7.4.4　缓存注解自调用失效问题　165



7.4.5　缓存脏数据说明　165



7.4.6　自定义缓存管理器　166



第8章　文档数据库——MongoDB　168



8.1　配置MongoDB　169



8.2　使用MongoTemplate实例　170



8.2.1　搭建开发环境　170



8.2.2　使用MongoTemplate操作文档　173



8.3　使用JPA　178



8.3.1　基本用法　178



8.3.2　使用自定义查询　180



第9章　初识Spring MVC　183



9.1　Spring MVC框架的设计　183



9.2　Spring MVC流程　184



9.3　定制Spring MVC的初始化　191



9.4　Spring MVC实例　192



9.4.1　开发控制器　193



9.4.2　视图和视图渲染　194



第　10章 深入Spring MVC开发　197



10.1　处理器映射　197



10.2　获取控制器参数　198



10.2.1　在无注解下获取参数　199



10.2.2　使用@RequestParam获取参数　199



10.2.3　传递数组　200



10.2.4　传递JSON　200



10.2.5　通过URL传递参数　203



10.2.6　获取格式化参数　204



10.3　自定义参数转换规则　205



10.3.1　处理器获取参数逻辑　205



10.3.2　一对一转换器（Converter）　208



10.3.3　GenericConverter集合和数组转换　210



10.4　数据验证　211



10.4.1　JSR-303 验证　211



10.4.2　参数验证机制　214



10.5　数据模型　217



10.6　视图和视图解析器　219



10.6.1　视图设计　219



10.6.2　视图实例——导出PDF文件　220



10.7　文件上传　224



10.7.1　Spring MVC对文件上传的支持　224



10.7.2　开发文件上传功能　226



10.8　拦截器　228



10.8.1　拦截器的设计　228



10.8.2　开发拦截器　229



10.8.3　多个拦截器的顺序　231



10.9　国际化　234



10.9.1　国际化消息源　234



10.9.2　国际化解析器　235



10.9.3　国际化实例——SessionLocaleResolver　237



10.10　Spring MVC拾遗　240



10.10.1　@ResponseBody转换为JSON的秘密　240



10.10.2　重定向　241



10.10.3　操作会话对象　243



10.10.4　给控制器增加通知　245



10.10.5　获取请求头参数　247



第　11章 构建REST风格网站　249



11.1　REST简述　249



11.1.1　REST名词解释　249



11.1.2　HTTP的动作　250



11.1.3　REST风格的一些误区　251



11.2　使用Spring MVC开发REST风格端点　251



11.2.1　Spring MVC整合REST　252



11.2.2　使用Spring开发REST风格的端点　252



11.2.3　使用@RestController　260



11.2.4　渲染结果　261



11.2.5　处理HTTP状态码、异常和响应头　262



11.3　客户端请求RestTemplate　266



11.3.1　使用RestTemplate请求后端　267



11.3.2　获取响应头、状态码和资源交换　269



第　12章 安全——Spring Security　271



12.1　概述和简单安全认证　271



12.2　使用WebSecurityConfigurerAdapter自定义　273



12.3　自定义用户服务信息　274



12.3.1　使用内存签名服务　275



12.3.2　使用数据库定义用户认证服务　276



12.3.3　使用自定义用户认证服务　279



12.4　限制请求　281



12.4.1　配置请求路径访问权限　282



12.4.2　使用Spring表达式配置访问权限　283



12.4.3　强制使用HTTPS　285



12.4.4　防止跨站点请求伪造　285



12.5　用户认证功能　287



12.5.1　自定义登录页面　287



12.5.2　启用HTTP Basic认证　288



12.5.3　登出　289



第　13章 学点Spring其他的技术　291



13.1　异步线程池　291



13.1.1　定义线程池和开启异步可用　292



13.1.2　异步实例　292



13.2　异步消息　294



13.2.1　JMS实例——ActiveMQ　295



13.2.2　使用AMQP——RabbitMQ　299



13.3　定时任务　303



13.4　WebSocket 应用　306



13.4.1　开发简易的WebSocket服务　306



13.4.2　使用STOMP　311



第　14章 Spring 5新框架——WebFlux　319



14.1　基础概念　319



14.1.1　响应式编程的宣言　320



14.1.2　Reactor模型　320



14.1.3　Spring WebFlux的概述　322



14.1.4　WebHandler接口和运行流程　323



14.2　通过Spring MVC方式开发WebFlux服务端　325



14.2.1　开发持久层　325



14.2.2　开发服务层　327



14.2.3　开发控制层　328



14.2.4　配置服务　330



14.2.5　客户端开发——WebClient　331



14.3　深入WebFlux服务端开发　335



14.3.1　类型转换器——Converter　335



14.3.2　验证器——Validator　337



14.3.3　访问静态资源　338



14.4　深入客户端开发　339



14.4.1　处理服务端错误和转换　339



14.4.2　设置请求头　341



14.5　使用路由函数方式开发WebFlux　342



14.5.1　开发处理器　342



14.5.2　开发请求路由　346



14.5.3　使用过滤器　347



第　15章 实践一下——抢购商品　349



15.1　设计与开发　349



15.1.1　数据库表设计　349



15.1.2　使用MyBatis开发持久层　350



15.1.3　使用Spring开发业务层和控制层　353



15.1.4　测试和配置　355



15.2　高并发开发　357



15.2.1　超发现象　357



15.2.2　悲观锁　358



15.2.3　乐观锁　359



15.2.4　使用Redis处理高并发　365



第　16章 部署、测试和监控　371



16.1　部署和运行　371



16.1.1　打包　371



16.1.2　运行项目　373



16.1.3　热部署　375



16.2　测试　376



16.2.1　构建测试类　376



16.2.2　使用随机端口和REST风格测试　377



16.2.3　Mock测试　378



16.3　Actuator监控端点　379



16.4　HTTP监控　381



16.4.1　查看敏感信息　382



16.4.2　shutdown端点　383



16.4.3　配置端点　385



16.4.4　自定义端点　387



16.4.5　健康指标项　389



16.5　JMX监控　392



第　17章 分布式开发——Spring Cloud　393



17.1　服务治理和服务发现——Eureka　395



17.1.1　配置服务治理节点　395



17.1.2　服务发现　397



17.1.3　配置多个服务治理中心节点　401



17.2　微服务之间的调用　403



17.2.1　Ribbon客户端负载均衡　403



17.2.2　Feign声明式调用　406



17.3　断路器——Hystrix　409



17.3.1　使用降级服务　410



17.3.2　启用Hystrix仪表盘　412



17.4　路由网关——Zuul　415



17.4.1　构建Zuul网关　415



17.4.2　使用过滤器　418



17.5　使用@SpringCloudApplication　421



附录　Spring Boot知识点补充　423


第　1章 欢迎迈入云世界，Spring　1



1.1　什么是微服务　1



1.2　什么是Spring，为什么它与微服务有关　4



1.3　在本书中读者会学到什么　5



1.4　为什么本书与你有关　6



1.5　使用Spring Boot来构建微服务　6



1.6　为什么要改变构建应用的方式　10



1.7　云到底是什么　11



1.8　为什么是云和微服务　13



1.9　微服务不只是编写代码　14



1.9.1　核心微服务开发模式　15



1.9.2　微服务路由模式　16



1.9.3　微服务客户端弹性模式　17



1.9.4　微服务安全模式　18



1.9.5　微服务日志记录和跟踪模式　19



1.9.6　微服务构建和部署模式　20



1.10　使用Spring Cloud构建微服务　22



1.10.1　Spring Boot　23



1.10.2　Spring Cloud Config　23



1.10.3　Spring Cloud服务发现　24



1.10.4　Spring Cloud与Netflix Hystrix和Netflix Ribbon　24



1.10.5　Spring Cloud与Netflix Zuul　24



1.10.6　Spring Cloud Stream　24



1.10.7　Spring Cloud Sleuth　24



1.10.8　Spring Cloud Security　25



1.10.9　代码供应　25



1.11　通过示例来介绍Spring Cloud　25



1.12　确保本书的示例是有意义的　27



1.13　小结　28



第　2章 使用Spring Boot构建微服务　29



2.1　架构师的故事：设计微服务架构　31



2.1.1　分解业务问题　31



2.1.2　建立服务粒度　32



2.1.3　互相交流：定义服务接口　35



2.2　何时不应该使用微服务　36



2.2.1　构建分布式系统的复杂性　36



2.2.2　服务器散乱　36



2.2.3　应用程序的类型　36



2.2.4　数据事务和一致性　37



2.3　开发人员的故事：用SpringBoot和Java构建微服务　37



2.3.1　从骨架项目开始　37



2.3.2　引导Spring Boot应用程序：编写引导类　39



2.3.3　构建微服务的入口：Spring Boot控制器　40



2.4　DevOps工程师的故事：构建运行时的严谨性　44



2.4.1　服务装配：打包和部署微服务　46



2.4.2　服务引导：管理微服务的配置　47



2.4.3　服务注册和发现：客户端如何与微服务通信　48



2.4.4　传达微服务的“健康状况”　49



2.5　将视角综合起来　51



2.6　小结　52



第3章　使用Spring Cloud配置服务器控制配置　53



3.1　管理配置（和复杂性）　54



3.1.1　配置管理架构　55



3.1.2　实施选择　56



3.2　构建Spring Cloud配置服务器　58



3.2.1　创建Spring Cloud Config引导类　61



3.2.2　使用带有文件系统的Spring Cloud配置服务器　62



3.3　将Spring Cloud Config与Spring Boot客户端集成　64



3.3.1　建立许可证服务对Spring Cloud Config服务器的依赖　65



3.3.2　配置许可证服务以使用Spring Cloud Config　66



3.3.3　使用Spring Cloud配置服务器连接数据源　69



3.3.4　使用@Value注解直接读取属性　72



3.3.5　使用Spring Cloud配置服务器和Git　73



3.3.6　使用Spring Cloud配置服务器刷新属性　73



3.4　保护敏感的配置信息　75



3.4.1　下载并安装加密所需的Oracle JCE jar　75



3.4.2　创建加密密钥　76



3.4.3　加密和解密属性　76



3.4.4　配置微服务以在客户端使用加密　78



3.5　最后的想法　79



3.6　小结　80



第4章　服务发现　81



4.1　我的服务在哪里　82



4.2　云中的服务发现　84



4.2.1　服务发现架构　84



4.2.2　使用Spring和Netflix Eureka进行服务发现实战　87



4.3　构建Spring Eureka服务　88



4.4　通过Spring Eureka注册服务　90



4.5　使用服务发现来查找服务　93



4.5.1　使用Spring DiscoveryClient查找服务实例　95



4.5.2　使用带有Ribbon功能的Spring RestTemplate调用服务　97



4.5.3　使用Netflix Feign客户端调用服务　98



4.6　小结　100



第5章　使用Spring Cloud和NetflixHystrix的客户端弹性模式　101



5.1　什么是客户端弹性模式　102



5.1.1　客户端负载均衡模式　103



5.1.2　断路器模式　103



5.1.3　后备模式　103



5.1.4　舱壁模式　104



5.2　为什么客户端弹性很重要　104



5.3　进入Hystrix　107



5.4　搭建许可服务器以使用Spring Cloud和Hystrix　107



5.5　使用Hystrix实现断路器　109



5.5.1　对组织微服务的调用超时　111



5.5.2　定制断路器的超时时间　112



5.6　后备处理　113



5.7　实现舱壁模式　115



5.8　基础进阶—微调Hystrix　118



5.9　线程上下文和Hystrix　122



5.9.1　ThreadLocal与Hystrix　122



5.9.2　HystrixConcurrencyStrategy实战　125



5.10　小结　129



第6章　使用Spring Cloud和Zuul进行服务路由　131



6.1　什么是服务网关　132



6.2　Spring Cloud和Netflix Zuul简介　133



6.2.1　建立一个Zuul Spring Boot项目　134



6.2.2　为Zuul服务使用Spring Cloud注解　134



6.2.3　配置Zuul与Eureka进行通信　135



6.3　在Zuul中配置路由　135



6.3.1　通过服务发现自动映射路由　136



6.3.2　使用服务发现手动映射路由　137



6.3.3　使用静态URL手动映射路由　140



6.3.4　动态重新加载路由配置　142



6.3.5　Zuul和服务超时　143



6.4　Zuul的真正威力：过滤器　144



6.5　构建第 一个生成关联ID的Zuul前置过滤器　147



6.6　构建接收关联ID的后置过滤器　155



6.7　构建动态路由过滤器　157



6.7.1　构建路由过滤器的骨架　159



6.7.2　实现run()方法　159



6.7.3　转发路由　161



6.7.4　整合　162



6.8　小结　163



第7章　保护微服务　164



7.1　OAuth2简介　165



7.2　从小事做起：使用Spring和OAuth2来保护单个端点　167



7.2.1　建立EagleEye OAuth2验证服务　167



7.2.2　使用OAuth2服务注册客户端应用程序　168



7.2.3　配置EagleEye用户　171



7.2.4　验证用户　172



7.3　使用OAuth2保护组织服务　175



7.3.1　将Spring Security和OAuth2 jar添加到各个服务　176



7.3.2　配置服务以指向OAuth2验证服务　176



7.3.3　定义谁可以访问服务　177



7.3.4　传播OAuth2访问令牌　180



7.4　JSON Web Token与OAuth2　183



7.4.1　修改验证服务以颁发JWT令牌　184



7.4.2　在微服务中使用JWT　188



7.4.3　扩展JWT令牌　189



7.4.4　从JWT令牌中解析自定义字段　191



7.5　关于微服务安全的总结　193



7.6　小结　195



第8章　使用Spring Cloud Stream的事件驱动架构　196



8.1　为什么使用消息传递、EDA和微服务　197



8.1.1　使用同步请求-响应方式来传达状态变化　198



8.1.2　使用消息传递在服务之间传达状态更改　199



8.1.3　消息传递架构的缺点　201



8.2　Spring Cloud Stream简介　202



8.3　编写简单的消息生产者和消费者　205



8.3.1　在组织服务中编写消息生产者　205



8.3.2　在许可证服务中编写消息消费者　210



8.3.3　在实际操作中查看消息服务　213



8.4　Spring Cloud Stream用例：分布式缓存　214



8.4.1　使用Redis来缓存查找　215



8.4.2　定义自定义通道　221



8.4.3　将其全部汇集在一起：在收到消息时清除缓存　222



8.5　小结　223



第9章　使用Spring Cloud Sleuth和Zipkin进行分布式跟踪　224



9.1　Spring Cloud Sleuth与关联ID　225



9.1.1　将Spring Cloud Sleuth添加到许可证服务和组织服务中　226



9.1.2　剖析Spring Cloud Sleuth跟踪　226



9.2　日志聚合与Spring Cloud Sleuth　227



9.2.1　Spring Cloud Sleuth与Papertrail实现实战　229



9.2.2　创建Papertrail账户并配置syslog连接器　230



9.2.3　将Docker输出重定向到Papertrail　232



9.2.4　在Papertrail中搜索Spring Cloud Sleuth的跟踪ID　234



9.2.5　使用Zuul将关联ID添加到HTTP响应　235



9.3　使用Open Zipkin进行分布式跟踪　237



9.3.1　添加Spring Cloud Sleuth和Zipkin依赖项　238



9.3.2　配置服务以指向Zipkin　238



9.3.3　安装和配置Zipkin服务器　239



9.3.4　设置跟踪级别　240



9.3.5　使用Zipkin跟踪事务　241



9.3.6　可视化更复杂的事务　243



9.3.7　捕获消息传递跟踪　244



9.3.8　添加自定义跨度　246



9.4　小结　248



第　10章 部署微服务　250



10.1　EagleEye：在云中建立核心基础设施　251



10.1.1　使用亚马逊的RDS创建PostgreSQL数据库　253



10.1.2　在AWS中创建Redis集群　257



10.1.3　创建ECS集群　258



10.2　超越基础设施：部署EagleEye　262



10.3　构建和部署管道的架构　265



10.4　构建和部署管道实战　268



10.5　开始构建和部署管道：GitHub和Travis CI　270



10.6　使服务能够在Travis CI中构建　270



10.6.1　构建的核心运行时配置　273



10.6.2　安装预构建工具　275



10.6.3　执行构建　277



10.6.4　标记源代码　277



10.6.5　构建微服务并创建Docker镜像　279



10.6.6　将镜像推送到Docker Hub　279



10.6.7　在Amazon ECS中启动服务　280



10.6.8　启动平台测试　280



10.7　关于构建和部署管道的总结　282



10.8　小结　282



附录A　在桌面运行云服务　283



附录B　OAuth2授权类型　291

1.1　Spring风云再起　　1

1.1.1　重新认识Spring　　2

1.1.2　Spring Boot精要　　3

1.1.3　Spring Boot不是什么　　6

1.2　Spring Boot入门　　6

1.2.1　安装Spring Boot CLI　　7

1.2.2　使用Spring Initializr初始化Spring Boot项目　　10

1.3　小结　　18

第2章　开发第一个应用程序　　19

2.1　运用Spring Boot　　19

2.1.1　查看初始化的Spring Boot新项目　　21

2.1.2　Spring Boot项目构建过程解析　　24

2.2　使用起步依赖　　27

2.2.1　指定基于功能的依赖　　28

2.2.2　覆盖起步依赖引入的传递依赖　　29

2.3　使用自动配置　　30

2.3.1　专注于应用程序功能　　31

2.3.2　运行应用程序　　36

2.3.3　刚刚发生了什么　　38

2.4　小结　　41

第3章　自定义配置　　42

3.1　覆盖Spring Boot自动配置　　42

3.1.1　保护应用程序　　43

3.1.2　创建自定义的安全配置　　44

3.1.3　掀开自动配置的神秘面纱　　48

3.2　通过属性文件外置配置　　49

3.2.1　自动配置微调　　50

3.2.2　应用程序Bean的配置外置　　55

3.2.3　使用Profile进行配置　　59

3.3　定制应用程序错误页面　　62

3.4　小结　　64

第4章　测试　　66

4.1　集成测试自动配置　　66

4.2　测试Web应用程序　　68

4.2.1　模拟Spring MVC　　69

4.2.2　测试Web安全　　72

4.3　测试运行中的应用程序　　74

4.3.1　用随机端口启动服务器　　75

4.3.2　使用Selenium测试HTML页面　　76

4.4　小结　　78

第5章　Groovy与Spring Boot CLI　　80

5.1　开发Spring Boot CLI应用程序　　80

5.1.1　设置CLI项目　　81

5.1.2　通过Groovy消除代码噪声　　81

5.1.3　发生了什么　　85

5.2　获取依赖　　86

5.2.1　覆盖默认依赖版本　　87

5.2.2　添加依赖仓库　　88

5.3　用CLI运行测试　　89

5.4　创建可部署的产物　　91

5.5　小结　　91

第6章　在Spring Boot中使用Grails　　93

6.1　使用GORM进行数据持久化　　93

6.2　使用Groovy Server Pages定义视图　　98

6.3　结合Spring Boot与Grails 3　　100

6.3.1　创建新的Grails项目　　100

6.3.2　定义领域模型　　103

6.3.3　开发Grails控制器　　104

6.3.4　创建视图　　105

6.4　小结　　107

第7章　深入Actuator　　108

7.1　揭秘Actuator的端点　　108

7.1.1　查看配置明细　　109

7.1.2　运行时度量　　115

7.1.3　关闭应用程序　　121

7.1.4　获取应用信息　　121

7.2　连接Actuator的远程shell　　122

7.2.1　查看autoconfig报告　　123

7.2.2　列出应用程序的Bean　　124

7.2.3　查看应用程序的度量信息　　124

7.2.4　调用Actuator端点　　125

7.3　通过JMX监控应用程序　　126

7.4　定制Actuator　　128

7.4.1　修改端点ID　　128

7.4.2　启用和禁用端点　　129

7.4.3　添加自定义度量信息　　129

7.4.4　创建自定义跟踪仓库　　132

7.4.5　插入自定义健康指示器　　134

7.5　保护Actuator端点　　136

7.6　小结　　138

第8章　部署Spring Boot应用程序　　139

8.1　衡量多种部署方式　　139

8.2　部署到应用服务器　　140

8.2.1　构建WAR文件　　141

8.2.2　创建生产Profile　　142

8.2.3　开启数据库迁移　　145

8.3　推上云端　　150

8.3.1　部署到Cloud Foundry　　150

8.3.2　部署到Heroku　　153

8.4　小结　　155

附录A　Spring Boot开发者工具　　157

附录B　Spring Boot起步依赖　　163

附录C　配置属性　　169

附录D　Spring Boot依赖　　202

第1 章 Spring 基础 2
1.1 Spring 概述 . 2
1.2 Spring 项目快速搭建 5
1.3 Spring 基础配置 .17


第2 章 Spring 常用配置 30
2.1 Bean 的Scope . 30
2.2 Spring EL 和资源调用 33
2.3 Bean 的初始化和销毁 37
2.4 Profile 40
2.5 事件（Application Event） 44


第3 章 Spring 高级话题 48
3.1 Spring Aware . 48
3.2 多线程 . 51
3.3 计划任务 . 54
3.4 条件注解@Conditional 56
3.5 组合注解与元注解 . 60
3.6 @Enable*注解的工作原理 63
3.7 测试 . 66


第二部分 点睛Spring MVC 4.x

第4 章 Spring MVC 基础 72


第三部分 实战Spring Boot

第5 章 Spring Boot 基础 . 122


第6 章 Spring Boot 核心 . 138

第7 章 Spring Boot 的Web 开发 170
7.1 Spring Boot 的Web 开发支持 . 170
7.2 Thymeleaf 模板引擎 . 171
7.2.4 实战 177
7.3 Web 相关配置 . 182
7.4 Tomcat 配置 187
7.5 Favicon 配置 . 196
7.6 WebSocket . 197
7.7 基于Bootstrap 和AngularJS 的现代Web 应用 212


第8 章 Spring Boot 的数据访问 233
8.1 引入Docker 237
8.2 Spring Data JPA 248
8.3 Spring Data REST . 284
8.4 声名式事务 . 297
8.5 数据缓存Cache 309
8.6 非关系型数据库NoSQL 320
8.6.1 MongoDB . 320
8.6.2 Redis . 329


第9 章 Spring Boot 企业级开发 340
9.1 安全控制Spring Security . 340
9.2 批处理Spring Batch . 362
9.3 异步消息 . 385
9.4 系统集成Spring Integration . 395


第10 章 Spring Boot 开发部署与测试 . 407


第11 章 应用监控 . 431


第12 章 分布式系统开发 456
12.1 微服务、原生云应用 . 456
12.2 Spring Cloud 快速入门 . 457
12.3 实战 . 458
12.4 基于Docker 部署 .478




Spring Boot / Spring Cloud
104. 什么是 spring boot？

在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。

SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。

105. 为什么要用 spring boot？
Spring Boot使编码变简单

Spring Boot使配置变简单

Spring Boot使部署变简单

Spring Boot使监控变简单

Spring的不足
106. spring boot 核心配置文件是什么？

Spring Boot提供了两种常用的配置文件：

properties文件
yml文件
107. spring boot 配置文件有哪几种类型？它们有什么区别？

Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。

108. spring boot 有哪些方式可以实现热部署？

SpringBoot热部署实现有两种方式：

①. 使用spring loaded

在项目中添加如下代码：

<build>
        <plugins>
            <plugin>
                <!-- springBoot编译插件-->
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <dependencies>
                    <!-- spring热部署 -->
                    <!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 -->
                    <dependency>
                        <groupId>org.springframework</groupId>
                        <artifactId>springloaded</artifactId>
                        <version>1.2.6.RELEASE</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
添加完毕后需要使用mvn指令运行：

首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的"+",然后选择maven将出现右侧面板，在红色划线部位输入如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）

在这里插入图片描述点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可
在这里插入图片描述
②. 使用spring-boot-devtools

在项目的pom文件中添加依赖：

 <!--热部署jar-->
 <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-devtools</artifactId>
 </dependency>
1
2
3
4
5
然后：使用 shift+ctrl+alt+"/" （IDEA中的快捷键） 选择"Registry" 然后勾选 compiler.automake.allow.when.app.running

109. jpa 和 hibernate 有什么区别？

JPA Java Persistence API，是Java EE 5的标准ORM接口，也是ejb3规范的一部分。
Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。
JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。
ibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。
hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。
hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。
110. 什么是 spring cloud？

从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。

Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。

Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：
在这里插入图片描述
使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。

111. spring cloud 断路器的作用是什么？

在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。

断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。

112. spring cloud 的核心组件有哪些？

①. 服务发现——Netflix Eureka

一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。

②. 客服端负载均衡——Netflix Ribbon

Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。

③. 断路器——Netflix Hystrix

断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。

④. 服务网关——Netflix Zuul

类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。

⑤. 分布式配置——Spring Cloud Config

这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。

转载自：https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA