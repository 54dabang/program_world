第1章　Java EE简介
1．1　Java EE
1．1．1　Java EE架构
1．1．2　Java EE的缺点
1．2　Spring
1．2．1　Spring IoC容器和AOP
1．2．2　Spring的缺点
1．3　Spring Boot
1．4　Hello，Spring Boot
1．4．1　创建一个Maven工程
1．4．2　增加Web支持
1．4．3　Hello Spring Boot示例
1．4．4　使用热部署
1．4．5　添加REST支持
第2章　Spring Boot基础
2．1　检查Java环境与安装Java
2．2　安装和配置Maven
2．2．1　Maven介绍
2．2．2　安装Maven
2．2．3　设置Maven
2．2．4　使用IDE设置Maven
2．2．5　Maven的常用命令
2．3　Spring核心技术
2．3．1　Spring的历史
2．3．2　Spring容器介绍
2．3．3　Spring AOP介绍
第3章　MVC框架
3．1　集成MVC框架
3．1．1　引入依赖
3．1．2　Web应用目录结构
3．1．3　Java包名结构
3．2　使用Controller
3．3　URL映射到方法
3．3．1　@RequestMapping
3．3．2　URL路径匹配
3．3．3　HTTP method匹配
3．3．4　consumes和produces
3．3．5　params和header匹配
3．4　方法参数
3．4．1　PathVariable
3．4．2　Model＆ModelAndView
3．4．3　JavaBean接受HTTP参数
3．4．4　@RequsetBody接受JSON
3．4．5　MultipartFile
3．4．6　@ModelAttribute
3．4．7　@InitBinder
3．5　验证框架
3．5．1　JSR-303
3．5．2　MVC中使用@Validated
3．5．3　自定义校验
3．6　WebMvcConfigurer
3．6．1　拦截器
3．6．2　跨域访问
3．6．3　格式化
3．6．4　注册Controller
3．7　视图技术
3．7．1　使用Freemarker
3．7．2　使用Beetl
3．7．3　使用Jackson
3．7．4　Redirect和Forward
3．8　通用错误处理
3．9　@Service和@Transactional
3．9．1　声明一个Service类
3．9．2　事务管理
3．10　curl命令
第4章　视图技术
4．1　Beetl模板引擎
4．1．1　安装Beetl
4．1．2　设置定界符号和占位符
4．1．3　配置Beetl
4．1．4　groupTemplate
4．2　使用变量
4．2．1　全局变量
4．2．2　局部变量
4．2．3　共享变量
4．2．4　模板变量
4．3　表达式
4．3．1　计算表达式
4．3．2　逻辑表达式
4．4　控制语句
4．4．1　循环语句
4．4．2　条件语句
4．4．3　try catch
4．5　函数调用
4．6　格式化函数
4．7　直接调用Java
4．8　标签函数
4．9　HTML标签
4．10　安全输出
4．11　高级功能
4．11．1　配置Beetl
4．11．2　自定义函数
4．11．3　自定义格式化函数
4．11．4　自定义标签函数
4．11．5　自定义HTML标签
4．11．6　布局
4．11．7　AJAX局部渲染
4．12　脚本引擎
4．13　JSON技术
4．13．1　在Spring Boot中使用Jackson
4．13．2　自定义ObjectMapper
4．13．3　Jackson的三种使用方式
4．13．4　Jackson树遍历
4．13．5　对象绑定
4．13．6　流式操作
4．13．7　Jackson注解
4．13．8　集合的反序列化
4．14　MVC分离开发
4．14．1　集成WebSimulate
4．14．2　模拟JSON响应
4．14．3　模拟模板渲染
第5章　数据库访问
5．1　配置数据源
5．2　Spring JDBC Template
5．2．1　查询
5．2．2　修改
5．2．3　JdbcTemplate增强
5．3　BeetlSQL介绍
5．3．1　BeetlSQL功能概览
5．3．2　添加Maven依赖
5．3．3　配置BeetlSQL
5．3．4　SQLManager
5．3．5　使用SQL文件
5．3．6　Mapper
5．3．7　使用实体
5．4　SQLManager内置CRUD
5．4．1　内置的插入API
5．4．2　内置的更新（删除）API
5．4．3　内置的查询API
5．4．4　代码生成方法
5．5　使用sqlId
5．5．1　md文件命名
5．5．2　md文件构成
5．5．3　调用sqlId
5．5．4　翻页查询
5．5．5　TailBean
5．5．6　ORM查询
5．5．7　其他API
5．5．8　Mapper详解
5．6　BeetlSQL的其他功能
5．6．1　常用函数和标签
5．6．2　主键设置
5．6．3　BeetlSQL注解
5．6．4　NameConversion
5．6．5　锁
第6章　Spring Data JPA
6．1　集成Spring Data JPA
6．1．1　集成数据源
6．1．2　配置JPA支持
6．1．3　创建Entity
6．1．4　简化Entity
6．2　Repository
6．2．1　CrudRepository
6．2．2　PagingAndSortingRepository
6．2．3　JpaRepository
6．2．4　持久化Entity
6．2．5　Sort
6．2．6　Pageable和Page
6．2．7　基于方法名字查询
6．2．8　@Query查询
6．2．9　使用JPA Query
6．2．10　Example查询
第7章　Spring Boot配置
7．1　配置Spring Boot
7．1．1　服务器配置
7．1．2　使用其他Web服务器
7．1．3　配置启动信息
7．1．4　配置浏览器显示ico
7．2　日志配置
7．3　读取应用配置
7．3．1　Environment
7．3．2　@Value
7．3．3　@ConfigurationProperties
7．4　Spring Boot自动装配
7．4．1　@Configuration和@Bean
7．4．2　Bean条件装配
7．4．3　Class条件装配
7．4．4　Environment装配
7．4．5　其他条件装配
7．4．6　联合多个条件
7．4．7　Condition接口
7．4．8　制作Starter
第8章　部署Spring Boot应用
8．1　以jar文件运行
8．2　以war方式部署
8．3　多环境部署
8．4　@Profile注解
第9章　Testing单元测试
9．1　JUnit介绍
9．1．1　JUnit的相关概念
9．1．2　JUnit测试
9．1．3　Assert
9．1．4　Suite
9．2　Spring Boot单元测试
9．2．1　测试范围依赖
9．2．2　Spring Boot测试脚手架
9．2．3　测试Service
9．2．4　测试MVC
9．2．5　完成MVC请求模拟
9．2．6　比较MVC的返回结果
9．2．7　JSON比较
9．3　Mockito
9．3．1　模拟对象
9．3．2　模拟方法参数
9．3．3　模拟方法返回值
9．4　面向数据库应用的单元测试
9．4．1　@Sql
9．4．2　XLSUnit
9．4．3　XLSUnit的基本用法
第10章　REST
10．1　REST简介
10．1．1　REST风格的架构
10．1．2　使用“api”作为上下文
10．1．3　增加一个版本标识
10．1．4　标识资源
10．1．5　确定HTTP Method
10．1．6　确定HTTP Status
10．1．7　REST VS． WebService
10．2　Spring Boot集成REST
10．2．1　集成REST
10．2．2　@RestController
10．2．3　REST Client
10．3　Swagger UI
10．3．1　集成Swagger
10．3．2　Swagger规范
10．3．3　接口描述
10．3．4　查询参数描述
10．3．5　URI中的参数
10．3．6　HTTP头参数
10．3．7　表单参数
10．3．8　文件上传参数
10．3．9　整个请求体作为参数
10．4　模拟REST服务
第11章　MongoDB
11．1　安装MongoDB
11．2　使用shell
11．2．1　指定数据库
11．2．2　插入文档
11．2．3　查询文档
11．2．4　更新操作
11．2．5　删除操作
11．3　Spring Boot集成MongoDB
11．4　增删改查
11．4．1　增加API
11．4．2　根据主键查询API
11．4．3　查询API
11．4．4　修改API
11．4．5　删除API
11．4．6　使用MongoDatabase
11．4．7　打印日志
第12章　Redis
12．1　安装Redis
12．2　使用redis-cli
12．2．1　安全设置
12．2．2　基本操作
12．2．3　keys
12．2．4　Redis List
12．2．5　Redis Hash
12．2．6　Set
12．2．7　Pub/Sub
12．3　Spring Boot集成Redis
12．4　使用StringRedisTemplate
12．4．1　opsFor
12．4．2　绑定Key的操作
12．4．3　RedisConnection
12．4．4　Pub/Sub
12．5　序列化策略
12．5．1　默认序列化策略
12．5．2　自定义序列化策略
第13章　Elasticsearch
13．1　Elasticsearch介绍
13．1．1　安装Elasticsearch
13．1．2　Elasticsearch的基本概念
13．2　使用REST访问Elasticsearch
13．2．1　添加文档
13．2．2　根据主键查询
13．2．3　根据主键更新
13．2．4　根据主键删除
13．2．5　搜索文档
13．2．6　联合多个索引搜索
13．3　使用RestTemplate访问ES
13．3．1　创建Book
13．3．2　使用RestTemplate获取搜索结果
13．4　Spring Data Elastic
13．4．1　安装Spring Data
13．4．2　编写Entity
13．4．3　编写Dao
13．4．4　编写Controller
第14章　Cache
14．1　关于Cache
14．1．1　Cache的组件和概念
14．1．2　Cache的单体应用
14．1．3　使用专有的Cache服务器
14．1．4　使用一二级缓存服务器
14．2　Spring Boot Cache
14．3　注释驱动缓存
14．3．1　@Cacheable
14．3．2　Key生成器
14．3．3　@CachePut
14．3．4　@CacheEvict
14．3．5　@Caching
14．3．6　@CacheConfig
14．4　使用Redis Cache
14．4．1　集成Redis缓存
14．4．2　禁止缓存
14．4．3　定制缓存
14．5　Redis缓存原理
14．6　实现Redis两级缓存
14．6．1　实现TwoLevelCacheManager
14．6．2　创建RedisAndLocalCache
14．6．3　缓存同步说明
14．6．4　将代码组合在一起
第15章　Spring Session
15．1　水平扩展实现
15．2　Nginx的安装和配置
15．2．1　安装Nginx
15．2．2　配置Nginx
15．3　Spring Session
15．3．1　Spring Session介绍
15．3．2　使用Redis
15．3．3　Nginx+Redis
第16章　Spring Boot和ZooKeeper
16．1　ZooKeeper
16．1．1　ZooKeeper的数据结构
16．1．2　安装ZooKeeper
16．1．3　ZooKeeper的基本命令
16．1．4　领导选取演示
16．1．5　分布式锁演示
16．1．6　服务注册演示
16．2　Spring Boot集成ZooKeeper
16．2．1　集成Curator
16．2．2　Curator API
16．3　实现分布式锁
16．4　服务注册
16．4．1　通过ServiceDiscovery注册服务
16．4．2　获取服务
16．5　领导选取
第17章　监控Spring Boot应用
17．1　安装Acutator
17．2　HTTP跟踪
17．3　日志查看
17．4　线程栈信息
17．5　内存信息
17．6　查看URL映射
17．7　查看Spring容器管理的Bean
17．8　其他监控
17．9　编写自己的监控信息
17．9．1　编写HealthIndicator
17．9．2　自定义监控

第Ⅰ部分　基础知识

第1 章　云原生应用程序 3

第2 章　训练营：Spring Boot 和Cloud Foundry 21

第3 章　符合十二要素程序风格的配置 67

第４章　测试 85

第5 章　迁移遗留的应用程序 115

第Ⅱ部分　Web 服务

第6 章　REST API 137

第7 章　路由 179

第8 章　边缘服务 197

第Ⅲ部分　数据整合

第9 章　数据管理 251

第10 章　消息系统 303

第11 章　批处理和任务 325

第12 章　数据集成 363

第IV 部分　生产

第13 章　可观测的系统 411

第14 章　服务代理 469

第15 章　持续交付 497

第V 部分　附录

附录A　在Java EE 中使用Spring Boot 527


第1章 初览Spring Boot 2
1.1 Spring Framework时代 2
1.2 Spring Boot简介 3
1.3 Spring Boot的特性 5
1.4 准备运行环境 5
1.4.1 装配JDK 8 5
1.4.2 装配Maven 6
1.4.3 装配IDE（集成开发环境） 8
第2章 理解独立的Spring应用 9
2.1 创建Spring Boot应用 10
2.1.1 命令行方式创建Spring Boot应用 11
2.1.2 图形化界面创建Spring Boot应用 21
2.1.3 创建Spring Boot应用可执行JAR 29
2.2 运行Spring Boot应用 31
2.2.1 执行Spring Boot应用可执行JAR 32
2.2.2 Spring Boot应用可执行JAR资源结构 32
2.2.3 FAT JAR和WAR执行模块——spring-boot-loader 36
2.2.4 JarLauncher的实现原理 40
第3章 理解固化的Maven依赖 58
3.1 spring-boot-starter-parent与spring-boot-dependencies简介 58
3.2 理解spring-boot-starter-parent与spring-boot- dependencies 61
第4章 理解嵌入式Web容器 70
4.1 嵌入式Servlet Web容器 71
4.1.1 Tomcat作为嵌入式Servlet Web容器 72
4.1.2 Jetty作为嵌入式Servlet Web容器 77
4.1.3 Undertow作为嵌入式Servlet Web容器 80
4.2 嵌入式Reactive Web容器 82
4.2.1 UndertowServletWebServer作为嵌入式Reactive Web容器 82
4.2.2 UndertowWebServer作为嵌入式Reactive Web容器 84
4.2.3 WebServerInitializedEvent 91
4.2.4 Jetty作为嵌入式Reactive Web容器 93
4.2.5 Tomcat作为嵌入式Reactive Web容器 94
第5章 理解自动装配 96
5.1 理解@SpringBootApplication注解语义 97
5.2 @SpringBootApplication属性别名 103
5.3 @SpringBootApplication标注非引导类 107
5.4 @EnableAutoConfiguration激活自动装配 108
5.5 @SpringBootApplication“继承”@Configuration CGLIB提升特性 110
5.6 理解自动配置机制 112
5.7 创建自动配置类 116
第6章 理解Production- Ready特性 119
6.1 理解Production-Ready一般性定义 120
6.2 理解Spring Boot Actuator 123
6.3 Spring Boot Actuator Endpoints 124
6.4 理解“外部化配置 129
6.5 理解“规约大于配置” 132
6.6 小马哥有话说 134
6.6.1 Spring Boot作为微服务中间件 134
6.6.2 Spring Boot作为Spring Cloud基础设施 135
6.7 下一站：走向自动装配 135
第2部分 走向自动装配
第7章 走向注解驱动编程（Annotation-Driven） 138
7.1 注解驱动发展史 138
7.1.1 注解驱动启蒙时代：Spring Framework 1.x 138
7.1.2 注解驱动过渡时代：Spring Framework 2.x 139
7.1.3 注解驱动黄金时代：Spring Framework 3.x 142
7.1.4 注解驱动完善时代：Spring Framework 4.x 146
7.1.5 注解驱动当下时代：Spring Framework 5.x 151
7.2 Spring核心注解场景分类 152
7.3 Spring注解编程模型 154
7.3.1 元注解（Meta-Annotations） 154
7.3.2 Spring模式注解（Stereotype Annotations） 155
7.3.3 Spring组合注解（Composed Annotations） 187
7.3.4 Spring注解属性别名和覆盖（Attribute Aliases and Overrides） 195
第8章 Spring注解驱动设计模式 225
8.1 Spring @Enable模块驱动 225
8.1.1 理解@Enable模块驱动 225
8.1.2 自定义@Enable模块驱动 226
8.1.3 @Enable模块驱动原理 236
8.2 Spring Web自动装配 250
8.2.1 理解Web自动装配 250
8.2.2 自定义Web自动装配 254
8.2.3 Web自动装配原理 258
8.3 Spring条件装配 270
8.3.1 理解配置条件装配 271
8.3.2 自定义配置条件装配 274
8.3.3 配置条件装配原理 277
第9章 Spring Boot自动装配 292
9.1 理解Spring Boot自动装配 295
9.1.1 理解@EnableAutoConfiguration 296
9.1.2 优雅地替换自动装配 298
9.1.3 失效自动装配 298
9.2 Spring Boot自动装配原理 299
9.2.1 @EnableAutoConfiguration读取候选装配组件 301
9.2.2 @EnableAutoConfiguration排除自动装配组件 305
9.2.3 @EnableAutoConfiguration过滤自动装配组件 307
9.2.4 @EnableAutoConfiguration自动装配事件 313
9.2.5 @EnableAutoConfiguration自动装配生命周期 317
9.2.6 @EnableAutoConfiguration排序自动装配组件 324
9.2.7 @EnableAutoConfiguration自动装配BasePackages 332
9.3 自定义Spring Boot自动装配 337
9.3.1 自动装配Class命名的潜规则 338
9.3.2 自动装配package命名的潜规则 338
9.3.3 自定义Spring Boot Starter 340
9.4 Spring Boot条件化自动装配 346
9.4.1 Class条件注解 347
9.4.2 Bean条件注解 358
9.4.3 属性条件注解 370
9.4.4 Resource条件注解 376
9.4.5 Web应用条件注解 391
9.4.6 Spring表达式条件注解 397
9.5 小马哥有话说 401
9.6 下一站：理解SpringApplication 402
第3部分 理解SpringApplication
第10章 SpringApplication初始化阶段 405
10.1 SpringApplication构造阶段 405
10.1.1 理解SpringApplication主配置类 406
10.1.2 SpringApplication的构造过程 410
10.1.3 推断Web应用类型 411
10.1.4 加载Spring应用上下文初始化器（ApplicationContextInitializer） 412
10.1.5 加载Spring应用事件监听器（ApplicationListener） 415
10.1.6 推断应用引导类 416
10.2 SpringApplication配置阶段 417
10.2.1 自定义SpringApplication 417
10.2.2 调整SpringApplication设置 417
10.2.3 增加SpringApplication配置源 420
10.2.4 调整Spring Boot外部化配置 423
第11章 SpringApplication运行阶段 425
11.1 SpringApplication准备阶段 425
11.1.1 理解SpringApplicationRunListeners 426
11.1.2 理解SpringApplicationRunListener 428
11.1.3 理解Spring Boot事件 431
11.1.4 理解Spring事件/监听机制 432
11.1.5 理解Spring Boot事件/监听机制 492
11.1.6 装配ApplicationArguments 509
11.1.7 准备ConfigurableEnvironment 512
11.1.8 创建Spring应用上下文（ConfigurableApplicationContext） 512
11.1.9 Spring应用上下文运行前准备 516
11.2 Spring应用上下文启动阶段 537
11.3 Spring应用上下文启动后阶段 539
11.3.1 afterRefresh方法签名的变化 540
11.3.2 afterRefresh方法语义的变化 541
11.3.3 Spring Boot事件ApplicationStartedEvent语义的变化 543
11.3.4 执行CommandLineRunner和ApplicationRunner 548
第12章 SpringApplication结束阶段 550
12.1 SpringApplication正常结束 550
12.2 SpringApplication异常结束 555
12.2.1 Spring Boot异常处理 556
12.2.2 错误分析报告器——FailureAnalysisReporter 562
12.2.3 自定义实现FailureAnalyzer和FailureAnalysisReporter 564
12.2.4 Spring Boot 2.0重构handleRunFailure和reportFailure方法 566
12.2.5 Spring Boot 2.0的SpringBootExceptionReporter接口 567
第13章 Spring Boot应用退出 571
13.1 Spring Boot应用正常退出 572
13.1.1 ExitCodeGenerator Bean生成退出码 572
13.1.2 ExitCodeGenerator Bean退出码使用场景 576
13.2 Spring Boot应用异常退出 580
13.2.1 ExitCodeGenerator异常使用场景 582
13.2.2 ExitCodeExceptionMapper Bean映射异常与退出码 587
13.2.3 退出码用于SpringApplication异常结束 589
13.3 小马哥有话说 594
13.4 下一站：运维篇 596

1.2　注解还是XML　2
1.3　Spring Boot的优点　3
1.4　传统Spring MVC和Spring Boot的对比　4
第　2章 聊聊开发环境搭建和基本开发　10
2.1　搭建Spring Boot开发环境　10
2.1.1　搭建Eclipse开发环境　10
2.1.2　搭建IntelliJ IDEA开发环境　13
2.2　Spring Boot的依赖和自动配置　15
2.3　使用自定义配置　19
2.4　开发自己的Spring Boot项目　21
第3章　全注解下的Spring IoC　23



3.1　IoC容器简介　23
3.2　装配你的Bean　27



3.2.1　通过扫描装配你的Bean　27



3.2.2　自定义第三方Bean　31



3.3　依赖注入　32



3.3.1　注解@Autowired　34



3.3.2　消除歧义性——@Primary和@Quelifier　35



3.3.3　带有参数的构造方法类的装配　36



3.4　生命周期　37



3.5　使用属性文件　42



3.6　条件装配Bean　45



3.7　Bean的作用域　46



3.8　使用@Profile　48



3.9　引入XML配置Bean　50



3.10　使用Spring EL　51



第4章　开始约定编程——Spring AOP　53



4.1　约定编程　53



4.1.1　约定　53



4.1.2　ProxyBean的实现　57



4.1.3　总结　60



4.2　AOP的概念　61



4.2.1　为什么使用AOP　61



4.2.2　AOP 术语和流程　64



4.3　AOP开发详解　65



4.3.1　确定连接点　65



4.3.2　开发切面　66



4.3.3　切点定义　67



4.3.4　测试AOP　68



4.3.5　环绕通知　71



4.3.6　引入　72



4.3.7　通知获取参数　74



4.3.8　织入　75



4.4　多个切面　77



第5章　访问数据库　82



5.1　配置数据源　83



5.1.1　启动默认数据源　83



5.1.2　配置自定义数据源　83



5.2　使用JdbcTemplate操作数据库　86



5.3　使用JPA（Hibernate）操作数据　90



5.3.1　概述　90



5.3.2　开发JPA　90



5.4　整合MyBatis框架　96



5.4.1　MyBatis简介　96



5.4.2　MyBatis的配置　97



5.4.3　Spring Boot整合MyBatis　101



5.4.4　MyBatis的其他配置　104



第6章　聊聊数据库事务处理　107



6.1　JDBC的数据库事务　108



6.2　Spring声明式事务的使用　110



6.2.1　Spring声明式数据库事务约定　110



6.2.2　@Transactional的配置项　111



6.2.3　Spring事务管理器　113



6.2.4　测试数据库事务　114



6.3　隔离级别　118



6.3.1　数据库事务的知识　118



6.3.2　详解隔离级别　120



6.4　传播行为　124



6.4.1　传播行为的定义　125



6.4.2　测试传播行为　126



6.5　@Transactional自调用失效问题　130



第7章　使用性能利器——Redis　134



7.1　spring-data-redis项目简介　135



7.1.1　spring-data-redis项目的设计　135



7.1.2　RedisTemplate　137



7.1.3　Spring对Redis数据类型操作的封装　139



7.1.4　SessionCallback和RedisCallback接口　141



7.2　在Spring Boot中配置和使用Redis　142



7.2.1　在Spring Boot中配置Redis　142



7.2.2　操作Redis数据类型　143



7.3　Redis的一些特殊用法　148



7.3.1　使用Redis事务　148



7.3.2　使用Redis流水线　149



7.3.3　使用Redis发布订阅　150



7.3.4　使用Lua脚本　153



7.4　使用Spring缓存注解操作Redis　156



7.4.1　缓存管理器和缓存的启用　156



7.4.2　开发缓存注解　157



7.4.3　测试缓存注解　163



7.4.4　缓存注解自调用失效问题　165



7.4.5　缓存脏数据说明　165



7.4.6　自定义缓存管理器　166



第8章　文档数据库——MongoDB　168



8.1　配置MongoDB　169



8.2　使用MongoTemplate实例　170



8.2.1　搭建开发环境　170



8.2.2　使用MongoTemplate操作文档　173



8.3　使用JPA　178



8.3.1　基本用法　178



8.3.2　使用自定义查询　180



第9章　初识Spring MVC　183



9.1　Spring MVC框架的设计　183



9.2　Spring MVC流程　184



9.3　定制Spring MVC的初始化　191



9.4　Spring MVC实例　192



9.4.1　开发控制器　193



9.4.2　视图和视图渲染　194



第　10章 深入Spring MVC开发　197



10.1　处理器映射　197



10.2　获取控制器参数　198



10.2.1　在无注解下获取参数　199



10.2.2　使用@RequestParam获取参数　199



10.2.3　传递数组　200



10.2.4　传递JSON　200



10.2.5　通过URL传递参数　203



10.2.6　获取格式化参数　204



10.3　自定义参数转换规则　205



10.3.1　处理器获取参数逻辑　205



10.3.2　一对一转换器（Converter）　208



10.3.3　GenericConverter集合和数组转换　210



10.4　数据验证　211



10.4.1　JSR-303 验证　211



10.4.2　参数验证机制　214



10.5　数据模型　217



10.6　视图和视图解析器　219



10.6.1　视图设计　219



10.6.2　视图实例——导出PDF文件　220



10.7　文件上传　224



10.7.1　Spring MVC对文件上传的支持　224



10.7.2　开发文件上传功能　226



10.8　拦截器　228



10.8.1　拦截器的设计　228



10.8.2　开发拦截器　229



10.8.3　多个拦截器的顺序　231



10.9　国际化　234



10.9.1　国际化消息源　234



10.9.2　国际化解析器　235



10.9.3　国际化实例——SessionLocaleResolver　237



10.10　Spring MVC拾遗　240



10.10.1　@ResponseBody转换为JSON的秘密　240



10.10.2　重定向　241



10.10.3　操作会话对象　243



10.10.4　给控制器增加通知　245



10.10.5　获取请求头参数　247



第　11章 构建REST风格网站　249



11.1　REST简述　249



11.1.1　REST名词解释　249



11.1.2　HTTP的动作　250



11.1.3　REST风格的一些误区　251



11.2　使用Spring MVC开发REST风格端点　251



11.2.1　Spring MVC整合REST　252



11.2.2　使用Spring开发REST风格的端点　252



11.2.3　使用@RestController　260



11.2.4　渲染结果　261



11.2.5　处理HTTP状态码、异常和响应头　262



11.3　客户端请求RestTemplate　266



11.3.1　使用RestTemplate请求后端　267



11.3.2　获取响应头、状态码和资源交换　269



第　12章 安全——Spring Security　271



12.1　概述和简单安全认证　271



12.2　使用WebSecurityConfigurerAdapter自定义　273



12.3　自定义用户服务信息　274



12.3.1　使用内存签名服务　275



12.3.2　使用数据库定义用户认证服务　276



12.3.3　使用自定义用户认证服务　279



12.4　限制请求　281



12.4.1　配置请求路径访问权限　282



12.4.2　使用Spring表达式配置访问权限　283



12.4.3　强制使用HTTPS　285



12.4.4　防止跨站点请求伪造　285



12.5　用户认证功能　287



12.5.1　自定义登录页面　287



12.5.2　启用HTTP Basic认证　288



12.5.3　登出　289



第　13章 学点Spring其他的技术　291



13.1　异步线程池　291



13.1.1　定义线程池和开启异步可用　292



13.1.2　异步实例　292



13.2　异步消息　294



13.2.1　JMS实例——ActiveMQ　295



13.2.2　使用AMQP——RabbitMQ　299



13.3　定时任务　303



13.4　WebSocket 应用　306



13.4.1　开发简易的WebSocket服务　306



13.4.2　使用STOMP　311



第　14章 Spring 5新框架——WebFlux　319



14.1　基础概念　319



14.1.1　响应式编程的宣言　320



14.1.2　Reactor模型　320



14.1.3　Spring WebFlux的概述　322



14.1.4　WebHandler接口和运行流程　323



14.2　通过Spring MVC方式开发WebFlux服务端　325



14.2.1　开发持久层　325



14.2.2　开发服务层　327



14.2.3　开发控制层　328



14.2.4　配置服务　330



14.2.5　客户端开发——WebClient　331



14.3　深入WebFlux服务端开发　335



14.3.1　类型转换器——Converter　335



14.3.2　验证器——Validator　337



14.3.3　访问静态资源　338



14.4　深入客户端开发　339



14.4.1　处理服务端错误和转换　339



14.4.2　设置请求头　341



14.5　使用路由函数方式开发WebFlux　342



14.5.1　开发处理器　342



14.5.2　开发请求路由　346



14.5.3　使用过滤器　347



第　15章 实践一下——抢购商品　349



15.1　设计与开发　349



15.1.1　数据库表设计　349



15.1.2　使用MyBatis开发持久层　350



15.1.3　使用Spring开发业务层和控制层　353



15.1.4　测试和配置　355



15.2　高并发开发　357



15.2.1　超发现象　357



15.2.2　悲观锁　358



15.2.3　乐观锁　359



15.2.4　使用Redis处理高并发　365



第　16章 部署、测试和监控　371



16.1　部署和运行　371



16.1.1　打包　371



16.1.2　运行项目　373



16.1.3　热部署　375



16.2　测试　376



16.2.1　构建测试类　376



16.2.2　使用随机端口和REST风格测试　377



16.2.3　Mock测试　378



16.3　Actuator监控端点　379



16.4　HTTP监控　381



16.4.1　查看敏感信息　382



16.4.2　shutdown端点　383



16.4.3　配置端点　385



16.4.4　自定义端点　387



16.4.5　健康指标项　389



16.5　JMX监控　392



第　17章 分布式开发——Spring Cloud　393



17.1　服务治理和服务发现——Eureka　395



17.1.1　配置服务治理节点　395



17.1.2　服务发现　397



17.1.3　配置多个服务治理中心节点　401



17.2　微服务之间的调用　403



17.2.1　Ribbon客户端负载均衡　403



17.2.2　Feign声明式调用　406



17.3　断路器——Hystrix　409



17.3.1　使用降级服务　410



17.3.2　启用Hystrix仪表盘　412



17.4　路由网关——Zuul　415



17.4.1　构建Zuul网关　415



17.4.2　使用过滤器　418



17.5　使用@SpringCloudApplication　421



附录　Spring Boot知识点补充　423


第　1章 欢迎迈入云世界，Spring　1



1.1　什么是微服务　1



1.2　什么是Spring，为什么它与微服务有关　4



1.3　在本书中读者会学到什么　5



1.4　为什么本书与你有关　6



1.5　使用Spring Boot来构建微服务　6



1.6　为什么要改变构建应用的方式　10



1.7　云到底是什么　11



1.8　为什么是云和微服务　13



1.9　微服务不只是编写代码　14



1.9.1　核心微服务开发模式　15



1.9.2　微服务路由模式　16



1.9.3　微服务客户端弹性模式　17



1.9.4　微服务安全模式　18



1.9.5　微服务日志记录和跟踪模式　19



1.9.6　微服务构建和部署模式　20



1.10　使用Spring Cloud构建微服务　22



1.10.1　Spring Boot　23



1.10.2　Spring Cloud Config　23



1.10.3　Spring Cloud服务发现　24



1.10.4　Spring Cloud与Netflix Hystrix和Netflix Ribbon　24



1.10.5　Spring Cloud与Netflix Zuul　24



1.10.6　Spring Cloud Stream　24



1.10.7　Spring Cloud Sleuth　24



1.10.8　Spring Cloud Security　25



1.10.9　代码供应　25



1.11　通过示例来介绍Spring Cloud　25



1.12　确保本书的示例是有意义的　27



1.13　小结　28



第　2章 使用Spring Boot构建微服务　29



2.1　架构师的故事：设计微服务架构　31



2.1.1　分解业务问题　31



2.1.2　建立服务粒度　32



2.1.3　互相交流：定义服务接口　35



2.2　何时不应该使用微服务　36



2.2.1　构建分布式系统的复杂性　36



2.2.2　服务器散乱　36



2.2.3　应用程序的类型　36



2.2.4　数据事务和一致性　37



2.3　开发人员的故事：用SpringBoot和Java构建微服务　37



2.3.1　从骨架项目开始　37



2.3.2　引导Spring Boot应用程序：编写引导类　39



2.3.3　构建微服务的入口：Spring Boot控制器　40



2.4　DevOps工程师的故事：构建运行时的严谨性　44



2.4.1　服务装配：打包和部署微服务　46



2.4.2　服务引导：管理微服务的配置　47



2.4.3　服务注册和发现：客户端如何与微服务通信　48



2.4.4　传达微服务的“健康状况”　49



2.5　将视角综合起来　51



2.6　小结　52



第3章　使用Spring Cloud配置服务器控制配置　53



3.1　管理配置（和复杂性）　54



3.1.1　配置管理架构　55



3.1.2　实施选择　56



3.2　构建Spring Cloud配置服务器　58



3.2.1　创建Spring Cloud Config引导类　61



3.2.2　使用带有文件系统的Spring Cloud配置服务器　62



3.3　将Spring Cloud Config与Spring Boot客户端集成　64



3.3.1　建立许可证服务对Spring Cloud Config服务器的依赖　65



3.3.2　配置许可证服务以使用Spring Cloud Config　66



3.3.3　使用Spring Cloud配置服务器连接数据源　69



3.3.4　使用@Value注解直接读取属性　72



3.3.5　使用Spring Cloud配置服务器和Git　73



3.3.6　使用Spring Cloud配置服务器刷新属性　73



3.4　保护敏感的配置信息　75



3.4.1　下载并安装加密所需的Oracle JCE jar　75



3.4.2　创建加密密钥　76



3.4.3　加密和解密属性　76



3.4.4　配置微服务以在客户端使用加密　78



3.5　最后的想法　79



3.6　小结　80



第4章　服务发现　81



4.1　我的服务在哪里　82



4.2　云中的服务发现　84



4.2.1　服务发现架构　84



4.2.2　使用Spring和Netflix Eureka进行服务发现实战　87



4.3　构建Spring Eureka服务　88



4.4　通过Spring Eureka注册服务　90



4.5　使用服务发现来查找服务　93



4.5.1　使用Spring DiscoveryClient查找服务实例　95



4.5.2　使用带有Ribbon功能的Spring RestTemplate调用服务　97



4.5.3　使用Netflix Feign客户端调用服务　98



4.6　小结　100



第5章　使用Spring Cloud和NetflixHystrix的客户端弹性模式　101



5.1　什么是客户端弹性模式　102



5.1.1　客户端负载均衡模式　103



5.1.2　断路器模式　103



5.1.3　后备模式　103



5.1.4　舱壁模式　104



5.2　为什么客户端弹性很重要　104



5.3　进入Hystrix　107



5.4　搭建许可服务器以使用Spring Cloud和Hystrix　107



5.5　使用Hystrix实现断路器　109



5.5.1　对组织微服务的调用超时　111



5.5.2　定制断路器的超时时间　112



5.6　后备处理　113



5.7　实现舱壁模式　115



5.8　基础进阶—微调Hystrix　118



5.9　线程上下文和Hystrix　122



5.9.1　ThreadLocal与Hystrix　122



5.9.2　HystrixConcurrencyStrategy实战　125



5.10　小结　129



第6章　使用Spring Cloud和Zuul进行服务路由　131



6.1　什么是服务网关　132



6.2　Spring Cloud和Netflix Zuul简介　133



6.2.1　建立一个Zuul Spring Boot项目　134



6.2.2　为Zuul服务使用Spring Cloud注解　134



6.2.3　配置Zuul与Eureka进行通信　135



6.3　在Zuul中配置路由　135



6.3.1　通过服务发现自动映射路由　136



6.3.2　使用服务发现手动映射路由　137



6.3.3　使用静态URL手动映射路由　140



6.3.4　动态重新加载路由配置　142



6.3.5　Zuul和服务超时　143



6.4　Zuul的真正威力：过滤器　144



6.5　构建第 一个生成关联ID的Zuul前置过滤器　147



6.6　构建接收关联ID的后置过滤器　155



6.7　构建动态路由过滤器　157



6.7.1　构建路由过滤器的骨架　159



6.7.2　实现run()方法　159



6.7.3　转发路由　161



6.7.4　整合　162



6.8　小结　163



第7章　保护微服务　164



7.1　OAuth2简介　165



7.2　从小事做起：使用Spring和OAuth2来保护单个端点　167



7.2.1　建立EagleEye OAuth2验证服务　167



7.2.2　使用OAuth2服务注册客户端应用程序　168



7.2.3　配置EagleEye用户　171



7.2.4　验证用户　172



7.3　使用OAuth2保护组织服务　175



7.3.1　将Spring Security和OAuth2 jar添加到各个服务　176



7.3.2　配置服务以指向OAuth2验证服务　176



7.3.3　定义谁可以访问服务　177



7.3.4　传播OAuth2访问令牌　180



7.4　JSON Web Token与OAuth2　183



7.4.1　修改验证服务以颁发JWT令牌　184



7.4.2　在微服务中使用JWT　188



7.4.3　扩展JWT令牌　189



7.4.4　从JWT令牌中解析自定义字段　191



7.5　关于微服务安全的总结　193



7.6　小结　195



第8章　使用Spring Cloud Stream的事件驱动架构　196



8.1　为什么使用消息传递、EDA和微服务　197



8.1.1　使用同步请求-响应方式来传达状态变化　198



8.1.2　使用消息传递在服务之间传达状态更改　199



8.1.3　消息传递架构的缺点　201



8.2　Spring Cloud Stream简介　202



8.3　编写简单的消息生产者和消费者　205



8.3.1　在组织服务中编写消息生产者　205



8.3.2　在许可证服务中编写消息消费者　210



8.3.3　在实际操作中查看消息服务　213



8.4　Spring Cloud Stream用例：分布式缓存　214



8.4.1　使用Redis来缓存查找　215



8.4.2　定义自定义通道　221



8.4.3　将其全部汇集在一起：在收到消息时清除缓存　222



8.5　小结　223



第9章　使用Spring Cloud Sleuth和Zipkin进行分布式跟踪　224



9.1　Spring Cloud Sleuth与关联ID　225



9.1.1　将Spring Cloud Sleuth添加到许可证服务和组织服务中　226



9.1.2　剖析Spring Cloud Sleuth跟踪　226



9.2　日志聚合与Spring Cloud Sleuth　227



9.2.1　Spring Cloud Sleuth与Papertrail实现实战　229



9.2.2　创建Papertrail账户并配置syslog连接器　230



9.2.3　将Docker输出重定向到Papertrail　232



9.2.4　在Papertrail中搜索Spring Cloud Sleuth的跟踪ID　234



9.2.5　使用Zuul将关联ID添加到HTTP响应　235



9.3　使用Open Zipkin进行分布式跟踪　237



9.3.1　添加Spring Cloud Sleuth和Zipkin依赖项　238



9.3.2　配置服务以指向Zipkin　238



9.3.3　安装和配置Zipkin服务器　239



9.3.4　设置跟踪级别　240



9.3.5　使用Zipkin跟踪事务　241



9.3.6　可视化更复杂的事务　243



9.3.7　捕获消息传递跟踪　244



9.3.8　添加自定义跨度　246



9.4　小结　248



第　10章 部署微服务　250



10.1　EagleEye：在云中建立核心基础设施　251



10.1.1　使用亚马逊的RDS创建PostgreSQL数据库　253



10.1.2　在AWS中创建Redis集群　257



10.1.3　创建ECS集群　258



10.2　超越基础设施：部署EagleEye　262



10.3　构建和部署管道的架构　265



10.4　构建和部署管道实战　268



10.5　开始构建和部署管道：GitHub和Travis CI　270



10.6　使服务能够在Travis CI中构建　270



10.6.1　构建的核心运行时配置　273



10.6.2　安装预构建工具　275



10.6.3　执行构建　277



10.6.4　标记源代码　277



10.6.5　构建微服务并创建Docker镜像　279



10.6.6　将镜像推送到Docker Hub　279



10.6.7　在Amazon ECS中启动服务　280



10.6.8　启动平台测试　280



10.7　关于构建和部署管道的总结　282



10.8　小结　282



附录A　在桌面运行云服务　283



附录B　OAuth2授权类型　291

1.1　Spring风云再起　　1

1.1.1　重新认识Spring　　2

1.1.2　Spring Boot精要　　3

1.1.3　Spring Boot不是什么　　6

1.2　Spring Boot入门　　6

1.2.1　安装Spring Boot CLI　　7

1.2.2　使用Spring Initializr初始化Spring Boot项目　　10

1.3　小结　　18

第2章　开发第一个应用程序　　19

2.1　运用Spring Boot　　19

2.1.1　查看初始化的Spring Boot新项目　　21

2.1.2　Spring Boot项目构建过程解析　　24

2.2　使用起步依赖　　27

2.2.1　指定基于功能的依赖　　28

2.2.2　覆盖起步依赖引入的传递依赖　　29

2.3　使用自动配置　　30

2.3.1　专注于应用程序功能　　31

2.3.2　运行应用程序　　36

2.3.3　刚刚发生了什么　　38

2.4　小结　　41

第3章　自定义配置　　42

3.1　覆盖Spring Boot自动配置　　42

3.1.1　保护应用程序　　43

3.1.2　创建自定义的安全配置　　44

3.1.3　掀开自动配置的神秘面纱　　48

3.2　通过属性文件外置配置　　49

3.2.1　自动配置微调　　50

3.2.2　应用程序Bean的配置外置　　55

3.2.3　使用Profile进行配置　　59

3.3　定制应用程序错误页面　　62

3.4　小结　　64

第4章　测试　　66

4.1　集成测试自动配置　　66

4.2　测试Web应用程序　　68

4.2.1　模拟Spring MVC　　69

4.2.2　测试Web安全　　72

4.3　测试运行中的应用程序　　74

4.3.1　用随机端口启动服务器　　75

4.3.2　使用Selenium测试HTML页面　　76

4.4　小结　　78

第5章　Groovy与Spring Boot CLI　　80

5.1　开发Spring Boot CLI应用程序　　80

5.1.1　设置CLI项目　　81

5.1.2　通过Groovy消除代码噪声　　81

5.1.3　发生了什么　　85

5.2　获取依赖　　86

5.2.1　覆盖默认依赖版本　　87

5.2.2　添加依赖仓库　　88

5.3　用CLI运行测试　　89

5.4　创建可部署的产物　　91

5.5　小结　　91

第6章　在Spring Boot中使用Grails　　93

6.1　使用GORM进行数据持久化　　93

6.2　使用Groovy Server Pages定义视图　　98

6.3　结合Spring Boot与Grails 3　　100

6.3.1　创建新的Grails项目　　100

6.3.2　定义领域模型　　103

6.3.3　开发Grails控制器　　104

6.3.4　创建视图　　105

6.4　小结　　107

第7章　深入Actuator　　108

7.1　揭秘Actuator的端点　　108

7.1.1　查看配置明细　　109

7.1.2　运行时度量　　115

7.1.3　关闭应用程序　　121

7.1.4　获取应用信息　　121

7.2　连接Actuator的远程shell　　122

7.2.1　查看autoconfig报告　　123

7.2.2　列出应用程序的Bean　　124

7.2.3　查看应用程序的度量信息　　124

7.2.4　调用Actuator端点　　125

7.3　通过JMX监控应用程序　　126

7.4　定制Actuator　　128

7.4.1　修改端点ID　　128

7.4.2　启用和禁用端点　　129

7.4.3　添加自定义度量信息　　129

7.4.4　创建自定义跟踪仓库　　132

7.4.5　插入自定义健康指示器　　134

7.5　保护Actuator端点　　136

7.6　小结　　138

第8章　部署Spring Boot应用程序　　139

8.1　衡量多种部署方式　　139

8.2　部署到应用服务器　　140

8.2.1　构建WAR文件　　141

8.2.2　创建生产Profile　　142

8.2.3　开启数据库迁移　　145

8.3　推上云端　　150

8.3.1　部署到Cloud Foundry　　150

8.3.2　部署到Heroku　　153

8.4　小结　　155

附录A　Spring Boot开发者工具　　157

附录B　Spring Boot起步依赖　　163

附录C　配置属性　　169

附录D　Spring Boot依赖　　202

第1 章 Spring 基础 2
1.1 Spring 概述 . 2
1.2 Spring 项目快速搭建 5
1.3 Spring 基础配置 .17


第2 章 Spring 常用配置 30
2.1 Bean 的Scope . 30
2.2 Spring EL 和资源调用 33
2.3 Bean 的初始化和销毁 37
2.4 Profile 40
2.5 事件（Application Event） 44


第3 章 Spring 高级话题 48
3.1 Spring Aware . 48
3.2 多线程 . 51
3.3 计划任务 . 54
3.4 条件注解@Conditional 56
3.5 组合注解与元注解 . 60
3.6 @Enable*注解的工作原理 63
3.7 测试 . 66


第二部分 点睛Spring MVC 4.x

第4 章 Spring MVC 基础 72


第三部分 实战Spring Boot

第5 章 Spring Boot 基础 . 122


第6 章 Spring Boot 核心 . 138

第7 章 Spring Boot 的Web 开发 170
7.1 Spring Boot 的Web 开发支持 . 170
7.2 Thymeleaf 模板引擎 . 171
7.2.4 实战 177
7.3 Web 相关配置 . 182
7.4 Tomcat 配置 187
7.5 Favicon 配置 . 196
7.6 WebSocket . 197
7.7 基于Bootstrap 和AngularJS 的现代Web 应用 212


第8 章 Spring Boot 的数据访问 233
8.1 引入Docker 237
8.2 Spring Data JPA 248
8.3 Spring Data REST . 284
8.4 声名式事务 . 297
8.5 数据缓存Cache 309
8.6 非关系型数据库NoSQL 320
8.6.1 MongoDB . 320
8.6.2 Redis . 329


第9 章 Spring Boot 企业级开发 340
9.1 安全控制Spring Security . 340
9.2 批处理Spring Batch . 362
9.3 异步消息 . 385
9.4 系统集成Spring Integration . 395


第10 章 Spring Boot 开发部署与测试 . 407


第11 章 应用监控 . 431


第12 章 分布式系统开发 456
12.1 微服务、原生云应用 . 456
12.2 Spring Cloud 快速入门 . 457
12.3 实战 . 458
12.4 基于Docker 部署 .478

-------------
开发过程中，后台的参数校验是必不可少的，所以经常会看到类似下面这样的代码

img
img
这样写并没有什么错，还挺工整的，只是看起来不是很优雅而已。

接下来，用Validation来改写这段

2、Spring Boot文档中的Validation
在Spring Boot的官网中，关于Validation只是简单的提了一句，如下

img
img
其实，Spring Validator和Hibernate Validator是两套Validator，可以混着用，这里我们用Hibernate Validator

3、Hibernate Validator
https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#preface

4、Spring Validator
https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#validation

5、示例
5.1、引入spring-boot-starter-validation
img
img
5.2、定义一个对象
img
img
5.3、适用@Valid校验，并将校验结果放到BindingResult对象中
img
img
注意：

默认情况下，如果校验失败会抛javax.validation.ConstraintViolationException异常，可以用统一异常处理去对这些异常做处理

An Errors/BindingResult argument is expected to be declared immediately after the model attribute

5.4、看效果
img
img
img
img
如果在校验的对象后面再加上Model对象的话，如果返回的是ModelAndView就可以将这个Model设置到其中，这样在页面就可以取到错误消息了

img
img
仅仅只是单字段校验的话未免也太不灵活了吧，如果字段之间有关联关系，那该如何校验呢？答案是自定义

5.5、自定义校验规则
https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-customconstraints

img
img
这里，以优惠券创建为例来演示如何自定义校验规则

首先，优惠券表单如下（仅仅只是演示用）：

img
img
这里除了自定义了两条校验规则之外，还用到了分组。

为什么要有分组这一说呢？因为，举个例子，添加的时候不需要校验id，而修改的时候id不能为空，有了分组以后，就可以添加的时候校验用组A，修改的时候校验用组B

下面重点看一下@CheckTimeInterval

第一步、定义一个注解叫CheckTimeInterval

img
img
第二步、定义Validator去校验它

img
img
顺便提一句，这里BeanWrapper去取对象的属性值，我们稍微看一下BeanWrapper是做什么的

img
img
img
img
言归正传

第三步、验证

img
img
img
img
img
img
看，自定义的校验生效了

6、补充
6.1、校验模式
https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#section-fail-fast

下面补充一点，关于校验模式

默认会校验完所有属性，然后将错误信息一起返回，但很多时候不需要这样，一个校验失败了，其它就不必校验了

为此，需要这样设置

img
img
6.2、单个参数校验
img
img
img
img
img
img
如果是调整页面的时候参数校验失败的话，这时可以不做处理，让其调到错误页面。

如果是接口参数校验失败的话，可以在这里进行统一处理，并返回。例如：

img
img
6.3、错误页面
img
img
img
img
以刚才优惠券详情为例

http://localhost:8080/coupon/detail.html　　　　　　400

http://localhost:8080/coupon/detail.html?id=　　　　400

http://localhost:8080/coupon/detail.html?id=abc　　 400

http://localhost:8080/coupon/detail222.html?id=123　　404

无权限　　403

int a = 1 / 0;　　500

6.4、@Valid与@Validated
https://blog.csdn.net/qq_27680317/article/details/79970590




-------------------------------------------------------

Spring Boot / Spring Cloud
104. 什么是 spring boot？

在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。

SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。

105. 为什么要用 spring boot？
Spring Boot使编码变简单

Spring Boot使配置变简单

Spring Boot使部署变简单

Spring Boot使监控变简单

Spring的不足
106. spring boot 核心配置文件是什么？

Spring Boot提供了两种常用的配置文件：

properties文件
yml文件
107. spring boot 配置文件有哪几种类型？它们有什么区别？

Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。相对于properties文件而言，yml文件更年轻，也有很多的坑。可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。

108. spring boot 有哪些方式可以实现热部署？

SpringBoot热部署实现有两种方式：

①. 使用spring loaded

在项目中添加如下代码：

<build>
        <plugins>
            <plugin>
                <!-- springBoot编译插件-->
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <dependencies>
                    <!-- spring热部署 -->
                    <!-- 该依赖在此处下载不下来，可以放置在build标签外部下载完成后再粘贴进plugin中 -->
                    <dependency>
                        <groupId>org.springframework</groupId>
                        <artifactId>springloaded</artifactId>
                        <version>1.2.6.RELEASE</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>
添加完毕后需要使用mvn指令运行：

首先找到IDEA中的Edit configurations ,然后进行如下操作：（点击左上角的"+",然后选择maven将出现右侧面板，在红色划线部位输入如图所示指令，你可以为该指令命名(此处命名为MvnSpringBootRun)）

在这里插入图片描述点击保存将会在IDEA项目运行部位出现，点击绿色箭头运行即可
在这里插入图片描述
②. 使用spring-boot-devtools

在项目的pom文件中添加依赖：

 <!--热部署jar-->
 <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-devtools</artifactId>
 </dependency>

然后：使用 shift+ctrl+alt+"/" （IDEA中的快捷键） 选择"Registry" 然后勾选 compiler.automake.allow.when.app.running

109. jpa 和 hibernate 有什么区别？

JPA Java Persistence API，是Java EE 5的标准ORM接口，也是ejb3规范的一部分。
Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。
JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。
ibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。
hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。
hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。
110. 什么是 spring cloud？

从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。

Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。

Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：
在这里插入图片描述
使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。

111. spring cloud 断路器的作用是什么？

在Spring Cloud中使用了Hystrix 来实现断路器的功能，断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。

断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。

112. spring cloud 的核心组件有哪些？

①. 服务发现——Netflix Eureka

一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。

②. 客服端负载均衡——Netflix Ribbon

Ribbon，主要提供客户侧的软件负载均衡算法。Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。

③. 断路器——Netflix Hystrix

断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。

④. 服务网关——Netflix Zuul

类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。

⑤. 分布式配置——Spring Cloud Config

这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。

转载自：https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA


Spring Boot整合JWT实现用户认证（附源码）
Java知音  今天
点击上方“Java知音”，选择“置顶公众号”

技术文章第一时间送达！




https://dwz.cn/yv1Do6e3


初探JWT
什么是JWT
JWT(Json Web Token)，是一种工具，格式为XXXX.XXXX.XXXX的字符串，JWT以一种安全的方式在用户和服务器之间传递存放在JWT中的不敏感信息。

为什么要用JWT
设想这样一个场景，在我们登录一个网站之后，再把网页或者浏览器关闭，下一次打开网页的时候可能显示的还是登录的状态，不需要再次进行登录操作，通过JWT就可以实现这样一个用户认证的功能。当然使用Session可以实现这个功能，但是使用Session的同时也会增加服务器的存储压力，而JWT是将存储的压力分布到各个客户端机器上，从而减轻服务器的压力。

JWT长什么样
JWT由3个子字符串组成，分别为Header，Payload以及Signature，结合JWT的格式即：Header.Payload.Signature。（Claim是描述Json的信息的一个Json，将Claim转码之后生成Payload）。

Header

Header是由以下这个格式的Json通过Base64编码（编码不是加密，是可以通过反编码的方式获取到这个原来的Json，所以JWT中存放的一般是不敏感的信息）生成的字符串，Header中存放的内容是说明编码对象是一个JWT以及使用“SHA-256”的算法进行加密（加密用于生成Signature）

{
"typ":"JWT",
"alg":"HS256"
}
Claim

Claim是一个Json，Claim中存放的内容是JWT自身的标准属性，所有的标准属性都是可选的，可以自行添加，比如：JWT的签发者、JWT的接收者、JWT的持续时间等；同时Claim中也可以存放一些自定义的属性，这个自定义的属性就是在用户认证中用于标明用户身份的一个属性，比如用户存放在数据库中的id，为了安全起见，一般不会将用户名及密码这类敏感的信息存放在Claim中。将Claim通过Base64转码之后生成的一串字符串称作Payload。

{
"iss":"Issuer —— 用于说明该JWT是由谁签发的",
"sub":"Subject —— 用于说明该JWT面向的对象",
"aud":"Audience —— 用于说明该JWT发送给的用户",
"exp":"Expiration Time —— 数字类型，说明该JWT过期的时间",
"nbf":"Not Before —— 数字类型，说明在该时间之前JWT不能被接受与处理",
"iat":"Issued At —— 数字类型，说明该JWT何时被签发",
"jti":"JWT ID —— 说明标明JWT的唯一ID",
"user-definde1":"自定义属性举例",
"user-definde2":"自定义属性举例"
}
Signature

Signature是由Header和Payload组合而成，将Header和Claim这两个Json分别使用Base64方式进行编码，生成字符串Header和Payload，然后将Header和Payload以Header.Payload的格式组合在一起形成一个字符串，然后使用上面定义好的加密算法和一个密匙（这个密匙存放在服务器上，用于进行验证）对这个字符串进行加密，形成一个新的字符串，这个字符串就是Signature。

总结



JWT实现认证的原理
服务器在生成一个JWT之后会将这个JWT会以Authorization : Bearer JWT 键值对的形式存放在cookies里面发送到客户端机器，在客户端再次访问收到JWT保护的资源URL链接的时候，服务器会获取到cookies中存放的JWT信息，首先将Header进行反编码获取到加密的算法，在通过存放在服务器上的密匙对Header.Payload 这个字符串进行加密，比对JWT中的Signature和实际加密出来的结果是否一致，如果一致那么说明该JWT是合法有效的，认证成功，否则认证失败。

JWT实现用户认证的流程图




JWT的代码实现
这里的代码实现使用的是Spring Boot（版本号：1.5.10）框架，以及Apache Ignite（版本号：2.3.0）数据库。有关Ignite和Spring Boot的整合可以查看这里。

http://blog.csdn.net/ltl112358/article/details/79399026

代码说明：
代码中与JWT有关的内容如下：

config包中JwtCfg类配置生成一个JWT并配置了JWT拦截的URL

controller包中PersonController 用于处理用户的登录注册时生成JWT，SecureController 用于测试JWT

model包中JwtFilter 用于处理与验证JWT的正确性

其余属于Ignite数据库访问的相关内容


JwtCfg 类

这个类中声明了一个@Bean ，用于生成一个过滤器类，对/secure 链接下的所有资源访问进行JWT的验证

/**
 * This is Jwt configuration which set the url "/secure/*" for filtering
 * @program: users
 * @create: 2018-03-03 21:18
 **/
@Configuration
public class JwtCfg {

    @Bean
    public FilterRegistrationBean jwtFilter() {
        final FilterRegistrationBean registrationBean = new FilterRegistrationBean();
        registrationBean.setFilter(new JwtFilter());
        registrationBean.addUrlPatterns("/secure/*");

        return registrationBean;
    }

}
JwtFilter 类

这个类声明了一个JWT过滤器类，从Http请求中提取JWT的信息，并使用了”secretkey”这个密匙对JWT进行验证

/**
 * Check the jwt token from front end if is invalid
 * @program: users
 * @create: 2018-03-01 11:03
 **/
public class JwtFilter extends GenericFilterBean {

    public void doFilter(final ServletRequest req, final ServletResponse res, final FilterChain chain)
            throws IOException, ServletException {

        // Change the req and res to HttpServletRequest and HttpServletResponse
        final HttpServletRequest request = (HttpServletRequest) req;
        final HttpServletResponse response = (HttpServletResponse) res;

        // Get authorization from Http request
        final String authHeader = request.getHeader("authorization");

        // If the Http request is OPTIONS then just return the status code 200
        // which is HttpServletResponse.SC_OK in this code
        if ("OPTIONS".equals(request.getMethod())) {
            response.setStatus(HttpServletResponse.SC_OK);

            chain.doFilter(req, res);
        }
        // Except OPTIONS, other request should be checked by JWT
        else {

            // Check the authorization, check if the token is started by "Bearer "
            if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                throw new ServletException("Missing or invalid Authorization header");
            }

            // Then get the JWT token from authorization
            final String token = authHeader.substring(7);

            try {
                // Use JWT parser to check if the signature is valid with the Key "secretkey"
                final Claims claims = Jwts.parser().setSigningKey("secretkey").parseClaimsJws(token).getBody();

                // Add the claim to request header
                request.setAttribute("claims", claims);
            } catch (final SignatureException e) {
                throw new ServletException("Invalid token");
            }

            chain.doFilter(req, res);
        }
    }
}
PersonController 类

这个类中在用户进行登录操作成功之后，将生成一个JWT作为返回

/**
 * @program: users
 * @create: 2018-02-27 19:28
 **/
@RestController
public class PersonController {

    @Autowired
    private PersonService personService;


    /**
     * User register with whose username and password
     * @param reqPerson
     * @return Success message
     * @throws ServletException
     */
    @RequestMapping(value = "/register", method = RequestMethod.POST)
    public String register(@RequestBody() ReqPerson reqPerson) throws ServletException {
        // Check if username and password is null
        if (reqPerson.getUsername() == "" || reqPerson.getUsername() == null
                || reqPerson.getPassword() == "" || reqPerson.getPassword() == null)
            throw new ServletException("Username or Password invalid!");

        // Check if the username is used
        if(personService.findPersonByUsername(reqPerson.getUsername()) != null)
            throw new ServletException("Username is used!");

        // Give a default role : MEMBER
        List<Role> roles = new ArrayList<Role>();
        roles.add(Role.MEMBER);

        // Create a person in ignite
        personService.save(new Person(reqPerson.getUsername(), reqPerson.getPassword(), roles));
        return "Register Success!";
    }

    /**
     * Check user`s login info, then create a jwt token returned to front end
     * @param reqPerson
     * @return jwt token
     * @throws ServletException
     */
    @PostMapping
    public String login(@RequestBody() ReqPerson reqPerson) throws ServletException {
        // Check if username and password is null
        if (reqPerson.getUsername() == "" || reqPerson.getUsername() == null
                || reqPerson.getPassword() == "" || reqPerson.getPassword() == null)
            throw new ServletException("Please fill in username and password");

        // Check if the username is used
        if(personService.findPersonByUsername(reqPerson.getUsername()) == null
                || !reqPerson.getPassword().equals(personService.findPersonByUsername(reqPerson.getUsername()).getPassword())){
            throw new ServletException("Please fill in username and password");
        }

        // Create Twt token
        String jwtToken = Jwts.builder().setSubject(reqPerson.getUsername()).claim("roles", "member").setIssuedAt(new Date())
                .signWith(SignatureAlgorithm.HS256, "secretkey").compact();

        return jwtToken;
    }
}
SecureController 类

这个类中只是用于测试JWT功能，当用户认证成功之后，/secure 下的资源才可以被访问

/**
 * Test the jwt, if the token is valid then return "Login Successful"
 * If is not valid, the request will be intercepted by JwtFilter
 * @program: users
 * @create: 2018-03-01 11:05
 **/
@RestController
@RequestMapping("/secure")
public class SecureController {

    @RequestMapping("/users/user")
    public String loginSuccess() {
        return "Login Successful!";
    }

}
代码功能测试
本例使用Postman对代码进行测试，这里并没有考虑到安全性传递的明文密码，实际上应该用SSL进行加密

1.首先进行一个新的测试用户的注册，可以看到注册成功的提示返回



2.再让该用户进行登录，可以看到登录成功之后返回的JWT字符串



3.直接申请访问/secure/users/user ，这时候肯定是无法访问的，服务器返回500错误



4.将获取到的JWT作为Authorization属性提交，申请访问/secure/users/user ，可以访问成功



示例代码
https://github.com/ltlayx/SpringBoot-Ignite

参考
http://blog.leapoahead.com/2015/09/06/understanding-jwt/ ↩
https://aboullaite.me/spring-boot-token-authentication-using-jwt/



Spring Boot是最流行的用于开发微服务的Java框架。在本文中，我将与你分享自2016年以来我在专业开发中使用Spring Boot所采用的最佳实践。这些内容是基于我的个人经验和一些熟知的Spring Boot专家的文章。

在本文中，我将重点介绍Spring Boot特有的实践（大多数时候，也适用于Spring项目）。以下依次列出了最佳实践，排名不分先后。

欢迎胖友在文末留言，分享你的 Spring Boot 的最佳实践。

1、使用自定义BOM来维护第三方依赖
这条实践是我根据实际项目中的经历总结出的。

Spring Boot项目本身使用和集成了大量的开源项目，它帮助我们维护了这些第三方依赖。但是也有一部分在实际项目使用中并没有包括进来，这就需要我们在项目中自己维护版本。如果在一个大型的项目中，包括了很多未开发模块，那么维护起来就非常的繁琐。

怎么办呢？事实上，Spring IO Platform就是做的这个事情，它本身就是Spring Boot的子项目，同时维护了其他第三方开源库。我们可以借鉴Spring IO Platform来编写自己的基础项目platform-bom，所有的业务模块项目应该以BOM的方式引入。这样在升级第三方依赖时，就只需要升级这一个依赖的版本而已。

<dependencyManagement>


<dependencies>


<dependency>


<groupId>
io.spring.platform
</groupId>


<artifactId>
platform-bom
</artifactId>


<version>
Cairo-SR3
</version>


<type>
pom
</type>


<scope>
import
</scope>


</dependency>


</dependencies>

</dependencyManagement>

PS.IT牧场注：Spring IO Platform已于2019-04-09到达生命周期，并由spring-boot-dependencies接替，因此，请勿直接使用IO Platform，但可借鉴IO Platform的写法。
2、使用自动配置
Spring Boot的一个主要特性是使用自动配置。这是Spring Boot的一部分，它可以简化你的代码并使之工作。当在类路径上检测到特定的jar文件时，自动配置就会被激活。

使用它的最简单方法是依赖Spring Boot Starters。因此，如果你想与Redis进行集成，你可以首先包括：

<dependency>


<groupId>
org.springframework.boot
</groupId>


<artifactId>
spring-boot-starter-data-redis
</artifactId>

</dependency>

如果你想与MongoDB进行集成，需要这样：

<dependency>


<groupId>
org.springframework.boot
</groupId>


<artifactId>
spring-boot-starter-data-mongodb
</artifactId>

</dependency>

借助于这些starters，这些繁琐的配置就可以很好地集成起来并协同工作，而且它们都是经过测试和验证的。这非常有助于避免可怕的Jar地狱。

https://dzone.com/articles/what-is-jar-hell

通过使用以下注解属性，可以从自动配置中排除某些配置类：

@EnableAutoConfiguration
（
exclude
=

{
ClassNotToAutoconfigure
.
class
}）

但只有在绝对必要时才应该这样做。

有关自动配置的官方文档可在此处找到：

https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html。

3、使用Spring Initializr来开始一个新的Spring Boot项目
这一条最佳实践来自Josh Long （Spring Advocate，@starbuxman）。

Spring Initializr 提供了一个超级简单的方法来创建一个新的Spring Boot项目，并根据你的需要来加载可能使用到的依赖。

https://start.spring.io/

使用Initializr创建应用程序可确保你获得经过测试和验证的依赖项，这些依赖项适用于Spring自动配置。你甚至可能会发现一些新的集成，但你可能并没有意识到这些。

4、考虑为常见的组织问题创建自己的自动配置
这一条也来自Josh Long（Spring Advocate，@starbuxman）——这个实践是针对高级用户的。

如果你在一个严重依赖Spring Boot的公司或团队中工作，并且有共同的问题需要解决，那么你可以创建自己的自动配置。

这项任务涉及较多工作，因此你需要考虑何时获益是值得投入的。与多个略有不同的定制配置相比，维护单个自动配置更容易。

如果将这个提供Spring Boot配置以开源库的形式发布出去，那么将极大地简化数千个用户的配置工作。

5、正确设计代码目录结构
尽管允许你有很大的自由，但是有一些基本规则值得遵守来设计你的源代码结构。

避免使用默认包。确保所有内容（包括你的入口点）都位于一个名称很好的包中，这样就可以避免与装配和组件扫描相关的意外情况；

将Application.java（应用的入口类）保留在顶级源代码目录中；

我建议将控制器和服务放在以功能为导向的模块中，但这是可选的。一些非常好的开发人员建议将所有控制器放在一起。不论怎样，坚持一种风格！

6、保持@Controller的简洁和专注
Controller应该非常简单。你可以在此处阅读有关GRASP中有关控制器模式部分的说明。你希望控制器作为协调和委派的角色，而不是执行实际的业务逻辑。以下是主要做法：

https://en.wikipedia.org/wiki/GRASP(object-orienteddesign)#Controller

控制器应该是无状态的！默认情况下，控制器是单例，并且任何状态都可能导致大量问题；

控制器不应该执行业务逻辑，而是依赖委托；

控制器应该处理应用程序的HTTP层，这不应该传递给服务；

控制器应该围绕用例/业务能力来设计。

要深入这个内容，需要进一步地了解设计REST API的最佳实践。无论你是否想要使用Spring Boot，都是值得学习的。

7、围绕业务功能构建@Service
Service是Spring Boot的另一个核心概念。我发现最好围绕业务功能/领域/用例（无论你怎么称呼都行）来构建服务。

在应用中设计名称类似 AccountService, UserService, PaymentService这样的服务，比起像 DatabaseService、 ValidationService、 CalculationService这样的会更合适一些。

你可以决定使用Controler和Service之间的一对一映射，那将是理想的情况。但这并不意味着，Service之间不能互相调用！

8、使数据库独立于核心业务逻辑之外
我之前还不确定如何在Spring Boot中最好地处理数据库交互。在阅读了罗伯特·C·马丁的“Clear Architecture”之后，对我来说就清晰多了。

你希望你的数据库逻辑于服务分离出来。理想情况下，你不希望服务知道它正在与哪个数据库通信，这需要一些抽象来封装对象的持久性。

罗伯特C.马丁强烈地说明，你的数据库是一个“细节”，这意味着不将你的应用程序与特定数据库耦合。过去很少有人会切换数据库，我注意到，使用Spring Boot和现代微服务开发会让事情变得更快。

9、保持业务逻辑不受Spring Boot代码的影响
考虑到“Clear Architecture”的教训，你还应该保护你的业务逻辑。将各种Spring Boot代码混合在一起是非常诱人的……不要这样做。如果你能抵制诱惑，你将保持你的业务逻辑可重用。

部分服务通常成为库。如果不从代码中删除大量Spring注解，则更容易创建。

10、推荐使用构造函数注入
这一条实践来自Phil Webb（Spring Boot的项目负责人, @phillip_webb）。

保持业务逻辑免受Spring Boot代码侵入的一种方法是使用构造函数注入。不仅是因为 @Autowired注解在构造函数上是可选的，而且还可以在没有Spring的情况下轻松实例化bean。

11、熟悉并发模型
我写过的最受欢迎的文章之一是“介绍Spring Boot中的并发”。我认为这样做的原因是这个领域经常被误解和忽视。如果使用不当，就会出现问题。

https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/

在Spring Boot中，Controller和Service是默认是单例。如果你不小心，这会引入可能的并发问题。你通常也在处理有限的线程池。请熟悉这些概念。

如果你正在使用新的WebFlux风格的Spring Boot应用程序，我已经解释了它在“Spring’s WebFlux/Reactor Parallelism and Backpressure”中是如何工作的。

12、加强配置管理的外部化
这一点超出了Spring Boot，虽然这是人们开始创建多个类似服务时常见的问题……

你可以手动处理Spring应用程序的配置。如果你正在处理多个Spring Boot应用程序，则需要使配置管理能力更加强大。

我推荐两种主要方法：

使用配置服务器，例如Spring Cloud Config；

将所有配置存储在环境变量中（可以基于git仓库进行配置）。

这些选项中的任何一个（第二个选项多一些）都要求你在DevOps更少工作量，但这在微服务领域是很常见的。

13、提供全局异常处理
你真的需要一种处理异常的一致方法。Spring Boot提供了两种主要方法：

你应该使用HandlerExceptionResolver定义全局异常处理策略；

你也可以在控制器上添加@ExceptionHandler注解，这在某些特定场景下使用可能会很有用。

这与Spring中的几乎相同，并且Baeldung有一篇关于REST与Spring的错误处理的详细文章，非常值得一读。

https://www.baeldung.com/exception-handling-for-rest-with-spring

14、使用日志框架
你可能已经意识到这一点，但你应该使用Logger进行日志记录，而不是使用System.out.println()手动执行。这很容易在Spring Boot中完成，几乎没有配置。只需获取该类的记录器实例：

Logger
 logger
=

LoggerFactory
.
getLogger
(
MyClass
.
class
);

这很重要，因为它可以让你根据需要设置不同的日志记录级别。

15、测试你的代码
这不是Spring Boot特有的，但它需要提醒——测试你的代码！如果你没有编写测试，那么你将从一开始就编写遗留代码。

如果有其他人使用你的代码库，那边改变任何东西将会变得危险。当你有多个服务相互依赖时，这甚至可能更具风险。

由于存在Spring Boot最佳实践，因此你应该考虑将Spring Cloud Contract用于你的消费者驱动契约，它将使你与其他服务的集成更容易使用。

16、使用测试切片让测试更容易，并且更专注
这一条实践来自Madhura Bhave（Spring 开发者, @madhurabhave23）。

使用Spring Boot测试代码可能很棘手——你需要初始化数据层，连接大量服务，模拟事物……实际上并不是那么难！答案是使用测试切片。

使用测试切片，你可以根据需要仅连接部分应用程序。这可以为你节省大量时间，并确保你的测试不会与未使用的内容相关联。来自spring.io的一篇名为Custom test slice with Spring test 1.4的博客文章解释了这种技术。

https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4

============================================




SpringBoot：企业常用的starter
Java团长  前天
原文作者：SimpleWu

原文链接：cnblogs.com/SimpleWu/p/9798146.html

SpringBoot简介
Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Boot致力于在蓬勃发展的快速应用开发领域（rapid application development）成为领导者。

Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。

Spring Boot的主要优点：

为所有Spring开发者更快的入门

开箱即用，提供各种默认配置来简化项目配置

内嵌式容器简化Web项目

没有冗余代码生成和XML配置的要求

在下面的代码中只要有一定基础会发现这写代码实例非常简单对于开发者来说几乎是“零配置”。

SpringBoot运行
开发工具：jdk8，IDEA,STS，eclipse（需要安装STS插件）这些都支持快速启动SpringBoot工程。我这里就不快速启动了，使用maven工程。学习任何一项技术首先就要精通HelloWord，那我们来跑个初体验。

首先只用maven我们创建的maven工程直接以jar包的形式创建就行了，首先我们来引入SpringBoot的依赖

首先我们需要依赖SpringBoot父工程，这是每个项目中必须要有的。

<!--引入SpringBoot父依赖-->
<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.5.RELEASE</version>
        <relativePath/>
</parent>
<!--编码与JAVA版本-->
<properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <java.version>1.8</java.version>
</properties>
我们启动WEB模块当然必须要引入WEB模块的依赖

<dependencies>
        <!--引入SpringBoot-WEB模块-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>
我们需要编写一个SpringBoot启动类，SpringbootFirstExperienceApplication.java

@SpringBootApplication
public class SpringbootFirstExperienceApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootFirstExperienceApplication.class, args);
    }
}
到了这里我们直接把他当成SpringMVC来使用就行了，不过这里默认是不支持JSP官方推荐使用模板引擎，后面会写到整合JSP。这里我就不写Controller了。

@SpringBootApplication：之前用户使用的是3个注解注解他们的main类。分别是@Configuration,@EnableAutoConfiguration,@ComponentScan。由于这些注解一般都是一起使用，spring boot提供了一个统一的注解@SpringBootApplication。

注意事项：我们使用这个注解在不指定扫描路径的情况下，SpringBoot只能扫描到和SpringbootFirstExperienceApplication同包或子包的Bean；

SpringBoot目录结构
在src/main/resources中我们可以有几个文件夹：

templates：用来存储模板引擎的，Thymeleaf，FreeMarker，Velocity等都是不错的选择。

static：存储一些静态资源，css,js等

public：在默认SpringBoot工程中是不生成这个文件夹的，但是在自动配置中我们可以有这个文件夹用来存放公共的资源（html等）

application.properties：这个文件名字是固定的，SpringBoot启动会默认加载这些配置在这里面可以配置端口号，访问路径，数据库连接信息等等。这个文件非常重要，当然官方中推出了一个yml格式这是非常强大的数据格式。

整合JdbcTemplate
引入依赖：

 <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.5.2.RELEASE</version>
    </parent>
    <dependencies>
        <!--引入WEB模块-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
         <!--引入JDBC模块-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
         <!--引入数据库驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
配置application.properties，虽然说是“零配置”但是这些必要的肯定要指定，否则它怎么知道连那个数据库？

spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
使用方式：

@Service
public class EmployeeService {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public boolean saveEmp(String name,String email,String gender){
        String sql = "insert into tal_employee values(null,?,?,?)";
        int result = jdbcTemplate.update(sql, name,email,gender);
        System.out.println("result : " + result);
        return result > 0 ? true:false;
    }
}


@RestController
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    @RequestMapping("/save")
    public String insert(String name,String email,String gender){
        boolean result = employeeService.saveEmp(name, email, gender);
        if(result){
            return "success";
        }
        return "error";
    }
}
这里我们直接返回一个文本格式。

@RestController
在上面的代码中我们使用到这个注解修改我们的Controller类而是不使用@Controller这个注解，其实中包含了@Controller，同时包含@ResponseBody既然修饰在类上面那么就是表示这个类中所有的方法都是@ResponseBody所以在这里我们返回字符串在前台我们会以文本格式展示，如果是对象那么它会自动转换成json格式返回。

整合JSP
在创建整合JSP的时候指定要选WAR，一定要选WAR。

引入依赖：

<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.2.RELEASE</version>
</parent>
<dependencies>
    <!-- SpringBoot WEB组件 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- 整合JSP依赖 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-tomcat</artifactId>
    </dependency>
    <dependency>
        <groupId>org.apache.tomcat.embed</groupId>
        <artifactId>tomcat-embed-jasper</artifactId>
    </dependency>
</dependencies>
然后我们只需要配置试图解析器路径就可以了。

#配置试图解析器前缀
spring.mvc.view.prefix=/WEB-INF/views/
#配置试图解析器后缀
spring.mvc.view.suffix=.jsp
整合JPA
同样的整合JPA我们只需要启动我们SpringBoot已经集成好的模块即可。

添加依赖：

<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.5.2.RELEASE</version>
    </parent>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--启动JPA组件-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
    </dependencies>
启动JPA组件后直接配置数据库连接信息就可以使用JPA功能。

Application.properties

spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
实体类：Employee.java

@Table(name="tal_employee")
@Entity
public class Employee implements Serializable{
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;
    @Column(name="last_Name")
    private String lastName;
    private String email;
    private String gender;
    //get set 省略
}
EmployeeDao接口：

public interface EmployeeDao extends JpaRepository<Employee, Integer>{
}
EmployeeController.java:

@Controller
public class EmployeeController {
    @Autowired
    private EmployeeDao employeeDao;

    @ResponseBody
    @RequestMapping("/emps")
    public List<Employee> getEmployees(){
        List<Employee> employees = employeeDao.findAll();
        System.out.println(employees);
        return employees;
    }
}
整合MyBatis
引入依赖：

<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.5.2.RELEASE</version>
    </parent>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!--引入对JDBC的支持-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
         <!--引入对logging的支持-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>
        <!-- SpringBoot MyBatis启动器 -->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>1.2.2</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>
    </dependencies>
配置application.properties

spring.datasource.url=jdbc:mysql://localhost:3306/mybatis
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
##############datasource classpath 数据连接池地址##############
#spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

#指定我们的mapper.xml位置
mybatis.mapper-locations=classpath:com/simple/springboot/mybatis/dao/mapper/*.xml
#entity.class 指定我们实体类所在包位置
mybatis.type-aliases-package=com.simple.springboot.mybatis.entity
当然这里还有很多属性如果想要使用可以参考官方文档。到了这里其他就不写了，把他当作SSM使用就ok。

注意事项：在我们的Dao层接口中一定要在类上加上注解@Mapper否则无法扫描到。

AOP功能使用
在我们SpringBoot中使用AOP非常简单。

package com.simple.springboot.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class SpringBootAspect {

    /**
     * 定义一个切入点
     * @author:SimpleWu
     * @Date:2018年10月12日
     */
    @Pointcut(value="execution(* com.simple.springboot.util.*.*(..))")
    public void aop(){}

    /**
     * 定义一个前置通知
     * @author:SimpleWu
     * @Date:2018年10月12日
     */
    @Before("aop()")
    public void aopBefore(){
        System.out.println("前置通知 SpringBootAspect....aopBefore");
    }

    /**
     * 定义一个后置通知
     * @author:SimpleWu
     * @Date:2018年10月12日
     */
    @After("aop()")
    public void aopAfter(){
        System.out.println("后置通知  SpringBootAspect....aopAfter");
    }

    /**
     * 处理未处理的JAVA异常
     * @author:SimpleWu
     * @Date:2018年10月12日
     */
    @AfterThrowing(pointcut="aop()",throwing="e")
    public void exception(Exception e){
        System.out.println("异常通知 SpringBootAspect...exception .." + e);
    }

    /**
     * 环绕通知
     * @author:SimpleWu
     * @throws Throwable
     * @Date:2018年10月12日
     */
    @Around("aop()")
    public void around(ProceedingJoinPoint invocation) throws Throwable{
        System.out.println("SpringBootAspect..环绕通知 Before");
        invocation.proceed();
        System.out.println("SpringBootAspect..环绕通知 After");
    }
}
任务调度
SpringBoot已经集成好一个调度功能。

@Component
public class ScheduledTasks {
    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");

    /**
     * 任务调度，每隔5秒执行一次
     * @author:SimpleWu
     * @Date:2018年10月12日
     */

    @Scheduled(fixedRate = 1000)
    public void reportCurrentTime() {
        System.out.println("现在时间：" + dateFormat.format(new Date()));
    }
}
然后启动的时候我们必须要在主函数类上加上注解：@EnableScheduling（翻译过来就是开启调度）

/**
 * SpringBoot使用任务调度
 * @EnableScheduling标注程序开启任务调度
 * @author :SimpleWu
 * @Date:2018年10月12日
 */

@SpringBootApplication
@EnableScheduling
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}
本文所有测试代码实例：

https://gitlab.com/450255266/code
