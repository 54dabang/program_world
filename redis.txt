
1 为何选择Redis？ 1

合适之选？ 2

尝试使用Redis 4

流行的使用模式 9

Redis不合心意？马上再试试！ 11


Redis键 14

Redis键模式 15

键分隔符和命名约定 17

手动创建Redis模式 19

解构Redis对象映射器 22

键过期 27

键的注意事项 27

大O符号 28

为自定义代码计算大O符号 30

回顾Redis数据结构的时间复杂度 32

字符串 32

哈希 33

列表 34

集合 35

有序集合 36

高级有序集合操作 39

位串和位操作 39

HyperLogLogs 41


配置Redis 44

主从复制 45

32位Redis 45

INFO memory详解 47

键过期 49

LRU键清除策略 54

创建内存高效的Redis数据结构 62

小巧的哈希、列表、集合和有序集合 62

把位、字节和Redis字符串用作随机访问数组 68

优化哈希，高效存储 69

硬件和网络延迟 72

操作系统建议 74


Redis的内部结构 76

理解redis．h和redis．c 83

Redis序列化协议 93

Redis RDB格式 97

使用Redis和Python创建协程 99

使用Node．js和Redis实现Todo列表应用 103

复制与公共访问 106


在Redis中使用Lua 108

使用Redis的KEYS和ARGV 117

Redis中的高级Lua脚本 121

MARC21数据提取 121

纸质文具在线商店 123

让JSON-LD、Lua和Redis协同工作 126

Redis Lua调试器 130

Redis的编程与管理 133

主从复制 134

使用MULTI和EXEC实现事务 136

Redis在DevOps中扮演的角色 139

6 可伸缩性：Redis集群和Sentinel 142
数据分区的方法 142
范围分区 143
列表分区 145
哈希分区 148
复合分区 149
键哈希标签 150
使用Twemproxy实现Redis集群 151
使用关联数据片段服务器测试Twemproxy 152
Redis集群的背景 158
Redis集群概览 159
使用Redis集群 160
Redis集群实时重新配置及重新分片 165
故障转移 168
在Redis集群中替换或者升级节点 170
使用Redis Sentinel进行监控 171
为区域代码列表分区配置Redis Sentinel 173

7 Redis与互补的NoSQL技术 177
NoSQL技术的繁荣 177
Redis作为MongoDB的分析补充 181
Redis作为ElasticSearch的预处理组件 192
在BIBCAT中使用Redis和ElasticSearch 193
ElasticSearch、Logstash和Redis 198
Redis作为Fedora Commons的智能缓存补充 199

8 Docker容器与云端部署 206
Linux容器 206
与Redis相关的Docker基础 211
Docker镜像中的层 219
Docker文件系统后端 220
Docker和Redis的问题 227
使用Docker Compose打包应用程序 227
Redis和AWS 232
专门的云托管选项 233
Redis Labs 234
DigitalOcean Redis 234

9 任务管理与消息队列 236
Redis的发布/订阅模式概述 236
发布/订阅RESP回复 237
SUBSCRIBE和UNSUBSCRIBE RESP数组 237
PSUBSCRIBE和UNSUBSCRIBE数组 239
使用redis-cli进行发布/订阅 240
Redis发布订阅实战 242
第一个工作站采用Python进行发布订阅 244
第二个工作站采用Node．js进行发布订阅 246
第三个工作站使用Lua客户端进行发布订阅 248
Redis键空间通知 251
使用Redis和Celery进行任务管理 255
GIS和RestMQ 259
使用RestMQ进行任务管理 262
使用Redis技术进行消息通信 264
使用Disque进行消息通信 264

10 信息流的测量与管理 267
基于Redis的ETL方案 267
将JSON转换成RESP 273
管理Redis时的安全考虑 279
使用Redis Web仪表板进行运营监测 282
机器学习 283
朴素贝叶斯与工作分类 284
使用Redis实现线性规划 294



1.2 下载和安装Redis

1.3 启动和停止Redis

1.4 使用redis-cli 连接到Redis

1.5 获取服务器信息.

1.6 理解Redis 事件模型

1.7 理解Redis 通信协议

2.2 使用字符串（string）类型
2.3 使用列表（list）类型
2.4 使用哈希（hash）类型
2.5 使用集合（set）类型
2.6 使用有序集合（sorted set）类型

2.7 使用HyperLogLog 类型.

2.8 使用Geo 类型.

2.9 键管理

3.2 使用位图（bitmap）

3.3 设置键的过期时间

3.4 使用SORT 命令

3.5 使用管道（pipeline）

3.6 理解Redis 事务（transaction）

3.7 使用发布订阅（PubSub）

3.8 使用Lua 脚本

3.9 调试Lua 脚本

4.2 Redis 常见应用场景

4.3 使用正确的数据类型

4.4 使用正确的API .

4.5 使用Java 连接到Redis

4.6 使用Python 连接到Redis

4.7 使用Spring Data 连接到Redis

4.8 使用Redis 编写MapReduce 作业

4.9 使用Redis 编写Spark 作业

第5 章复制

5.1 本章概要

5.2 配置Redis 的复制机制

5.3 复制机制的调优

5.4 复制机制的故障诊断

第6 章持久化

6.1 本章概要

6.2 使用RDB

6.3 探究RDB 文件

6.4 使用AOF

6.5 探究AOF 文件

6.6 RDB 和AOF 的结合使用.

第7 章配置高可用和集群

7.1 本章概要

7.2 配置Sentinel

7.3 测试Sentinel

7.4 管理Sentinel

7.5 配置Redis Cluster

7.6 测试Redis Cluster

7.7 管理Redis Cluster

第8 章生产环境部署

8.1 本章概要

8.2 在Linux 上部署Redis

8.3 Redis 安全相关设置

8.4 配置客户端连接选项

8.5 配置内存策略

8.6 基准测试

8.7 日志

第9 章管理Redis

9.1 本章概要

9.2 管理Redis 服务器配置

9.3 使用bin/redis-cli 操作Redis

9.4 备份和恢复

9.5 监控内存使用情况

9.6 管理客户端

9.7 数据迁移

第10 章Redis 的故障诊断

10.1 本章概要

10.2 Redis 的健康检查

10.3 使用SLOWLOG 识别慢查询

10.4 延迟问题的故障诊断

10.5 内存问题的故障诊断

10.6 崩溃问题的故障诊断

第11 章使用Redis 模块扩展Redis

11.1 本章概要.

11.2 加载Redis 模块

11.3 编写Redis 模块

第12 章Redis 生态系统

12.2 Redisson 客户端

12.3 Twemproxy

12.4 Codis—一个基于代理的高性能Redis 集群解决方案

12.5 CacheCloud 管理系统

12.6 Pika—一个与Redis 兼容的NoSQL 数据库


第1章　简介 1
1．1 历史与发展 1
1．2 特性 2
1．2．1 存储结构 2
1．2．2 内存存储与持久化 3
1．2．3 功能丰富 3
1．2．4 简单稳定 4
第2章　准备 7
2．1　安装Redis 7
2．1．1 在POSIX系统中安装 7
2．1．2　在OS X系统中安装 8
2．1．3　在Windows中安装 9
2．2　启动和停止Redis 11
2．2．1　启动Redis 12
2．2．2　停止Redis 14
2．3　Redis命令行客户端 14
2．3．1　发送命令 14
2．3．2　命令返回值 15
2．4　配置 17
2．5　多数据库 17
第3章　入门 19
3．1 热身 19
3．2 字符串类型 21
3．2．1 介绍 22
3．2．2 命令 22
3．2．3 实践 25
3．2．4 命令拾遗 27
3．3 散列类型 32
3．3．1 介绍 33
3．3．2 命令 34
3．3．3 实践 37
3．3．4 命令拾遗 39
3．4 列表类型 40
3．4．1 介绍 41
3．4．2 命令 41
3．4．3 实践 44
3．4．5 命令拾遗 46
3．5 集合类型 48
3．5．1 介绍 48
3．5．2 命令 49
3．5．3 实践 52
3．5．4 命令拾遗 54
3．6 有序集合类型 57
3．6．1 介绍 57
3．6．2 命令 58
3．6．3 实践 62
3．6．4 命令拾遗 63
第4章　进阶 67
4．1　事务 67
4．1．1　概述 68
4．1．2　错误处理 69
4．1．3　WATCH命令介绍 70
4．2　过期时间 72
4．2．1　命令介绍 73
4．2．2　实现访问频率限制之一 75
4．2．3　实现访问频率限制之二 76
4．2．4　实现缓存 77
4．3　排序 78
4．3．1　有序集合的集合操作 78
4．3．2　SORT命令 79
4．3．3　BY参数 81
4．3．4　GET参数 83
4．3．5　STORE参数 84
4．3．6　性能优化 85
4．4　消息通知 85
4．4．1　任务队列 86
4．4．2　使用Redis实现任务队列 87
4．4．3　优先级队列 88
4．4．4　“发布/订阅”模式 90
4．4．5　按照规则订阅 91
4．5　管道 92
4．6　节省空间 93
4．6．1　精简键名和键值 94
4．6．2　内部编码优化 94
第5章　实践 103
5．1 PHP与Redis 103
5．1．1 安装 104
5．1．2 使用方法 104
5．1．3 简便用法 105
5．1．4 实践：用户注册登录功能 107
5．2 Ruby与Redis 111
5．2．1 安装 111
5．2．2 使用方法 111
5．2．3 简便用法 112
5．2．4 实践：自动完成 112
5．3 Python与Redis 116
5．3．1 安装 116
5．3．2 使用方法 116
5．3．3 简便用法 117
5．3．4 实践：在线的好友 117
5．4 Node．js与Redis 123
5．4．1 安装 123
5．4．2 使用方法 123
5．4．3 简便用法 125
5．4．4 实践：IP地址查询 127
第6章　脚本 131
6．1 概览 131
6．1．1 脚本介绍 132
6．1．2 实例：访问频率限制 132
6．2 Lua语言 133
6．2．1 Lua语法 134
6．2．2 标准库 143
6．2．3 其他库 147
6．3 Redis与Lua 147
6．3．1 在脚本中调用Redis命令 148
6．3．2 从脚本中返回值 148
6．3．3 脚本相关命令 149
6．3．4 应用实例 150
6．4 深入脚本 153
6．4．1 KEYS与ARGV 153
6．4．2 沙盒与随机数 154
6．4．3 其他脚本相关命令 154
6．4．4 原子性和执行时间 155
第7章　持久化 157
7．1 RDB方式 157
7．1．1 根据配置规则进行自动快照 158
7．1．2 用户执行SAVE或BGSAVE命令 158
7．1．3 执行FLUSHALL命令 159
7．1．4 执行复制时 159
7．1．5 快照原理 159
7．2AOF方式 160
7．2．1 开启AOF 160
7．2．2 AOF的实现 161
7．2．3 同步硬盘数据 162
第8章　集群 165
8．1 复制 165
8．1．1 配置 165
8．1．2 原理 168
8．1．3 图结构 170
8．1．4 读写分离与一致性 170
8．1．5 从数据库持久化 171
8．1．6 硬盘复制 172
8．1．7 增量复制 172
8．2 哨兵 173
8．2．1 什么是哨兵 174
8．2．2 马上上手 175
8．2．3 实现原理 177
8．2．4 哨兵的部署 180
8．3 集群 181
8．3．1 配置集群 182
8．3．2 节点的增加 185
8．3．3 插槽的分配 185
8．3．4 获取与插槽对应的节点 189
8．3．5 故障恢复 191
第9章　管理 193
9．1 安全 193
9．1．1 可信的环境 193
9．1．2 数据库密码 194
9．1．3 命名命令 194
9．2 通信协议 195
9．2．1 简单协议 195
9．2．2 统一请求协议 197
9．3 管理工具 197
9．3．1 redis-cli 198
9．3．2 phpRedisAdmin 199
9．3．3 Rdbtools 201
附录A　Redis命令属性 203
附录B　配置参数索引 209
附录C　CRC16实现参考 213

第1章　初识Redis 1

1.1　盛赞Redis 1

1.2　Redis特性 2

1.3　Redis使用场景 5

1.3.1　Redis可以做什么 5

1.3.2　Redis不可以做什么 5

1.4　用好Redis的建议 6

1.5　正确安装并启动Redis 6

1.5.1　安装Redis 7

1.5.2　配置、启动、操作、关闭Redis 8

1.6　Redis重大版本 11

1.7　本章重点回顾 14

第2章　API的理解和使用 15

2.1　预备 15

2.1.1　全局命令 15

2.1.2　数据结构和内部编码 18

2.1.3　单线程架构 19

2.2　字符串 21

2.2.1　命令 22

2.2.2　内部编码 27

2.2.3　典型使用场景 28

2.3　哈希 31

2.3.1　命令 32

2.3.2　内部编码 35

2.3.3　使用场景 36

2.4　列表 38

2.4.1　命令 38

2.4.2　内部编码 43

2.4.3　使用场景 44

2.5　集合 46

2.5.1　命令 46

2.5.2　内部编码 50

2.5.3　使用场景 51

2.6　有序集合 52

2.6.1　命令 53

2.6.2　内部编码 59

2.6.3　使用场景 59

2.7　键管理 60

2.7.1　单个键管理 60

2.7.2　遍历键 67

2.7.3　数据库管理 70

2.8　本章重点回顾 73

第3章　小功能大用处 74

3.1　慢查询分析 74

3.1.1　慢查询的两个配置参数 75

3.1.2　最佳实践 77

3.2　Redis Shell 78

3.2.1　redis-cli详解 78

3.2.2　redis-server详解 82

3.2.3　redis-benchmark详解 83

3.3　Pipeline 84

3.3.1　Pipeline概念 84

3.3.2　性能测试 85

3.3.3　原生批量命令与Pipeline对比 86

3.3.4　最佳实践 87

3.4　事务与Lua 87

3.4.1　事务 87

3.4.2　Lua用法简述 90

3.4.3　Redis与Lua 92

3.4.4　案例 94

3.4.5　Redis如何管理Lua脚本 96

3.5　Bitmaps 98

3.5.1　数据结构模型 98

3.5.2　命令 98

3.5.3　Bitmaps分析 101

3.6　HyperLogLog 102

3.7　发布订阅 105

3.7.1　命令 106

3.7.2　使用场景 108

3.8　GEO 109

3.9　本章重点回顾 112

第4章　客户端 113

4.1　客户端通信协议 113

4.2　Java客户端Jedis 117

4.2.1　获取Jedis 117

4.2.2　Jedis的基本使用方法 118

4.2.3　Jedis连接池的使用方法 122

4.2.4　Redis中Pipeline的使用方法 125

4.2.5　Jedis的Lua脚本 126

4.3　Python客户端redis-py 128

4.3.1　获取redis-py 128

4.3.2　redis-py的基本使用方法 128

4.3.3　redis-py中Pipeline的使用方法 130

4.3.4　redis-py中的Lua脚本使用方法 130

4.4　客户端管理 131

4.4.1　客户端API 132

4.4.2　客户端相关配置 145

4.4.3　客户端统计片段 145

4.5　客户端常见异常 146

4.6　客户端案例分析 149

4.6.1　Redis内存陡增 149

4.6.2　客户端周期性的超时 151

4.7　本章重点回顾 153

第5章　持久化 154

5.1　RDB 154

5.1.1　触发机制 154

5.1.2　流程说明 155

5.1.3　RDB文件的处理 156

5.1.4　RDB的优缺点 156

5.2　AOF 157

5.2.1　使用AOF 157

5.2.2　命令写入 157

5.2.3　文件同步 158

5.2.4　重写机制 159

5.2.5　重启加载 161

5.2.6　文件校验 162

5.3　问题定位与优化 162

5.3.1　fork操作 162

5.3.2　子进程开销监控和优化 163

5.3.3　AOF追加阻塞 165

5.4　多实例部署 166

5.5　本章重点回顾 167

第6章　复制 168

6.1　配置 168

6.1.1　建立复制 168

6.1.2　断开复制 170

6.1.3　安全性 170

6.1.4　只读 170

6.1.5　传输延迟 171

6.2　拓扑 171

6.3　原理 172

6.3.1　复制过程 172

6.3.2　数据同步 175

6.3.3　全量复制 178

6.3.4　部分复制 181

6.3.5　心跳 183

6.3.6　异步复制 184

6.4　开发与运维中的问题 184

6.4.1　读写分离 184

6.4.2　主从配置不一致 186

6.4.3　规避全量复制 186

6.4.4　规避复制风暴 187

6.5　本章重点回顾 188

第7章　Redis的噩梦：阻塞 189

7.1　发现阻塞 189

7.2　内在原因 191

7.2.1　API或数据结构使用不合理 191

7.2.2　CPU饱和 193

7.2.3　持久化阻塞 194

7.3　外在原因 195

7.3.1　CPU竞争 195

7.3.2　内存交换 195

7.3.3　网络问题 196

7.4　本章重点回顾 199

第8章　理解内存 200

8.1　内存消耗 200

8.1.1　内存使用统计 200

8.1.2　内存消耗划分 201

8.1.3　子进程内存消耗 203

8.2　内存管理 204

8.2.1　设置内存上限 204

8.2.2　动态调整内存上限 204

8.2.3　内存回收策略 205

8.3　内存优化 209

8.3.1　redisObject对象 209

8.3.2　缩减键值对象 210

8.3.3　共享对象池 211

8.3.4　字符串优化 213

8.3.5　编码优化 216

8.3.6　控制键的数量 223

8.4　本章重点回顾 225

第9章　哨兵 226

9.1　基本概念 226

9.1.1　主从复制的问题 227

9.1.2　高可用 227

9.1.3　Redis Sentinel的高可用性 229

9.2　安装和部署 232

9.2.1　部署拓扑结构 232

9.2.2　部署Redis数据节点 233

9.2.3　部署Sentinel节点 234

9.2.4　配置优化 236

9.2.5　部署技巧 243

9.3　API 244

9.4　客户端连接 249

9.4.1　Redis Sentinel的客户端 249

9.4.2　Redis Sentinel客户端基本实现原理 249

9.4.3　Java操作Redis Sentinel 251

9.5　实现原理 254

9.5.1　三个定时监控任务 254

9.5.2　主观下线和客观下线 256

9.5.3　领导者Sentinel节点选举 258

9.5.4　故障转移 261

9.6　开发与运维中的问题 262

9.6.1　故障转移日志分析 262

9.6.2　节点运维 268

9.6.3　高可用读写分离 271

9.7　本章重点回顾 272

第10章　集群 274

10.1　数据分布 274

10.1.1　数据分布理论 274

10.1.2　Redis数据分区 277

10.1.3　集群功能限制 278

10.2　搭建集群 278

10.2.1　准备节点 278

10.2.2　节点握手 280

10.2.3　分配槽 282

10.2.4　用redis-trib.rb搭建集群 284

10.3　节点通信 287

10.3.1　通信流程 287

10.3.2　Gossip消息 287

10.3.3　节点选择 290

10.4　集群伸缩 291

10.4.1　伸缩原理 291

10.4.2　扩容集群 293

10.4.3　收缩集群 301

10.5　请求路由 305

10.5.1　请求重定向 305

10.5.2　Smart客户端 309

10.5.3　ASK重定向 318

10.6　故障转移 323

10.6.1　故障发现 323

10.6.2　故障恢复 329

10.6.3　故障转移时间 334

10.6.4　故障转移演练 334

10.7　集群运维 336

10.7.1　集群完整性 336

10.7.2　带宽消耗 337

10.7.3　Pub/Sub广播问题 337

10.7.4　集群倾斜 338

10.7.5　集群读写分离 339

10.7.6　手动故障转移 341

10.7.7　数据迁移 344

10.8　本章重点回顾 344

第11章　缓存设计 346

11.1　缓存的收益和成本 346

11.2　缓存更新策略 347

11.3　缓存粒度控制 349

11.4　穿透优化 350

11.5　无底洞优化 352

11.6　雪崩优化 359

11.7　热点key重建优化 360

11.8　本章重点回顾 364

第12章　开发运维的“陷阱” 365

12.1　Linux配置优化 365

12.1.1　内存分配控制 365

12.1.2　swappiness 367

12.1.3　THP 369

12.1.4　OOM killer 370

12.1.5　使用NTP 371

12.1.6　ulimit 371

12.1.7　TCP backlog 372

12.2　flushall/flushdb误操作 372

12.2.1　缓存与存储 373

12.2.2　借助AOF机制恢复 373

12.2.3　RDB有什么变化 374

12.2.4　从节点有什么变化 374

12.2.5　快速恢复数据 374

12.3　安全的Redis 375

12.3.1　Redis密码机制 377

12.3.2　伪装危险命令 378

12.3.3　防火墙 380

12.3.4　bind 380

12.3.5　定期备份数据 381

12.3.6　不使用默认端口 381

12.3.7　使用非root用户启动 381

12.4　处理bigkey 382

12.4.1　bigkey的危害 382

12.4.2　如何发现 382

12.4.3　如何删除 383

12.4.4　最佳实践思路 386

12.5　寻找热点key 386

12.6　本章重点回顾 391

第13章　Redis监控运维云平台CacheCloud 392

13.1　CacheCloud是什么 392

13.1.1　现有问题 393

13.1.2　CacheCloud基本功能 393

13.2　快速部署 395

13.2.1　CacheCloud环境需求 395

13.2.2　CacheCloud快速开始 395

13.3　机器部署 397

13.3.1　部署脚本 398

13.3.2　添加机器 399

13.4　接入应用 400

13.4.1　总体流程 401

13.4.2　账户申请和审批 401

13.4.3　应用申请和审批 402

13.4.4　客户端接入 405

13.5　用户功能 407

13.5.1　应用统计信息 408

13.5.2　实例列表 409

13.5.3　应用详情 409

13.5.4　命令曲线 409

13.5.5　CacheCloud Redis Shell控制台 410

13.5.6　慢查询 410

13.5.7　应用拓扑 411

13.6　运维功能 413

13.6.1　应用运维 413

13.6.2　接入已存在的Redis节点 415

13.6.3　Redis配置模板 416

13.6.4　迁移工具 417

13.6.5　监控报警 420

13.6.6　系统配置管理 422

13.7　客户端上报 423

13.7.1　客户端上报整体设计 424

13.7.2　Jedis核心代码修改 424

13.7.3　带上报功能的客户端 426

13.7.4　CacheCloud客户端统计 427

13.8　本章重点回顾 429

第14章　Redis配置统计字典 430

14.1　info系统状态说明 430

14.1.1　命令说明 430

14.1.2　详细说明 431

14.2　standalone配置说明和分析 436

14.2.1　总体配置 436

14.2.2　最大内存及策略 437

14.2.3　AOF相关配置 437

14.2.4　RDB相关配置 438

14.2.5　慢查询配置 438

14.2.6　数据结构优化配置 439

14.2.7　复制相关配置 439

14.2.8　客户端相关配置 440

14.2.9　安全相关配置 440

14.3　Sentinel配置说明和分析 440

14.4　Cluster配置说明和分析 441

第一部分　入门
第1章　初识Redis　2
1．1　Redis简介　3
1．1．1　Redis与其他数据库和软件的对比　3
1．1．2　附加特性　4
1．1．3　使用Redis的理由　5
1．2　Redis数据结构简介　6
1．2．1　Redis中的字符串　7
1．2．2　Redis中的列表　9
1．2．3　Redis的集合　10
1．2．4　Redis的散列　11
1．2．5　Redis的有序集合　12
1．3　你好Redis　13
1．3．1　对文章进行投票　15
1．3．2　发布并获取文章　17
1．3．3　对文章进行分组　19
1．4　寻求帮助　21
1．5　小结　21

第2章　使用Redis构建Web应用　23
2．1　登录和cookie缓存　24
2．2　使用Redis实现购物车　28
2．3　网页缓存　29
2．4　数据行缓存　30
2．5　网页分析　33
2．6　小结　34

第二部分　核心概念
第3章　Redis命令　38
3．1　字符串　39
3．2　列表　42
3．3　集合　44
3．4　散列　46
3．5　有序集合　48
3．6　发布与订阅　52
3．7　其他命令　54
3．7．1　排序　54
3．7．2　基本的Redis事务　56
3．7．3　键的过期时间　58
3．8　小结　60

第4章　数据安全与性能保障　61
4．1　持久化选项　61
4．1．1　快照持久化　62
4．1．2　AOF持久化　66
4．1．3　重写/压缩AOF文件　67
4．2　复制　68
4．2．1　配置Redis的配置选项　69
4．2．2　Redis复制的启动过程　70
4．2．3　主从链　71
4．2．4　检验磁盘写入　72
4．3　处理系统故障　73
4．3．1　验证快照文件和AOF文件　74
4．3．2　更换故障主服务器　75
4．4　Redis事务　76
4．4．1　定义用户信息和用户包裹　77
4．4．2　将物品放到市场上销售　78
4．4．3　购买物品　80
4．5　非事务型流水线　82
4．6　关于性能方面的注意事项　85
4．7　小结　87

第5章　使用Redis构建支持程序　88
5．1　使用Redis来记录日志　88
5．1．1　最新日志　89
5．1．2　常见日志　90
5．2　计数器和统计数据　91
5．2．1　将计数器存储到Redis里面　91
5．2．2　使用Redis存储统计数据　96
5．2．3　简化统计数据的记录与发现　98
5．3　查找IP所属城市以及国家　100
5．3．1　载入位置表格　100
5．3．2　查找IP所属城市　102
5．4　服务的发现与配置　103
5．4．1　使用Redis存储配置信息　103
5．4．2　为每个应用程序组件分别配置一个Redis服务器　104
5．4．3　自动Redis连接管理　106
5．5　小结　107

第6章　使用Redis构建应用程序组件　109
6．1　自动补全　109
6．1．1　自动补全最近联系人　110
6．1．2　通讯录自动补全　112
6．2　分布式锁　115
6．2．1　锁的重要性　116
6．2．2　简易锁　118
6．2．3　使用Redis构建锁　119
6．2．4　细粒度锁　122
6．2．5　带有超时限制特性的锁　124
6．3　计数信号量　126
6．3．1　构建基本的计数信号量　126
6．3．2　公平信号量　128
6．3．3　刷新信号量　131
6．3．4　消除竞争条件　132
6．4　任务队列　133
6．4．1　先进先出队列　133
6．4．2　延迟任务　136
6．5　消息拉取　139
6．5．1　单接收者消息的发送与订阅替代品　140
6．5．2　多接收者消息的发送与订阅替代品　141
6．6　使用Redis进行文件分发　145
6．6．1　根据地理位置聚合用户数据　146
6．6．2　发送日志文件　148
6．6．3　接收日志文件　149
6．6．4　处理日志文件　150
6．7　小结　152

第7章　基于搜索的应用程序　153
7．1　使用Redis进行搜索　153
7．1．1　基本搜索原理　154
7．1．2　对搜索结果进行排序　160
7．2　有序索引　162
7．2．1　使用有序集合对搜索结果进行排序　162
7．2．2　使用有序集合实现非数值排序　164
7．3　广告定向　166
7．3．1　什么是广告服务器？　167
7．3．2　对广告进行索引　167
7．3．3　执行广告定向操作　170
7．3．4　从用户行为中学习　174
7．4　职位搜索　180
7．4．1　逐个查找合适的职位　180
7．4．2　以搜索方式查找合适的职位　181
7．5　小结　182

第8章　构建简单的社交网站　184
8．1　用户和状态　185
8．1．1　用户信息　185
8．1．2　状态消息　186
8．2　主页时间线　187
8．3　关注者列表和正在关注列表　188
8．4　状态消息的发布与删除　191
8．5　流API　194
8．5．1　流API提供的数据　195
8．5．2　提供数据　196
8．5．3　对流消息进行过滤　199
8．6　小结　205

第三部分　进阶内容
第9章　降低内存占用　208
9．1　短结构　208
9．1．1　压缩列表表示　209
9．1．2　集合的整数集合编码　211
9．1．3　长压缩列表和大整数集合带来的性能问题　212
9．2　分片结构　214
9．2．1　分片式散列　215
9．2．2　分片集合　218
9．3　打包存储二进制位和字节　221
9．3．1　决定被存储位置信息的格式　221
9．3．2　存储打包后的数据　223
9．3．3　对分片字符串进行聚合计算　224
9．4　小结　226

第10章　扩展Redis　227
10．1　扩展读性能　227
10．2　扩展写性能和内存容量　230
10．2．1　处理分片配置信息　232
10．2．2　创建分片服务器连接装饰器　233
10．3　扩展复杂的查询　234
10．3．1　扩展搜索查询量　235
10．3．2　扩展搜索索引大小　235
10．3．3　对社交网站进行扩展　240
10．4　小结　247

第11章　Redis的Lua脚本编程　248
11．1　在不编写C代码的情况下添加新功能　248
11．1．1　将Lua脚本载入Redis　249
11．1．2　创建新的状态消息　251
11．2　使用Lua重写锁和信号量　254
11．2．1　使用Lua实现锁的原因　254
11．2．2　重写锁实现　255
11．2．3　使用Lua实现计数信号量　257
11．3　移除WATCH/MULTI/EXEC事务　258
11．3．1　回顾群组自动补全程序　259
11．3．2　再次对物品买卖市场进行改进　261
11．4　使用Lua对列表进行分片　263
11．4．1　分片列表的构成　263
11．4．2　将元素推入分片列表　265
11．4．3　从分片里面里面弹出元素　266
11．4．4　对分片列表执行阻塞弹出操作　267
11．5　小结　270

附录A　快速安装指南　271

附录B　其他资源和参考资料　279


第1篇 基础和应用篇 / 1

1.1 授人以鱼不如授人以渔 / 1

1.1.1 由 Redis 面试想到的 / 1

1.1.2 本书的内容范围 / 2

1.1.3 Redis 可以做什么 / 3

1.1.4 小结 / 3

1.1.5 扩展阅读 / 4

1.2 万丈高楼平地起——Redis 基础数据结构 / 4

1.2.1 Redis 的安装 / 5

1.2.2 5 种基础数据结构 / 6

1.2.3 容器型数据结构的通用规则 / 17

1.2.4 过期时间 / 17

1.2.5 思考&作业 / 17

1.3 千帆竞发——分布式锁 / 18

1.3.1 分布式锁的奥义 / 18

1.3.2 超时问题 / 20

1.3.3 可重入性 / 21

1.3.4 思考&作业 / 24

1.4 缓兵之计——延时队列 / 24

1.4.1 异步消息队列 / 24

1.4.2 队列空了怎么办 / 26

1.4.3 阻塞读 / 26

1.4.4 空闲连接自动断开 / 26

1.4.5 锁冲突处理 / 27

1.4.6 延时队列的实现 / 27

1.4.7 进一步优化 / 30

1.4.8 思考&作业 / 31

1.5 节衣缩食——位图 / 31

1.5.1 基本用法 / 31

1.5.2 统计和查找 / 34

1.5.3 魔术指令 bitfield / 35

1.5.4 思考&作业 / 38

1.6 四两拨千斤——HyperLogLog / 38

1.6.1 使用方法 / 39

1.6.2 pfadd 中的 pf 是什么意思 / 41

1.6.3 pfmerge 适合的场合 / 42

1.6.4 注意事项 / 42

1.6.5 HyperLogLog 实现原理 / 42

1.6.6 pf 的内存占用为什么是 12KB / 49

1.6.7 思考&作业 / 50

1.7 层峦叠嶂——布隆过滤器 / 50

1.7.1 布隆过滤器是什么 / 51

1.7.2 Redis 中的布隆过滤器 / 51

1.7.3 布隆过滤器的基本用法 / 52

1.7.4 注意事项 / 59

1.7.5 布隆过滤器的原理 / 60

1.7.6 空间占用估计 / 61

1.7.7 实际元素超出时，误判率会怎样变化 / 62

1.7.8 用不上 Redis 4.0 怎么办 / 63

1.7.9 布隆过滤器的其他应用 / 63

1.8 断尾求生——简单限流 / 64

1.8.1 如何使用 Redis 来实现简单限流策略 / 64

1.8.2 解决方案 / 65

1.8.3 小结 / 67

1.9 一毛不拔——漏斗限流 / 68

1.9.1 Redis-Cell / 71

1.9.2 思考&作业 / 72

1.9.3 扩展阅读：Redis-Cell 作者介绍 / 72

1.10 近水楼台——GeoHash / 73

1.10.1 用数据库来算附近的人 / 73

1.10.2 GeoHash 算法 / 74

1.10.3 Geo 指令的基本用法 / 75

1.10.4 注意事项 / 78

1.11 大海捞针——scan / 79

1.11.1 scan 基本用法 / 80

1.11.2 字典的结构 / 82

1.11.3 scan 遍历顺序 / 82

1.11.4 字典扩容 / 83

1.11.5 对比扩容、缩容前后的遍历顺序 / 84

1.11.6 渐进式 rehash / 85

1.11.7 更多的 scan 指令 / 85

1.11.8 大 key 扫描 / 85

第2 篇 原理篇 / 87

2.1 鞭辟入里——线程 IO 模型 / 87

2.1.1 非阻塞 IO / 87

2.1.2 事件轮询 （多路复用） / 88

2.1.3 指令队列 / 90

2.1.4 响应队列 / 90

2.1.5 定时任务 / 90

2.1.6 扩展阅读 / 90

2.2 交头接耳——通信协议 / 90

2.2.1 RESP / 91

2.2.2 客户端→服务器 / 92

2.2.3 服务器→客户端 / 92

2.2.4 小结 / 95

2.2.5 扩展阅读 / 95

2.3 未雨绸缪——持久化 / 95

2.3.1 快照原理 / 96

2.3.2 fork（多进程） / 96

2.3.3 AOF 原理 / 97

2.3.4 AOF 重写 / 98

2.3.5 fsync / 98

2.3.6 运维 / 98

2.3.7 Redis 4.0 混合持久化 / 99

2.3.8 思考&作业 / 100

2.4 雷厉风行——管道 / 100

2.4.1 Redis 的消息交互 / 100

2.4.2 管道压力测试 / 101

2.4.3 深入理解管道本质 / 102

2.4.4 小结 / 104

2.5 同舟共济——事务 / 104

2.5.1 Redis 事务的基本用法 / 104

2.5.2 原子性 / 105

2.5.3 discard（丢弃） / 106

2.5.4 优化 / 106

2.5.5 watch / 107

2.5.6 注意事项 / 108

2.5.7 思考&作业 / 110

2.6 小道消息——PubSub / 110

2.6.1 消息多播 / 110

2.6.2 PubSub / 111

2.6.3 模式订阅 / 113

2.6.4 消息结构 / 114

2.6.5 PubSub 的缺点 / 115

2.6.6 补充 / 115

2.7 开源节流——小对象压缩 / 115

2.7.1 32bit VS 64bit / 116

2.7.2 小对象压缩存储（ziplist） / 116

2.7.3 内存回收机制 / 120

2.7.4 内存分配算法 / 120

第3 篇 集群篇 / 122

3.1 有备无患——主从同步 / 122

3.1.1 CAP 原理 / 122

3.1.2 最终一致 / 123

3.1.3 主从同步与从从同步 / 123

3.1.4 增量同步 / 124

3.1.5 快照同步 / 124

3.1.6 增加从节点 / 125

3.1.7 无盘复制 / 125

3.1.8 wait 指令 / 125

3.1.9 小结 / 126

3.2 李代桃僵——Sentinel / 126

3.2.1 消息丢失 / 128

3.2.2 Sentinel 基本用法 / 128

3.2.3 思考&作业 / 129

3.3 分而治之——Codis / 130

3.3.1 Codis 分片原理 / 131

3.3.2 不同的 Codis 实例之间槽位关系如何同步 / 132

3.3.3 扩容 / 132

3.3.4 自动均衡 / 133

3.3.5 Codis 的代价 / 133

3.3.6 Codis 的优点 / 134

3.3.7 mget 指令的操作过程 / 134

3.3.8 架构变迁 / 135

3.3.9 Codis 的尴尬 / 135

3.3.10 Codis 的后台管理 / 136

3.3.11 思考&作业 / 136

3.4 众志成城——Cluster / 137

3.4.1 槽位定位算法 / 138

3.4.2 跳转 / 138

3.4.3 迁移 / 138

3.4.4 容错 / 140

3.4.5 网络抖动 / 140

3.4.6 可能下线（PFAIL）与确定下线（Fail） / 141

3.4.7 Cluster 基本用法 / 141

3.4.8 槽位迁移感知 / 142

3.4.9 集群变更感知 / 143

3.4.10 思考&作业 / 143

第4 篇 拓展篇 / 144

4.1 耳听八方——Stream / 144

4.1.1 消息 ID / 145

4.1.2 消息内容 / 145

4.1.3 增删改查 / 145

4.1.4 独立消费 / 147

4.1.5 创建消费组 / 148

4.1.6 消费 / 150

4.1.7 Stream 消息太多怎么办 / 152

4.1.8 消息如果忘记 ack 会怎样 / 153

4.1.9 PEL 如何避免消息丢失 / 153

4.1.10 Stream 的高可用 / 153

4.1.11 分区 Partition / 154

4.1.12 小结 / 154

4.2 无所不知——Info 指令 / 154

4.2.1 Redis 每秒执行多少次指令 / 155

4.2.2 Redis 连接了多少客户端 / 156

4.2.3 Redis 内存占用多大 / 156

4.2.4 复制积压缓冲区多大 / 157

4.2.5 思考&作业 / 158

4.3 拾遗补漏——再谈分布式锁 / 158

4.3.1 Redlock 算法 / 158

4.3.2 Redlock 使用场景 / 159

4.3.3 扩展阅读：redlock-py 的作者 / 160

4.4 朝生暮死——过期策略 / 160

4.4.1 过期的 key 集合 / 160

4.4.2 定时扫描策略 / 160

4.4.3 从节点的过期策略 / 161

4.5 优胜劣汰——LRU / 162

4.5.1 LRU 算法 / 163

4.5.2 近似 LRU 算法 / 164

4.5.3 思考&作业 / 165

4.6 平波缓进——懒惰删除 / 165

4.6.1 Redis 为什么使用懒惰删除 / 165

4.6.2 flush / 166

4.6.3 异步队列 / 166

4.6.4 AOF Sync 也很慢 / 166

4.6.5 更多异步删除点 / 166

4.7 妙手仁心——优雅地使用 Jedis / 167

4.7.1 重试 / 171

4.7.2 思考&作业 / 172

4.8 居安思危——保护 Redis / 172

4.8.1 指令安全 / 172

4.8.2 端口安全 / 173

4.8.3 Lua 脚本安全 / 174

4.8.4 SSL 代理 / 174

4.8.5 小结 / 174

4.9 隔墙有耳——Redis 安全通信 / 175

4.9.1 spiped 原理 / 176

4.9.2 spiped 使用入门 / 176

4.9.3 思考&作业 / 179

第5 篇 源码篇 / 180

5.1 丝分缕析——探索“字符串”内部 / 180

5.1.1 embstr VS raw / 181

5.1.2 扩容策略 / 184

5.1.3 思考&作业 / 184

5.2 循序渐进——探索“字典”内部 / 184

5.2.1 dict 内部结构 / 184

5.2.2 渐进式 rehash / 186

5.2.3 查找过程 / 187

5.2.4 hash 函数 / 188

5.2.5 hash 攻击 / 188

5.2.6 扩容条件 / 188

5.2.7 缩容条件 / 189

5.2.8 set 的结构 / 189

5.2.9 思考&作业 / 189

5.3 挨肩迭背——探索“压缩列表”内部 / 190

5.3.1 增加元素 / 192

5.3.2 级联更新 / 192

5.3.3 intset 小整数集合 / 194

5.3.4 思考&作业 / 195

5.4 风驰电掣——探索“快速列表”内部 / 195

5.4.1 每个 ziplist 存多少元素 / 197

5.4.2 压缩深度 / 198

5.5 凌波微步——探索“跳跃列表”内部 / 198

5.5.1 基本结构 / 199

5.5.2 查找过程 / 199

5.5.3 随机层数 / 200

5.5.4 插入过程 / 201

5.5.5 删除过程 / 202

5.5.6 更新过程 / 203

5.5.7 如果 score 值都一样呢 / 203

5.5.8 元素排名是怎么算出来的 / 203

5.5.9 思考&作业 / 204

5.5.10 题外话 / 204

5.6 破旧立新——探索“紧凑列表”内部 / 205

5.6.1 级联更新 / 207

5.6.2 取代 ziplist 尚需时日 / 207

5.6.3 思考&作业 / 207

5.7 金枝玉叶——探索“基数树”内部 / 207

5.7.1 应用 / 208

5.7.2 结构 / 210

5.7.3 思考&作业 / 213

5.8 精益求精——LFU VS LRU / 213

5.8.1 Redis 对象的热度 / 213

5.8.2 LRU 模式 / 213

5.8.3 LFU 模式 / 214

5.8.4 为什么 Redis 要缓存系统时间戳 / 217

5.8.5 Redis 为什么在获取 lruclock 时使用原子操作 / 217

5.8.6 如何打开 LFU 模式 / 218

5.8.7 思考&作业 / 218

5.9 如履薄冰——懒惰删除的巨大牺牲 / 218

5.9.1 懒惰删除的最初实现不是异步线程 / 219

5.9.2 异步线程方案其实也相当复杂 / 219

5.9.3 异步删除的实现 / 221

5.9.4 队列安全 / 224

5.9.5 思考&作业 / 225

5.10 跋山涉水——深入字典遍历 / 225

5.10.1 一边遍历一边修改 / 226

5.10.2 重复遍历的难题 / 227

5.10.3 迭代器的结构 / 227

5.10.4 迭代过程 / 229

5.10.5 迭代器的选择 / 231

5.10.6 思考&作业 / 232
























179. redis 是什么？都有哪些使用场景？

Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。



Redis 使用场景：

数据高并发的读写

海量数据的读写

对扩展性要求高的数据

180. redis 有哪些功能？

数据缓存功能

分布式锁的功能

支持数据持久化

支持事务

支持消息队列

181. redis 和 memecache 有什么区别？

memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型

redis的速度比memcached快很多

redis可以持久化其数据

182. redis 为什么是单线程的？

因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。



关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。



而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。

183. 什么是缓存穿透？怎么解决？

缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。



解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

184. redis 支持的数据类型有哪些？

string、list、hash、set、zset。

185. redis 支持的 java 客户端都有哪些？

Redisson、Jedis、lettuce等等，官方推荐使用Redisson。

186. jedis 和 redisson 有哪些区别？



Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。



Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

187. 怎么保证缓存和数据库数据的一致性？

合理设置缓存的过期时间。

新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。

188. redis 持久化有几种方式？

Redis 的持久化有两种方式，或者说有两种策略：



RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。

AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。

189. redis 怎么实现分布式锁？

Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。



占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。

190. redis 分布式锁有什么缺陷？

Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

191. redis 如何做内存优化？

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。



比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。

192. redis 淘汰策略有哪些？

volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。

volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。

volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。

allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。

allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。

no-enviction（驱逐）：禁止驱逐数据。

193. redis 常见的性能问题有哪些？该如何解决？

主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。

Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。


本文主要讲了 Redis 的持久化相关功能，持久化一直是影响 Redis 性能的高发地，也是面试中经常被问到的。

包括 RDB 相关的特定和优缺点，AOF 的优缺点，事实上，由于 RDB 的数据实时性问题，目前用 AOF 比较多了，而持久化恢复也是优先 AOF。

RDB 是旧的模式，现在基本上都使用 AOF，当然，今天两个都会一起聊聊。

二、RDB
RDB 流程图：



RDB 特点：

1、RDB 是一种快照模式，即——保存的是 key value 数据内容。

2、RDB 有 2 种持久方式，同步 save 模式和异步 bgsave 模式。由于 save 是同步的，所以可以保证数据一致性，而 bgsave 则不能。

3、save 可以在客户端显式触发，也可以在 shutdown 时自动触发；bgsave 可以在客户端显式触发，也可以通过配置由定时任务触发，也可以在 slave 节点触发。

4、save 导致 redis 同步阻塞，基本已经废弃。bgsave 则不会导致阻塞，但也有缺点：在 fork 时，需要增加内存服务器开销，因为当内存不够时，将使用虚拟内存，导致阻塞 Redis 运行。所以，需要保证空闲内存足够。

5、默认执行 shutdown 时，如果没有开启 AOF，则自动执行 bgsave。

6、每次的 RDB 文件都是替换的。

关于优化：

Redis 会压缩 RDB 文件，使用 LZF 算法，让最终的 RDB 文件远小于内存大小，默认开启。但会消耗 CPU。

RDB 缺点：

1、无法秒级持久化。

2、老版本 Redis 无法兼容新版本 RDB。

RDB 优点：

1、文件紧凑，适合备份，全量复制场景。例如每 6 小时执行 bgsave，保存到文件系统之类的。

2、Redis 加载 RDB 恢复数据远远快于 AOF。

三、AOF
由于 RDB 的数据实时性问题，AOF（append only file） 是目前 Redis 持久化的主流方式。

AOF 特点：

1、默认文件名是 appendonly.aof。和 RDB 一样，保存在配置中 dir 目录下。

2、AOF 相比较于 RDB，每次都会保存写命令，数据实时性更高。

3、AOF 由于每次都会记录写命令，文件会很大，因此需要进行优化，称之为“重写机制”（下面详细说）。

4、AOF 每次保存的写命令都放在一个缓冲区，根据不同的策略（下面详细说）同步到磁盘。

“重写机制” 细节：

1、fork 子进程（类似 bgsave）

2、主进程会写到2个缓冲区，一个是原有的 “AOF 缓存区”，一个是专门为子进程准备的 “AOF 重写缓冲区”；

3、子进程写到到新的 AOF 文件中，批量的，默认 32m；写完后通知主进程。

4、主进程把“AOF 重写缓冲区”的数据写到新 AOF 文件中。

5、将新的 AOF 文件替换老文件。

重写流程图：



缓冲区同步策略，由参数 appendfsync 控制，一共3种：

1、always：调用系统 fsync 函数，直到同步到硬盘返回；严重影响redis性能。

2、everysec：先调用 OS write 函数， 写到缓冲区，然后 redis 每秒执行一次 OS fsync 函数。推荐使用这种方式。

3、no: 只执行 write OS 函数，具体同步硬盘策略由 OS 决定；不推荐，数据不安全，容易丢失数据。

四、持久化恢复
AOF 和 RDB 文件都可以用于服务器重启时的数据恢复，具体流程如下图：



从图中可以看出优先加载 AOF，当没有 AOF 时才加载 RDB。当 AOF 或者 RDB 存在错误，则加载失败。

五、问题排查和性能优化
Redis 持久化是影响 Redis 性能的高发地，也是面试中常问的问题。

1、fork 操作

当 Redis 做 RDB 或者 AOF 重写时，必然要进行 fork 操作，对于 OS 来说，fork 都是一个重量级操作。而且，fork 还会拷贝一些数据，虽然不会拷贝主进程所有的物理空间，但会复制主进程的空间内存页表。对于 10GB 的 Redis 进程，需要复制大约 20MB 的内存页表，因此 fork 操作耗时跟进程总内存量息息相关，再加上，如果使用虚拟化技术，例如 Xen 虚拟机，fork 会更加耗时。

一个正常的 fork 耗时大概在 20毫秒左右。为什么呢，假设一个 Redis 实例的 OPS 在 5 万以上，如果 fork 操作耗时在秒级，那么僵拖慢几万条命令的执行，对生产环境影响明显。

我们可以在 Info stats 统计中查询 latestforkusec 指标获取最近一次 fork 操作耗时，单位微秒。

如何优化：

1) 优先使用物理机或者高效支持 fork 的虚拟化技术，避免使用 Xen。

2) 控制 redis 实例最大内存，尽量控制在 10GB 以内。

3) 合理配置 Linux 内存分配策略，避免内存不足导致 fork 失败。

4) 降低 fork 的频率，如适度放宽 AOF 自动触发时机，避免不必要的全量复制。

2、子进程开销

fork 完毕之后，会创建子进程，子进程负责 RDB 或者 AOF 重写，这部分过程主要涉及到 CPU，内存，硬盘三个地方的优化。

1) CPU 写入文件的过程是 CPU 密集的过程，通常子进程对单核 CPU 利用率接近 90%。如何优化呢？既然是 CPU 密集型操作，就不要绑定单核 CPU，因为这样会和父 CPU 进行竞争。同时，不要和其他 CPU 密集型服务不是在一个机器上。如果部署了多个 Redis 实例，尽力保证统一时刻只有一个子进程执行重写工作。

2) 内存子进程通过 fork 操作产生，占用内存大小等同于父进程，理论上需要两倍的内存完成持久化操作，但 Linux 有 copy on write 机制，父子进程会共享相同的物理内存页，当父进程处理写操作时，会把要修改的页创建对应的副本，而子进程在 fork 操作过程中，共享整个父进程内存快照。即——如果重写过程中存在内存修改操作，父进程负责创建所修改内存页的副本。这里就是内存消耗的地方。如何优化呢？尽量保证同一时刻只有一个子进程在工作；避免大量写入时做重写操作。

3) 硬盘 硬盘开销分析：子进程主要职责是将 RDB 或者 AOF 文件写入硬盘进行持久化，势必对硬盘造成压力，可通过工具例如 iostat，iotop 等，分析硬盘负载情况。

如何优化：

1) 不要和其他高硬盘负载的服务放在一台机器上，例如 MQ，存储。

2) AOF 重写时会消耗大量硬盘 IO，可以开启配置 no-appendfsync-on-rewrite，默认关闭。表示在 AOF 重写期间不做 fsync 操作。

3) 当开启 AOF 的 Redis 在高并发场景下，如果使用普通机械硬盘，每秒的写速率是 100MB左右，这时，Redis 的性能瓶颈在硬盘上，建议使用 SSD。

4) 对于单机配置多个 Redis 实例的情况，可以配置不同实例分盘存储 AOF 文件，分摊硬盘压力。

3、AOF 追加阻塞

当开启 AOF 持久化时，常用的同步硬盘的策略是“每秒同步” everysec，用于平衡性能和数据安全性，对于这种方式，redis 使用另一条线程每秒执行 fsync 同步硬盘，当系统资源繁忙时，将造成 Redis 主线程阻塞。

流程图如下：



通过上图可以发现：everysec 配置最多可能丢失 2 秒数据，不是 1 秒；如果系统 fsync 缓慢，将会导致 Redis 主线程阻塞影响效率。

问题定位：

1) 发生 AOF 阻塞时，会输入日志。用于记录 AOF fsync 阻塞导致拖慢 Redis 服务的行为。

2) 每当 AOF 追加阻塞事件发生时，在 info Persistence 统计中，aofdelayedfsync 指标会累加，查看这个指标方便定位 AOF 阻塞问题。

3) AOF 同步最多运行 2 秒的延迟，当延迟发生时说明硬盘存在性能问题，可通过监控工具 iotop 查看，定位消耗 IO 的进程。

4、单机多实例部署

Redis 单线程架构无法充分利用多核CPU，通常的做法是一台机器上部署多个实例，当多个实例开启 AOF 后，彼此之间就会产生CPU 和 IO 的竞争。

如何解决这个问题呢？

让所有实例的 AOF 串行执行。

我们通过 info Persistence 中关于 AOF 的信息写出 Shell 脚本，然后串行执行实例的 AOF 持久化。

整个过程如图：



通过不断判断 AOF 的状态，手动执行 AOF 重写，保证 AOF 不会存在竞争。具体的 Shell 编写以及 info 信息判断，可以查看下图：

本文主要讲了 Redis 的持久化相关功能，持久化一直是影响 Redis 性能的高发地，也是面试中经常被问到的。包括 RDB 相关的特定和优缺点，AOF 的优缺点，事实上，由于 RDB 的数据实时性问题，目前用 AOF 比较多了。而持久化恢复也是优先 AOF。

关于持久化的问题排查，就很麻烦了，但无非几个方面，fork 耗时，子进程的 CPU，内存，硬盘开销，AOF 的同步阻塞，单机多实例部署。

这些优化，可以通过前面写的分析进行排查。

