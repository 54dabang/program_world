面试题1：给一个超过100G大小的log file, log中存着IP地址, 设计算法找到出现次数最多的IP地址？

解析：100G的文件给我们的感觉是太大，我们的电脑内存一般都为4G左右所以不可能一次性把这么多的信息都加载到内存，所以就要进行切分成100份。IP地址是字符串太长，我们可以把它转化为整型%100，这样取模后的值都落在0-99的区间里，所取模后值相同的IP地址都被分配到同一个文件，这时我们就可以采用哈希表统计出每个文件中最多的那个IP地址，最后比较得到100个IP中最大的那个IP就可以了 。

面试题2：与上题条件相同，如何找到top K的IP？

解析：看到求TOP K个IP就要立马反应到使用堆排序，这里的堆排序应该注意的是要建一个小堆，想一下我们建大堆的话只能保证堆顶元素为最大的，这样只能得到最大的那个IP。

面试题3：给定100亿个整数，设计算法找到只出现一次的整数

解析：整数分为有符号和无符号两种，有符号数的取值为-2147483648~2147483648 是从-21亿到+21亿， 无符号数的范围为0~4294967296是从0到42亿，然而给了我们100亿个整数，要找出只出现一次的整数，所以我们还是要用到哈希表的思想，但我们最好不要定义一个整型数组，因为 42亿*4B  约为16G，这么大的数组我们再进行切分的话就太麻烦了，这里我们可以使用BitMap,用一个位来表示一个数存不存在，不存在表示为0，出现一次表示为1，出现一次以上用另一个位表示。这样就可以将数组的大小减为原来的16分之一。还遇到一个问题，就是到底怎么定义这个数组，正数好定义，负数的话我们可以用32位全1（-1）和它取异或取到和正数相同的位置，我们此时定义一个二维数组，一半表示正数一半表示负数，都位于同一行。此时我们使用1G的空间就可以解决这个问题了。

拓展：要是面试官问我这里只有500M或者更少的空间的话怎么做？

解析：同样采用切分的思想，不过我觉得这里我们直接可以按数的范围直接切分。要是有500M 内存的话，我们就切一次就可以了，此时如果我们有50%的几率一次就找到这个只出现一次的数，效率可能更高。

面试题4：给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集？

解析：这道题思路和上面的一样。

面试题5：1个文件有100亿个int，1G内存，设计算法找到出现次数不超过2次的所有整数

解析：这个问题和以上唯一 不同这道题是找不超过两次的整数，方法一样。

面试题6：给两个文件，分别有100亿个query，我们只有1G内存，如何找到两个文件交集分别给出精确算法和近似算法!

解析：求两个文件的交集，这种算法我们肯定要用到比较，如果我们把两个文件都均分为100份，拿一个文件里的一份分别与另一个文件里的100份分别比较一次的话效率 就太低了，我们可以借用第1道面试题的思维对它们进行取模，这样我们只要比较取模的为同一值的两个文件比较就可以了，如果相同则标记。

面试题7：如何扩展BloomFilter使得它支持删除元素的操作？

解析：BloomFilter并不支持删除元素的操作，因为很可能产生哈希冲突（就是由不同的哈希函数算出的位置指向同一个位），这样改变一个位很可能会影响到其他元素的判断。这里我们可以按照和智能指针sharedptr的思想即“引用计数”来解决，我们添加一个count计数器，每当我们在这个位上表示一个元素时就让它count++，每删除一个涉及到这个位表示的元素时就让它count--,这样只当count为0时我们再对这一位置0，这样就完成了删除的操作。

面试题8：如何扩展BloomFilter使得它支持计数操作？

解析：这道题思想和上一道题一样。

面试题9：给上千个文件，每个文件大小为1K—100M。给n个词，设计算法对每个词找到所有包含它的文件，你只有100K内存

解析：我们可以使用布隆过滤器来判断一个文件是否包含这n个单词生成n个布隆过滤器放到外存，我们事先定义好一个包含这n个单词信息的文件info，每当我们在一个文件找到一个对应的单词就将这个文件的信息写入info对应单词的位置。我们只有100K内存，这100K内存我们一部分用来存放布隆过滤器一部分可以存放文件，因为文件最小都为100K，所以我们可以尝试把它切分为50K的小文件，每个文件标志好所属的大文件，这样我们每次读入一个布隆过滤器和一个小文件，如果这个文件有对应的单词则在info中标记所属大文件的信息，如果没有则读入下一个布隆过滤器，把所有布隆过滤器都使用后，再读下一个文件重复上述步骤直至把所有文件都遍历完。

面试题10：有一个词典，包含N个英文单词，现在任意给一个字符串，设计算法找出包含这个字符串的所有英文单词

解析：首先判断一个单词是否包含一个字符串我们可以用strstr这个函数，对于这个问题，我觉得如果该字符串的前缀和要找的单词一样的话可以采用字典树来查找，但是N个英文单词我们可以假设它很大，我们把它放到一个文件里，每次只读出固定个数个单词进行判断。

总结：对于此类大数据问题我们一般都是采用哈希切分即模上一个数组的长度将数据分配到一个合理的位置，同时将一个大文件切分为小文件，这样特别方便将其与其他数进行比较例如对IP地址取整后进行哈希切分，或者对内部元素进行操作。使用BloomFilter可以进行判断元素在集合的存在与否。

1. spark的runtime

这个主要是standalone模式下的master和worker，executor，driver，再加上yarn模式下的resourcemanager和nodemanager。要了解一个spark应用提交的过程，也即是driver和executor在集群管理器内部启动的过程，然后就是rpc过程，各个角色的作用。

高手的问题就是如何给两者分配合适内存，然后executor执行task倾斜的表现及如何解决。这些都在星球里分享过了。然后如何对executor的存活挂掉新增进行监控告警。executor动态分配表现及带来的问题。

再高级一点就是driver和executor的类加载器及加载类的原理及过程，当然包括rpc，依赖传输，task调度等。

就这吧……

2.spark core

spark core股名思义就是spark的核心内容，主要是rdd的五大特性及操作算子特点介绍。

DAG的生成，划分，task的调度执行。

数据本地性原理及如何利用和会存在哪些隐患。这也在公众号发过文章和视频了。

reducebykey，groupbykey的区别等等类似算子对比，如何高效使用mappartition，然后foreachPartition与foreach之间的区别及底层实现原理，这些星球里➕公众号都发过了。

宽依赖，窄依赖等老生常谈的不多说了...基础都不去了解记忆的人面试不过很正常。

来点猛料，广播变量的原理及演变过程，使用场景，使用广播变量一定划算吗？大变量咋办呢？

累加器的原理及应用场景，累加器使用有陷阱么？

序列化，反序列化，闭包，垃圾回收机制（过期rdd的回收，cache的回收等）。这个星球里打过了～

checkpoint如何在spark core应用呢？何种场景适合？源码系列教程。

并行度相关配置，这个星球里也反复强调了，合理设置可以大幅度提高性能。

害怕了吗，还是就此打住吧，太多了～

在星球里➕公众号都有讲过了。

3.spark streaming

spark streaming核心原理大家都知道是微批处理。

基于receiver和direct api两种模式的原理，最好读懂源码。

主要是跟Kafka 结合的两种模式的区别。

direct这种模式如何实现仅一次处理。checkpoint的使用。

如何进行状态管理，upstatebykey，redis，hbase，alluxio作为状态管理存储设备的时候优缺点，然后就是故障恢复会引起的问题及如何避免等等吧。

合理设置批处理时间，为啥批处理时间不能太大，也不能太小，task倾斜，数据倾斜如何解决。

内存申请，kafka分区设置的依据是啥？

并行度问题，这个也是浪尖反复强调的，彻底理解对spark任务调优帮助很大。

blockrdd和kafkardd的底层区别。

与spark sql和hivecontext结合使用。

广播变量的使用及释放机制等。

动态分区发现和topic发现机制。

executor存活监控，task执行情况监控，未处理队列积累的健康告警（非常重要）等价于对lagsize的监控告警。

小文件问题，星球里文章很详细。根源上避免才是王道。顺便提一句：为啥namenode那么怕小文件呢？

作为7*24小时的应用程序，如何进行监控告警及故障自动恢复～

可怕的内容，多的一笔，拿着手机一个字一个字打，好累。

4.spark sql

在数仓的领域，实时处理都用它，而且structured streaming也逐步依赖于sql引擎了。

常见算子的使用及理解，并行度问题，大小表join，如何广播小表。

join，group by等数据倾斜如何发现及处理方法，这个浪尖还专门录制过视频，星球里球友应该都知道，不知道回去翻看一下。

常见的存储格式，parquet，txt，json，orc对比及对性能的影响。

调优大部分也是针对并行度，文件大小，数据倾斜，task倾斜，内存和cpu合理设置等。

5.structured streaming

这个我也系统整理了案例，分享到了星球里，要是没用过的话，建议用一下。

动态表，增量sql引擎，仅一次处理，维表join等非常好用，watermark，还有就是繁杂的join 机制。

当然限制还是很多的，期待后续版本。

spark streaming在spark 2.4的时候都没更新了，后面就主推sql引擎相关内容了，还是值得期待的。

不过话虽这么说，我觉得flink也相对好用，就是可能bug多些，新版本好点。


1、海量日志数据，提取出某日访问百度次数最多的那个IP。

      首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。

或者如下阐述（雪域之鹰）：
算法思想：分而治之+Hash
1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；
2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址；
3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址；
4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP；

2、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。
    假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。

    典型的Top K算法，还是在这篇文章里头有所阐述，详情请参见：十一、从头到尾彻底解析Hash表算法。

    文中，给出的最终算法是：
    第一步、先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计（之前写成了排序，特此订正。July、2011.04.27）；
    第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。
        即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比所以，我们最终的时间复杂度是：O（N） + N'*O（logK），（N为1000万，N’为300万）。ok，更多，详情，请参考原文。

    或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。


3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。

    方案：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。

    如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。
    对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。


4、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。

    还是典型的TOP K算法，解决方案如下：
    方案1：
    顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。

    找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。

    对这10个文件进行归并排序（内排序与外排序相结合）。

    方案2：
     一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。

    方案3：
    与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。


5、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？

    方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。

    遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。

    遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。

    求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

    方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。

    Bloom filter日后会在本BLOG内详细阐述。


6、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。

    方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

    方案2：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。


7、腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？

    与上第6题类似，我的第一反应时快速排序+二分查找。以下是其它更好的方法：
    方案1：oo，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

    dizengrong：
    方案2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下：
又因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；
这里我们把40亿个数中的每一个用32位的二进制来表示
假设这40亿个数开始放在一个文件中。

    然后将这40亿个数分成两类:
      1.最高位为0
      2.最高位为1
    并将这两类分别写入到两个文件中，其中一个文件中数的个数<=20亿，而另一个>=20亿（这相当于折半了）；
与要查找的数的最高位比较并接着进入相应的文件再查找

    再然后把这个文件为又分成两类:
      1.次最高位为0
      2.次最高位为1

    并将这两类分别写入到两个文件中，其中一个文件中数的个数<=10亿，而另一个>=10亿（这相当于折半了）；
    与要查找的数的次最高位比较并接着进入相应的文件再查找。
    .......
    以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。

   附：这里，再简单介绍下，位图方法：
    使用位图法判断整形数组是否存在重复
    判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。

    位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为2N。如果已知数组的最大值即能事先给新数组定长的话效率还能提高一倍。

    欢迎，有更好的思路，或方法，共同交流。


8、怎么在海量数据中找出重复次数最多的一个？

    方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。


9、上千万或上亿数据（有重复），统计其中出现次数最多的钱N个数据。

    方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第2题提到的堆机制完成。


10、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。

    方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度）。然后是找出出现最频繁的前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大的哪一个。


附、100w个数中找出最大的100个数。

    方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。

    方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。

    方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。

致谢：http://www.cnblogs.com/youwang/。



第二部分、十个海量数据处理方法大总结

    ok，看了上面这么多的面试题，是否有点头晕。是的，需要一个总结。接下来，本文将简单总结下一些处理海量数据问题的常见方法，而日后，本BLOG内会具体阐述这些方法。

    下面的方法全部来自http://hi.baidu.com/yanxionglu/blog/博客，对海量数据的处理方法进行了一个一般性的总结，当然这些方法可能并不能完全覆盖所有的问题，但是这样的一些方法也基本可以处理绝大多数遇到的问题。下面的一些问题基本直接来源于公司的面试笔试题目，方法不一定最优，如果你有更好的处理方法，欢迎讨论。

一、Bloom filter

　　适用范围：可以用来实现数据字典，进行数据的判重，或者集合求交集

　　基本原理及要点：
　　对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。

　　还有一个比较重要的问题，如何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)*(m/n)时错误率最小。在错误率不大于E的情况下，m至少要等于n*lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应该>=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。

　　举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。

　　注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。

　　扩展：
　　Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。

　　问题实例：给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？

　　根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿*8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。


二、Hashing

　　适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存

　　基本原理及要点：
　　hash函数选择，针对字符串，整数，排列，具体相应的hash方法。
　　碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。

      扩展：
　　d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。

　　问题实例：
　　1).海量日志数据，提取出某日访问百度次数最多的那个IP。
　　IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。


三、bit-map

　　适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下

　　基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码

　　扩展：bloom filter可以看做是对bit-map的扩展

　　问题实例：
　　1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。
　　8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。
　　2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。

　　将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。


四、堆

　　适用范围：海量数据前n大，并且n比较小，堆可以放入内存

　　基本原理及要点：最大堆求前n小，最小堆求前n大。方法，比如求前n小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。

　　扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。

　　问题实例：
　　1)100w个数中找最大的前100个数。
　　用一个100个元素大小的最小堆即可。



五、双层桶划分----其实本质上就是【分而治之】的思想，重在“分”的技巧上！

　　适用范围：第k大，中位数，不重复或重复的数字
　　基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子。

　　扩展：
　　问题实例：
　　1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。
　　有点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。

　　2).5亿个int找它们的中位数。
　　这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。

　　实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。


六、数据库索引

　　适用范围：大数据量的增删改查

　　基本原理及要点：利用数据的设计实现方法，对海量数据的增删改查进行处理。


七、倒排索引(Inverted index)

　　适用范围：搜索引擎，关键字查询

　　基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。

　以英文为例，下面是要被索引的文本：
    T0 = "it is what it is"
    T1 = "what is it"
    T2 = "it is a banana"

我们就能得到下面的反向文件索引：

    "a":      {2}
    "banana": {2}
    "is":     {0, 1, 2}
    "it":     {0, 1, 2}
    "what":   {0, 1}

　检索的条件"what","is"和"it"将对应集合的交集。

　　正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。

　　扩展：
　　问题实例：文档检索系统，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。


八、外排序

　　适用范围：大数据的排序，去重

　　基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树

　　扩展：

　　问题实例：
　　1).有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。

　　这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。


九、trie树

　　适用范围：数据量大，重复多，但是数据种类小可以放入内存

　　基本原理及要点：实现方式，节点孩子的表示方式

　　扩展：压缩实现。

　　问题实例：
　　1).有10个文件，每个文件1G，每个文件的每一行都存放的是用户的query，每个文件的query都可能重复。要你按照query的频度排序。
　　2).1000万字符串，其中有些是相同的(重复),需要把重复的全部去掉，保留没有重复的字符串。请问怎么设计和实现？
　　3).寻找热门查询：查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个，每个不超过255字节。


十、分布式处理 mapreduce

　　适用范围：数据量大，但是数据种类小可以放入内存

　　基本原理及要点：将数据交给不同的机器去处理，数据划分，结果归约。

　　扩展：
　　问题实例：
　　1).The canonical example application of MapReduce is a process to count the appearances of
each different word in a set of documents:
　　2).海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。
　　3).一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中数(median)？


经典问题分析
　　上千万or亿数据（有重复），统计其中出现次数最多的前N个数据,分两种情况：可一次读入内存，不可一次读入。

　　可用思路：trie树+堆，数据库索引，划分子集分别统计，hash，分布式计算，近似统计，外排序

　　所谓的是否能一次读入内存，实际上应该指去除重复后的数据量。如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过 map，hashmap，trie，然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当然这样导致维护次数增加，不如完全统计后在求前N大效率高。

　　如果数据无法放入内存。一方面我们可以考虑上面的字典方法能否被改进以适应这种情形，可以做的改变就是将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。

　　当然还有更好的方法，就是可以采用分布式计算，基本上就是map-reduce过程，首先可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。

　　实际上可能想直接将数据均分到不同的机子上进行处理，这样是无法得到正确的解的。因为一个数据可能被均分到不同的机子上，而另一个则可能完全聚集到一个机子上，同时还可能存在具有相同数目的数据。比如我们要找出现次数最多的前100个，我们将1000万的数据分布到10台机器上，找到每台出现次数最多的前 100个，归并之后这样不能保证找到真正的第100个，因为比如出现次数最多的第100个可能有1万个，但是它被分到了10台机子，这样在每台上只有1千个，假设这些机子排名在1000个之前的那些都是单独分布在一台机子上的，比如有1001个，这样本来具有1万个的这个就会被淘汰，即使我们让每台机子选出出现次数最多的1000个再归并，仍然会出错，因为可能存在大量个数为1001个的发生聚集。因此不能将数据随便均分到不同机子上，而是要根据hash 后的值将它们映射到不同的机子上处理，让不同的机器处理一个数值范围。

　 而外排序的方法会消耗大量的IO，效率不会很高。而上面的分布式方法，也可以用于单机版本，也就是将总的数据根据值的范围，划分成多个不同的子文件，然后逐个处理。处理完毕之后再对这些单词的及其出现频率进行一个归并。实际上就可以利用一个外排序的归并过程。

　 另外还可以考虑近似计算，也就是我们可以通过结合自然语言属性，只将那些真正实际中出现最多的那些词作为一个字典，使得这个规模可以放入内存。

==========
前言：在这个用户量爆炸、并发极高的互联网时代，对于如今的IT行业，在极大量的数据处理这一块的能力，无疑某些程度上是其技术实力的体现。例如淘宝、支付宝在双十一这天的峰值时期，每秒要处理的数据量几乎都是百亿级别，新浪微博在春晚将要处理一亿左右人的抢红包活动。海量数据处理能力是一家大公司必须要做得非常硬的一个技术块，这样才能在互联网行业的激烈竞争中站稳脚跟。因此，海量数据问题在面试中也是经常问到的，并且也是很能体现你的知识底蕴的一个方面。

下面我们通过七个问题来进行讲解。

Ps:本文需要堆、哈希、位图、布隆这些知识基础，若你不明白这些目前还是先不要看下去了，当然，没有耐心去一个一个方法看的肯定也看不下去。

正文：

海量数据的定义：内存里存不下或者会占用太多内存的数据量。（注意：我们说的是内存，因为这些数据都是要拿来直接用的）

注意：在这里讲的是方法，因为别人问你也不是要你自己能实现一个处理海量的数据的轮子，重要的是能表述清楚原理，因此无关紧要的细节各位自行忽略(比如下面的log file怎么取模,log file中的IP怎么提取之类的问题)

1）给⼀一个超过100G大小的log ﬁle, log中存着IP地址, 设计算法找到出现次数最多的IP地址。如何找到top K的IP？

        这样的问题如果出现在数据量较小的情形下，用一个map或者unordered_map都能很快的处理，但是100G这样的量级放在一个map里是绝对不可行的。因此，我们采用哈希切分。

        什么是哈希切分？

        100G文件我们无法处理，是1G文件我们能处理，100M文件我们能处理

        因此，哈希切分的第一步：映射切分(分治)

        首先把所有log file中的IP挨个提取出来，然后这个总量为100G的IP文件，我们通过对所有进行IP%1000这样一个操作，把100G的大文件切分成了1000个100M的小文件

        第二步：对每个切分小文件进行统计

        这个统计过程一般直接用unordered_map<IP,size_t>就能完成，然后在每个切分小文件里，我们很快就能找到出现次数最多的那个IP

        第三步：排序

        由第二步得到了1000个出现频率最高的IP后，由于我们在这里只用找出出现次数最多的IP，那么O(n)次内遍历一趟就能找出来，当然，如果找前k个，那就用一个容量为k的小堆就能完成。

        过程如图(后面大部分题都是这么个模式，就不再画图了)

        

        好了，思考的同学肯定会有疑问，这样做难道不会出现相同的IP没有被映射到一个文件的问题嘛？当然不会啦。因为第一步的哈希映射是等价映射，相同的IP%1000后是一定会被映射到同一小文件里的，因此不存在这种问题。同时，我们这里%1000改成%100也是同样可以的，只不过%1000比%100更能避免同一小文件里映射了太多IP的问题。

        总得来说就是：映射->统计->排序

        OK,有了对哈希切分的基础，后面的好几个问题用哈希切分就迎刃而解了，但是这些问题我们就不说哈希切分这个方法了，对于这类问题，你会发现哈希切分几乎是个万金油的方法╭(′▽`)╭(′▽`)╯

2）给定100亿个整数，设计算法找到只出现一次的整数

        这个问题如果出现在数据量比较小的情况下，把位图(BitSet)进行扩展无疑是最节省空间与时间的方法。

        把位图每个标记位由普通位图的一个变为两个，因为普通位图只能标记在或不在，而我们的要求是判断是否只出现一次，因此我们用两个位来标记就好啦，因为两个位可以表示：0次、1次、2次、3次，但这是100亿个整数诶！

        我们先做个计算：假定我们的位图用两个位为来标记一个数字，一个字节就能标记4个正数，而我们有100亿个，那么就需要100/4 = 25亿字节，10亿字节约等于1g,也就是说我们的位图也至少要开2.5个g左右的内存空间。2.5g内存对如今的计算机似乎也不大，但如果我就是要你不用超过1g内存呢 ◔ ‸◔？

        机灵的你一定想到了哈希切分！没错，我们先哈希切分，然后每次用位图统计只出现一次的正数，即使我们切10份，每次用位图也就需要250M空间，这样就能把内存占用控制在250M左右，这样问题就解决了。

 

 3）给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集 

        有了前面两题的基础，这个问题是不是就迎刃而解了，这道题在上题的基础上，我们只要把位图改为用普通位图，然后该切分还是切分，我们再来计算一下：现在一个字节可以标记八个整数，那么我们对于每个文件需要  100/8 = 12.5亿字节，约等于1.25g左右，因为有两个文件，我们需要两个位图，那么我们要就要2.5g左右空间。

        同样，我们对两个文件分别分10份，每次使用两个位图，这两个位图按位与得到的结果就记录好了交集，每次我们又把交集里出现的正数统计好，记录下来，这样内存也可以很好的控制在1g以下。

4）1个文件有100亿个int，1G内存，设计算法找到出现次数不超过2次的所有整数

        这个问题非常简单了，就是把第二题中要找的只出现一次的整数，改成找出现一次、出现两次的整数，其他的就不符合哦我们要求啦，方法仍然就是把普通位图进行扩展。

5）给两个文件，分别有100亿个query，我们只有1G内存，如何找到两个文件交集？分别给出精确算法和近似算法

        为了方便讲解，避免不必要的讨论，我们假定这个query就是字符串类型。

        首先，对于字符串类型，直接用位图肯定是没法用了，那我们就用布隆过滤器(BloomFilter)

        布隆的特点：存在不一定是准确的(虽然一般几率较小)，不存在是一定准确的

        因此，对于近似算法，我们用普通的布隆过滤器能做到的就是近似准确的，毕竟HasnFunc对于字符串的映射到整型是无限集到有限集的映射，是有可能出现不同字符串映射到同一个位的，即使几率很小。

        同样，都不用我说你也知道，先哈希切分，再布隆，每次把两个布隆按位与的结果记录下来即可。

        对于精确算法，我们是这样实现的，把布隆进行扩展，原来用一个HashFunc映射一次来映射一个位，那么我们用N个字符串HashFunc来映射N个位，(N的取值是有具体理论的，这里不进行赘述)，占用的空间回事原来的N倍，但是这样出现误判的几率就几乎是不可能有了。做了这个处理后，后面的步骤是相同的。

6）如何扩展BloomFilter使得它支持删除元素的操作？如何扩展BloomFilter使得它支持计数操作？

        在这道题里说的布隆当然是说的精确的布隆过滤器，它是不支持删除的，因为删除的时候会产生对其他数据的连锁效应，比两个字符串经过三个映射后，其可能有一个映射位是相同的，这个时候删除这两个字符串中的哪一个字符串都不太好处理。这两个问题其实问的是同一件事，只要支持了计数，那么就必然是置产删除的。   

        那么怎么使它支持计数呢？我们原来是每个HashFunc会映射到一个位，现在每个HashFunc映射到n个位来计数(类似位图的扩展)，比如n为2，那么就能表示这个映射到的位被标记了0、1、2、3次，每次Set操作，该位+1，每次ReSet操作，该位-1，这样就能做到计数与删除了，当然，对空间的消耗也是成倍的，并且，这个计数位到底应该有几个对于要处理的问题是合适的也是一个要考虑的问题，比如n为2最多才能被标记三次。

7）与(1)题条件相同，如何直接用Linux系统命令实现找到top K的IP？

        第一步要做的仍然是哈希切分，然后每一组文件里要用到awk sort uniq  具体要怎么用还得看Log file 中每一行的格式。

