package ch04.sec04.impl;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import ch04.sec04.Cipher;

public class AESCipher implements Cipher {
    public byte[] encrypt(byte[] source, byte[] key) {
        SecretKey skey = new SecretKeySpec(key, "AES");
        javax.crypto.Cipher cipher;
        try {
            cipher = javax.crypto.Cipher.getInstance("AES");
            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, skey);
            return cipher.doFinal(source);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException ex) {
            RuntimeException ex2 = new RuntimeException();
            ex2.initCause(ex);
            throw ex2;
        }
    }

    public byte[] decrypt(byte[] source, byte[] key) {
        SecretKey skey = new SecretKeySpec(key, "AES");
        javax.crypto.Cipher cipher;
        try {
            cipher = javax.crypto.Cipher.getInstance("AES");
            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, skey);
            return cipher.doFinal(source);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException ex) {
            RuntimeException ex2 = new RuntimeException();
            ex2.initCause(ex);
            throw ex2;
        }
    }

    @Override
    public int strength() {
        return 10;
    }
}
package ch04.sec04.impl;

import ch04.sec04.Cipher;

public class AESCipherFactory {
    public static Cipher provider() { return new AESCipher(); }
}
package ch11.sec01;

import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
import java.util.List;

import ch11.sec02.BugReport;
import ch11.sec02.Reference;
import ch11.sec02.Test;

@interface Entity {}

@interface Param { String value(); }

@Target(ElementType.TYPE_PARAMETER)
@interface Immutable {}


public abstract class AnnotationDemo {
    @Test public void checkRandomInsertions() {}

    @Test(timeout=10000)
    public void hopefullyNotTooSlowAlgo() {}

    class CacheTest {}

    @BugReport(showStopper=true,
        assignedTo="Harry",
        testCase=CacheTest.class,
        status=BugReport.Status.CONFIRMED)
    public void buggyMethod() {}

    @BugReport(reportedBy={"Harry", "Fred"})
    public void anotherBuggyMethod() {}

    @BugReport(reportedBy="Harry")
    public void yetAnotherBuggyMethod() {}

    @BugReport(ref=@Reference(id=11235811))
    public void andAnotherBuggyMethod() {}

    @Test
    @BugReport(showStopper=true, reportedBy="Joe")
    public void checkMoreRandomInsertions() {}

    @BugReport(showStopper=true, reportedBy="Joe")
    @BugReport(reportedBy={"Harry", "Carl"})
    public void checkEvenMoreRandomInsertions() {}

    public abstract List<?> getList(String table);

    @Entity public class User {}
    @SuppressWarnings("unchecked") List<User> users = (List<User>) getList("users");
    public User getUser(@Param("id") String userId) { return null; }

    public class Cache<@Immutable V> {}
}package ch03.sec09;

import java.util.Random;

public class AnonymousClassDemo {
    private static Random generator = new Random();

    public static IntSequence randomInts(int low, int high) {
        return new IntSequence() {
            public int next() { return low + generator.nextInt(high - low + 1); }
            public boolean hasNext() { return true; }
        };
    }

    public static void main(String[] args) {
        IntSequence dieTosses = randomInts(1, 6);
        for (int i = 0; i < 10; i++) System.out.println(dieTosses.next());
    }
}
package ch04.sec01;

import java.util.ArrayList;

public class AnonymousSubclassDemo {
    public static void main(String[] args) {
        ArrayList<String> names = new ArrayList<String>(100) {
            public void add(int index, String element) {
                super.add(index, element);
                System.out.printf("Adding %s at %d\n", element, index);
            }
        };

        names.add(0, "Peter");
        names.add(1, "Paul");
        names.add(0, "Mary");
        System.out.println(names);

        invite(new ArrayList<String>() {{ add("Harry"); add("Sally"); }});
    }

    public static void invite(ArrayList<String> friends) {
        System.out.println("Guest list: " + friends);
    }
}
package ch01.sec04;

public class ArithmeticDemo {
    public static void main(String[] args) {
        // Division and remainder

        System.out.println(17 / 5);
        System.out.println(17 % 5);
        System.out.println(Math.floorMod(17, 5));

        System.out.println(-17 / 5);
        System.out.println(-17 % 5);
        System.out.println(Math.floorMod(-17, 5));

        // Increment and decrement

        int[] a = { 17, 29 };
        int n = 0;
        System.out.printf("%d %d\n", a[n++], n);
        n = 0;
        System.out.printf("%d %d\n", a[++n], n);

        // Powers and roots

        System.out.println(Math.pow(10, 9));
        System.out.println(Math.sqrt(1000000));

        // Number conversions

        double x = 42;
        System.out.println(x); // 42.0

        float f = 123456789;
        System.out.println(f); // 1.23456792E8

        x = 3.75;
        n = (int) x;
        System.out.println(n); // 3

        n = (int) Math.round(x);
        System.out.println(n); // 4

        System.out.println('J' + 1); // 75
        char next = (char)('J' + 1);
        System.out.println(next); // 'K'

        n = (int) 3000000000L;
        System.out.println(n); // -1294967296
    }
}
package ch01.sec08;

import java.util.Arrays;

public class ArrayDemo {
    public static void main(String[] args) {
        String[] names = new String[10];
        for (int i = 0; i < names.length / 2; i++) {
            names[i] = "";
        }
        names[0] = "Fred";
        names[1] = names[0];
        System.out.println("names="+Arrays.toString(names));

        int[] primes = { 17, 19, 23, 29, 31 };
        primes = new int[] { 2, 3, 5, 7, 11, 13 };

        // Enhanced for loop
        int sum = 0;
        for (int n : primes) {
            sum += n;
        }

        System.out.println("sum=" +sum);

        // Aliasing and copying
        int[] numbers = primes;
        numbers[5] = 42; // Also changes primes
        System.out.println("primes=" + Arrays.toString(primes));

        primes[5] = 13;
        int[] copiedPrimes = Arrays.copyOf(primes, primes.length);
        copiedPrimes[5] = 31; // Doesn't change primes
        System.out.println("primes=" + Arrays.toString(primes));
        System.out.println("copiedPrimes=" + Arrays.toString(copiedPrimes));
    }
}
package ch01.sec08;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ArrayListDemo {
    public static void main(String[] args) {
        ArrayList<String> friends = new ArrayList<>();
        friends.add("Peter");
        friends.add("Paul");
        friends.remove(1);
        friends.add(0, "Paul"); // Adds before index 0
        System.out.println("friends=" + friends);
        String first = friends.get(0);
        System.out.println("first=" + first);
        friends.set(1, "Mary");
        for (int i = 0; i < friends.size(); i++) {
            System.out.println(friends.get(i));
        }

        ArrayList<String> people = friends;
        people.set(0, "Mary"); // now friends.get(0) is also "Mary"
        System.out.println("friends=" + friends);

        ArrayList<String> copiedFriends = new ArrayList<>(friends);
        copiedFriends.set(0, "Fred"); // doesn't change friends
        System.out.println("copiedFriends=" + copiedFriends);
        System.out.println("friends=" + friends);

        friends = new ArrayList<>(List.of("Peter", "Paul", "Mary"));
        String[] names = friends.toArray(new String[0]);
        System.out.println("names=" + Arrays.toString(names));

        ArrayList<String> moreFriends = new ArrayList<>(List.of(names));
        System.out.println("moreFriends=" + moreFriends);

        Collections.reverse(friends);
        System.out.println("After reversing, friends=" + friends);
        Collections.shuffle(friends);
        System.out.println("After shuffling, friends=" + friends);
        Collections.sort(friends);
        System.out.println("After sorting, friends=" + friends);
    }
}
package ch01.sec09;

import java.util.Arrays;

public class ArrayMethodDemo {
    public static void swap(int[] values, int i, int j) {
        int temp = values[i];
        values[i] = values[j];
        values[j] = temp;
    }

    public static int[] firstLast(int[] values) {
        if (values.length == 0) return new int[0];
        else return new int[] { values[0], values[values.length - 1] };
    }

    public static void main(String[] args) {
        int[] fibs = { 1, 1, 2, 3, 5, 8, 11, 13 };
        swap(fibs, 2, fibs.length - 2);
        System.out.println(Arrays.toString(fibs));
        System.out.println(Arrays.toString(firstLast(fibs)));
    }
}package ch04.sec05;

import java.lang.reflect.Array;
import java.util.Arrays;

public class ArrayReflection {
    public static Object[] badCopyOf(Object[] array, int newLength) { // Not useful
        Object[] newArray = new Object[newLength];
        for (int i = 0; i < Math.min(array.length, newLength); i++)
            newArray[i] = array[i];
        return newArray;
    }

    public static Object goodCopyOf(Object array, int newLength) {
        Class<?> cl = array.getClass();
        if (!cl.isArray()) return null;
        Class<?> componentType = cl.getComponentType();
        int length = Array.getLength(array);
        Object newArray = Array.newInstance(componentType, newLength);
        for (int i = 0; i < Math.min(length, newLength); i++)
            Array.set(newArray, i, Array.get(array,  i));
        return newArray;
    }

    public static void main(String[] args) {
        int[] primes = { 2, 3, 5, 7, 11 };
        primes = (int[]) goodCopyOf(primes, 10);
        System.out.println(Arrays.toString(primes));
    }
}
package ch06.sec04;

import java.util.function.Predicate;

public class ArrayUtil {
    public static <T> void printAll(T[] elements, Predicate<? super T> filter) {
        for (T e : elements)
            if (filter.test(e))
                System.out.println(e.toString());
    }
}
package ch06.sec06;

import java.util.ArrayList;
import java.util.function.IntFunction;

public class ArrayUtil {
    public static <T> T[] repeat(int n, T obj, IntFunction<T[]> constr) {
        T[] result = constr.apply(n);
        for (int i = 0; i < n; i++) result[i] = obj;
        return result;
    }

    public static int[] repeat(int n, int obj, IntFunction<int[]> constr) {
        int[] result = constr.apply(n);
        for (int i = 0; i < n; i++) result[i] = obj;
        return result;
    }

    public static <T> T[] repeat(int n, T obj, T[] array) {
        T[] result;
        if (array.length >= n)
            result = array;
        else {
            @SuppressWarnings("unchecked") T[] newArray
               = (T[]) java.lang.reflect.Array.newInstance(
                   array.getClass().getComponentType(),  n);
            result = newArray;
        }
        for (int i = 0; i < n; i++) result[i] = obj;
        return result;
    }

    @SafeVarargs public static <T> ArrayList<T> asList(T... elements) {
        ArrayList<T> result = new ArrayList<>();
        for (T e : elements) result.add(e);
        return result;
    }
}
package ch06.sec02;

public class ArrayUtil {
    public static <T> void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    public static <T> T[] swap(int i, int j, T... values) {
        T temp = values[i];
        values[i] = values[j];
        values[j] = temp;
        return values;
    }
}package ch06.sec02;

public class ArrayUtilDemo {
    public static void main(String[] args) {
        String[] friends = { "Peter", "Paul", "Mary" };
        ArrayUtil.swap(friends, 0, 1);

        // Uncomment to see error message
        // Double[] result = Arrays.swap(0, 1, 1.5, 2, 3);
    }
}
// Normally, assertions are disabled. Be sure to run with
// assertions enabled to see the assertion error.

package ch05.sec02;

import java.util.Arrays;
import java.util.Scanner;

public class AssertionDemo {
    public static double[] solveQuadraticEquation(double a, double b, double c) {
        double discriminant = b * b - 4 * a * c;
        assert discriminant >= 0;
        assert a != 0 : "a == 0; not a quadradic equation";
        double discrRoot = Math.sqrt(discriminant);
        return new double[] {
                (-b - discrRoot) / (2 * a),
                (-b + discrRoot) / (2 * a)
        };
    }

    public static void main(String[] args) {
        try (Scanner in = new Scanner(System.in)) {
            System.out.println("Enter a b c (e.g. 0 2 1)");
            double a = in.nextDouble();
            double b = in.nextDouble();
            double c = in.nextDouble();
            System.out.println(Arrays.toString(solveQuadraticEquation(a, b, c)));
        }
    }
}
package ch10.sec02;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import jdk.incubator.http.HttpClient;
import jdk.incubator.http.HttpRequest;
import jdk.incubator.http.HttpResponse;
import jdk.incubator.http.HttpResponse.BodyHandler;

public class AsyncDemo {
    public static void main(String[] args) throws URISyntaxException, InterruptedException {
        String urlString = "http://horstmann.com";
        ExecutorService executor = Executors.newCachedThreadPool();
        HttpClient client = HttpClient.newBuilder()
                .executor(executor)
                .build();
        HttpRequest request
            = HttpRequest.newBuilder(new URI(urlString)).GET().build();
        client.sendAsync(request, BodyHandler.asString())
            .thenApply(HttpResponse::body)
            .whenComplete((s, t) -> {
                if (t == null) System.out.println(s);
                else t.printStackTrace();
                executor.shutdown();
            });
        executor.awaitTermination(10, TimeUnit.MINUTES);
    }
}
package ch10.sec06;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

public class AtomicLongDemo {
    public static AtomicLong count = new AtomicLong();

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 1; i <= 1000; i++) {
            int taskId = i;
            Runnable task = () -> {
                for (int k = 1; k <= 10000; k++)
                    count.incrementAndGet();
                System.out.println(taskId + ": " + count);
            };
            executor.execute(task);
        }
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.MINUTES);
        System.out.println("Final value: " + count);
    }
}package ch01.sec04;

import java.math.BigDecimal;
import java.math.BigInteger;

public class BigNumberDemo {
    public static void main(String[] args) {
        BigInteger n = BigInteger.valueOf(876543210123456789L);
        BigInteger k = new BigInteger("9876543210123456789");
        BigInteger r = BigInteger.valueOf(5).multiply(n.add(k)); // r = 5 * (n + k)
        System.out.println(r);
        System.out.println(2.0 - 1.1);
        BigDecimal d = BigDecimal.valueOf(2, 0).subtract(BigDecimal.valueOf(11, 1));
        System.out.println(d);
    }
}
package ch09.sec01;

import java.io.DataInput;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

// See http://en.wikipedia.org/wiki/BMP_file_format

public class BinaryIO {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get("chart.bmp");
        try (InputStream inStream = Files.newInputStream(path)) {
            DataInput in = new DataInputStream(inStream);
            byte[] header = new byte[2];
            in.readFully(header);
            int size = swap(in.readInt());
            in.readInt();
            in.readInt();
            int headerSize = swap(in.readInt());
            int width = swap(in.readInt());
            int height = swap(in.readInt());
            short planes = swap(in.readShort());
            short depth = swap(in.readShort());
            int compressionMode = swap(in.readInt());;
            System.out.println("Header: " + new String(header, StandardCharsets.US_ASCII));
            System.out.println("Size: " + size);
            System.out.println("Header size : " + headerSize);
            System.out.println("Width : " + width);
            System.out.println("Height : " + height);
            System.out.println("Planes : " + planes);
            System.out.println("Depth : " + depth);
            System.out.println("Compression mode : " + compressionMode);
        }
    }

    public static int swap(int n) {
        return (n & 0xFF000000) >> 24 | (n & 0xFF0000) >> 8 | (n & 0xFF00) << 8 | (n & 0xFF) << 24;
    }

    public static short swap(short n) {
        return (short) ((n & 0xFF00) >> 8 | (n & 0xFF) << 8);
    }

}
package ch07.sec05;

import java.util.BitSet;

public class BitsetDemo {
    public static void main(String[] args) {
        // This program demonstrates the Sieve of Erathostenes for finding primes
        int n = 100000;
        BitSet primes = new BitSet(n + 1);
        for (int i = 2; i <= n; i++)
           primes.set(i);
        for (int i = 2; i * i <= n; i++) {
           if (primes.get(i)) {
              for (int k = 2 * i; k <= n; k += i)
                 primes.clear(k);
           }
        }
        System.out.println(primes);
    }
}
package ch11.sec02;

import java.lang.annotation.ElementType;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.METHOD})
@Repeatable(BugReports.class)
public @interface BugReport {
    boolean showStopper() default false;
    String assignedTo() default "";
    Class<?> testCase() default Void.class;
    Status status() default Status.REPORTED;
    String[] reportedBy() default {};
    Reference ref() default @Reference(id=0);
    enum Status { REPORTED, CONFIRMED, ASSIGNED, FIXED, WONTFIX };
}

@Target({ElementType.TYPE, ElementType.METHOD})
@interface BugReports {
    BugReport[] value();
}package ch03.sec04;

import javafx.application.*;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.*;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.scene.text.*;
import javafx.stage.*;

// From the command line, you can run this program as
// java ch03.sec04.ButtonDemo
// even though it has no main method

public class ButtonDemo extends Application {
    public void start(Stage stage) {

        Button button = new Button("Ok");
        button.setOnAction(event ->
            System.out.println("Thanks for clicking!"));

        Label message = new Label("Hello, JavaFX!");
        message.setFont(new Font(100));
        VBox root = new VBox();
        root.getChildren().addAll(button, message);
        Scene scene = new Scene(root);
        stage.setScene(scene);
        stage.show();
    }
}package ch03.sec03;

import javafx.application.*;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.*;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.scene.text.*;
import javafx.stage.*;

// From the command line, you can run this program as
// java ch03.sec03.ButtonDemo
// even though it has no main method

public class ButtonDemo extends Application {
   public void start(Stage stage) {

      Button cancelButton = new Button("Cancel");
      cancelButton.setOnAction(new CancelAction());

      Label message = new Label("Hello, JavaFX!");
      message.setFont(new Font(100));
      VBox root = new VBox();
      root.getChildren().addAll(cancelButton, message);
      Scene scene = new Scene(root);
      stage.setScene(scene);
      stage.show();
   }
}

class CancelAction implements EventHandler<ActionEvent> {
    public void handle(ActionEvent event) {
        System.out.println("Oh noes!");
    }
}package ch14.sec01;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URI;

import javax.tools.SimpleJavaFileObject;

public class ByteArrayClass extends SimpleJavaFileObject {
    private ByteArrayOutputStream out;

    ByteArrayClass(String name) {
        super(URI.create("bytes:///" + name.replace('.','/') + ".class"),
            Kind.CLASS);
    }

    public byte[] getCode() {
        return out.toByteArray();
    }

    @Override
    public OutputStream openOutputStream() throws IOException {
        // TODO Auto-generated method stub
        out = new ByteArrayOutputStream();
        return out;
    }
}
package ch14.sec01;

public class ByteArrayClassLoader extends ClassLoader {
    private Iterable<ByteArrayClass> classes;

    public ByteArrayClassLoader(Iterable<ByteArrayClass> classes) {
        this.classes = classes;
    }

    @Override public Class<?> findClass(String name) throws ClassNotFoundException {
        for (ByteArrayClass cl : classes) {
            if (cl.getName().equals("/" + name.replace('.','/') + ".class")) {
                byte[] bytes = cl.getCode();
                return defineClass(name, bytes, 0, bytes.length);
            }
        }
        throw new ClassNotFoundException(name);
    }
}package ch04.sec04.impl;

import ch04.sec04.Cipher;

public class CaesarCipher implements Cipher {
    public byte[] encrypt(byte[] source, byte[] key) {
        byte[] result = new byte[source.length];
        for (int i = 0; i < source.length; i++)
            result[i] = (byte)(source[i] + key[0]);
        return result;
    }
    public byte[] decrypt(byte[] source, byte[] key) {
        return encrypt(source, new byte[] { (byte) -key[0] });
    }
    public int strength() { return 1; }
}package ch02.sec01;

import java.time.DayOfWeek;
import java.time.LocalDate;

public class Cal {
    public static void main(String[] args) {
        LocalDate date = LocalDate.now().withDayOfMonth(1);
        int month;
        if (args.length >= 2) {
            month = Integer.parseInt(args[0]);
            int year = Integer.parseInt(args[1]);
            date = LocalDate.of(year, month, 1);
        } else {
            month = date.getMonthValue();
        }

        System.out.println(" Mon Tue Wed Thu Fri Sat Sun");
        DayOfWeek weekday = date.getDayOfWeek();
        int value = weekday.getValue(); // 1 = Monday, ... 7 = Sunday
        for (int i = 1; i < value; i++)
            System.out.print("    ");
        while (date.getMonthValue() == month) {
            System.out.printf("%4d", date.getDayOfMonth());
            date = date.plusDays(1);
            if (date.getDayOfWeek().getValue() == 1)
                System.out.println();
        }
        if (date.getDayOfWeek().getValue() != 1)
           System.out.println();
    }
}
package ch04.sec03;

import java.util.Scanner;

public class Calculator {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("First operand: ");
        int a = in.nextInt();
        System.out.print("Operator: ");
        String opSymbol = in.next();
        System.out.print("Second operand: ");
        int b = in.nextInt();
        for (Operation op : Operation.values()) {
            if (op.getSymbol().equals(opSymbol)) {
                int result = op.eval(a, b);
                System.out.println(result);
            }
        }
    }
}
package ch04.sec03;

import java.util.Scanner;

public class Calculator2 {


    public static int eval(Operation op, int arg1, int arg2) {
        int result = 0;
        switch (op) {
            case ADD: result = arg1 + arg2; break;
            case SUBTRACT: result = arg1 - arg2; break;
            case MULTIPLY: result = arg1 * arg2; break;
            case DIVIDE: result = arg1 / arg2; break;
        }
        return result;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("First operand: ");
        int a = in.nextInt();
        System.out.print("Operator: ");
        String opSymbol = in.next();
        System.out.print("Second operand: ");
        int b = in.nextInt();
        for (Operation op : Operation.values()) {
            if (op.getSymbol().equals(opSymbol)) {
                System.out.println(eval(op, a, b));
            }
        }
    }
}
package ch10.sec01;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CallableDemo {
    public static long occurrences(String word, Path path) {
        try {
            String contents = new String(Files.readAllBytes(path),
                StandardCharsets.UTF_8);
            return Pattern.compile("\\PL+")
                    .splitAsStream(contents)
                    .filter(Predicate.isEqual(word))
                    .count();
        } catch (IOException ex) {
            return 0;
        }
    }

    public static Set<Path> descendants(Path p) throws IOException {
        try (Stream<Path> entries = Files.walk(p)) {
            return entries.collect(Collectors.toSet());
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException, IOException {
        String word = "String";
        Set<Path> paths = descendants(Paths.get("."));
        List<Callable<Long>> tasks = new ArrayList<>();
        for (Path p : paths) tasks.add(
            () -> { return occurrences(word, p); });
        int processors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(processors);
        List<Future<Long>> results = executor.invokeAll(tasks);
        long total = 0;
        for (Future<Long> result : results) total += result.get();
        System.out.println("Occurrences of String: " + total);

        String searchWord = "occurrences";
        List<Callable<Path>> searchTasks = new ArrayList<>();
        for (Path p : paths) searchTasks.add(
            () -> { if (occurrences(searchWord, p) > 0) return p; else throw new RuntimeException(); });
        Path found = executor.invokeAny(searchTasks);
        System.out.println(found);
        executor.shutdown();
    }
}
package ch02.sec02;

public class CallByValueDemo {
    public static void main(String[] args) {
        EvilManager boss = new EvilManager();

        Employee fred = new Employee("Fred", 50000);
        System.out.println("Salary before: " + fred.getSalary());
        boss.giveRandomRaise(fred);
        System.out.println("Salary after: " + fred.getSalary());

        double sales = 100000;
        System.out.println("Sales before: " + sales);
        boss.increaseRandomly(sales);
        System.out.println("Sales after: " + sales);

        System.out.println("Employee before: " + fred.getName());
        boss.replaceWithZombie(fred);
        System.out.println("Employee after: " + fred.getName());
    }
}
package ch13.sec08;

import java.nio.charset.Charset;
import java.util.Collection;
import java.util.Locale;

public class CharacterEncodings {
    public static void main(String[] args) {
        Charset platformEncoding = Charset.defaultCharset();
        System.out.println("Your platform encoding: " + platformEncoding);

        Collection<Charset> availableCharset = Charset.availableCharsets().values();
        Locale locale = Locale.getDefault();
        for (Charset charset: availableCharset) {
            String displayName = charset.displayName(locale);
            System.out.println(displayName);
        }
    }
}
package ch09.sec01;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

public class CharsetDemo {
    public static void main(String[] args) {
        System.out.println("Default charset on this computer: " + Charset.defaultCharset());
        System.out.println("Available charsets on this JVM: " + Charset.availableCharsets().keySet());

        String str = "Java\u2122";
        System.out.println(str);
        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);
        showBytes(bytes);
            // Note that the trademark character takes three bytes
        showBytes(str.getBytes(StandardCharsets.UTF_16));
            // Note the byte order mark
        showBytes(str.getBytes(StandardCharsets.ISO_8859_1));
            // The trademark character can't be encoded and becomes a ?

        System.out.println(new String(bytes, Charset.forName("windows-1252")));
            // How can you tell this was the wrong encoding? How could a program tell?
    }

    public static void showBytes(byte[] bytes) {
        for (byte b : bytes) System.out.printf("%2X ", b);
        System.out.println();
    }
}
package ch10.sec05 ;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CHMDemo {
    public static ConcurrentHashMap<String, Long> map = new ConcurrentHashMap<>();

    public static void process(Path path) {
        try {
            String contents = new String(Files.readAllBytes(path),
                StandardCharsets.UTF_8);
            for (String word : contents.split("\\PL+")) {
                map.merge(word, 1L, Long::sum);
                // or map.compute(word, (k, v) -> v == null ? 1 : v + 1);
                /* or
                map.putIfAbsent(word, 0L);
                Long oldValue, newValue;
                do {
                    oldValue = map.get(word);
                    newValue = oldValue + 1;
                } while (!map.replace(word, oldValue, newValue));
                */
                /* but not
                Long oldValue = map.get(word);
                Long newValue = oldValue == null ? 1 : oldValue + 1;
                map.put(word, newValue); // Error—might not replace oldValue
                */
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    public static Set<Path> descendants(Path p) throws IOException {
        try (Stream<Path> entries = Files.walk(p)) {
            return entries.filter(Files::isRegularFile).collect(Collectors.toSet());
        }
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException, IOException {
        int processors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(processors);
        Path pathToRoot = Paths.get(".");
        for (Path p : descendants(pathToRoot)) {
            executor.execute(() -> process(p));
        }
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.MINUTES);
        System.out.println(map);
    }
}
package ch04.sec04;

public interface Cipher {
    byte[] encrypt(byte[] source, byte[] key);
    byte[] decrypt(byte[] source, byte[] key);
    int strength();
}package ch04.sec04;

public class ClassDemo {
    public static void main(String[] args) throws ReflectiveOperationException {
        Object obj = System.out;
        Class<?> cl = obj.getClass();

        System.out.println("This object is an instance of " + cl.getName());

        String className = "java.util.Scanner";
        cl = Class.forName(className);
            // An object describing the java.util.Scanner class
        cl = java.util.Scanner.class;
        System.out.println(cl.getName());
        Class<?> cl2 = String[].class; // Describes the array type String[]
        System.out.println(cl2.getName());
        System.out.println(cl2.getCanonicalName());
        Class<?> cl3 = Runnable.class; // Describes the Runnable interface
        System.out.println(cl3.getName());
        Class<?> cl4 = int.class; // Describes the int type
        System.out.println(cl4.getName());
        Class<?> cl5 = void.class; // Describes the void type
        System.out.println(cl5.getName());
    }
}
package ch06.sec03;

import java.util.ArrayList;

public class Closeables {
    public static <T extends AutoCloseable> void closeAll(ArrayList<T> elems) throws Exception {
        for (T elem : elems) elem.close();
    }
}package ch06.sec03;

import java.io.PrintStream;
import java.util.ArrayList;

public class CloseablesDemo {
    public static void main(String[] args) throws Exception {
        PrintStream p1 = new PrintStream("/tmp/1");
        PrintStream p2 = new PrintStream("/tmp/2");
        ArrayList<PrintStream> ps = new ArrayList<>();
        ps.add(p1);
        ps.add(p2);
        Closeables.closeAll(ps);
    }
}package ch13.sec05;

import java.text.Collator;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.TreeSet;

public class CollatorDemo {
    public static void main(String[] args) {
        Locale locale = Locale.forLanguageTag("en");
        Collator coll = Collator.getInstance(locale);
        ArrayList<String> words = new ArrayList<>(
                List.of("Athens", "Ångström", "Zulu", "able", "zebra"));
        words.sort(coll);
        System.out.println(words);

        coll = Collator.getInstance(locale);
        coll.setStrength(Collator.PRIMARY);
        TreeSet<String> set = new TreeSet<>(coll);
        set.addAll(List.of("San José", "San Jose", "SAN JOSE", "San Jose\u0301"));
        System.out.println(set.size());

        coll = Collator.getInstance(locale);
        coll.setStrength(Collator.SECONDARY);
        set = new TreeSet<>(coll);
        set.addAll(List.of("San José", "San Jose", "SAN JOSE", "San Jose\u0301"));
        System.out.println(set.size());

        coll = Collator.getInstance(locale);
        coll.setStrength(Collator.TERTIARY);
        set = new TreeSet<>(coll);
        set.addAll(List.of("San José", "San Jose", "SAN JOSE", "San Jose\u0301"));
        System.out.println(set.size());

        coll = Collator.getInstance(locale);
        coll.setStrength(Collator.IDENTICAL);
        coll.setDecomposition(Collator.NO_DECOMPOSITION);
        set = new TreeSet<>(coll);
        set.addAll(List.of("San José", "San Jose", "SAN JOSE", "San Jose\u0301"));
        System.out.println(set.size());

        coll = Collator.getInstance(locale);
        set = new TreeSet<>(coll);
        set.addAll(List.of("JavaTM", "Java\u2122"));
        System.out.println(set.size());

        coll = Collator.getInstance(locale);
        coll.setDecomposition(Collator.FULL_DECOMPOSITION);
        set = new TreeSet<>(coll);
        set.addAll(List.of("JavaTM", "Java\u2122"));
        System.out.println(set.size());

        System.out.println(Arrays.toString(Normalizer.normalize("ée\u0301\u2122", Normalizer.Form.NFC).codePoints().mapToObj(n -> String.format("%04X", n)).toArray()));
        System.out.println(Arrays.toString(Normalizer.normalize("ée\u0301\u2122", Normalizer.Form.NFD).codePoints().mapToObj(n -> String.format("%04X", n)).toArray()));
        System.out.println(Arrays.toString(Normalizer.normalize("ée\u0301\u2122", Normalizer.Form.NFKC).codePoints().mapToObj(n -> String.format("%04X", n)).toArray()));
        System.out.println(Arrays.toString(Normalizer.normalize("ée\u0301\u2122", Normalizer.Form.NFKD).codePoints().mapToObj(n -> String.format("%04X", n)).toArray()));
    }
}
package ch08.sec09;

import java.io.IOException;
import java.util.Collections;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CollectingIntoMaps {

    public static class Person {
        private int id;
        private String name;

        public Person(int id, String name) { this.id = id; this.name = name; }
        public int getId() { return id; }
        public String getName() { return name; }
        public String toString() { return getClass().getName() +
              "[id=" + id + ",name=" + name + "]";
        }
    }

    public static Stream<Person> people() {
        return Stream.of(new Person(1001, "Peter"), new Person(1002, "Paul"), new Person(1003,
                "Mary"));
    }

    public static void main(String[] args) throws IOException {
        Map<Integer, String> idToName = people().collect(
                Collectors.toMap(Person::getId, Person::getName));
        System.out.println("idToName: " + idToName);

        Map<Integer, Person> idToPerson = people().collect(
                Collectors.toMap(Person::getId, Function.identity()));
        System.out.println("idToPerson: " + idToPerson.getClass().getName() + idToPerson);

        idToPerson = people().collect(
                Collectors.toMap(Person::getId, Function.identity(), (existingValue, newValue) -> {
                    throw new IllegalStateException();
                }, TreeMap::new));

        System.out.println("idToPerson: " + idToPerson.getClass().getName() + idToPerson);

        Stream<Locale> locales = Stream.of(Locale.getAvailableLocales());
        Map<String, String> languageNames = locales.collect(Collectors.toMap(
                Locale::getDisplayLanguage,
                loc -> loc.getDisplayLanguage(loc),
                (existingValue, newValue) -> existingValue));
        System.out.println("languageNames: " + languageNames);

        locales = Stream.of(Locale.getAvailableLocales());
        Map<String, Set<String>> countryLanguageSets = locales.collect(
                Collectors.toMap(
                        Locale::getDisplayCountry,
                        l -> Collections.singleton(l.getDisplayLanguage()),
                        (a, b) -> { // union of a and b
                            Set<String> union = new HashSet<>(a);
                            union.addAll(b);
                            return union;
                }));
        System.out.println("countryLanguageSets: " + countryLanguageSets);
    }
}
package ch08.sec08;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.IntSummaryStatistics;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CollectingResults {
    public static Stream<String> noVowels(String filename) throws IOException {
        String contents = new String(Files.readAllBytes(Paths.get(filename)),
                StandardCharsets.UTF_8);
        List<String> wordList = List.of(contents.split("\\PL+"));
        Stream<String> words = wordList.stream();
        return words.map(s -> s.replaceAll("[aeiouAEIOU]", ""));
    }

    public static <T> void show(String label, Set<T> set) {
        System.out.print(label + ": " + set.getClass().getName());
        System.out.println("["
                + set.stream().limit(10).map(Object::toString).collect(Collectors.joining(", "))
                + "]");
    }

    public static void main(String[] args) throws IOException {
        Iterator<Integer> iter = Stream.iterate(0, n -> n + 1).limit(10).iterator();
        while (iter.hasNext())
            System.out.println(iter.next());

        Object[] numbers = Stream.iterate(0, n -> n + 1).limit(10).toArray();
        System.out.println(numbers); // Note it's an Object[] array

        try {
            Integer number = (Integer) numbers[0]; // OK
            System.out.println("number: " + number);
            Integer[] numbers2 = (Integer[]) numbers; // Throws exception
        } catch (ClassCastException ex) {
            ex.printStackTrace();
        }

        Integer[] numbers3 = Stream.iterate(0, n -> n + 1).limit(10).toArray(Integer[]::new);
        System.out.println(numbers3); // Note it's an Integer[] array

        HashSet<String> noVowelHashSet = noVowels("alice.txt").collect(HashSet::new, HashSet::add,
                HashSet::addAll);
        show("noVowelHashSet", noVowelHashSet);

        Set<String> noVowelSet = noVowels("alice.txt").collect(Collectors.toSet());
        show("noVowelSet", noVowelSet);

        TreeSet<String> noVowelTreeSet = noVowels("alice.txt").collect(
                Collectors.toCollection(TreeSet::new));
        show("noVowelTreeSet", noVowelTreeSet);

        String result = noVowels("alice.txt").limit(10).collect(Collectors.joining());
        System.out.println(result);
        result = noVowels("alice.txt").limit(10).collect(Collectors.joining(", "));
        System.out.println(result);

        IntSummaryStatistics summary = noVowels("alice.txt").collect(
                Collectors.summarizingInt(String::length));
        double averageWordLength = summary.getAverage();
        double maxWordLength = summary.getMax();
        System.out.println("Average word length: " + averageWordLength);
        System.out.println("Max word length: " + maxWordLength);

        noVowels("alice.txt").limit(10).forEach(System.out::println);
    }
}
package ch03.sec08;

import java.util.Arrays;
import java.util.Comparator;
import static java.util.Comparator.*;


public class ComparatorDemo {
    public static void main(String[] args) {
        Person[] people = {
                new Person("George", "Washington"),
                new Person("John", "Adams"),
                new Person("Thomas", "Jefferson"),
                new Person("James", "Madison"),
                new Person("James", "Monroe"),
                new Person("John", "Quincy", "Adams"),
                new Person("Andrew", "Jackson"),
                new Person("Martin", "van Buren"),
                new Person("William", "Henry", "Harrison"),
                new Person("John", "Tyler"),
                new Person("James", "Knox", "Polk"),
                new Person("Zachary", "Taylor"),
                new Person("Millard", "Fillmore"),
                new Person("Franklin", "Pierce"),
                new Person("James", "Buchanan"),
                new Person("Abraham", "Lincoln"),
                new Person("Andrew", "Johnson"),
                new Person("Ulysses", "S.", "Grant"),
                new Person("Rutherford", "Birchard", "Hayes"),
                new Person("James", "Abram", "Garfield"),
                new Person("Grover", "Cleveland"),
                new Person("Benjamin", "Harrison"),
                new Person("Grover", "Cleveland"),
                new Person("William", "McKinley"),
                new Person("Theodore", "Roosevelt"),
                new Person("William", "Howard", "Taft"),
                new Person("Woodrow", "Wilson"),
                new Person("Warren", "Gamaliel", "Harding"),
                new Person("Calvin", "Coolidge"),
                new Person("Herbert", "Hoover"),
                new Person("Franklin", "Delano", "Roosevelt"),
                new Person("Harry", "S.", "Truman"),
                new Person("Dwight", "David", "Eisenhower"),
                new Person("John", "Fitzgerald", "Kennedy"),
                new Person("Lyndon", "Baines", "Johnson"),
                new Person("Richard", "Mulhouse", "Nixon"),
                new Person("Gerald", "Ford"),
                new Person("James", "Earl", "Carter"),
                new Person("Ronald", "Reagan"),
                new Person("George", "Herbert Walker", "Bush"),
                new Person("William", "Jefferson", "Clinton"),
                new Person("George", "Walker", "Bush"),
                new Person("Barack", "Hussein", "Obama")
        };

        Arrays.sort(people, Comparator.comparing(Person::getName));
        System.out.println(Arrays.toString(people));

        Arrays.sort(people,
                Comparator.comparing(Person::getLastName)
                .thenComparing(Person::getFirstName));
        System.out.println(Arrays.toString(people));

        Arrays.sort(people, Comparator.comparing(Person::getName,
                (s, t) -> s.length() - t.length()));

        Arrays.sort(people, Comparator.comparingInt(p -> p.getName().length()));
        System.out.println(Arrays.toString(people));

        Arrays.sort(people, comparing(Person::getMiddleName,
                nullsFirst(naturalOrder())));
        System.out.println(Arrays.toString(people));

        Arrays.sort(people, comparing(Person::getName,
                reverseOrder()));
        System.out.println(Arrays.toString(people));
    }
}
package ch14.sec02;

import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Paths;

import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

public class CompileDemo {
    public static void main(String[] args) throws IOException, ScriptException {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");

        //if (engine implements Compilable) {
            Reader reader = Files.newBufferedReader(Paths.get("/tmp/next.js"));
            CompiledScript script = ((Compilable) engine).compile(reader);
            script.eval();
        //}
    }
}
package ch14.sec01;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.tools.Diagnostic;
import javax.tools.DiagnosticCollector;
import javax.tools.FileObject;
import javax.tools.ForwardingJavaFileManager;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.JavaFileObject.Kind;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;

public class CompilerDemo {
    public static void main(String[] args) throws ReflectiveOperationException {
        String pointCode = makeClass("Point", "int", "x", "int", "y");
        String rectangleCode = makeClass("Rectangle", "Point", "topLeft", "int",
                "width", "int", "height");
        System.out.println(rectangleCode);

        List<StringSource> sources = List.of(
                new StringSource("Point", pointCode),
                new StringSource("Rectangle", rectangleCode));
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        DiagnosticCollector<JavaFileObject> collector = new DiagnosticCollector<>();

        List<ByteArrayClass> classes = new ArrayList<>();
        StandardJavaFileManager stdFileManager = compiler
                .getStandardFileManager(null, null, null);
        JavaFileManager fileManager = new ForwardingJavaFileManager<JavaFileManager>(
                stdFileManager) {
            @Override
            public JavaFileObject getJavaFileForOutput(Location location,
                    String className, Kind kind, FileObject sibling)
                    throws IOException {
                if (kind == Kind.CLASS) {
                    ByteArrayClass outfile = new ByteArrayClass(className);
                    classes.add(outfile);
                    return outfile;
                } else
                    return super.getJavaFileForOutput(location, className,
                            kind, sibling);
            }
        };
        JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager,
                collector, null, null, sources);
        Boolean result = task.call();
        for (Diagnostic<? extends JavaFileObject> d : collector.getDiagnostics()) {
            System.out.println(d);
        }
        System.out.println(result);
        ByteArrayClassLoader loader = new ByteArrayClassLoader(classes);
        Class<?> cl = Class.forName("Rectangle", true, loader);
        System.out.println(Arrays.toString(cl.getDeclaredFields()));
        System.out.println(Arrays.toString(cl.getDeclaredMethods()));
    }

    public static String makeClass(String name, String... typesAndFields) {
        StringBuilder result = new StringBuilder();
        result.append(String.format("public class %s {\n", name));
        for (int i = 0; i < typesAndFields.length; i += 2) {
            String type = typesAndFields[i];
            String field = typesAndFields[i + 1];
            String ufield = field.substring(0, 1).toUpperCase()
                    + field.substring(1);
            result.append(String.format("    private %s %s;\n", type, field));
            result.append(String.format(
                    "    public %s get%s() { return %s; }\n", type, ufield,
                    field));
            result.append(String.format(
                    "    public void set%2$s(%1$s %3$s) { this.%3$s = %3$s; }\n", type, ufield,
                    field));
        }
        result.append("}\n");
        return result.toString();
    }
}
package ch07.sec02;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class ConcurrentModificationDemo {
    public static void main(String[] args) {
        Collection<String> coll = new ArrayList<>();
        coll.add("Peter");
        coll.add("Paul");
        coll.add("Mary");
        System.out.println(coll);
        Iterator<String> iter1 = coll.iterator();
        Iterator<String> iter2 = coll.iterator();
        iter2.next();
        iter2.remove();
        System.out.println(coll);
        iter1.next();
        System.out.println(coll);
    }
}
package ch04.sec01;

public class ConcurrentWorker extends Worker {
    public void work() {
        Thread t = new Thread(super::work);
        t.start();
    }
}package ch04.sec01;

public class ConcurrentWorkerTest {
    public static void main(String[] args) {
        ConcurrentWorker worker = new ConcurrentWorker();
        worker.work();
        System.out.println("Done");
    }
}
package ch03.sec05;

import java.util.ArrayList;

public class ConstructorReferenceDemo {
    public static void main(String[] args) {
        ArrayList<String> names = new ArrayList<>();
        names.add("Peter");
        names.add("Paul");
        names.add("Mary");
        Employee[] employees = names.stream().map(Employee::new).toArray(Employee[]::new);
        for (Employee e : employees) System.out.println(e.getName());
    }
}
package ch10.sec07;

public class Counter {
    private int value;
    public synchronized int increment() {
        value++;
        return value;
    }
}package ch10.sec07;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class CounterDemo {
    public static Counter count = new Counter();

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 1; i <= 100; i++) {
            Runnable task = () -> {
                for (int k = 1; k <= 1000; k++)
                    count.increment();
            };
            executor.execute(task);
        }
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.MINUTES);
        System.out.println("Final value: " + (count.increment() - 1));
    }
}package ch08.sec01;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

public class CountLongWords {
    public static void main(String[] args) throws IOException {
        String contents = new String(Files.readAllBytes(Paths.get("alice.txt")),
                StandardCharsets.UTF_8);
        List<String> words = List.of(contents.split("\\PL+"));

        long count = 0;
        for (String w : words) {
            if (w.length() > 12)
                count++;
        }
        System.out.println(count);

        count = words.stream().filter(w -> w.length() > 12).count();
        System.out.println(count);

        count = words.parallelStream().filter(w -> w.length() > 12).count();
        System.out.println(count);
    }
}
package com.horstmann.places;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement
public class Country {
   @XmlElement private String name;
   @XmlElement private double area;

   public Country() {}

   public Country(String name, double area) {
      this.name = name;
      this.area = area;
   }

   public String getName() {
      return name;
   }

   public double getArea() {
      return area;
   }
}
package com.horstmann.places;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement
public class Country {
   @XmlElement private String name;
   @XmlElement private double area;

   public Country() {}

   public Country(String name, double area) {
      this.name = name;
      this.area = area;
   }

   public String getName() {
      return name;
   }

   public double getArea() {
      return area;
   }
}
package ch08.sec02;

import java.io.IOException;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CreatingStreams {
    public static <T> void show(String title, Stream<T> stream) {
        final int SIZE = 10;
        List<T> firstElements = stream.limit(SIZE + 1).collect(Collectors.toList());
        System.out.print(title + ": ");
        if (firstElements.size() <= SIZE)
            System.out.println(firstElements);
        else {
            firstElements.remove(SIZE);
            String out = firstElements.toString();
            System.out.println(out.substring(0, out.length() - 1) + ", ...]");
        }
    }

    public static void main(String[] args) throws IOException {
        Path path = Paths.get("../alice.txt");
        String contents = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);

        Stream<String> words = Stream.of(contents.split("\\PL+"));
        show("words", words);
        Stream<String> song = Stream.of("gently", "down", "the", "stream");
        show("song", song);
        Stream<String> silence = Stream.empty();
        show("silence", silence);

        Stream<String> echos = Stream.generate(() -> "Echo");
        show("echos", echos);

        Stream<Double> randoms = Stream.generate(Math::random);
        show("randoms", randoms);

        Stream<BigInteger> integers = Stream.iterate(BigInteger.ONE, n -> n.add(BigInteger.ONE));
        show("integers", integers);

        BigInteger limit = new BigInteger("7");
        integers = Stream.iterate(BigInteger.ZERO,
            n -> n.compareTo(limit) < 0,
            n -> n.add(BigInteger.ONE));
        show("integers", integers);

        Stream<String> wordsAnotherWay = Pattern.compile("\\PL+").splitAsStream(contents);
        show("wordsAnotherWay", wordsAnotherWay);

        try (Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8)) {
            show("lines", lines);
        }
    }
}
package ch02.sec04;

import java.time.LocalDate;
import java.util.ArrayList;

public class CreditCardForm {
    private static final ArrayList<Integer> expirationYear = new ArrayList<>();
    static {
        // Add the next twenty years to the array list
        int year = LocalDate.now().getYear();
        for (int i = year; i <= year + 20; i++) {
            expirationYear.add(i);
        }
    }
    // ...
}
package com.horstmann.places;

import java.io.*;
import org.apache.commons.csv.*;

public class CSVDemo {
   public static void main(String[] args) throws IOException {
      Reader in = new FileReader("countries.csv");
      Iterable<CSVRecord> records = CSVFormat.EXCEL.withDelimiter(';').withHeader().parse(in);
      for (CSVRecord record : records) {
         String name = record.get("Name");
         double area = Double.parseDouble(record.get("Area"));
         System.out.println(name + " has area " + area);
      }
   }
}
package com.horstmann.places;

import java.io.*;
import org.apache.commons.csv.*;

public class CSVDemo {
   public static void main(String[] args) throws IOException {
      Reader in = new FileReader("countries.csv");
      Iterable<CSVRecord> records = CSVFormat.EXCEL.withDelimiter(';').withHeader().parse(in);
      for (CSVRecord record : records) {
         String name = record.get("Name");
         double area = Double.parseDouble(record.get("Area"));
         System.out.println(name + " has area " + area);
      }
   }
}
package ch13.sec03;

import java.text.NumberFormat;
import java.util.Currency;
import java.util.Locale;
import java.util.Set;

public class Currencies {
    public static void main(String[] args) {
        NumberFormat dollarFormatter = NumberFormat.getCurrencyInstance(Locale.US);
        NumberFormat euroFormatter = NumberFormat.getCurrencyInstance(Locale.GERMANY);
        double exchangeRate = 0.8;
        double dollars = 10000;
        double euros = dollars * exchangeRate;
        System.out.println("You paid " + dollarFormatter.format(dollars));
        System.out.println("You received " + euroFormatter.format(euros));

        NumberFormat formatter = NumberFormat.getCurrencyInstance(Locale.US);
        System.out.println("You paid " + formatter.format(dollars));
        formatter.setCurrency(Currency.getInstance("EUR"));
        System.out.println("You received " + formatter.format(euros));

        Set<Currency> currencies = Currency.getAvailableCurrencies();
        Locale loc = Locale.GERMAN;
        for (Currency currency : currencies) {
            System.out.printf("%s = %s (%s)\n",
                    currency.getSymbol(),
                    currency.getDisplayName(),
                    currency.getDisplayName(loc));
        }
    }
}
package ch12.sec03;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.temporal.TemporalAdjuster;
import java.time.temporal.TemporalAdjusters;

public class DateAdjusters {
    public static void main(String[] args) {
        int year = 2014;
        int month = 6;
        LocalDate firstTuesday = LocalDate.of(year, month, 1).with(
                TemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY));
        System.out.println("firstTuesday: " + firstTuesday);

        LocalDate today = LocalDate.of(2013, 11, 9); // Saturday
        TemporalAdjuster NEXT_WORKDAY = w -> {
            LocalDate result = (LocalDate) w;
            do {
                result = result.plusDays(1);
            } while (result.getDayOfWeek().getValue() >= 6);
            return result;
        };

        LocalDate backToWork = today.with(NEXT_WORKDAY);
        System.out.println("backToWork: " + backToWork);

        TemporalAdjuster NEXT_WORKDAY2 = TemporalAdjusters.ofDateAdjuster(w -> {
            LocalDate result = w; // No cast
                do {
                    result = result.plusDays(1);
                } while (result.getDayOfWeek().getValue() >= 6);
                return result;
            });
        backToWork = today.with(NEXT_WORKDAY2);
        System.out.println("backToWork: " + backToWork);
    }
}
package ch13.sec04;

import java.time.LocalTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.time.format.TextStyle;
import java.util.Locale;

public class DateAndTimeFormatting {
    public static void main(String[] args) {
        ZonedDateTime appointment = ZonedDateTime.of(2015, 7, 16, 9, 30, 0, 0,
            ZoneId.of("America/New_York"));

        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(
                FormatStyle.LONG, FormatStyle.SHORT);
        String formatted = formatter.format(appointment);
        System.out.println(formatted);
        formatted = formatter.withLocale(Locale.FRENCH).format(appointment);
        System.out.println(formatted);
        LocalTime time = LocalTime.parse("9:32 AM",
                DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).withLocale(Locale.ENGLISH));
        System.out.println("Parsed time: " + time);

        Locale locale = Locale.forLanguageTag("fi");
        for (Month m : Month.values())
            System.out.printf("%-15s%-15s\n",
                    m.getDisplayName(TextStyle.FULL, locale),
                    m.getDisplayName(TextStyle.FULL_STANDALONE, locale));
    }
}
package ch05.sec01;

public class DefaultUncaughtExceptionHandlerDemo {
    public static void main(String[] args) {
        Thread.setDefaultUncaughtExceptionHandler((thread, ex) -> {
            System.err.println(ex.getMessage());
            System.err.println("Goodbye, cruel world!");
        });
        System.out.println(1 / 0);
    }
}
package com.horstmann.places;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

public class Demo {
   public static void main(String[] args) throws JAXBException {
      Country belgium = new Country("Belgium", 30510);
      JAXBContext context = JAXBContext.newInstance(Country.class);
      Marshaller m = context.createMarshaller();
      m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
      m.marshal(belgium, System.out);
   }
}
package com.horstmann.places;

import java.io.IOException;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

public class Demo {
   public static void main(String[] args) throws JAXBException {
      Country belgium = new Country("Belgium", 30510);
      JAXBContext context = JAXBContext.newInstance(Country.class);
      Marshaller m = context.createMarshaller();
      m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true;
      m.marshal(belgium, System.out);
   }
}
package ch03.sec01;

public class DigitSequence implements IntSequence {
    private int number;

    public DigitSequence(int n) {
        number = n;
    }

    public boolean hasNext() {
        return number != 0;
    }

    public int next() {
        int result = number % 10;
        number /= 10;
        return result;
    }

    public int rest() {
        return number;
    }
}package ch09.sec02;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.util.stream.Stream;

public class DirectoryDemo {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get(System.getProperty("java.home"));
        System.out.printf("Directories inside %s:\n", path);
        try (Stream<Path> entries = Files.list(path)) {
            entries.forEach(System.out::println);
        }

        System.out.printf("\nDirectories and subdirectories inside %s:\n", path);
        try (Stream<Path> entries = Files.walk(path)) {
            System.out.printf("%d files\n", entries.count());
        }

        // Copy directory tree

        Path source = path;
        Path target = Files.createTempDirectory("corejava").resolve("jre");
        Files.walk(source).forEach(p -> {
            try {
                Path q = target.resolve(source.relativize(p));
                if (Files.isDirectory(p)) {
                    System.out.printf("Creating %s\n", q);
                    Files.createDirectory(q);
                }
                else {
                    System.out.printf("Copying %s to %s\n", p, q);
                    Files.copy(p, q);
                }
            } catch (IOException ex) {
                throw new UncheckedIOException(ex);
            }
        });

        // Delete the copy

        Path root = target;
        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {
            public FileVisitResult visitFile(Path file,
                    BasicFileAttributes attrs) throws IOException {
                Files.delete(file);
                System.out.printf("Deleting %s\n", file);
                return FileVisitResult.CONTINUE;
            }
            public FileVisitResult postVisitDirectory(Path dir,
                    IOException ex) throws IOException {
                if (ex != null) throw ex;
                Files.delete(dir);
                System.out.printf("Removing %s\n", dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }
}package ch04.sec02;

import java.util.Objects;

public class DiscountedItem extends Item {
    private double discount;

    public DiscountedItem(String description, double price, double discount) {
        super(description, price);
        this.discount = discount;
    }

    public boolean equals(Object otherObject) {
        if (!super.equals(otherObject)) return false;
        DiscountedItem other = (DiscountedItem) otherObject;
        return discount == other.discount;
    }

    public int hashCode() {
        return Objects.hash(super.hashCode(), discount);
    }
}package ch01.sec07;

import java.util.*;

public class DoDemo {
   public static void main(String[] args) {
      Random generator = new Random();
      int target = 5;
      int count = 1;
      int next;
      do {
         next = generator.nextInt(10);
         count++;
      } while (next != target);

      System.out.println("After " + count + " iterations, there was a values of " + target);
   }
}
package ch08.sec11;

import static java.util.stream.Collectors.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Stream;

public class DownstreamCollectors {

    public static class City {
        private String name;
        private String state;
        private int population;

        public City(String name, String state, int population) {
           this.name = name;
           this.state = state;
           this.population = population;
        }

        public String getName() { return name; }
        public String getState() { return state; }
        public int getPopulation() { return population; }

        public String toString() { return name; }
    }

    public static Stream<City> readCities(String filename) throws IOException {
        return Files.lines(Paths.get(filename)).map(l -> l.split(", ")).map(a -> new City(a[0], a[1], Integer.parseInt(a[2])));
    }

    public static Stream<String> codePoints(String s) {
        List<String> result = new ArrayList<>();
        int i = 0;
        while (i < s.length()) {
            int j = s.offsetByCodePoints(i, 1);
            result.add(s.substring(i, j));
            i = j;
        }
        return result.stream();
    }

    public static void main(String[] args) throws IOException {
        Stream<Locale> locales = Stream.of(Locale.getAvailableLocales());
        locales = Stream.of(Locale.getAvailableLocales());
        Map<String, Set<Locale>> countryToLocaleSet = locales.collect(
           groupingBy(Locale::getCountry, toSet()));
        System.out.println("countryToLocaleSet: " + countryToLocaleSet);

        locales = Stream.of(Locale.getAvailableLocales());
        Map<String, Long> countryToLocaleCounts = locales.collect(
           groupingBy(Locale::getCountry, counting()));
        System.out.println("countryToLocaleCounts: " + countryToLocaleCounts);

        Stream<City> cities = readCities("cities.txt");
        Map<String, Integer> stateToCityPopulation = cities.collect(
           groupingBy(City::getState, summingInt(City::getPopulation)));
        System.out.println("stateToCityPopulation: " + stateToCityPopulation);

        cities = readCities("cities.txt");
        Map<String, Optional<City>> stateToLargestCity = cities.collect(
            groupingBy(City::getState,
            maxBy(Comparator.comparing(City::getPopulation))));
        System.out.println("stateToLargestCity: " + stateToLargestCity);

        cities = readCities("cities.txt");
        Map<String, Optional<String>> stateToLongestCityName = cities.collect(
           groupingBy(City::getState,
              mapping(City::getName,
                 maxBy(Comparator.comparing(String::length)))));

        System.out.println("stateToLongestCityName: " + stateToLongestCityName);

        locales = Stream.of(Locale.getAvailableLocales());
        Map<String, Set<String>> countryToLanguages = locales.collect(
           groupingBy(Locale::getDisplayCountry,
              mapping(Locale::getDisplayLanguage,
                 toSet())));
        System.out.println("countryToLanguages: " + countryToLanguages);

        cities = readCities("cities.txt");
        Map<String, Set<String>> codePointsByState
            = cities.collect(
                groupingBy(City::getState,
                    flatMapping(c -> codePoints(c.getName().toLowerCase()),
                        toSet())));
        System.out.println("codePointsByState: " + codePointsByState);

        cities = readCities("cities.txt");
        Map<String, Set<City>> largeCitiesByState
            = cities.collect(
                groupingBy(City::getState,
                    filtering(c -> c.getPopulation() > 500000,
                        toSet())));

        System.out.println("largeCitiesByState: " + largeCitiesByState);

        cities = readCities("cities.txt");
        Map<String, IntSummaryStatistics> stateToCityPopulationSummary = cities.collect(
           groupingBy(City::getState,
              summarizingInt(City::getPopulation)));
        System.out.println(stateToCityPopulationSummary.get("NY"));

        cities = readCities("cities.txt");
        Map<String, String> stateToCityNames = cities.collect(
           groupingBy(City::getState,
              reducing("", City::getName,
                 (s, t) -> s.length() == 0 ? t : s + ", " + t)));

        cities = readCities("cities.txt");
        stateToCityNames = cities.collect(
           groupingBy(City::getState,
              mapping(City::getName,
                 joining(", "))));
        System.out.println("stateToCityNames: " + stateToCityNames);
    }
}
package ch09.sec05;

import java.io.Serializable;

public class Employee implements Serializable {
    private String name;
    private double salary;
    private Manager boss;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public void setBoss(Manager boss) {
        this.boss = boss;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public String toString() {
        return String.format("%s[name=%s,salary=%.2f,boss=%s]",
                getClass().getName(), name, salary, boss);
    }
}
package com.horstmann.corejava;

public class Employee {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }
}
package com.horstmann.employees;

public class Employee {
    private String name;
    protected double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }
}
package ch02.sec03;

import java.util.Random;

public class Employee {
    private String name = "";
    private double salary;
    private final int id;

    { // An initialization block
        Random generator = new Random();
        id = 1 + generator.nextInt(1_000_000);
    }

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public Employee(double salary) {
        // name already set to ""
        this.salary = salary;
    }

    public Employee(String name) {
        // salary automatically set to zero
        this.name = name;
    }

    public Employee() {
        this("", 0);
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public int getId() {
        return id;
    }
}
package ch02.sec04;

public class Employee {
    private static int lastId = 0;
    private int id;
    private String name;
    private double salary;

    public Employee() {
        lastId++;
        id = lastId;
    }

    public Employee(String name, double salary) {
        this();
        this.name = name;
        this.salary = salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public int getId() {
        return id;
    }
}
package ch03.sec02;

public class Employee implements Person, Identified {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public int getId() { return Identified.super.getId(); }
}package ch03.sec03;

public class Employee implements Comparable<Employee> {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public Employee(double salary) {
        this.name = "";
        this.salary = salary;
    }

    public Employee(String name) {
        // salary automatically set to zero
        this.name = name;
    }

    public Employee() {
        this("", 0);
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public int compareTo(Employee other) {
        return Double.compare(salary, other.salary);
    }
}
package ch03.sec05;

public class Employee {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public Employee(String name) {
        this(name, 0);
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }
}
package ch04.sec01;

public class Employee {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public final String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }
}
package ch04.sec02;

public class Employee {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public final String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public String toString() {
        return getClass().getName() + "[name=" + name
            + ",salary=" + salary + "]";
    }

    public Employee clone() throws CloneNotSupportedException {
        return (Employee) super.clone();
    }
}
package ch06.sec04;

public class Employee {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public final String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }
}
package ch02.sec02;

public class Employee {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }
}
package ch02.sec03;

public class EmployeeDemo {
    public static void main(String[] args) {
        Employee james = new Employee("James Bond", 500000);
            // calls Employee(String, double) constructor
        Employee anonymous = new Employee("", 40000);
            // calls Employee(double) constructor
        Employee unpaid = new Employee("Igor Intern");
        Employee e = new Employee();
            // no-arg constructor
    }
}
package com.horstmann.corejava;

public class EmployeeDemo {
    public static void main(String[] args) {
        Employee fred = new Employee("Fred", 50000);
        fred.raiseSalary(10);
        System.out.println(fred.getName());
        System.out.println(fred.getSalary());
    }
}
package ch02.sec02;

public class EmployeeDemo {
    public static void main(String[] args) {
        Employee fred = new Employee("Fred", 50000);
        fred.raiseSalary(10);
        System.out.println(fred.getName());
        System.out.println(fred.getSalary());
    }
}
package ch06.sec04;

import java.util.ArrayList;
import java.util.function.Predicate;

public class Employees {
    public static void printNames(ArrayList<? extends Employee> staff) {
        for (int i = 0; i < staff.size(); i++) {
            Employee e = staff.get(i);
            System.out.println(e.getName());
        }
    }

    public static void printAll1(Employee[] staff, Predicate<Employee> filter) {
        for (Employee e : staff)
            if (filter.test(e))
                System.out.println(e.getName());
    }

    public static void printAll2(Employee[] staff, Predicate<? super Employee> filter) {
        for (Employee e : staff)
            if (filter.test(e))
                System.out.println(e.getName());
    }

    public static void main(String[] args) {
        Employee[] employees = {
          new Employee("Fred", 50000),
          new Employee("Wilma", 60000),
        };
        printAll1(employees, e -> e.getSalary() > 100000);
        printAll2(employees, e -> e.getSalary() > 100000);
        Predicate<Object> evenLength = e -> e.toString().length() % 2 == 0;
        // printAll1(employees, evenLength);
        printAll2(employees, evenLength);
    }
}
package ch06.sec01;

public class Entry<K, V> {
    private K key;
    private V value;

    public Entry(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() { return key; }
    public V getValue() { return value; }
}
package ch04.sec03;

public class EnumDemo {
    public static void main(String[] args) {
        Size notMySize = Size.valueOf("SMALL");
        System.out.println(notMySize);

        for (Size s : Size.values()) { System.out.println(s); }

        System.out.println(Size.MEDIUM.ordinal());
    }
}
package ch07.sec05;

import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Set;

public class EnumSetDemo {
    enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY };
    public static void main(String[] args) {
        Set<Weekday> always = EnumSet.allOf(Weekday.class);
        Set<Weekday> never = EnumSet.noneOf(Weekday.class);
        Set<Weekday> workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);
        Set<Weekday> mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);
        System.out.println(always);
        System.out.println(never);
        System.out.println(workday);
        System.out.println(mwf);

        EnumMap<Weekday, String> personInCharge = new EnumMap<>(Weekday.class);
        personInCharge.put(Weekday.MONDAY, "Fred");
        System.out.println(personInCharge);
    }
}
package ch02.sec02;

import java.util.Random;

public class EvilManager {
    private Random generator;

    public EvilManager() {
        generator = new Random();
    }

    public void giveRandomRaise(Employee e) {
        double percentage = 10 * generator.nextDouble();
        e.raiseSalary(percentage);
    }

    public void increaseRandomly(double x) { // Won't work
        double amount = x * 10 * generator.nextDouble();
        x += amount;
    }

    public void replaceWithZombie(Employee e) {
        e = new Employee("", 0);
    }
}package ch06.sec06;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.Callable;

public class Exceptions {
    @SuppressWarnings("unchecked")
    private static <T extends Throwable> void throwAs(Throwable e) throws T {
        throw (T) e; //
    }

    public static <V> V doWork(Callable<V> c) {
        try {
            return c.call();
        } catch (Throwable ex) {
            Exceptions.<RuntimeException>throwAs(ex);
            return null;
        }
    }

    public static String readAll(Path path) {
        return doWork(() -> new String(Files.readAllBytes(path)));
    }

    public static void main(String[] args) {
        String result = readAll(Paths.get("/tmp/quuqux"));
        System.out.println(result);
    }
}package ch08.sec04;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ExtractingCombining {
    public static <T> void show(String title, Stream<T> stream) {
        final int SIZE = 10;
        List<T> firstElements = stream.limit(SIZE + 1).collect(Collectors.toList());
        System.out.print(title + ": ");
        if (firstElements.size() <= SIZE)
            System.out.println(firstElements);
        else {
            firstElements.remove(SIZE);
            String out = firstElements.toString();
            System.out.println(out.substring(0, out.length() - 1) + ", ...]");
        }
    }

    public static Stream<String> codePoints(String s) {
        List<String> result = new ArrayList<>();
        int i = 0;
        while (i < s.length()) {
            int j = s.offsetByCodePoints(i, 1);
            result.add(s.substring(i, j));
            i = j;
        }
        return result.stream();
    }

    public static void main(String[] args) throws IOException {
        Stream<Double> randoms = Stream.generate(Math::random).limit(5);
        show("randoms", randoms);

        String contents = "   Hello, World!   ";
        Stream<String> words = Stream.of(contents.split("\\PL+")).skip(1);
        show("words", words);

        String str = "123 Main Street";
        Stream<String> initialDigits = codePoints(str).takeWhile(
                s -> "0123456789".contains(s));
        show("initialDigits", initialDigits);
        str = "   Hello   ";
        Stream<String> withoutInitialWhiteSpace = codePoints(str).dropWhile(
                s -> s.trim().length() == 0);
        show("withoutInitialWhiteSpace", withoutInitialWhiteSpace);

        Stream<String> combined = Stream.concat(codePoints("Hello"),
                codePoints("Cat\uD83D\uDE3B"));
        show("combined", combined);
    }
}package ch09.sec02;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

public class FileDemo {
    public static void main(String[] args) throws IOException {
        Path tempPath = Files.createTempDirectory("corejava");

        Path workDir = Files.createDirectory(tempPath.resolve("work"));
        System.out.println(workDir);
        Path tempFile = Files.createTempFile(workDir, "test", ".txt");
        System.out.println(tempFile);
        Files.write(tempFile, "Hello".getBytes(StandardCharsets.UTF_8));
        Files.copy(tempFile, workDir.resolve("hello.txt"));

        Path target2 = workDir.resolve("hello2.txt");
        Files.move(tempFile, target2, StandardCopyOption.ATOMIC_MOVE);
        boolean deleted = Files.deleteIfExists(target2);
        if (deleted) System.out.println("Deleted " + target2);
    }
}
package ch05.sec01;

import java.io.IOException;

public class FileFormatException extends IOException {
    public FileFormatException() {}
    public FileFormatException(String message) {
        super(message);
    }
}package ch08.sec03;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FilterMapDemo {
    public static <T> void show(String title, Stream<T> stream) {
        final int SIZE = 10;
        List<T> firstElements = stream.limit(SIZE + 1).collect(Collectors.toList());
        System.out.print(title + ": ");
        if (firstElements.size() <= SIZE)
            System.out.println(firstElements);
        else {
            firstElements.remove(SIZE);
            String out = firstElements.toString();
            System.out.println(out.substring(0, out.length() - 1) + ", ...]");
        }
    }

    public static Stream<String> codePoints(String s) {
        List<String> result = new ArrayList<>();
        int i = 0;
        while (i < s.length()) {
            int j = s.offsetByCodePoints(i, 1);
            result.add(s.substring(i, j));
            i = j;
        }
        return result.stream();
    }

    public static void main(String[] args) throws IOException {
        String contents = new String(Files.readAllBytes(Paths.get("alice.txt")),
                StandardCharsets.UTF_8);
        List<String> words = List.of(contents.split("\\PL+"));
        Stream<String> longWords = words.stream().filter(w -> w.length() > 12);
        show("longWords", longWords);

        Stream<String> lowercaseWords = words.stream().map(String::toLowerCase);
        show("lowercaseWords", lowercaseWords);

        String[] song = { "row", "row", "row", "your", "boat", "gently", "down",
                "the", "stream" };
        Stream<String> firstChars = Stream.of(song).filter(w -> w.length() > 0).map(s -> s.substring(0, 1));
        show("firstChars", firstChars);

        Stream<String> letters = Stream.of(song).flatMap(w -> codePoints(w));
        show("letters", letters);
    }
}
package ch05.sec01;

import java.util.concurrent.RejectedExecutionException;

public class FinallyNotCompletingNormallyDemo {
    public static int parseInt(String number) {
        try {
            int n = Integer.parseInt(number);
            return n;
        } catch (NumberFormatException ex) {
            return 0;
        } finally {
            return -1; // This value is actually returned
        }
    }

    public static double parseDouble(String number) {
        try {
            double x = Double.parseDouble(number);
        } finally {
            throw new IllegalStateException(); // Masks NumberFormatException
        }
    }


    public static void main(String[] args) {
        System.out.println(parseInt("Fred"));
        System.out.println(parseInt("123"));
        try {
            System.out.println(parseDouble("Fred"));
        } catch(Exception ex) {
            System.out.println("Caught " + ex.getClass().getName());
        }
        try {
            System.out.println(parseDouble("12.3"));
        } catch(Exception ex) {
            System.out.println("Caught " + ex.getClass().getName());
        }
    }
}
package ch09.sec04;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FindingOneOrAllMatches {
    public static void main(String[] args) {
        String regex = "[+-]?\\d+";
        CharSequence input = "-123";
        if (Pattern.matches(regex, input))
            System.out.println(input + " is an integer");


        Pattern pattern = Pattern.compile(regex);
        input = "Fred";
        Matcher matcher = pattern.matcher(input);
        if (!matcher.matches())
            System.out.println(input + " is not an integer");

        Stream<String> strings = Stream.of("99 bottles of beer on the wall, 99 bottles of beer.".split(" "));
        Stream<String> result = strings.filter(pattern.asPredicate());
        System.out.println(result.collect(Collectors.toList()));

        input = "June 14, 1903";
        matcher = pattern.matcher(input);
        while (matcher.find()) {
            String match = matcher.group();
            System.out.println(match);
        }
    }
}
package ch10.sec07;

public class Flag {
    private boolean done;
    public synchronized void set() { done = true; }
    public synchronized boolean get() { return done; }
}package ch10.sec07;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class FlagDemo {
    private static Flag done = new Flag();

    public static void main(String[] args) {
        Runnable hellos = () -> {
            for (int i = 1; i <= 1000; i++)
                System.out.println("Hello " + i);
            done.set();
        };
        Runnable goodbye = () -> {
            int i = 1;
            while (!done.get()) i++;
            System.out.println("Goodbye " + i);
        };
        Executor executor = Executors.newCachedThreadPool();
        executor.execute(hellos);
        executor.execute(goodbye);
    }
}package ch09.sec04;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Flags {
    public static void main(String[] args) {
        showMatches("[AO\u00C9]", Pattern.CASE_INSENSITIVE, "San José");
        showMatches("[AO\u00C9]", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS, "San José");
        showMatches("^[a-z ]+$", Pattern.MULTILINE, "99 bottles\nof beer\non the\rwall\n");
        showMatches("^[a-z ]+$", Pattern.MULTILINE | Pattern.UNIX_LINES, "99 bottles\nof beer\non the\rwall\n");
        showMatches(".", 0, "99 bottles\nof beer");
        showMatches(".", Pattern.DOTALL, "99 bottles\nof beer");
        showMatches(".# What a pattern!", Pattern.COMMENTS, "Hello");
        showMatches(".", Pattern.LITERAL, "Hello. World.");
        showMatches("\u00E9", 0, "San Jose\u0301");
        showMatches("\u00E9", Pattern.CANON_EQ, "San Jose\u0301");
    }

    public static void showMatches(String regex, int flags, String input) {
        Pattern pattern = Pattern.compile(regex, flags);
        Matcher matcher = pattern.matcher(input);
        System.out.printf("%-30s%-30s", regex, input);
        while (matcher.find()) {
            String match = matcher.group();
            System.out.print(match + " ");
        }
        System.out.println();
    }
}
package ch01.sec07;

import java.util.*;

public class ForDemo {
   public static void main(String[] args) {
      Random generator = new Random();
      int count = 20;
      int sum = 0;
      for (int i = 1; i <= count; i++) {
         int next = generator.nextInt(10);
         sum = sum + next;
      }
      System.out.println("After " + count
         + " iterations, the sum is " + sum);
   }
}
package ch12.sec06;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.time.format.TextStyle;
import java.util.Locale;

public class Formatting {
    public static void main(String[] args) {
        ZonedDateTime apollo11launch = ZonedDateTime.of(1969, 7, 16, 9, 32, 0, 0,
            ZoneId.of("America/New_York"));

        String formatted = DateTimeFormatter.ISO_DATE_TIME.format(apollo11launch);
        // 1969-07-16T09:32:00-05:00[America/New_York]
        System.out.println(formatted);

        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);
        formatted = formatter.format(apollo11launch);
        // July 16, 1969 9:32:00 AM EDT
        System.out.println(formatted);
        formatted = formatter.withLocale(Locale.FRENCH).format(apollo11launch);
        // 16 juillet 1969 09:32:00 EDT
        System.out.println(formatted);

        formatter = DateTimeFormatter.ofPattern("E yyyy-MM-dd HH:mm");
        formatted = formatter.format(apollo11launch);
        System.out.println(formatted);

        LocalDate churchsBirthday = LocalDate.parse("1903-06-14");
        System.out.println("churchsBirthday: " + churchsBirthday);
        apollo11launch =
            ZonedDateTime.parse("1969-07-16 03:32:00-0400",
                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ssxx"));
        System.out.println("apollo11launch: " + apollo11launch);

        for (DayOfWeek w : DayOfWeek.values())
            System.out.print(w.getDisplayName(TextStyle.SHORT, Locale.ENGLISH) + " ");
    }
}
package com.horstmann.greetsvc.internal;

import com.horstmann.greetsvc.GreeterService;
import java.util.Locale;

public class FrenchGreeter implements GreeterService {
    public String greet(String subject) { return "Bonjour " + subject; }
    public Locale getLocale() { return Locale.FRENCH; }
}
package ch06.sec07;

import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class GenericReflectionDemo {
    public static void main(String[] args) throws ReflectiveOperationException {
        TypeVariable<Class<ArrayList>>[] vars = ArrayList.class.getTypeParameters();
        String name = vars[0].getName(); // "E"
        System.out.println(name);

        Method m = Collections.class.getMethod("sort", List.class);
        TypeVariable<Method>[] vars2 = m.getTypeParameters();
        name = vars2[0].getName(); // "T"
        System.out.println(name);

        Type[] bounds = vars2[0].getBounds();
        if (bounds[0] instanceof ParameterizedType) { // Comparable<? super T>
            ParameterizedType p = (ParameterizedType) bounds[0];
            Type[] typeArguments = p.getActualTypeArguments();
            if (typeArguments[0] instanceof WildcardType) { // ? super T
                WildcardType t = (WildcardType) typeArguments[0];
                Type[] upper = t.getUpperBounds(); // ? extends ... & ...
                Type[] lower = t.getLowerBounds(); // ? super ... & ...
                if (lower.length > 0) {
                    String description = lower[0].getTypeName(); // "T"
                    System.out.println(description);
                }
            }
        }
    }
}
package com.horstmann.greetsvc.internal;

import com.horstmann.greetsvc.GreeterService;
import java.util.Locale;
import java.util.Map;

public class GermanGreeter implements GreeterService {
   private Map<String, String> dictionary;
   public GermanGreeter(Map<String, String> dictionary) {
      this.dictionary = dictionary;
   }
    public String greet(String subject) {
       return "Hallo, " + dictionary.getOrDefault(subject, subject) + "!";
    }
    public Locale getLocale() { return Locale.GERMAN; }
}
package com.horstmann.greetsvc.internal;

import com.horstmann.greetsvc.GreeterService;
import java.util.Map;
import java.util.HashMap;

public class GermanGreeterFactory {
   public static GreeterService provider() {
      Map<String, String> dictionary = new HashMap<>();
      dictionary.put("World", "Welt");
      dictionary.put("Modular World", "modulare Welt");
      return new GermanGreeter(dictionary);
   }
}
package com.horstmann.greet;

public interface Greeter
{
    static Greeter newInstance()
    {
        return new com.horstmann.greet.internal.GreeterImpl();
    }

    String greet(String subject);
}
package com.horstmann.greet.internal;

import com.horstmann.greet.Greeter;

public class GreeterImpl implements Greeter
{
    public String greet(String subject)
    {
        return "Hello, " + subject + "!";
    }
}
package com.horstmann.greetsvc;

import java.util.Locale;

public interface GreeterService {
    String greet(String subject);
    Locale getLocale();
}
package ch01.sec08;

public class Greeting {
    public static void main(String[] args) {
        for (int i = 0; i < args.length; i++) {
            String arg = args[i];
            if (arg.equals("-h")) arg = "Hello";
            else if (arg.equals("-g")) arg = "Goodbye";
            System.out.println(arg);
        }
    }
}package ch08.sec10;

import java.io.IOException;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class GroupingPartitioning {
    public static void main(String[] args) throws IOException {
        Stream<Locale> locales = Stream.of(Locale.getAvailableLocales());
        Map<String, List<Locale>> countryToLocales = locales.collect(Collectors
                .groupingBy(Locale::getCountry));
        System.out.println("Swiss locales: " + countryToLocales.get("CH"));

        locales = Stream.of(Locale.getAvailableLocales());
        Map<Boolean, List<Locale>> englishAndOtherLocales = locales.collect(Collectors
                .partitioningBy(l -> l.getLanguage().equals("en")));
        System.out.println("English locales: " + englishAndOtherLocales.get(true));
    }
}package ch09.sec04;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Groups {
    public static void main(String[] args) {
        Pattern pattern = Pattern.compile("(\\p{Alnum}+(\\s+\\p{Alnum}+)*)\\s+([A-Z]{3})([0-9.]*)");
        String input = "Blackwell Toaster    USD29.95";
        Matcher matcher = pattern.matcher(input);
        if (matcher.matches()) {
            String item = matcher.group(1);
            String currency = matcher.group(3);
            String price = matcher.group(4);
            System.out.printf("item=%s,currency=%s,price=%s\n", item, currency, price);
        }

        pattern = Pattern.compile("(\\p{Alnum}+(?:\\s+\\p{Alnum}+)*)\\s+([A-Z]{3})([0-9.]*)");
        matcher = pattern.matcher(input);
        if (matcher.matches()) {
            String item = matcher.group(1);
            String currency = matcher.group(2);
            String price = matcher.group(3);
            System.out.printf("item=%s,currency=%s,price=%s\n", item, currency, price);
        }

        pattern = Pattern.compile("(?<item>\\p{Alnum}+(\\s+\\p{Alnum}+)*)\\s+(?<currency>[A-Z]{3})(?<price>[0-9.]*)");
        matcher = pattern.matcher(input);
        if (matcher.matches()) {
            String item = matcher.group("item");
            String currency = matcher.group("currency");
            String price = matcher.group("price");
            System.out.printf("item=%s,currency=%s,price=%s\n", item, currency, price);
        }
    }
}
package ch06.sec04;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class HeapPollutionDemo {
    public static void demo(List<String> words) {
        List<?> elements = words;
        System.out.println("Cast to List<Integer>");
        @SuppressWarnings("unchecked")
        List<Integer> numbers = (List<Integer>) elements;
        System.out.println("Success");
        System.out.println("Inserting an integer");
        numbers.add(42);
        System.out.println("Success");
        System.out.println("Removing it as a string");
        String word = words.get(0);
        System.out.println("Success");
        System.out.println(word);
    }

    public static void main(String[] args) {
        try {
            demo(new ArrayList<>());
        } catch (Throwable ex) {
            ex.printStackTrace();
        }
        try {
            demo(Collections.checkedList(new ArrayList<>(), String.class));
        } catch (Throwable ex) {
            ex.printStackTrace();
        }
    }
}
package com.horstmann.hello;

public class HelloWorld {
    public static void main(String[] args) {
       System.out.println("Hello, Modular World!");
    }
}
package com.horstmann.hello;

import javax.swing.JOptionPane;

public class HelloWorld {
    public static void main(String[] args) {
        JOptionPane.showMessageDialog(null, "Hello, Modular World!");
    }
}
package com.horstmann.hello;

import com.horstmann.greet.Greeter;

public class HelloWorld {
    public static void main(String[] args) {
       Greeter greeter = Greeter.newInstance();
       System.out.println(greeter.greet("Modular World"));
    }
}
package com.horstmann.hello;

import com.horstmann.greetsvc.GreeterService;
import java.util.Locale;
import java.util.ServiceLoader;

public class HelloWorld {
    public static void main(String[] args) {
        ServiceLoader<GreeterService> greeterLoader
            = ServiceLoader.load(GreeterService.class);
        GreeterService chosenGreeter = null;
        for (GreeterService greeter : greeterLoader) {
            if (args.length > 0 &&
                  greeter.getLocale().getLanguage().equals(args[0]))
               chosenGreeter = greeter;
        }
        if (chosenGreeter == null)
           System.out.println("No suitable greeter. Try with arg de or fr");
        else
           System.out.println(chosenGreeter.greet("Modular World"));
    }
}
package ch01.sec01;

// Our first Java program

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}package ch03.sec08;

import java.util.Arrays;
import java.util.Comparator;

public class HigherOrderDemo {
    public static Comparator<String> compareInDirecton(int direction) {
        return (x, y) -> direction * x.compareTo(y);
    }

    public static Comparator<String> reverse(Comparator<String> comp) {
        return (x, y) -> -comp.compare(x, y);
    }

    public static void main(String[] args) {
        String[] words = { "Mary", "had", "a", "little", "lamb" };
        Arrays.sort(words, compareInDirecton(-1));
        System.out.println(Arrays.toString(words));
        Arrays.sort(words, reverse(String::compareToIgnoreCase));
        System.out.println(Arrays.toString(words));
    }
}
package ch09.sec03;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Map;

import jdk.incubator.http.*;

public class HttpClientDemo {
    public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException {
        System.out.println("GET demo");
        HttpClient client = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(new URI("http://horstmann.com"))
                .GET()
                .build();
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandler.asString());
        System.out.println(response.body());

        System.out.println("\n\n\nPOST demo");
        client = HttpClient.newBuilder()
                .followRedirects(HttpClient.Redirect.ALWAYS)
                .build();
        Map<String, String> postData = new HashMap<>();
        postData.put("repo", "bj4cc");
        postData.put("problem", "ch06/c06_exp_6_105");
        postData.put("level", "1");
        postData.put("Numbers.java", solution);
        boolean first = true;
        StringBuilder body = new StringBuilder();
        for (Map.Entry<String, String> entry : postData.entrySet()) {
            if (first) first = false;
            else body.append("&");
            body.append(URLEncoder.encode(entry.getKey(), "UTF-8"));
            body.append("=");
            body.append(URLEncoder.encode(entry.getValue(), "UTF-8"));
        }

        request = HttpRequest.newBuilder()
                .uri(new URI("http://codecheck.it/check"))
                .header("Accept-Charset", "UTF-8")
                .header("Content-Type", "application/x-www-form-urlencoded")
                .POST(HttpRequest.BodyProcessor.fromString(body.toString()))
                .build();
        response = client.send(request, HttpResponse.BodyHandler.asString());
        System.out.println(response.body());
   }

    public static String solution = "public class Numbers {\n" +
            "    public int countSevens(int n) {\n" +
            "        int r = 0;\n" +
            "        while (n > 0) {\n" +
            "            if (n % 10 == 7) r++;\n" +
            "            n /= 10;\n" +
            "        }\n" +
            "        return r;\n" +
            "    }" +
            "}";
}
package ch03.sec02;

public interface Identified {
    default int getId() { return Math.abs(hashCode()); }
}package ch03.sec06;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;

import javax.imageio.ImageIO;

public class ImageDemo {
    public static BufferedImage createImage(int width, int height, PixelFunction f) {
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

        for (int x = 0; x < width; x++)
            for (int y = 0; y < height; y++) {
                Color color = f.apply(x, y);
                image.setRGB(x, y, color.getRGB());
            }
        return image;
    }

    public static void main(String[] args) throws IOException {
        BufferedImage frenchFlag = ImageDemo.createImage(150, 100,
            (x, y) -> x < 50 ? Color.BLUE : x < 100 ? Color.WHITE : Color.RED);
        Path path = Paths.get("flag.png");
        ImageIO.write(frenchFlag, "PNG", path.toFile());
        System.out.println("Image saved to " + path.toAbsolutePath());
    }
}
package ch04.sec01;

public class InheritanceDemo {
    public static void main(String[] args) {
        Manager boss = new Manager("Fred", 200000);
        boss.setBonus(10000); // Defined in subclass
        System.out.println(boss.getSalary());
        boss.raiseSalary(5); // Inherited from superclass
        System.out.println(boss.getSalary());
        Employee empl = boss; // Ok to convert to superclass
        empl.raiseSalary(5); // Can still apply superclass methods
        System.out.println(empl.getSalary()); // Calls Manager.getSalary

        if (empl instanceof Manager) {
            Manager mgr = (Manager) empl;
            mgr.setBonus(20000);
        }
    }
}package ch01.sec06;

import java.util.Scanner;

public class InputDemo {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("What is your name?");
        String name = in.nextLine();
        System.out.println("How old are you?");
        if (in.hasNextInt()) {
            int age = in.nextInt();
            System.out.printf("Hello, %s. Next year, you'll be %d.\n", name, age + 1);
        } else {
            System.out.printf("Hello, %s. Are you too young to enter an integer?", name);
        }
    }
}
package ch10.sec08;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class InterruptionDemo {
    public static BigInteger big(long value) { return BigInteger.valueOf(value); }
    public static BigInteger big(String value) { return new BigInteger(value); }

    public static BigInteger isPrime(BigInteger n) {
        BigInteger m = n;
        BigInteger a = big(2);
        while (a.multiply(a).compareTo(m) <= 0) {
            if (Thread.currentThread().isInterrupted()) {
                System.err.println("Interrupted!");
                return null;
            }
            if (m.remainder(a).equals(big(0)))
                throw new RuntimeException();
            else
                a = a.add(big(1));
        }
        return n;
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executor = Executors.newCachedThreadPool();
        List<Callable<BigInteger>> tasks = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            BigInteger n = big("10000000000").add(big(i));
            tasks.add(() -> isPrime(n));
        }
        BigInteger result = executor.invokeAny(tasks);
        System.out.println(result + " is prime");
    }
}package ch03.sec02;

public interface IntSequence {
    default boolean hasNext() { return true; };
    int next();
}package ch03.sec09;

public interface IntSequence {
    boolean hasNext();
    int next();
}package ch03.sec01;

public interface IntSequence {
    boolean hasNext();
    int next();
}package ch03.sec01;

public class IntSequenceDemo {
    public static double average(IntSequence seq, int n) {
        int count = 0;
        double sum = 0;
        while (seq.hasNext() && count < n) {
            count++;
            sum += seq.next();
        }
        return count == 0 ? 0 : sum / count;
    }

    public static void main(String[] args) {
        SquareSequence squares = new SquareSequence();
        double avg = average(squares, 100);
        System.out.println("Average of first 100 squares: " + avg);

        IntSequence digits = new DigitSequence(1729);
        while (digits.hasNext()) System.out.print(digits.next() + " ");
        System.out.println();

        digits = new DigitSequence(1729);
        avg = average(digits, 100);
            // Will only look at the first four sequence values
        System.out.println("Average of the digits: " + avg);
    }
}
package ch02.sec06;

import java.util.ArrayList;

public class Invoice {
    private static class Item { // Item is nested inside Invoice
        String description;
        int quantity;
        double unitPrice;

        double price() { return quantity * unitPrice; }
        public String toString() {
            return quantity + " x " + description + " @ $" + unitPrice + " each";
        }
    }

    private ArrayList<Item> items = new ArrayList<>();

    public void addItem(String description, int quantity, double unitPrice) {
        Item newItem = new Item();
        newItem.description = description;
        newItem.quantity = quantity;
        newItem.unitPrice = unitPrice;
        items.add(newItem);
    }

    public void print() {
        double total = 0;
        for (Item item : items) {
            System.out.println(item);
            total += item.price();
        }
        System.out.println(total);
    }
}package ch02.sec06;

public class InvoiceDemo {
    public static void main(String[] args) {
        Invoice invoice = new Invoice();
        invoice.addItem("Blackwell Toaster", 2, 24.95);
        invoice.addItem("ZapXpress Microwave Oven", 1, 49.95);
        invoice.print();
    }
}
package ch04.sec02;

import java.util.Objects;

public class Item {
    private String description;
    private double price;

    public Item(String description, double price) {
        this.description = description;
        this.price = price;
    }

    public boolean equals(Object otherObject) {
        // A quick test to see if the objects are identical
        if (this == otherObject) return true;
        // Must return false if the explicit parameter is null
        if (otherObject == null) return false;
        // Check that otherObject is a Item
        if (getClass() != otherObject.getClass()) return false;
        // Test whether the instance variables have identical values
        Item other = (Item) otherObject;
        return Objects.equals(description, other.description)
            && price == other.price;
    }

    public int hashCode() {
        return Objects.hash(description, price);
    }
}package ch07.sec02;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class IteratorDemo {
    public static void main(String[] args) {
        Collection<String> coll = new ArrayList<>();
        coll.add("Peter");
        coll.add("Paul");
        coll.add("Mary");
        Iterator<String> iter = coll.iterator();
        while (iter.hasNext()) {
            String element = iter.next();
            process(element);
        }

        iter = coll.iterator();
        while (iter.hasNext()) {
            String element = iter.next();
            if (element.startsWith("M"))
                iter.remove();
        }

        coll.removeIf(e -> e.endsWith("r"));

        for (String element : coll)
            process(element);
    }

    public static void process(String s) { System.out.println("Processing " + s); }
}
package ch07.sec05;

public class Job implements Comparable<Job> {
    private int priority;
    private String description;

    public Job(int priority, String description) {
        this.priority = priority;
        this.description = description;
    }

    public int compareTo(Job other) {
        return priority - other.priority;
    }

    public String getDescription() {
        return description;
    }
}
package ch09.sec05;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

import javafx.geometry.Point2D;

public class LabeledPoint implements Serializable {
    private String label;
    private transient Point2D point;

    public LabeledPoint(String label, Point2D point) {
        this.label = label;
        this.point = point;
    }

    public String toString() {
        // TODO Auto-generated method stub
        return String.format("%s[label=%s,point=%s]", getClass().getName(), label, point);
    }

    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeDouble(point.getX());
        out.writeDouble(point.getY());
    }

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        double x = in.readDouble();
        double y = in.readDouble();
        point = new Point2D(x, y);
    }
}
package ch03.sec04;

import java.util.ArrayList;
import java.util.Arrays;

public class LambdaDemo {
    public static void main(String[] args) {
        String[] friends = { "Peter", "Paul", "Mary" };
        Arrays.sort(friends,
                (first, second) -> first.length() - second.length());
        System.out.println(Arrays.toString(friends));
        ArrayList<String> enemies = new ArrayList<>(Arrays.asList("Malfoy", "Crabbe", "Goyle", null));
        enemies.removeIf(e -> e == null);
        System.out.println(enemies);
    }
}
package ch12.sec07;

import java.sql.Time;
import java.sql.Timestamp;
import java.text.MessageFormat;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.GregorianCalendar;

public class Legacy {
    public static void main(String[] args) {
        System.out.println("java.util.Date <-> Instant");
        System.out.println(new java.util.Date().toInstant());
        System.out.println(java.util.Date.from(Instant.now()));

        System.out.println("GregorianCalendar <-> ZonedDateTime");
        System.out.println(new GregorianCalendar().toZonedDateTime());
        System.out.println(GregorianCalendar.from(ZonedDateTime.now()));

        Timestamp christmas = Timestamp.valueOf("2014-12-25 18:30:00");
        System.out.println("java.sql.Timestamp <-> Instant");
        System.out.println(christmas.toInstant());
        System.out.println(Timestamp.from(Instant.now()));

        System.out.println("java.sql.Timestamp <-> LocalDateTime");
        System.out.println(christmas.toLocalDateTime());
        System.out.println(Timestamp.valueOf(LocalDateTime.now()));

        System.out.println("java.sql.Date <-> LocalDate");
        System.out.println(java.sql.Date.valueOf("2014-12-25").toLocalDate());
        System.out.println(java.sql.Date.valueOf(LocalDate.now()));

        System.out.println("java.sql.Time <-> LocalTime");
        System.out.println(Time.valueOf("18:30:00").toLocalTime());
        System.out.println(Time.valueOf(LocalTime.now()));

        System.out.println("DateTimeFormatter -> DateFormat");
        MessageFormat message = new MessageFormat("Today is {0}.");
        message.setFormat(0, DateTimeFormatter.ISO_WEEK_DATE.toFormat());
        System.out.println(message.format(new Object[] { LocalDate.now() }) );
    }
}
package ch07.sec04;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.TreeMap;

public class LinkedHashMapDemo {
    public static void main(String[] args) {
        Map<String, Integer> weekdays = new HashMap<>();
        initialize(weekdays);
        System.out.println(weekdays);

        weekdays = new TreeMap<>();
        initialize(weekdays);
        System.out.println(weekdays);

        weekdays = new LinkedHashMap<>();
        initialize(weekdays);
        System.out.println(weekdays);
    }

    public static void initialize(Map<String, Integer> weekdays) {
        weekdays.put("Monday", 1);
        weekdays.put("Tuesday", 2);
        weekdays.put("Wednesday", 3);
        weekdays.put("Thursday", 4);
        weekdays.put("Friday", 5);
        weekdays.put("Saturday", 6);
        weekdays.put("Sunday", 7);
    }
}
package ch07.sec02;

import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

public class ListIteratorDemo {
    public static void main(String[] args) {
        List<String> friends = new LinkedList<>();
        ListIterator<String> iter = friends.listIterator();
        iter.add("Fred"); // Fred |
        iter.add("Wilma"); // Fred Wilma |
        iter.previous(); // Fred | Wilma
        iter.set("Barney"); // Fred | Barney
        System.out.println(friends);
    }
}
package ch06.sec04;

import java.util.List;

public class Lists {
    public static boolean hasNulls(List<?> elements) {
        for (Object e : elements) {
            if (e == null) return true;
        }
        return false;
    }

    public static void swap(List<?> elements, int i, int j) {
        swapHelper(elements, i, j);
    }

    private static <T> void swapHelper(List<T> elements, int i, int j) {
        T temp = elements.get(i);
        elements.set(i, elements.get(j));
        elements.set(j, temp);
    }
}package ch03.sec09;

import java.util.Random;

public class LocalClassDemo {
    private static Random generator = new Random();

    public static IntSequence randomInts(int low, int high) {
        class RandomSequence implements IntSequence {
            public int next() { return low + generator.nextInt(high - low + 1); }
            public boolean hasNext() { return true; }
        }

        return new RandomSequence();
    }

    public static void main(String[] args) {
        IntSequence dieTosses = randomInts(1, 6);
        for (int i = 0; i < 10; i++) System.out.println(dieTosses.next());
    }
}
package ch12.sec02;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.Month;
import java.time.temporal.ChronoUnit;

public class LocalDates {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now(); // Today’s date
        System.out.println("today: " + today);

        LocalDate alonzosBirthday = LocalDate.of(1903, 6, 14);
        alonzosBirthday = LocalDate.of(1903, Month.JUNE, 14);
        // Uses the Month enumeration
        System.out.println("alonzosBirthday: " + alonzosBirthday);

        LocalDate programmersDay = LocalDate.of(2014, 1, 1).plusDays(255);
        // September 13, but in a leap year it would be September 12
        System.out.println("programmersDay: " + programmersDay);

        LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
        LocalDate christmas = LocalDate.of(2014, Month.DECEMBER, 25);

        System.out.println("Until christmas: " + independenceDay.until(christmas));
        System.out.println("Until christmas: " + independenceDay.until(christmas, ChronoUnit.DAYS));

        System.out.println(LocalDate.of(2016, 1, 31).plusMonths(1));
        System.out.println(LocalDate.of(2016, 3, 31).minusMonths(1));

        DayOfWeek startOfLastMillennium = LocalDate.of(1900, 1, 1).getDayOfWeek();
        System.out.println("startOfLastMillennium: " + startOfLastMillennium);
        System.out.println(startOfLastMillennium.getValue());
        System.out.println(DayOfWeek.SATURDAY.plus(3));
    }
}
package ch13.sec01;

import java.text.NumberFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.util.Arrays;
import java.util.Locale;
import java.util.stream.Stream;

public class Locales {
    public static void main(String[] args) {
        System.out.println(NumberFormat.getNumberInstance(
                Locale.ENGLISH).format(123456.78));
        System.out.println(NumberFormat.getNumberInstance(
                Locale.GERMAN).format(123456.78));

        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
        LocalDate date = LocalDate.of(1961, 3, 22);
        System.out.println(formatter.withLocale(
                Locale.ENGLISH).format(date));
        System.out.println(formatter.withLocale(
                Locale.GERMAN).format(date));
        System.out.println(formatter.withLocale(
                Locale.CHINESE).format(date));

        formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG);
        System.out.println(formatter.withLocale(
                Locale.ENGLISH).format(date));
        System.out.println(formatter.withLocale(
                Locale.GERMAN).format(date));
        System.out.println(formatter.withLocale(
                Locale.CHINESE).format(date));

        Locale usEnglish = Locale.forLanguageTag("en-US");

        Locale defaultLocale = Locale.getDefault();
        Locale displayLocale = Locale.getDefault(Locale.Category.DISPLAY);
        Locale formatLocale = Locale.getDefault(Locale.Category.FORMAT);
        System.out.println("Default locales");
        System.out.println("General: " + defaultLocale);
        System.out.println("Display: " + displayLocale);
        System.out.println("Format: " + formatLocale);


        System.out.println("Available locales:");
        for (Locale loc : Locale.getAvailableLocales()) {
            String languageTag = loc.toLanguageTag();
            System.out.println(languageTag + ": " + loc.getDisplayName());
        }

        Locale loc = Locale.forLanguageTag("de-CH");
        System.out.println(loc.getDisplayName(Locale.GERMAN));

        Locale.setDefault(Locale.Category.FORMAT, Locale.GERMAN);
        System.out.println(LocalDate.now());
    }
}
package ch12.sec04;

import java.time.LocalTime;

public class LocalTimes {
    public static void main(String[] args) {
        LocalTime rightNow = LocalTime.now();
        LocalTime bedtime = LocalTime.of(22, 30);
        bedtime = LocalTime.of(22, 30, 0);

        System.out.println("rightNow: " + rightNow);
        System.out.println("bedtime: " + bedtime);

        LocalTime wakeup = bedtime.plusHours(8); // wakeup is 6:30
        System.out.println("wakeup: " + wakeup);
    }
}
package ch10.sec07;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockDemo {
    public static int count;
    public static Lock countLock = new ReentrantLock();

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 1; i <= 100; i++) {
            Runnable task = () -> {
                for (int k = 1; k <= 1000; k++) {
                    countLock.lock();
                    try {
                        count++; // Critical section
                    } finally {
                        countLock.unlock(); // Make sure the lock is unlocked
                    }
                }
            };
            executor.execute(task);
        }
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.MINUTES);
        System.out.println("Final value: " + count);
    }
}package ch05.sec03;

import java.util.logging.ConsoleHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;

public class LoggingDemo {
    public static void main(String[] args) {
        Logger.getGlobal().info("Starting program");
        Logger.getGlobal().setLevel(Level.OFF);
        Logger.getGlobal().info("Global logger turned off");
        Logger logger = Logger.getLogger("com.horstmann.corejava");
        logger.fine("Global logger turned off");
        logger.setLevel(Level.FINE);
        logger.fine("Set logger to fine");
        logger.setUseParentHandlers(false);
        Handler handler = new ConsoleHandler();
        handler.setLevel(Level.FINE);
        logger.addHandler(handler);
        logger.fine("Configured handler");
    }
}
package ch10.sec06;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.LongAccumulator;
import java.util.concurrent.atomic.LongAdder;

public class LongAdderDemo {
    public static LongAdder count = new LongAdder();

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 1; i <= 1000; i++) {
            Runnable task = () -> {
                for (int k = 1; k <= 100000; k++)
                    count.increment();
            };
            executor.execute(task);
        }
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.MINUTES);
        System.out.println("Final value: " + count);

        LongAccumulator largest = new LongAccumulator(Long::max, 0);
        largest.accumulate(42L);
        long max = largest.get();
        System.out.println(max);

        ConcurrentHashMap<String,LongAdder> counts = new ConcurrentHashMap<>();
        for (String key : "Row, row, row a boat".split("\\PL+"))
            counts.computeIfAbsent(key, k -> new LongAdder()).increment();
        System.out.println(counts);
    }
}
package ch04.sec02;

public class Manager extends Employee {
    private double bonus;

    public Manager(String name, double salary) {
        super(name, salary);
        bonus = 0;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }

    public double getSalary() { // Overrides superclass method
        return super.getSalary() + bonus;
    }

    public String toString() {
        return super.toString() + "[bonus=" + bonus + "]";
    }

    public Manager clone() throws CloneNotSupportedException {
        return (Manager) super.clone();
    }
} package ch06.sec04;

public class Manager extends Employee {
    private double bonus;

    public Manager(String name, double salary) {
        super(name, salary);
        bonus = 0;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }

    public double getSalary() { // Overrides superclass method
        return super.getSalary() + bonus;
    }
} package ch09.sec05;

public class Manager extends Employee {
    private double bonus;

    public Manager(String name, double salary) {
        super(name, salary);
        bonus = 0;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }

    public double getSalary() { // Overrides superclass method
        return super.getSalary() + bonus;
    }

    public String toString() {
        return super.toString() + "[bonus=" + bonus + "]";
    }
} package com.horstmann.managers;

import com.horstmann.employees.Employee;

public class Manager extends Employee {
    private double bonus;

    public Manager(String name, double salary) {
        super(name, salary);
        bonus = 0;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }

    public double getSalary() {
        return salary + bonus; // Ok to access protected salary variable
    }
} package ch04.sec01;

public class Manager extends Employee {
    private double bonus;

    public Manager(String name, double salary) {
        super(name, salary);
        bonus = 0;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }

    public double getSalary() { // Overrides superclass method
        return super.getSalary() + bonus;
    }
} package ch07.sec04;

import java.util.HashMap;
import java.util.Map;

public class MapDemo {
    public static void main(String[] args) {
        Map<String, Integer> counts = new HashMap<>();
        counts.put("Alice", 1); // Adds the key/value pair to the map
        counts.put("Alice", 2); // Updates the value for the key

        int count = counts.get("Alice");
        System.out.println(count);
        count = counts.getOrDefault("Barney", 0);
        System.out.println(count);

        String word = "Fred";
        counts.merge(word, 1, Integer::sum);
        counts.merge(word, 1, Integer::sum);
        System.out.println(counts.get(word));

        for (Map.Entry<String, Integer> entry : counts.entrySet()) {
            String key = entry.getKey();
            Integer value = entry.getValue();
            process(key, value);
        }

        counts.forEach((k, v) -> process(k, v));
    }

    public static void process(String key, Integer value) {
        System.out.printf("Processing key %s and value %d\n", key, value);
    }

}
package ch09.sec01;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

// See http://en.wikipedia.org/wiki/BMP_file_format

public class MemoryMappedFileDemo {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get("chart.bmp");
        try (FileChannel channel = FileChannel.open(path,
                StandardOpenOption.READ, StandardOpenOption.WRITE)) {
            ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE,
                    0, channel.size());
            buffer.order(ByteOrder.LITTLE_ENDIAN);
            int size = buffer.getInt(2);
            int headerSize = buffer.getInt(14);
            int width = buffer.getInt(18);
            int height = buffer.getInt(22);
            short planes = buffer.getShort(26);
            short depth = buffer.getShort(28);
            int compressionMode = buffer.getInt(30);;
            System.out.println("Size: " + size);
            System.out.println("Header size : " + headerSize);
            System.out.println("Width : " + width);
            System.out.println("Height : " + height);
            System.out.println("Planes : " + planes);
            System.out.println("Depth : " + depth);
            System.out.println("Compression mode : " + compressionMode);

        }
    }
}
package ch04.sec02;

import java.util.ArrayList;

public final class Message {
    private String sender;
    private ArrayList<String> recipients;
    private String text;



    public Message(String sender, String text) {
        this.sender = sender;
        this.text = text;
        recipients = new ArrayList<>();
    }

    public void addRecipient(String recipient) {
        recipients.add(recipient);
    };

    public Message clone() {
        try {
            Message cloned = (Message) super.clone();
            @SuppressWarnings("unchecked") ArrayList<String> clonedRecipients
                = (ArrayList<String>) recipients.clone();
            cloned.recipients = clonedRecipients;
            return cloned;
        } catch (CloneNotSupportedException ex) {
            return null;
        }
    }
}package ch13.sec06;

import java.text.MessageFormat;
import java.time.Instant;
import java.util.Date;

public class MessageFormatDemo {
    public static void main(String[] args) {
        String message = MessageFormat.format("Hello, it is now {0,time,short}.", Date.from(Instant.now()));
        System.out.println(message);

        String template = "{0,choice,0#No files|1#1 file|2#{0} files} copied";
        System.out.println(MessageFormat.format(template, 0));
        System.out.println(MessageFormat.format(template, 1));
        System.out.println(MessageFormat.format(template, 42));
        System.out.println(MessageFormat.format(template, -1)); // First limit is ignored!
    }

}
package ch01.sec01;

import java.util.Random;

public class MethodDemo {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
        System.out.println("Hello, World!".length());
        System.out.println(new Random().nextInt());

        Random generator = new Random();
        System.out.println(generator.nextInt());
        System.out.println(generator.nextInt());
    }
}package ch04.sec05;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Scanner;

public class MethodPrinter {
    public static void main(String[] args) throws ReflectiveOperationException {
        System.out.print("Class name: ");
        Scanner in = new Scanner(System.in);
        String className = in.nextLine();
        Class<?> cl = Class.forName(className);
        while (cl != null) {
            for (Method m : cl.getDeclaredMethods()) {
                System.out.println(
                    Modifier.toString(m.getModifiers()) + " " +
                    m.getReturnType().getCanonicalName() + " " +
                    m.getName() +
                    Arrays.toString(m.getParameters()));
            }
            cl = cl.getSuperclass();
        }
    }
}
package ch03.sec05;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;

public class MethodReferenceDemo {
    public static void main(String[] args) {
        String[] strings = { "Mary", "had", "a", "little", "lamb" };
        Arrays.sort(strings, String::compareToIgnoreCase);
        System.out.println(Arrays.toString(strings));
        ArrayList<String> list = new ArrayList<>(Arrays.asList("Malfoy", "Crabbe", "Goyle", null));
        list.removeIf(Objects::isNull);
        list.forEach(System.out::println);
    }
}
package ch04.sec03;

public enum Modifier {
    PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, ABSTRACT;
    private int mask;

    static {
        int maskBit = 1;
        for (Modifier m : Modifier.values()) {
            m.mask = maskBit;
            maskBit *= 2;
        }
    }

    public int getMask() {
        return mask;
    }
}@SuppressWarnings("module")
module ch15.sec04 {
   requires java.desktop;
}
@SuppressWarnings("module")
module ch15.sec05 {
   requires com.horstmann.greet;
}
@SuppressWarnings("module")
module ch15.sec06 {
   requires java.xml.bind;
   opens com.horstmann.places to java.xml.bind;
}
@SuppressWarnings("module")
module ch15.sec08 {
   requires com.horstmann.greetsvc;
   uses com.horstmann.greetsvc.GreeterService;
}
@SuppressWarnings("module")
module ch15.sec09 {
   requires commons.csv;
}
module com.horstmann.greet {
   exports com.horstmann.greet;
}
module com.horstmann.greetsvc {
    exports com.horstmann.greetsvc;
    provides com.horstmann.greetsvc.GreeterService
       with com.horstmann.greetsvc.internal.FrenchGreeter, com.horstmann.greetsvc.internal.GermanGreeterFactory;
}
module ch15.sec03 {
}
@SuppressWarnings("module")
module ch15.sec08 {
}
package ch04.sec01;

public interface Named {
    default String getName() { return ""; }
}package ch02.sec06;

import java.util.ArrayList;

public class Network {
    public class Member { // Member is an inner class of Network
        private String name;
        private ArrayList<Member> friends = new ArrayList<>();

        public Member(String name) {
            this.name = name;
        }

        public void deactivate() {
            members.remove(this);
        }

        public void addFriend(Member newFriend) {
            friends.add(newFriend);
        }

        public boolean belongsTo(Network n) {
            return Network.this == n;
        }

        public String toString() {
            StringBuilder result = new StringBuilder(name);
            result.append(" with friends ");
            for (Member friend : friends) {
                result.append(friend.name);
                result.append(", ");
            }
            return result.subSequence(0, result.length() - 2).toString();
        }
    }

    private ArrayList<Member> members = new ArrayList<>();

    public Member enroll(String name) {
        Member newMember = new Member(name);
        members.add(newMember);
        return newMember;
    }

    public String toString() {
        return members.toString();
    }
}package ch02.sec06;

public class NetworkDemo {
    public static void main(String[] args) {
        Network myFace = new Network();
        Network tooter = new Network();
        Network.Member fred = myFace.enroll("Fred");
        Network.Member wilma = myFace.new Member("Wilma");
            // An object, but not enrolled
            // Make the constructor private to avoid this
        fred.addFriend(wilma);

        Network.Member barney = tooter.enroll("Barney");
        fred.addFriend(barney);
        System.out.println(myFace);
            // If it shouldn't be possible to add a friend
            // from another network, call belongsTo
        System.out.println(barney.belongsTo(myFace));
    }
}
package ch01.sec02;

public class NumberDemo {
    public static void main(String[] args) {
        System.out.println(4000000000L); // long literal
        System.out.println(0xCAFEBABE); // hex literal
        System.out.println(0b1001); // binary literal
        System.out.println(011); // octal literal

        // Underscores in literals
        System.out.println(1_000_000_000);
        System.out.println(0b1111_0100_0010_0100_0000);

        // Advanced topic: Unsigned quantities
        System.out.println(Byte.toUnsignedInt((byte )-127));

        System.out.println(3.14F); // float literal
        System.out.println(3.14); // double literal
        System.out.println(3.14D); // double literal
        System.out.println(0x1.0p-3); // hex double literal

        // Infinity and NaN
        System.out.println(1.0 / 0.0);
        System.out.println(-1.0 / 0.0);
        System.out.println(0.0 / 0.0);

        System.out.println(1.0 / 0.0 == Double.POSITIVE_INFINITY);
        System.out.println(-1.0 / 0.0 == Double.NEGATIVE_INFINITY);
        System.out.println(0.0 / 0.0 == Double.NaN);

        System.out.println(Double.isInfinite(1.0 / 0.0));
        System.out.println(Double.isNaN(0.0 / 0.0));
        System.out.println(Double.isFinite(0.0 / 0.0));

        // Roundoff error

        System.out.println(2.0 - 1.1);

        // Character literals

        System.out.println('J');
        System.out.println('J' == 74);
        System.out.println('\u004A');
        System.out.println('\u263A');
    }
}package ch13.sec02;

import java.text.NumberFormat;
import java.text.ParseException;
import java.util.Locale;
import java.util.Scanner;

public class NumberFormats {
    public static void main(String[] args) {
        Locale loc = Locale.GERMANY;
        NumberFormat formatter = NumberFormat.getCurrencyInstance(loc);
        double amt = 123456.78;
        String result = formatter.format(amt);
        System.out.println(result);

        try (Scanner in = new Scanner(System.in)) {
            System.out.print("Enter a number such as 12,345: ");
            String input = in.next();
            formatter = NumberFormat.getNumberInstance();
               // Get the number formatter for default format locale
            Number parsed = formatter.parse(input);
            double x = parsed.doubleValue();
            System.out.println("Parsed number: " + x);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
}
package ch04.sec03;

public enum Operation {
    ADD("+") {
        public int eval(int arg1, int arg2) { return arg1 + arg2; }
    },
    SUBTRACT("-") {
        public int eval(int arg1, int arg2) { return arg1 - arg2; }
    },
    MULTIPLY("*") {
        public int eval(int arg1, int arg2) { return arg1 * arg2; }
    },
    DIVIDE("/") {
        public int eval(int arg1, int arg2) { return arg1 / arg2; }
    };

    private String symbol;
    Operation(String symbol) { this.symbol = symbol; }
    public String getSymbol() { return symbol; }

    public abstract int eval(int arg1, int arg2);
}package ch08.sec07;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

class User
{
    public User(String id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String toString() {
        return name;
    }

    private String id;
    private String name;
}

class Users {
    private static User[] users = {
            new User("gboole", "George Boole"),
            new User("achurch", "Alonzo Church"),
            new User("hcurry", "Haskell Curry")
    };

    public static Optional<User> lookup(String id) {
        return Stream.of(users).filter(u -> u.getId().equals(id)).findFirst();
    }

    public static User classicLookup(String id) {
        for (User u : users) {
            if (u.getId().equals(id)) return u;
        }
        return null;
    }
}

public class OptionalDemo {

    public static <T> void show(String title, Stream<T> stream) {
        final int SIZE = 10;
        List<T> firstElements = stream.limit(SIZE + 1).collect(Collectors.toList());
        System.out.print(title + ": ");
        if (firstElements.size() <= SIZE)
            System.out.println(firstElements);
        else {
            firstElements.remove(SIZE);
            String out = firstElements.toString();
            System.out.println(out.substring(0, out.length() - 1) + ", ...]");
        }
    }

    public static void main(String[] args) throws IOException {
        String contents = new String(Files.readAllBytes(Paths.get("alice.txt")),
                StandardCharsets.UTF_8);
        List<String> wordList = List.of(contents.split("\\PL+"));

        Optional<String> optionalValue = wordList.stream().filter(s -> s.contains("fred"))
                .findFirst();
        System.out.print(optionalValue.orElse("No word") + " contains fred");

        Optional<String> optionalString = Optional.empty();
        String result = optionalString.orElse("N/A");
        System.out.println("result: " + result);
        result = optionalString.orElseGet(() -> System.getProperty("user.dir"));
        System.out.println("result: " + result);
        try {
            result = optionalString.orElseThrow(IllegalStateException::new);
            System.out.println("result: " + result);
        } catch (Throwable t) {
            t.printStackTrace();
        }
        Optional<String> result2 = optionalString.or(() ->
            Optional.ofNullable(System.getProperty("myapp.default")));
        System.out.println("result2: " + result2);

        optionalValue = wordList.stream().filter(s -> s.contains("red")).findFirst();
        optionalValue.ifPresent(s -> System.out.println(s + " contains red"));

        optionalValue = wordList.stream().filter(s -> s.contains("blue")).findFirst();
        optionalValue.ifPresentOrElse(
                s -> System.out.println(s + " contains blue"),
                () -> System.out.println("Nothing contains blue"));

        Set<String> results = new HashSet<>();
        optionalValue.ifPresent(results::add);
        Optional<Boolean> added = optionalValue.map(results::add);
        System.out.println("added: " + added);

        System.out.println(inverse(4.0).flatMap(OptionalDemo::squareRoot));
        System.out.println(inverse(-1.0).flatMap(OptionalDemo::squareRoot));
        System.out.println(inverse(0.0).flatMap(OptionalDemo::squareRoot));
        Optional<Double> result3 = Optional.of(-4.0).flatMap(OptionalDemo::inverse)
                .flatMap(OptionalDemo::squareRoot);
        System.out.println("result3: " + result3);

        Stream<String> ids = Stream.of("gboole", "jgosling");
        Stream<User> users = ids.map(Users::lookup)
            .filter(Optional::isPresent)
            .map(Optional::get);
        show("users", users);

        ids = Stream.of("gboole", "jgosling");
        users = ids.map(Users::lookup)
                .flatMap(Optional::stream);
        show("users", users);

        ids = Stream.of("gboole", "jgosling");
        users = ids.map(Users::classicLookup)
                .filter(Objects::nonNull);
        show("users", users);

        ids = Stream.of("gboole", "jgosling");
        users = ids.flatMap(
                id -> Stream.ofNullable(Users.classicLookup(id)));
        show("users", users);

        ids = Stream.of("gboole", "jgosling");
        users = ids.map(Users::classicLookup)
                .flatMap(Stream::ofNullable);
        show("users", users);
    }

    public static Optional<Double> inverse(Double x) {
        return x == 0 ? Optional.empty() : Optional.of(1 / x);
    }

    public static Optional<Double> squareRoot(Double x) {
        return x < 0 ? Optional.empty() : Optional.of(Math.sqrt(x));
    }
}
package ch08.sec05;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class OtherTransformations {
    public static <T> void show(String title, Stream<T> stream) {
        final int SIZE = 10;
        List<T> firstElements = stream.limit(SIZE + 1).collect(Collectors.toList());
        System.out.print(title + ": ");
        if (firstElements.size() <= SIZE)
            System.out.println(firstElements);
        else {
            firstElements.remove(SIZE);
            String out = firstElements.toString();
            System.out.println(out.substring(0, out.length() - 1) + ", ...]");
        }
    }

    public static void main(String[] args) throws IOException {
        Stream<String> uniqueWords = Stream.of("merrily", "merrily", "merrily", "gently")
                .distinct();
        show("uniqueWords", uniqueWords);

        String contents = new String(Files.readAllBytes(Paths.get("../alice.txt")),
                StandardCharsets.UTF_8);
        List<String> words = List.of(contents.split("\\PL+"));
        show("words", words.stream());

        Stream<String> distinct =  words.stream().distinct();
        show("distinct", distinct);

        Stream<String> sorted =  words.stream().sorted();
        show("sorted", sorted);

        Stream<String> distinctSorted =  words.stream().distinct().sorted();
        show("distinctSorted", distinctSorted);

        Stream<String> longestFirst =  words.stream().sorted(Comparator.comparing(String::length).reversed());
        show("longestFirst", longestFirst);

        Object[] powers = Stream.iterate(1.0, p -> p * 2)
                .peek(e -> System.out.println("Fetching " + e)).limit(20).toArray();
        System.out.println(Arrays.toString(powers));
    }
}
@Generated("com.horstmann.generator")
package ch11.sec01;
import javax.annotation.Generated;package ch10.sec04;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import java.util.stream.Stream;

public class ParallelAlgorithms {
    public static long occurrences(String word, Path path) {
        try {
            String contents = new String(Files.readAllBytes(path),
                StandardCharsets.UTF_8);
            return Pattern.compile("\\PL+")
                    .splitAsStream(contents)
                    .filter(Predicate.isEqual(word))
                    .count();
        } catch (IOException ex) {
            return 0;
        }
    }

    public static void main(String[] args) throws IOException {
        String contents = new String(Files.readAllBytes(Paths.get("alice.txt")),
                StandardCharsets.UTF_8);
        List<String> words = List.of(contents.split("\\PL+"));
        long result = words.parallelStream().filter(s -> s.startsWith("A")).count();
        System.out.println("Words starting with A: " + result);

        Path pathToRoot = Paths.get(".");
        try (Stream<Path> paths = Files.walk(pathToRoot)) {
            long total = paths.parallel()
                    .mapToLong(p -> occurrences("String", p))
                    .sum();
            System.out.println("Occurrences of String: " + total);
        }

        int[] values = new int[1000000];
        Arrays.parallelSetAll(values, i -> i % 10);
        // Fills values with 0 1 2 3 4 5 6 7 8 9 0 1 2 ...
        System.out.println(Arrays.toString(Arrays.copyOf(values, 20)));
        String[] wordArray = words.toArray(new String[words.size()]);
        Arrays.parallelSort(wordArray, Comparator.comparing(String::length));
        System.out.println(Arrays.toString(Arrays.copyOfRange(wordArray, wordArray.length / 2, wordArray.length / 2 + 20)));

        Arrays.parallelSort(values, values.length / 2, values.length);
        System.out.println(Arrays.toString(Arrays.copyOfRange(values, values.length / 2, values.length / 2 + 20)));
    }
}
package ch08.sec14;

import static java.util.stream.Collectors.counting;
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.groupingByConcurrent;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class ParallelStreams {
    public static void main(String[] args) throws IOException {
        String contents = new String(Files.readAllBytes(
                Paths.get("alice.txt")), StandardCharsets.UTF_8);
        List<String> words = List.of(contents.split("\\PL+"));

        // Very bad code ahead
        int[] shortWords = new int[10];
        words.parallelStream().forEach(
            s -> { if (s.length() < 10) shortWords[s.length()]++; });
        System.out.println(Arrays.toString(shortWords));

        // Try again--the result will likely be different (and also wrong)
        Arrays.fill(shortWords, 0);
        words.parallelStream().forEach(
            s -> { if (s.length() < 10) shortWords[s.length()]++; });
        System.out.println(Arrays.toString(shortWords));

        // Remedy: Group and count
        Map<Integer, Long> shortWordCounts =
            words.parallelStream()
                .filter(s -> s.length() < 10)
                .collect(
                    groupingBy(
                        String::length,
                        counting()));

        System.out.println(shortWordCounts);

        // Downstream order not deterministic
        Map<Integer, List<String>> result = words.parallelStream().collect(
                Collectors.groupingByConcurrent(String::length));

        System.out.println(result.get(14));

        result = words.parallelStream().collect(
                Collectors.groupingByConcurrent(String::length));

        System.out.println(result.get(14));

        Map<Integer, Long> wordCounts =
                words.parallelStream()
                    .collect(
                        groupingByConcurrent(
                            String::length,
                            counting()));

        System.out.println(wordCounts);
   }
}
package ch09.sec02;

import java.nio.file.Path;
import java.nio.file.Paths;

public class PathDemo {
    public static void main(String[] args) {
        Path absolute = Paths.get("/", "home", "cay");
        Path relative = Paths.get("myprog", "conf", "user.properties");
        System.out.println(absolute);
        System.out.println(relative);
        Path homeDirectory = Paths.get("/home/cay");
        System.out.println(homeDirectory);

        Path workPath = homeDirectory.resolve("myprog/work");
        System.out.println(workPath);
        Path tempPath = workPath.resolveSibling("temp");
        System.out.println(tempPath);

        relative = Paths.get("/home/cay").relativize(Paths.get("/home/fred/myprog"));
        System.out.println(relative);

        Path normalized = Paths.get("/home/cay/../fred/./myprog").normalize();
        System.out.println("normalized: " + normalized);

        absolute = Paths.get("config").toAbsolutePath();
        System.out.println("absolute: " + absolute);

        Path p = Paths.get("/home", "cay", "myprog.properties");
        System.out.println("p: " + p);
        Path parent = p.getParent();
        System.out.println("parent of p: " + parent);
        Path file = p.getFileName();
        System.out.println("file of p: " + file);
        Path root = p.getRoot();
        System.out.println("root of p: " + root);
        Path first = p.getName(0);
        System.out.println("first of p: " + first);
        Path dir = p.subpath(0, p.getNameCount() - 1);
        System.out.println("dir of p: " + dir);

        System.out.println("Components of p");
        for (Path component : p) {
            System.out.println(component);
        }
    }
}
package ch03.sec08;

public class Person {
    private String first;
    private String middle;
    private String last;

    public Person(String first, String middle, String last) {
        this.first = first;
        this.middle = middle;
        this.last = last;
    }

    public Person(String first, String last) {
        this.first = first;
        this.last = last;
    }

    public String getFirstName() {
        return first;
    }

    public String getMiddleName() {
        return middle;
    }

    public String getLastName() {
        return last;
    }

    public String getName() {
        if (middle == null) {
            return first + " " + last;
        }
        else {
            return first + " " + middle + " " + last;
        }
    }

    public String toString() {
        return getName();
    }
}
package ch04.sec01;

public abstract class Person {
    private String name;

    public Person(String name) { this.name = name; }
    public final String getName() { return name; }

    public abstract int getId();
}package ch09.sec05;

import java.io.Serializable;

public class Person implements Serializable {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    private Object writeReplace() {
        return new PersonProxy(id);
    }

    public String toString() {
        return String.format("%s[id=%d,name=%s]", getClass().getName(), id, name);
    }
}package ch03.sec02;

public interface Person {
    String getName();
    default int getId() { return 0; }
}package ch09.sec05;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public enum PersonDatabase {
    INSTANCE;

    private Map<Integer, Person> people = new ConcurrentHashMap<>();
    private PersonDatabase() {
        add(new Person(1, "Adam"));
        add(new Person(2, "Eve"));
    }

    public Person findById(int id) { return people.get(id); }

    public void add(Person p) {
        people.putIfAbsent(p.getId(), p);
    }
}package ch09.sec05;

import java.io.Serializable;

public class PersonProxy implements Serializable {
    private int id;

    public PersonProxy(int id) {
        this.id = id;
    }

    public Object readResolve() {
        return PersonDatabase.INSTANCE.findById(id);
    }
}package ch03.sec06;

import java.awt.Color;

@FunctionalInterface
public interface PixelFunction {
    Color apply(int x, int y);
}package ch11.sec04;

@ToString(includeName=false)
public class Point {
    @ToString(includeName=false) private int x;
    @ToString(includeName=false) private int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}package ch11.sec05;

import com.horstmann.annotations.ToString;

@ToString(includeName=false)
public class Point {
    private int x;
    private int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    @ToString(includeName=false) public int getX() { return x; }
    @ToString(includeName=false) public int getY() { return y; }
}package ch11.sec01;

public class Point {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public String toString(@ReadOnly Point this) { return "(" + x + "," + y + ")"; }

    @Override
    public boolean equals(@ReadOnly Point this, @ReadOnly Object obj) {
        Point other = (Point) obj;
        return x == other.x && y == other.y;
    }

    public static void main(String[] args) {
        System.out.println(new Point(1, 2).equals(new Point(1, 2)));
    }
}package ch09.sec03;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PostDemo {
    public static void main(String[] args) throws IOException {
        URL url = new URL("http://codecheck.it/check");
        URLConnection connection = url.openConnection();
        connection.setRequestProperty("Accept-Charset", "UTF-8");
        connection.setDoOutput(true);
        try (Writer out = new OutputStreamWriter(
                connection.getOutputStream(), "UTF-8")) {
            Map<String, String> postData = new HashMap<>();

            postData.put("repo", "bj4cc");
            postData.put("problem", "ch06/c06_exp_6_105");
            postData.put("level", "1");
            postData.put("Numbers.java", solution);
            boolean first = true;
            for (Map.Entry<String, String> entry : postData.entrySet()) {
                if (first) first = false;
                else out.write("&");
                out.write(URLEncoder.encode(entry.getKey(), "UTF-8"));
                out.write("=");
                out.write(URLEncoder.encode(entry.getValue(), "UTF-8"));
            }
        }

        Map<String, List<String>> headers = connection.getHeaderFields();
        System.out.println("Response headers: " + headers);
        try (InputStream in = connection.getInputStream()) {
            String contents = new String(readAllBytes(in));
            System.out.println(contents);
        }
    }

    public static byte[] readAllBytes(InputStream in) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        copy(in, out);
        return out.toByteArray();
    }

    public static void copy(InputStream in, OutputStream out) throws IOException {
        final int BLOCKSIZE = 1024;
        byte[] bytes = new byte[BLOCKSIZE];
        int len;
        while ((len = in.read(bytes)) != -1) out.write(bytes, 0, len);
        in.close();
        out.close();
    }

    public static String solution = "public class Numbers {\n" +
            "    public int countSevens(int n) {\n" +
            "        int r = 0;\n" +
            "        while (n > 0) {\n" +
            "            if (n % 10 == 7) r++;\n" +
            "            n /= 10;\n" +
            "        }\n" +
            "        return r;\n" +
            "    }" +
            "}";
}
package ch13.sec09;

import java.io.Console;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.prefs.BackingStoreException;
import java.util.prefs.InvalidPreferencesFormatException;
import java.util.prefs.Preferences;

public class PreferencesDemo {
    public static void main(String[] args) throws BackingStoreException, IOException, InvalidPreferencesFormatException {
        Preferences root = Preferences.userRoot();
        Preferences node = root.node("/com/horstmann/corejava");
        Path path = Paths.get("prefs.xml");
        if (args.length > 0) {
            if (args[0].equals("--clear")) {
                node.removeNode();
            } else if (args[0].equals("--export")) {
                try (OutputStream out = Files.newOutputStream(path)) {
                    node.exportSubtree(out);
                }
                System.out.println("Preferences exported to " + path.toAbsolutePath());
            } else if (args[0].equals("--import")) {
                try (InputStream in = Files.newInputStream(path)) {
                    Preferences.importPreferences(in);
                }
                System.out.println("Preferences imported from " + path.toAbsolutePath());
            }
        } else {
            String username = node.get("username", "");
            if (username.equals("")) {
                Console console = System.console();
                username = console.readLine("What is your name? ");
                node.put("username", username);
            }
            else System.out.println("Hello, " + username);
        }
    }
}
package ch08.sec13;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class PrimitiveTypeStreams {
    public static void show(String title, IntStream stream) {
        final int SIZE = 10;
        int[] firstElements = stream.limit(SIZE + 1).toArray();
        System.out.print(title + ": [");
        int i;
        for (i = 0; i < SIZE && i < firstElements.length; i++) {
            System.out.print(firstElements[i]);
            if (i < firstElements.length - 1)
                System.out.print(", ");
        }
        if (i < firstElements.length)
            System.out.print("...");
        System.out.println("]");
    }

    public static void main(String[] args) throws IOException {
        IntStream is1 = IntStream.generate(() -> (int) (Math.random() * 100));
        show("is1", is1);
        IntStream is2 = IntStream.range(5, 10);
        show("is2", is2);
        IntStream is3 = IntStream.rangeClosed(5, 10);
        show("is3", is3);

        Path path = Paths.get("../alice.txt");
        String contents = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);

        Stream<String> words = Stream.of(contents.split("\\PL+"));
        IntStream is4 = words.mapToInt(String::length);
        show("is4", is4);
        String sentence = "\uD835\uDD46 is the set of octonions.";
        System.out.println(sentence);
        IntStream codes = sentence.codePoints();
        System.out.println(codes.mapToObj(c -> String.format("%X ", c)).collect(
                Collectors.joining()));

        Stream<Integer> integers = IntStream.range(0, 100).boxed();
        IntStream is5 = integers.mapToInt(Integer::intValue);
        show("is5", is5);
    }
}
package ch07.sec05;

import java.util.PriorityQueue;

public class PriorityQueueDemo {
    public static void main(String[] args) {
        PriorityQueue<Job> jobs = new PriorityQueue<>();
        jobs.add(new Job(4, "Collect garbage"));
        jobs.add(new Job(9, "Match braces"));
        jobs.add(new Job(1, "Fix memory leak"));

        while (jobs.size() > 0) {
            Job job = jobs.remove(); // The most urgent jobs are removed first
            execute(job);
        }
    }

    public static void execute(Job job) {
        System.out.println(job.getDescription());
    }
}
package ch07.sec05;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

public class PropertiesDemo {
    public static void main(String[] args) throws IOException {
        Properties settings = new Properties();
        settings.put("width", "200");
        settings.put("title", "Hello, World!");
        Path path = Paths.get("demo.properties");
        try (OutputStream out = Files.newOutputStream(path)) {
            settings.store(out, "Program Properties");
        }

        settings = new Properties();
        try (InputStream in = Files.newInputStream(path)) {
            settings.load(in);
        }
        System.out.println(settings);

        String title = settings.getProperty("title", "New Document");
        String height = settings.getProperty("height", "100");
        System.out.println(title);
        System.out.println(height);
        System.out.println();
        System.out.println("System properties");
        Properties sysprops = System.getProperties();
        sysprops.forEach((k, v) -> System.out.printf("%s=%s\n", k, v));
    }
}
package ch04.sec05;


import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Arrays;

public class ProxyDemo {
    public static void main(String[] args) {
        Object[] values = new Object[1000];

        for (int i = 0; i < values.length; i++) {
            Object value = new Integer(i);
            values[i] = Proxy.newProxyInstance(
                null, value.getClass().getInterfaces(),
                (Object proxy, Method m, Object[] margs) -> {
                    System.out.println(value + "." + m.getName() + Arrays.toString(margs));
                    return m.invoke(value, margs);
                });
        }

        int position = Arrays.binarySearch(values, new Integer(500));
        System.out.println(values[position]);
    }
}
package ch10.sec07;

public class Queue {
    class Node { Object value; Node next; };
    private Node head;
    private Node tail;

    public synchronized void add(Object newValue) {
        Node n = new Node();
        if (head == null) head = n;
        else tail.next = n;
        tail = n;
        tail.value = newValue;
        notifyAll();
    }

    public synchronized Object remove() {
        if (head == null) return null;
        Node n = head;
        head = n.next;
        return n.value;
    }

    public synchronized Object take() throws InterruptedException {
        while (head == null) wait();
        Node n = head;
        head = n.next;
        return n.value;
    }
}package ch10.sec07;

import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class QueueDemo {
    public static Queue queue = new Queue();
    public static Set<Object> set = ConcurrentHashMap.newKeySet();

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 1; i <= 100; i++) {
            int taskId = i;
            executor.execute(() -> {
                for (int k = 1; k <= 1000; k++)
                    queue.add(taskId * 1000 + k);
            });
            executor.execute(() -> {
                for (int k = 1; k <= 1000; k++)
                    try {
                        set.add(queue.take());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
            });
        }
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.MINUTES);
        System.out.println("Final size: " + set.size());
    }
}package ch10.sec03;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class RaceConditionDemo {
    public static volatile int count;

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 1; i <= 100; i++) {
            int taskId = i;
            Runnable task = () -> {
                for (int k = 1; k <= 1000; k++)
                    count++;
                System.out.println(taskId + ": " + count);
            };
            executor.execute(task);
        }
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.MINUTES);
        System.out.println("Final value: " + count);
    }
}package ch02.sec04;

import java.util.Random;

public class RandomNumbers {
    private static Random generator = new Random();
    public static int nextInt(int low, int high) {
        return low + generator.nextInt(high - low + 1);
            // Ok to access the static generator variable
    }
}package ch07.sec06;

import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

public class RangeDemo {
    public static void main(String[] args) {
        List<String> sentence = List.of("A man, a plan, a cat, a ham, a yak, a yam, a hat, a canal, Panama!".split("[ ,]+"));
        List<String> nextFive = sentence.subList(5, 10);
        System.out.println(nextFive);

        TreeSet<String> words = new TreeSet<>(sentence);
        words.add("zebra");
        SortedSet<String> ysOnly = words.subSet("y", "z");
        System.out.println(ysOnly);

        SortedSet<String> nAndBeyond = words.tailSet("p");
        System.out.println(nAndBeyond);
    }
}
package ch10.sec09;

import java.io.IOException;
import java.nio.file.Paths;
import java.util.Scanner;

public class ReadDir {
    public static void main(String[] args) throws IOException, InterruptedException {
        Process process = new ProcessBuilder("/bin/ls", "-l").directory(Paths.get("/tmp").toFile()).start();
        try (Scanner in = new Scanner(process.getInputStream())) {
            while (in.hasNextLine())
                System.out.println(in.nextLine());
        }
        //int result = p.waitFor();
        //System.out.println("Exit value: " + result);
        process.onExit().thenAccept(
                p -> System.out.println("Exit value: " + p.exitValue()));
    }
}
package ch11.sec01;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target({ElementType.TYPE_USE, ElementType.PARAMETER})
public @interface ReadOnly {

}package ch11.sec01;

import java.util.NoSuchElementException;

public class ReceiverDemo {

    static class Sequence {
        private int from;
        private int to;
        public Sequence(int from, int to) {
            this.from = from;
            this.to = to;
        }

        class Iterator implements java.util.Iterator<Integer> {
            private int current;

            public Iterator(ReceiverDemo.Sequence Sequence.this) {
                this.current = Sequence.this.from;
            }

            @Override
            public boolean hasNext() {
                return current < to;
            }

            @Override
            public Integer next() {
                if (current >= to) throw new NoSuchElementException();
                Integer result = current;
                current++;
                return result;
            }

            @Override
            public void remove() {
                throw new UnsupportedOperationException();
            }
        }
    }

    public static void main(String[] args) {
        Sequence seq = new Sequence(0, 10);
        java.util.Iterator<Integer> iter = seq.new Iterator();
        while (iter.hasNext()) System.out.println(iter.next());
    }

}
package ch11.sec05;

import com.horstmann.annotations.ToString;

@ToString
public class Rectangle {
    private Point topLeft;
    private int width;
    private int height;
    public Rectangle(Point topLeft, int width, int height) {
        this.topLeft = topLeft;
        this.width = width;
        this.height = height;
    }
    @ToString(includeName=false) public Point getTopLeft() { return topLeft; }
    @ToString public int getWidth() { return width; }
    @ToString public int getHeight() { return height; }
}package ch11.sec04;

@ToString
public class Rectangle {
    @ToString(includeName=false) private Point topLeft;
    @ToString private int width;
    @ToString private int height;
    public Rectangle(Point topLeft, int width, int height) {
        this.topLeft = topLeft;
        this.width = width;
        this.height = height;
    }
}package ch08.sec12;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;

public class ReductionDemo {
    public static void main(String[] args) throws IOException {
        Integer[] digits = { 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6,
                4, 3, 3, 8, 3, 2, 7, 9, 5, 0, 2, 8, 8, 4, 1, 9, 7, 1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0,
                5, 8, 2, 0, 9, 7, 4, 9, 4, 4, 5, 9, 2, 3, 0, 7, 8, 1, 6, 4, 0, 6, 2, 8, 6 };
        Stream<Integer> values = Stream.of(digits);
        Optional<Integer> sum = values.reduce((x, y) -> x + y);
        System.out.println("sum: " + sum);

        values = Stream.empty();
        sum = values.reduce((x, y) -> x + y); // Or values.reduce(Integer::sum);
        System.out.println("sum: " + sum);

        values = Stream.of(digits);
        Integer sum2 = values.reduce(0, (x, y) -> x + y);
        System.out.println("sum2: " + sum2);

        values = Stream.empty();
        Integer sum3 = values.reduce(0, (x, y) -> x + y);
        System.out.println("sum3: " + sum3);

        String contents = new String(Files.readAllBytes(Paths.get("alice.txt")),
                StandardCharsets.UTF_8);
        List<String> words = List.of(contents.split("\\PL+"));

        int result = words.stream().reduce(
                0,
                (total, word) -> total + word.length(),
                (total1, total2) -> total1 + total2);

        System.out.println("result: " + result);
    }
}
package ch11.sec02;

public @interface Reference {
    long id();
}package ch02.sec01;

import java.util.ArrayList;

public class ReferenceDemo {
    public static void main(String[] args) {
        ArrayList<String> friends = new ArrayList<>();
            // friends is empty
        friends.add("Peter");
            // friends has size 1
        ArrayList<String> people = friends;
            // Now people and friends refer to the same object
        people.add("Paul");
        System.out.println(friends);
    }
}
package ch09.sec04;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexDemo {
    public static void main(String[] args) {
        System.out.printf("%-30s%-30s%-20s\n", "Regex", "Input", "Matches");
        showMatches("a", "Java");
        showMatches(".", "Java");
        showMatches("\\x{1D546}", "The octonions \uD835\uDD46");
        showMatches("\\uD835\\uDD46", "The octonions \uD835\uDD46");
        showMatches("\\n", "Hello\nWorld");
        showMatches("\\cJ", "Hello\nWorld");
        showMatches("\\\\", "c:\\windows\\system");
        showMatches("\\Q.\\E", "Hello. World.");
        showMatches("[A-Za-z]", "San Jos\u00E9");
        showMatches("[^aeiou]", "Hello");
        showMatches("[\\p{L}&&[^A-Za-z]]", "San Jos\u00E9");
        showMatches("\\d", "99 bottles of beer");
        showMatches("\\w", "99 bottles of rosé");
        showMatches("\\s*,\\s*", "Hello, World");
        showMatches("(e|o).l", "Hello, World");
        showMatches("(['\"]).*\\1", "Hello, 'World'");
        showMatches("(?<quote>['\"]).*\\k<quote>", "Hello, 'World'");
        showMatches("(?:[a-z]:)?([\\\\/])\\w+(\\1\\w+)*", "c:\\windows\\system and /bin");
        showMatches("(?i:jpe?g)", "JPEG, jpeg, JPG, and jpg");
        showMatches("[0-9]{3,}", "99 bottles of 333");
        showMatches("<(.+?>).*</\\1", "<i>Hello</i>, <b>World</b>!");
        showMatches("'[^']*+'", "This 'joke' isn't funny.");
        showMatches("\\G\\w+,\\s*", "Athens, Rome, New York, Paris");
        showMatches("\\p{Punct}", "Hello, World!");
        showMatches("\\p{sc=Greek}", "2\u03C0r");
        showMatches("\\p{InLetterlike Symbols}", "Java\u2122");
        showMatches("\\pP", "Hello, World!"); // Ok to omit {} around one-letter properties
        showMatches("\\p{IsUppercase}", "Hello, World!");
        showMatches("\\p{javaJavaIdentifierStart}", "99 bottles");
    }

    public static void showMatches(String regex, String input) {
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(input);
        System.out.printf("%-30s%-30s", regex, input);
        while (matcher.find()) {
            String match = matcher.group();
            System.out.print(match + " ");
        }
        System.out.println();
    }
}
package ch01.sec04;

public class RelationalDemo {
    public static void main(String[] args) {
        int length = 10;
        int n = 7;
        System.out.println(0 <= n && n < length);

        // Short circuit evaluation
        int s = 30;
        System.out.println(n != 0 && s + (100 - s) / n < 50);
        n = 0;
        System.out.println(n != 0 && s + (100 - s) / n < 50);
        System.out.println(n == 0 || s + (1 - s) / n >= 50);

        int time = 7;
        System.out.println(time < 12 ? "am" : "pm");
    }
}
package ch09.sec04;

import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class RemovingOrReplacingMatches {
    public static void main(String[] args) {
        Pattern commas = Pattern.compile("\\s*,\\s*");
        CharSequence input = "Peter , Paul,  Mary";
        String[] tokens = commas.split(input);
        System.out.println(Arrays.toString(tokens));

        Stream<String> tokenStream = commas.splitAsStream(input);
        System.out.println(tokenStream.collect(Collectors.toList()));

        Matcher matcher = commas.matcher(input);
        String result = matcher.replaceAll(",");
        System.out.println(result);

        Pattern time = Pattern.compile("(\\d{1,2}):(\\d{2})");
        matcher = time.matcher("3:45");
        result = matcher.replaceAll("$1 hours and $2 minutes");
        System.out.println(result);

        result = "3:45".replaceAll(
                "(?<hours>\\d{1,2}):(?<minutes>\\d{2})",
                "${hours} hours and ${minutes} minutes");
        System.out.println(result);
    }
}
package ch03.sec06;

import java.util.function.IntConsumer;

public class RepeatDemo {

    public static void repeat(int n, Runnable action) {
        for (int i = 0; i < n; i++)
            action.run();
    }

    public static void repeat(int n, IntConsumer action) {
        for (int i = 0; i < n; i++)
            action.accept(i);
    }

    public static void repeatMessage(String text, int count) {
        Runnable r = () -> {
           for (int i = 0; i < count; i++) {
              System.out.println(text);
           }
        };
        new Thread(r).start();
     }

    public static void main(String[] args) {
        repeat(10, () -> System.out.println("Hello, World!"));
        repeat(10, i -> System.out.println("Countdown: " + (9 - i)));
        repeatMessage("Hello", 10);
    }
}
package ch13.sec07;

import java.text.MessageFormat;
import java.util.Locale;
import java.util.ResourceBundle;

public class ResourceBundleDemo {
    public static void main(String[] args) {
        System.out.println(Locale.getDefault(Locale.Category.DISPLAY));
        System.out.println(Locale.getDefault(Locale.Category.FORMAT));


        Locale.setDefault(Locale.Category.DISPLAY, Locale.forLanguageTag("en"));
        Locale.setDefault(Locale.Category.FORMAT, Locale.forLanguageTag("fr-FR"));
        // Locale locale = Locale.forLanguageTag("fr-FR");
        ResourceBundle res = ResourceBundle.getBundle("ch11.sec07.messages");
        String priceTemplate = res.getString("price");
        System.out.println(MessageFormat.format(priceTemplate, 19.95));
        System.out.println(res.getString("greeting"));
        System.out.println(res.getString("farewell"));
    }
}
package ch10.sec01;

import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class RunnableDemo {
    public static void main(String[] args) {
        Runnable hellos = () -> {
            for (int i = 1; i <= 1000; i++)
                System.out.println("Hello " + i);
        };
        Runnable goodbyes = () -> {
            for (int i = 1; i <= 1000; i++)
                System.out.println("Goodbye " + i);
        };

        ExecutorService executor = Executors.newCachedThreadPool();
        executor.execute(hellos);
        executor.execute(goodbyes);
        executor.shutdown();
    }
}package ch03.sec03;

public class RunnableDemo {
    public static void main(String[] args) {
        Runnable task = new HelloTask();
        Thread thread = new Thread(task);
        thread.start();
        System.out.println("Thread started");
    }
}

class HelloTask implements Runnable {
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("Hello, World!");
        }
    }
}package ch11.sec04;

public class RuntimeAnnotationDemo {
    public static void main(String[] args) {
        Rectangle rect = new Rectangle(new Point(10, 10), 20, 30);
        System.out.println(ToStrings.toString(rect));
    }
}
package ch03.sec07;

public class ScopeDemo {
    public static void main(String[] args) {
        repeatMessage("Hello", 10);


        for (String a : args)
            new Thread(() -> System.out.println(a));
    }

    public static void repeatMessage(String text, int count) {
        Runnable r = () -> {
           for (int i = 0; i < count; i++) {
              System.out.println(text);
           }
        };
        new Thread(r).start();
     }
}
package ch14.sec02;

import java.io.StringWriter;

import javax.script.Bindings;
import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

public class ScriptEngineDemo {
    public static void main(String[] args) throws ScriptException, NoSuchMethodException {
        ScriptEngineManager manager = new ScriptEngineManager();
        ScriptEngine engine = manager.getEngineByName("nashorn");
        String scriptString = "6 * 7";
        Object result = engine.eval(scriptString);
        System.out.println(result);

        engine.eval("n = 1728");
        result = engine.eval("n + 1");
        System.out.println(result);

        System.out.println(engine.getFactory().getParameter("THREADING"));

        engine.put("k", 1728);
        result = engine.eval("k + 1");
        System.out.println(result);
        engine.eval("n = 1728");
        result = engine.get("n");
        System.out.println(result);

        Bindings scope = engine.createBindings();
        scope.put("m", 1728);
        result = engine.eval("m + 1", scope);
        System.out.println(result);

        StringWriter writer = new StringWriter();
        engine.getContext().setWriter(writer);
        engine.eval("print('Hello'); java.lang.System.out.println('World')");
        System.out.println("writer.toString(): " + writer.toString());

        /*
        StringReader reader = new StringReader("Fred");
        engine.getContext().setReader(reader);
        engine.eval("name = new java.util.Scanner(java.lang.System.in).nextLine();  java.lang.System.out.println(name)");
        System.out.println("Done");
        */

        engine.eval("function greet(how, whom) { return how + ', ' + whom + '!' }");
        result = ((Invocable) engine).invokeFunction("greet", "Hello", "World");
        System.out.println(result);

        engine.eval("function Greeter(how) { this.how = how }");
        engine.eval("Greeter.prototype.welcome = function(whom) { return this.how + ', ' + whom + '!' }");
        Object yo = engine.eval("new Greeter('Yo')");
        result = ((Invocable) engine).invokeMethod(yo, "welcome", "World");
        System.out.println(result);

        engine.eval("function welcome(whom) { return 'Hello, ' + whom + '!' }");
        Greeter g1 = ((Invocable) engine).getInterface(Greeter.class);
        result = g1.welcome("World");
        System.out.println(result);

        Greeter g2 = ((Invocable) engine).getInterface(yo, Greeter.class);
        result = g2.welcome("World");
        System.out.println(result);

        JSON json = ((Invocable) engine).getInterface(engine.eval("JSON"), JSON.class);
        result = json.parse("{\"name\": \"Fred\", \"age\": 42}");
        System.out.println(result);
        result = json.stringify(result);
        System.out.println(result);
    }

    public interface Greeter {
        String welcome(String whom);
    }

    public interface JSON {
        Object parse(String str);
        String stringify(Object obj);
    }
}
package ch09.sec05;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import javafx.geometry.Point2D;

public class SerializationDemo {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Path path = Paths.get("employees.ser");
        try (ObjectOutputStream out = new ObjectOutputStream(
                Files.newOutputStream(path))) {
            Employee peter = new Employee("Fred", 90000);
            Employee paul = new Manager("Barney", 105000);
            Manager mary = new Manager("Mary", 180000);
            peter.setBoss(mary);
            paul.setBoss(mary);
            out.writeObject(peter);
            out.writeObject(paul);

            out.writeObject(new LabeledPoint("origin", new Point2D(0, 0)));

            out.writeObject(PersonDatabase.INSTANCE.findById(1));
        }
        try (ObjectInputStream in = new ObjectInputStream(
                Files.newInputStream(path))) {
            Employee e1 = (Employee) in.readObject();
            Employee e2 = (Employee) in.readObject();
            System.out.println(e1);
            System.out.println(e2);

            System.out.println(in.readObject());
            System.out.println(in.readObject());
        }
    }
}
package ch04.sec04;

import java.io.UnsupportedEncodingException;
import java.util.Optional;
import java.util.ServiceLoader;

public class ServiceLoaderDemo {
    public static ServiceLoader<Cipher> cipherLoader = ServiceLoader.load(Cipher.class);

    public static void main(String[] args) throws UnsupportedEncodingException {
        int strength = args.length == 0 ? 1 : Integer.parseInt(args[0]);
        Cipher cipher = getCipher(strength);
        String message = "Meet me at the toga party.";
        byte[] bytes = cipher.encrypt(message.getBytes(),
                new byte[] { 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3 });
        String encrypted = new String(bytes, "UTF-8");
        System.out.println(encrypted);
    }

    public static Cipher getCipher(int minStrength) {
        for (Cipher cipher : cipherLoader) // Implicitly calls iterator
            if (cipher.strength() >= minStrength) return cipher;
        return null;
    }

    public static Optional<Cipher> getCipher2(int minStrength) {
        return cipherLoader.stream().map(ServiceLoader.Provider::get).filter(c -> c.strength() >= minStrength).findFirst();
    }
}
package ch07.sec03;

import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class SetDemo {
    public static void main(String[] args) {
        Set<String> badWords = new HashSet<>();
        badWords.add("sex");
        badWords.add("drugs");
        badWords.add("c++");

        Scanner in = new Scanner(System.in);
        System.out.print("Please choose a user name: ");
        String username = in.next();
        if (badWords.contains(username.toLowerCase()))
            System.out.println("Please choose a different user name");
        else
            System.out.println("Registered " + username + " since it wasn't one of " + badWords);

        TreeSet<String> countries = new TreeSet<>((u, v) ->
            u.equals(v) ? 0
            : u.equals("USA") ? -1
            : v.equals("USA") ? 1
            : u.compareTo(v));

        countries.add("Bahrain");
        countries.add("Australia");
        countries.add("USA");
        countries.add("Canada");
        System.out.println(countries);
    }
}
package ch08.sec06;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.Optional;

public class SimpleReductions {
    public static void main(String[] args) throws IOException {
        String contents = new String(Files.readAllBytes(Paths.get("alice.txt")),
                StandardCharsets.UTF_8);
        List<String> words = List.of(contents.split("\\PL+"));

        Optional<String> largest = words.stream().max(String::compareToIgnoreCase);
        System.out.println("largest: " + largest.orElse(""));

        boolean aWordStartsWithQ = words.stream().anyMatch(s -> s.startsWith("Q"));
        System.out.println("aWordStartsWithQ: " + aWordStartsWithQ);

        Optional<String> startsWithQ = words.stream().parallel().filter(s -> s.startsWith("Q")).findAny();
        System.out.println("startsWithQ: " + startsWithQ.orElse("(None)"));
            // Run the program again to see if it finds a different word
    }
}
package ch04.sec03;

public enum Size {
    SMALL("S"), MEDIUM("M"), LARGE("L"), EXTRA_LARGE("XL");

    private String abbreviation;

    Size(String abbreviation) {
        this.abbreviation = abbreviation;
    }

    public String getAbbreviation() { return abbreviation; }
}package ch03.sec03;

import java.util.Arrays;
import java.util.Comparator;

public class SortDemo {
    public static void main(String[] args) {
        String[] friends = { "Peter", "Paul", "Mary" };
        Arrays.sort(friends); // friends is now ["Mary", "Paul", "Peter"]
        System.out.println(Arrays.toString(friends));

        friends = new String[] { "Peter", "Paul", "Mary" };
        Arrays.sort(friends, new LengthComparator());
        System.out.println(Arrays.toString(friends));
    }
}

class LengthComparator implements Comparator<String> {
    public int compare(String first, String second) {
        return first.length() - second.length();
    }
}
package ch11.sec05;

/*
Run these commands:

javac com/horstmann/annotations/ToStringAnnotationProcessor.java
javac -processor com.horstmann.annotations.ToStringAnnotationProcessor ch11/sec05/*.java
java ch11.sec05.SourceLevelAnnotationDemo

*/

public class SourceLevelAnnotationDemo {
    public static void main(String[] args) {
        Rectangle rect = new Rectangle(new Point(10, 10), 20, 30);
        System.out.println(com.horstmann.annotations.ToStrings.toString(rect));
    }
}
package ch03.sec01;

public class SquareSequence implements IntSequence {
    private int i;

    public boolean hasNext() {
        return true;
    }

    public int next() {
        i++;
        return i * i;
    }
}package ch07.sec05;

import java.util.ArrayDeque;
import java.util.Queue;

public class StackQueueDemo {
    public static void main(String[] args) {
        ArrayDeque<String> stack = new ArrayDeque<>();
        stack.push("Peter");
        stack.push("Paul");
        stack.push("Mary");
        while (!stack.isEmpty())
            System.out.println(stack.pop());

        System.out.println();

        Queue<String> queue = new ArrayDeque<>();
        queue.add("Peter");
        queue.add("Paul");
        queue.add("Mary");
        while (!queue.isEmpty())
            System.out.println(queue.remove());

    }
}
package ch05.sec01;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

public class StackTraceDemo {
    public static void bad() {
        System.out.println(1 / 0);
    }

    public static void goodOrBad(boolean ok) {
        if (ok) good(); else bad();
    }

    public static void good() {
        StackWalker walker = StackWalker.getInstance();
        walker.forEach(frame -> System.err.println("Frame: " + frame));
    }

    public static void main(String[] args) {
        try {
            goodOrBad(false);
        } catch (Exception ex) {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ex.printStackTrace(new PrintStream(out));
            String description = out.toString();
            System.out.println("The stack trace in a string: " + description.replaceAll("\\s+",  " "));
        }
        goodOrBad(true);
    }
}
    package ch11.sec03;

import java.lang.annotation.Inherited;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Array;
import java.util.Arrays;

import javax.annotation.Generated;

@Retention(RetentionPolicy.RUNTIME) @Inherited @interface Persistent { }

@Persistent class Employee {}
class Manager extends Employee {} // Also @Persistent

@Repeatable(TestCases.class)
@interface TestCase {
    String params();
    String expected();
}

@interface TestCases {
    TestCase[] value();
}

public class StandardAnnotations {
    public class Point {
        // @Override public boolean equals(Point other) { return false; }
    }

    public static <T> T[] nCopies(int n, T value) {
        Class<?> cl = value.getClass();
        @SuppressWarnings("unchecked") T[] result = (T[]) Array.newInstance(cl,  n);
        for (int i = 0; i < n; i++) result[i] = value;
        return result;
    }

    @Generated(value="com.horstmann.generator", date="2015-01-04T12:08:56.235-0700") String message = null;

    @FunctionalInterface
    public interface IntFunction<R> {
        R apply(int value);
        // void consume(R value);
    }

    @TestCase(params="4", expected="24")
    @TestCase(params="0", expected="1")
    public static long factorial(int n) { return 0; }

    public static void main(String[] args) {
        System.out.println(Arrays.toString(nCopies(3, "Hello")));
        System.out.println(Arrays.toString(IntFunction.class.getAnnotations()));
        System.out.println(Arrays.toString(Employee.class.getAnnotations()));
        System.out.println(Arrays.toString(Manager.class.getAnnotations()));
    }
}
package ch02.sec05;

import static java.lang.Math.*;

public class StaticImportDemo {
    public static void main(String[] args) {
        double x = 3;
        double y = 4;
        double hypothenuse = sqrt(pow(x, 2) + pow(y, 2)); // i.e., Math.sqrt, Math.pow
        System.out.println(hypothenuse);
    }
}
package ch02.sec04;

import java.text.NumberFormat;

public class StaticMethodDemo {
    public static void main(String[] args) {
        int dieToss = RandomNumbers.nextInt(1, 6);
        System.out.println(dieToss);

        NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
        NumberFormat percentFormatter = NumberFormat.getPercentInstance();
        double x = 0.1;
        System.out.println(currencyFormatter.format(x)); // Prints $0.10
        System.out.println(percentFormatter.format(x)); // Prints 10%
    }
}
package ch01.sec09;

import java.util.Scanner;

public class StaticMethodDemo {
    public static double average(double x, double y) {
        double sum = x + y;
        return sum / 2;
    }

    public static void main(String[] args) {
        System.out.print("Enter two numbers: ");
        Scanner in = new Scanner(System.in);
        double a = in.nextDouble();
        double b = in.nextDouble();
        double result = average(a, b);
        System.out.println("Average: " + result);
    }
}package ch09.sec01;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

public class StreamDemo {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get("alice.txt");
        try (InputStream in = Files.newInputStream(path)) {
            int firstByte = in.read();
            System.out.println("First byte: " + firstByte);
            byte[] moreBytes = new byte[1_000_000];
            int bytesRead = in.read(moreBytes);
            System.out.println("Bytes read: " + bytesRead);
        }

        byte[] allBytes = Files.readAllBytes(path);
        String contents = new String(allBytes, StandardCharsets.UTF_8);
        System.out.println(contents.substring(0, 50) + "...");

        byte[] helloBytes = { 72, 101, 108, 108, 111, 10 };
        path = Paths.get("test.txt");
        try (OutputStream out = Files.newOutputStream(path)) {
            out.write(helloBytes);
        }

        URL url = new URL("http://horstmann.com/index.html");
        try (InputStream in = url.openStream()) {
            Files.copy(in, Paths.get("index.html"), StandardCopyOption.REPLACE_EXISTING);
        }

        InputStream in = new ByteArrayInputStream(helloBytes);
        int n;
        do {
            n = in.read();
            System.out.println(n);
        } while (n != -1);

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        out.write(helloBytes);
        byte[] bytes = out.toByteArray();
        System.out.println(new String(bytes, StandardCharsets.UTF_8));
    }
}
package ch01.sec05;

import java.time.ZoneId;
import java.util.Arrays;

public class StringDemo {
    public static void main(String[] args) {
        String location = "Java";
        String greeting = "Hello " + location;
        System.out.println(greeting);
        int age = 42;
        String output = age + " years";
        System.out.println(output);

        System.out.println("Next year, you will be " + age + 1); // Error
        System.out.println("Next year, you will be " + (age + 1)); // Ok

        String names = String.join(", ", "Peter", "Paul", "Mary");
        System.out.println(names);

        // String builder

        StringBuilder builder = new StringBuilder();
        for (String id : ZoneId.getAvailableZoneIds()) {
            builder.append(id);
            builder.append(", ");
        }
        String result = builder.toString();
        System.out.println(result.substring(0, 200) + "...");
        System.out.println(result.length());

        // Substring

        greeting = "Hello, World!";
        location = greeting.substring(7, 12);
        System.out.println(location);

        // Equality testing

        System.out.println(location.equals("World"));
        System.out.println(location == "World");
        System.out.println(location.equalsIgnoreCase("world"));
        System.out.println("word".compareTo("world"));

        // Converting between numbers and strings
        int n = 42;
        String str = Integer.toString(n, 2);
        System.out.println(str);

        n = Integer.parseInt(str);
        System.out.println(n);
        n = Integer.parseInt(str, 2);
        System.out.println(n);
        double x = Double.parseDouble("3.14");
        System.out.println(x);

        System.out.println(greeting.toUpperCase());
        System.out.println(greeting); // greeting is not changed

        // Unicode
        String javatm = "Java\u2122";
        System.out.println(javatm);
        System.out.println(Arrays.toString(javatm.codePoints().toArray()));
        System.out.println(javatm.length());

        String octonions = "\ud835\udd46";
        System.out.println(octonions);
        System.out.println(Arrays.toString(octonions.codePoints().toArray()));
        System.out.println(octonions.length()); // Counts code units, not Unicode code points
    }
}
package ch14.sec01;

import java.net.URI;

import javax.tools.SimpleJavaFileObject;

public class StringSource extends SimpleJavaFileObject {
    private String code;

    StringSource(String name, String code) {
        super(URI.create("string:///" + name.replace('.','/') + ".java"),
              Kind.SOURCE);
        this.code = code;
    }

    public CharSequence getCharContent(boolean ignoreEncodingErrors) {
        return code;
    }
}package ch04.sec01;

public class Student extends Person implements Named {
    private int id;

    public Student(String name, int id) { super(name); this.id = id; }
    public int getId() { return id; }
}package ch04.sec01;

public class StudentDemo {
    public static void main(String[] args) {
        Person p = new Student("Fred", 1729); // OK, a concrete subclass
        System.out.println(p.getName());
        Student s = (Student) p;
        System.out.println(s.getName());
        Named n = s;
        System.out.println(n.getName());
    }
}
package ch11.sec02;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {
    long timeout() default 0L;
}package ch08.scratch;

import java.util.stream.*;

public class Test {
    private static int prev;
    public static void main(String[] args) {
        Stream<Integer> values = Stream.of(1, 2, 2, 3, 3, 3, 4, 2);
        values = values.filter( x -> {
            boolean r = prev != x;
            prev = x;
            return r; })
                .peek(x -> { return; });
        values.forEach(System.out::println);
    }
}
package ch09.sec01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Stream;

public class TextIO {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get("alice.txt");
        String content = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);
        System.out.println("Characters: " + content.length());
        List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8);
        System.out.println("Lines: " + lines.size());
        try (Stream<String> lineStream = Files.lines(path, StandardCharsets.UTF_8)) {
            System.out.println("Average line length: " + lineStream.mapToInt(String::length).average().orElse(0));
        }
        try (Scanner in = new Scanner(path, "UTF-8")) {
            in.useDelimiter("\\PL+");
            int words = 0;
            while (in.hasNext()) {
                in.next();
                words++;
            }
            System.out.println("Words: " + words);
        }


        URL url = new URL("http://horstmann.com/index.html");
        try (BufferedReader reader
                = new BufferedReader(new InputStreamReader(url.openStream()))) {
            Stream<String> lineStream = reader.lines();
            System.out.println("Average line length: " + lineStream.mapToInt(String::length).average().orElse(0));
        }

        path = Paths.get("hello.txt");
        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(path, StandardCharsets.UTF_8))) {
            out.println("Hello");
        }
        content = "World\n";
        Files.write(path, content.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);
        path = Paths.get("copyOfAlice.txt");
        Files.write(path, lines, StandardCharsets.UTF_8);

        StringWriter writer = new StringWriter();
        Throwable throwable = new IllegalStateException();
        throwable.printStackTrace(new PrintWriter(writer));
        String stackTrace = writer.toString();
        System.out.println("Stack trace: " + stackTrace);
    }
}
package ch10.sec08;

public class ThreadDemo {
    public static void main(String[] args) throws InterruptedException {
        Runnable task = () -> { for (int i = 1; i <= 100; i++) System.out.print(i + " ");  };
        Thread thread = new Thread(task);
        thread.start();
        System.out.println("Started thread.");
        thread.join();
        System.out.println("\nJoined thread.");

        Runnable interruptibleTask = () -> {
            System.out.print("\nInterruptible: ");
            try {
                for (int i = 1; i <= 100; i++) {
                    System.out.print(i + " ");
                    Thread.sleep(100);
                }
            }
            catch (InterruptedException ex) {
                System.out.println("Interrupted!");
            }
        };

        thread = new Thread(interruptibleTask);
        thread.start();
        Thread.sleep(1000);
        thread.interrupt();

        Runnable exceptionalTask = () -> {
            System.out.print("\nExceptional: ");
            for (int i = 1; i <= 100; i++) {
                System.out.print(i + " ");
                if (i == 42) throw new IllegalStateException();
            }
        };
        thread = new Thread(exceptionalTask);
        thread.setUncaughtExceptionHandler((t, ex) -> System.out.println("Yikes!"));
        thread.start();
        thread.join();

        Runnable daemonTask = () -> {
            System.out.print("\nDaemon: ");
            for (int i = 1; i <= 100; i++) {
                System.out.print(i + " ");
                // if (i == 42) Thread.currentThread().setDaemon(true);
            }
        };
        thread = new Thread(daemonTask);
        thread.setDaemon(true);
        thread.start();
        System.out.println("\nGoodbye daemon!");
    }
}
package ch10.sec08;

import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ThreadLocalDemo {
    public static final NumberFormat sharedFormatter
        = NumberFormat.getCurrencyInstance(); // BAD
    public static final ThreadLocal<NumberFormat> currencyFormat
        = ThreadLocal.withInitial(() -> NumberFormat.getCurrencyInstance()); // GOOD

    public static String asCurrency(double value) {
        NumberFormat formatter = currencyFormat.get();
        // formatter = sharedFormatter
        // Try this to see what happens...
        return formatter.format(value);
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executor = Executors.newCachedThreadPool();
        List<Callable<String>> tasks = new ArrayList<>();
        for (int i = 1; i < 100; i++) {
            double value = 1000.01 * i;;
            tasks.add(() -> asCurrency(value));
        }
        List<Future<String>> result = executor.invokeAll(tasks);
        for (Future<String> f : result)
            System.out.println(f.get());
    }
}package ch05.sec01;

public class ThrowDemo {
    public static int randInt(int low, int high) {
        if (low > high)
            throw new IllegalArgumentException(
                "low should be <= high but low is "
                + low + " and high is " + high);

        return low + (int)(Math.random() * (high - low + 1));
    }

    public static void main(String[] args) {
        System.out.println("Generating a random number...");
        int r = randInt(10, 20);
        System.out.println("r = " + r);
        System.out.println("And another...");
        r = randInt(10, 5);
        System.out.println("r = " + r);
    }
}
package ch12.sec01;

import java.time.Duration;
import java.time.Instant;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Timeline {
    public static void main(String[] args) {
        Instant start = Instant.now();
        runAlgorithm();
        Instant end = Instant.now();
        Duration timeElapsed = Duration.between(start, end);
        long millis = timeElapsed.toMillis();
        System.out.printf("%d milliseconds\n", millis);

        Instant start2 = Instant.now();
        runAlgorithm2();
        Instant end2 = Instant.now();
        Duration timeElapsed2 = Duration.between(start2, end2);
        System.out.printf("%d milliseconds\n", timeElapsed2.toMillis());
        boolean overTenTimesFaster = timeElapsed.multipliedBy(10).minus(timeElapsed2).isNegative();
        System.out.printf("The first algorithm is %smore than ten times faster",
                overTenTimesFaster ? "" : "not ");
    }

    public static void runAlgorithm() {
        int size = 10;
        List<Integer> list = new Random().ints().map(i -> i % 100).limit(size).boxed()
                .collect(Collectors.toList());
        Collections.sort(list);
        System.out.println(list);
    }

    public static void runAlgorithm2() {
        int size = 10;
        List<Integer> list = new Random().ints().map(i -> i % 100).limit(size).boxed()
                .collect(Collectors.toList());
        while (!IntStream.range(1, list.size()).allMatch(
                i -> list.get(i - 1).compareTo(list.get(i)) <= 0))
            Collections.shuffle(list);
        System.out.println(list);
    }
}
package com.horstmann.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.SOURCE)
public @interface ToString {
    boolean includeName() default true;
}package ch11.sec04;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ToString {
    boolean includeName() default true;
}package com.horstmann.annotations;

import java.beans.Introspector;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic.Kind;
import javax.tools.JavaFileObject;

@SupportedAnnotationTypes("com.horstmann.annotations.ToString")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class ToStringAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations,
            RoundEnvironment currentRound) {
        if (annotations.size() == 0) return true;
        try {
            JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("com.horstmann.annotations.ToStrings");
            try (PrintWriter out = new PrintWriter(sourceFile.openWriter())) {
                out.println("// Automatically generated by com.horstmann.annotations.ToStringAnnotationProcessor");
                out.println("package com.horstmann.annotations;");
                out.println("public class ToStrings {");

                for (Element e : currentRound.getElementsAnnotatedWith(ToString.class)) {
                    if (e instanceof TypeElement) {
                        TypeElement te = (TypeElement) e;
                            writeToStringMethod(out, te);
                    }
                }
                out.println("    public static String toString(Object obj) {");
                out.println("        return java.util.Objects.toString(obj);");
                out.println("    }");
                out.println("}");
            }
        } catch (IOException ex) {
            processingEnv.getMessager().printMessage(Kind.ERROR, ex.getMessage());
        }
        return true;
    }

    private void writeToStringMethod(PrintWriter out, TypeElement te) {
        String className = te.getQualifiedName().toString();
        out.println("    public static String toString(" + className + " obj) {");
        ToString ann = te.getAnnotation(ToString.class);
        out.println("        StringBuilder result = new StringBuilder();");
        if (ann.includeName()) out.println("        result.append(\"" + className + "\");");
        out.println("        result.append(\"[\");");
        boolean first = true;
        for (Element c : te.getEnclosedElements()) {
            String methodName = c.getSimpleName().toString();
            ann = c.getAnnotation(ToString.class);
            if (ann != null) {
                if (first) first = false; else out.println("        result.append(\",\");");
                if (ann.includeName()) {
                    String fieldName = Introspector.decapitalize(methodName.replaceAll("^(get|is)", ""));
                        // Turn getWidth into width, isDone into done, getURL into URL
                    out.println("        result.append(\"" + fieldName + "=" + "\");");
                }
                out.println("        result.append(toString(obj." + methodName + "()));");
            }
        }
        out.println("        result.append(\"]\");");
        out.println("        return result.toString();");
        out.println("    }");
    }
}// Automatically generated by com.horstmann.annotations.ToStringAnnotationProcessor
package com.horstmann.annotations;
public class ToStrings {
    public static String toString(ch11.sec05.Point obj) {
        StringBuilder result = new StringBuilder();
        result.append("[");
        result.append(toString(obj.getX()));
        result.append(",");
        result.append(toString(obj.getY()));
        result.append("]");
        return result.toString();
    }
    public static String toString(ch11.sec05.Rectangle obj) {
        StringBuilder result = new StringBuilder();
        result.append("ch11.sec05.Rectangle");
        result.append("[");
        result.append(toString(obj.getTopLeft()));
        result.append(",");
        result.append("width=");
        result.append(toString(obj.getWidth()));
        result.append(",");
        result.append("height=");
        result.append(toString(obj.getHeight()));
        result.append("]");
        return result.toString();
    }
    public static String toString(Object obj) {
        return java.util.Objects.toString(obj);
    }
}
package ch11.sec04;

import java.lang.reflect.Field;

public class ToStrings {
    public static String toString(Object obj) {
        if (obj == null) return "null";
        Class<?> cl = obj.getClass();
        ToString ts = cl.getAnnotation(ToString.class);
        if (ts == null) return obj.toString();
        StringBuilder result = new StringBuilder();
        if (ts.includeName()) result.append(cl.getName());
        result.append("[");
        boolean first = true;
        for (Field f : cl.getDeclaredFields()) {
            ts = f.getAnnotation(ToString.class);
            if (ts != null) {
                if (first) first = false; else result.append(",");
                f.setAccessible(true);
                if (ts.includeName()) {
                    result.append(f.getName());
                    result.append("=");
                }
                try {
                    result.append(ToStrings.toString(f.get(obj)));
                } catch (ReflectiveOperationException ex) {
                    ex.printStackTrace();
                }
            }
        }
        result.append("]");
        return result.toString();
    }
}package ch05.sec01;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class TryFinallyDemo {
    public static Lock myLock = new ReentrantLock();
    private static int counter = 0;

    public static void main(String[] args) throws InterruptedException{
        Thread[] threads = new Thread[2];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                try {
                    for (int k = 1; k <= 1000; k++) {
                        myLock.lock();
                        try {
                            counter++;
                            Thread.sleep(1);
                        } finally {
                            myLock.unlock();
                        }
                    }
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
            });
        }
        for (Thread t : threads) t.start();

        // Try this: (1) Uncomment the line below
        // threads[0].interrupt();
        // Run the program. What happens? Why?
        // (2) Now comment out the lines try {, } finally {, }
        // Run the program. What happens? Why?

        for (Thread t : threads) t.join();
        System.out.println(counter);
    }
}
package ch05.sec01;

import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Paths;
import java.util.List;
import java.util.Scanner;

public class TryWithResourcesDemo {
    public static void print(Scanner in, PrintWriter out) {
        try (in; out) { // Effectively final variables
            while (in.hasNext())
                out.println(in.next().toLowerCase());
        }
    }

    public static void main(String[] args) throws IOException {
        List<String> lines = List.of("Mary had a little lamb. Its fleece was white as snow.".split(" "));
        try (PrintWriter out = new PrintWriter("/tmp/output1.txt")) {
            for (String line : lines) {
                out.println(line.toLowerCase());
            }
        }
        try (Scanner in = new Scanner(Paths.get("/usr/share/dict/words"));
                PrintWriter out = new PrintWriter("/tmp/output2.txt")) {
            while (in.hasNext())
                out.println(in.next().toLowerCase());
        }

        PrintWriter out3 = new PrintWriter("/tmp/output3.txt");
        try (out3) {
            for (String line : lines) {
                out3.println(line.toLowerCase());
            }
        }
    }
}package ch01.sec08;

import java.util.Arrays;

public class TwoDimensionalArrayDemo {
    public static void main(String[] args) {
        int[][] square = {
                { 16, 3, 2, 13 },
                { 3, 10, 11, 8 },
                { 9, 6, 7, 12 },
                { 4, 15, 14, 1}
            };

        // Swap two rows
        int[] temp = square[0];
        square[0] = square[1];
        square[1] = temp;
        System.out.println(Arrays.deepToString(square));

        int n = 5;
        int[][] triangle = new int[n][];
        for (int i = 0; i < n; i++) {
            triangle[i] = new int[i + 1];
            triangle[i][0] = 1;
            triangle[i][i] = 1;
            for (int j = 1; j < i; j++) {
                triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
            }
        }
        for (int r = 0; r < triangle.length; r++) {
            for (int c = 0; c < triangle[r].length; c++) {
                System.out.printf("%4d", triangle[r][c]);
            }
            System.out.println();
        }
        for (int[] row : triangle) {
            for (int element : row) {
               System.out.printf("%4d", element);
            }
            System.out.println();
        }
    }
}
package ch11.sec01;

import java.io.IOException;
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.util.Comparator;
import java.util.List;
import java.util.function.Function;

@Target(ElementType.TYPE_USE) @interface NonNull {}
@Target(ElementType.TYPE_USE) @interface Localized {}

public abstract class TypeUseAnnotations {
    List<@NonNull String> entries;
    Comparator<?> comp = Comparator.<@NonNull String> reverseOrder();
    @NonNull String[][] words;
    String @NonNull [][] moreWords;
    String[] @NonNull [] evenMoreWords;
    class Warning extends @Localized Message {}

    public static String text = new @Localized String("");
    public static String moreText = (@Localized String) "";
    public static String evenMoreText = text instanceof @Localized String ? text : null;
    public String read() throws @Localized IOException { return null; }

    public class Message { public String getText() { return ""; } }
    List<@Localized ? extends Message> warnings;
    List<? extends @Localized Message> greetings;
    Function<Message, String> fun = @Localized Message::getText;
}package ch01.sec09;

public class VarargsDemo {
    public static double average(double... values) {
        double sum = 0;
        for (double v : values) sum += v;
        return values.length == 0 ? 0 : sum / values.length;
    }

    public static double max(double first, double... rest) {
        double result = first;
        for (double v : rest) result = Math.max(v, result);
        return result;
    }

    public static void main(String[] args) {
        int n = 42;
        System.out.printf("%d\n", n);
        System.out.printf("%d %s\n", n, "widgets");

        double[] scores = { 3, 4.5, 10, 0 };
        double avg = average(scores);
        System.out.println(avg);
        double largest = max(3, 4.5, 10, 0);
        System.out.println(largest);
            // average() returns 0, but max() doesn't compile
    }
}package ch01.sec03;

import java.util.Random;

public class VariableDemo {
    public static final int DAYS_PER_YEAR = 365;

    enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN };

    public static void main(String[] args) {
        int total = 0;
        int i = 0, count;
        Random generator = new Random();
        double lotsa$ = 1000000000.0; // Legal, but not a good idea
        double élévation = 0.0;
        double π = 3.141592653589793;
        String Count = "Dracula"; // Not the same as count
        int countOfInvalidInputs = 0; // Example of camelCase
        final int DAYS_PER_WEEK = 7;
        Weekday startDay = Weekday.MON;
        // The following line would cause an error since count has not been initialized
        // System.out.println(count);
    }
}
package ch10.sec03;

import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class VisibilityDemo {
    private static boolean done = false; // add volatile

    public static void main(String[] args) {
        Runnable hellos = () -> {
            for (int i = 1; i <= 1000; i++)
                System.out.println("Hello " + i);
            done = true;
        };
        Runnable goodbye = () -> {
            int i = 1;
            while (!done) i++;
            System.out.println("Goodbye " + i);
        };
        Executor executor = Executors.newCachedThreadPool();
        executor.execute(hellos);
        executor.execute(goodbye);
    }
}package ch10.sec02;

import java.net.URL;
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TextArea;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class WebReader extends Application {
    private TextArea message;
    private ExecutorService executor = Executors.newCachedThreadPool();

    public void start(Stage stage) {
        message = new TextArea("");
        VBox pane = new VBox(10);
        HBox box = new HBox(10);
        Button read = new Button("Read");
        String url = "http://horstmann.com";
        read.setOnAction(event -> read(url));
        Button quit = new Button("Quit");
        quit.setOnAction(event -> System.exit(0));
        box.getChildren().addAll(read, quit);
        pane.getChildren().addAll(message, box);
        pane.setPadding(new Insets(10));
        stage.setScene(new Scene(pane));
        stage.setTitle("Hello");
        stage.show();
    }

    public void read(String url) {
        Runnable task = () -> {
            try {
                try (Scanner in = new Scanner(new URL(url).openStream())) {
                    while (in.hasNextLine()) {
                        Platform.runLater(() ->
                            message.appendText(in.nextLine() + "\n"));
                        Thread.sleep(100);
                    }
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        };
        executor.submit(task);
    }
}package ch01.sec07;

import java.util.*;

public class WhileDemo {
   public static void main(String[] args) {
      Random generator = new Random();
      int sum = 0;
      int count = 0;
      int target = 90;
      while (sum < target) {
         int next = generator.nextInt(10);
         sum = sum + next;
         count++;
      }
      System.out.println("After " + count
         + " iterations, the sum is " + sum);
   }
}
package ch06.sec05;

import java.util.ArrayList;
import java.util.List;

    public class WordList extends ArrayList<String> {
        public boolean add(String e) {
            return isBadWord(e) ? false : super.add(e);
        }

        public String get(int i) {
            return super.get(i).toLowerCase();
        }

        public static boolean isBadWord(String s) {
            return List.of("sex", "drugs", "c++").contains(s.toLowerCase());
        }
    }package ch06.sec05;

import java.util.ArrayList;

public class WordListDemo {
    public static void main(String[] args) {
        WordList words = new WordList();
        ArrayList<String> strings = words; // Ok—conversion to superclass
        strings.add("Hello");
        strings.add("C++");
        System.out.println(words);
    }
}
package ch04.sec01;

public class Worker {
    public void work() {
        for (int i = 0; i < 100; i++) System.out.println("Working");
    }
}package ch09.sec02;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.stream.Stream;

public class ZipDemo {
    public static void main(String[] args) throws IOException, URISyntaxException {
        Path javaHome = Paths.get(System.getProperty("java.home"));
        Path zipFile = javaHome.getParent().resolve("src.zip");
        if (!Files.exists(zipFile)) {
            System.err.println(zipFile + " does not exist.");
            return;
        }

        String sourceName = "java/lang/String.java";
        Path tempDir = Files.createTempDirectory("corejava");
        Path targetPath = tempDir.resolve(sourceName);
        Files.createDirectories(targetPath.getParent());
        try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, null)) {
            Files.copy(zipfs.getPath(sourceName), targetPath);
            Files.lines(targetPath).limit(40).forEach(System.out::println);
            System.out.println("\nFiles that don't end in .java:");
            try (Stream<Path> entries = Files.walk(zipfs.getPath("/"))) {
                entries.filter(p -> Files.isRegularFile(p) && !p.toString().endsWith(".java"))
                    .forEach(System.out::println);
            }
        }

        Path zipPath = tempDir.resolve("myfile.zip");
        URI uri = new URI("jar", zipPath.toUri().toString(), null);
        // Constructs the URI jar:file://myfile.zip
        try (FileSystem zipfs = FileSystems.newFileSystem(uri,
                Collections.singletonMap("create", "true"))) {
            // To add files, copy them into the ZIP file system
            Path filePath = targetPath;
            Files.copy(filePath, zipfs.getPath("/").resolve("String.java"));
        }
        System.out.println("Made zip file at " + zipPath);
    }
}
package ch12.sec05;

import java.time.*;

public class ZonedTimes {
    public static void main(String[] args) {
        ZonedDateTime apollo11launch = ZonedDateTime.of(1969, 7, 16, 9, 32, 0, 0,
            ZoneId.of("America/New_York"));
        // 1969-07-16T09:32-04:00[America/New_York]
        System.out.println("apollo11launch: " + apollo11launch);

        Instant instant = apollo11launch.toInstant();
        System.out.println("instant: " + instant);

        ZonedDateTime zonedDateTime = instant.atZone(ZoneId.of("UTC"));
        System.out.println("zonedDateTime: " + zonedDateTime);

        ZonedDateTime skipped = ZonedDateTime.of(
            LocalDate.of(2013, 3, 31),
            LocalTime.of(2, 30),
            ZoneId.of("Europe/Berlin"));
        // Constructs March 31 3:30
        System.out.println("skipped: " + skipped);

        ZonedDateTime ambiguous = ZonedDateTime.of(
            LocalDate.of(2013, 10, 27),
            // End of daylight savings time
            LocalTime.of(2, 30),
            ZoneId.of("Europe/Berlin"));
        // 2013-10-27T02:30+02:00[Europe/Berlin]
        ZonedDateTime anHourLater = ambiguous.plusHours(1);
        // 2013-10-27T02:30+01:00[Europe/Berlin]
        System.out.println("ambiguous: " + ambiguous);
        System.out.println("anHourLater: " + anHourLater);

        ZonedDateTime meeting = ZonedDateTime.of(
            LocalDate.of(2013, 10, 31),
            LocalTime.of(14, 30),
            ZoneId.of("America/Los_Angeles"));
        System.out.println("meeting: " + meeting);
        ZonedDateTime nextMeeting = meeting.plus(Duration.ofDays(7));
        // Caution! Won’t work with daylight savings time
        System.out.println("nextMeeting: " + nextMeeting);
        nextMeeting = meeting.plus(Period.ofDays(7)); // OK
        System.out.println("nextMeeting: " + nextMeeting);
    }
}
