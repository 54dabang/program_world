1.1 C++简介
1.2 C++简史
1.2.1 C语言
1.2.2 C语言编程原理
1.2.3 面向对象编程
1.2.4 C++和泛型编程
1.2.5 C++的起源
1.3 可移植性和标准
1.3.1 C++的发展
1.3.2 本书遵循的C++标准
1.4 程序创建的技巧
1.4.1 创建源代码文件
1.4.2 编译和链接
1.5 总结

第2章 开始学习C++
2.1 进入C++
2.1.1 main( )函数
2.1.2 C++注释
2.1.3 C++预处理器和iostream文件
2.1.4 头文件名
2.1.5 名称空间
2.1.6 使用cout进行C++输出
2.1.7 C++源代码的格式化
2.2 C++语句
2.2.1 声明语句和变量
2.2.2 赋值语句
2.2.3 cout的新花样
2.3 其他C++语句
2.3.1 使用cin
2.3.2 使用cout进行拼接
2.3.3 类简介
2.4 函数
2.4.1 使用有返回值的函数
2.4.2 函数变体
2.4.3 用户定义的函数
2.4.4 用户定义的有返回值的函数
2.4.5 在多函数程序中使用using编译指令
2.5 总结
2.6 复习题
2.7 编程练习

第3章 处理数据
3.1 简单变量
3.1.1 变量名
3.1.2 整型
3.1.3 整型short、int、long和long long
3.1.4 无符号类型
3.1.5 选择整型类型
3.1.6 整型字面值
3.1.7 C++如何确定常量的类型
3.1.8 char类型：字符和小整数
3.1.9 bool类型
3.2 const限定符
3.3 浮点数
3.3.1 书写浮点数
3.3.2 浮点类型
3.3.3 浮点常量
3.3.4 浮点数的优缺点
3.4 C++算术运算符
3.4.1 运算符优先级和结合性
3.4.2 除法分支
3.4.3 求模运算符
3.4.4 类型转换
3.4.5 C++11中的auto声明
3.5 总结
3.6 复习题
3.7 编程练习

第4章 复合类型
4.1 数组
4.1.1 程序说明
4.1.2 数组的初始化规则
4.1.3 C++11数组初始化方法
4.2 字符串
4.2.1 拼接字符串常量
4.2.2 在数组中使用字符串
4.2.3 字符串输入
4.2.4 每次读取一行字符串输入
4.2.5 混合输入字符串和数字
4.3 string类简介
4.3.1 C++11字符串初始化
4.3.2 赋值、拼接和附加
4.3.3 string类的其他操作
4.3.4 string类I/O
4.3.5 其他形式的字符串字面值
4.4 结构简介
4.4.1 在程序中使用结构
4.4.2 C++11结构初始化
4.4.3 结构可以将string类作为成员吗
4.4.4 其他结构属性
4.4.5 结构数组
4.4.6 结构中的位字段
4.5 共用体
4.6 枚举
4.6.1 设置枚举量的值
4.6.2 枚举的取值范围
4.7 指针和自由存储空间
4.7.1 声明和初始化指针
4.7.2 指针的危险
4.7.3 指针和数字
4.7.4 使用new来分配内存
4.7.5 使用delete释放内存
4.7.6 使用new来创建动态数组
4.8 指针、数组和指针算术
4.8.1 程序说明
4.8.2 指针小结
4.8.3 指针和字符串
4.8.4 使用new创建动态结构
4.8.5 自动存储、静态存储和动态存储
4.9 类型组合
4.10 数组的替代品
4.10.1 模板类vector
4.10.2 模板类array（C++11）
4.10.3 比较数组、vector对象和array对象
4.11 总结
4.12 复习题
4.13 编程练习

第5章 循环和关系表达式
5.1 for循环
5.1.1 for循环的组成部分
5.1.2 回到for循环
5.1.3 修改步长
5.1.4 使用for循环访问字符串
5.1.5 递增运算符（++）和递减运算符（--）
5.1.6 副作用和顺序点
5.1.7 前缀格式和后缀格式
5.1.8 递增/递减运算符和指针
5.1.9 组合赋值运算符
5.1.10 复合语句（语句块）
5.1.11 其他语法技巧--逗号运算符
5.1.12 关系表达式
5.1.13 赋值、比较和可能犯的错误
5.1.14 C-风格字符串的比较
5.1.15 比较string类字符串
5.2 while循环
5.2.1 for与while
5.3.2 等待一段时间：编写延时循环
5.3 do while循环
5.4 基于范围的for循环（C++11）
5.5 循环和文本输入
5.5.1 使用原始的cin进行输入
5.5.2 使用cin.get(char)进行补救
5.5.3 使用哪一个cin.get( )
5.5.4 文件尾条件
5.5.5 另一个cin.get( )版本
5.6 嵌套循环和二维数组
5.6.1 初始化二维数组
5.6.2 使用二维数组
5.7 总结
5.8 复习题
5.9 编程练习

第6章 分支语句和逻辑运算符
6.1 if语句
6.1.1 if else语句
6.1.2 格式化if else语句
6.1.3 if else if else结构
6.2 逻辑表达式
6.2.1 逻辑OR运算符：||
6.2.2 逻辑AND运算符：&&
6.2.3 用&&来设置取值范围
6.2.4 逻辑NOT运算符：！
6.2.5 逻辑运算符细节
6.2.6 其他表示方式
6.3 字符函数库cctype
6.4 ？：运算符
6.5 switch语句
6.5.1 将枚举量用作标签
6.5.2 switch和if else
6.6 break和continue语句
6.7 读取数字的循环
6.8 简单文件输入/输出
6.8.1 文本I/O和文本文件
6.8.2 写入到文本文件中
6.8.3 读取文本文件
6.9 总结
6.10 复习题
6.11 编程练习

第7章 函数--C++的编程模块
7.1 复习函数的基本知识
7.1.1 定义函数
7.1.2 函数原型和函数调用
7.2 函数参数和按值传递
7.2.1 多个参数
7.2.2 另外一个接受两个参数的函数
7.3 函数和数组
7.3.1 函数如何使用指针来处理数组
7.3.2 将数组作为参数意味着什么
7.3.3 更多数组函数示例
7.3.4 使用数组区间的函数
7.3.5 指针和const
7.4 函数和二维数组
7.5 函数和C-风格字符串
7.5.1 将C-风格字符串作为参数的函数
7.5.2 返回c-风格字符串的函数
7.6 函数和结构
7.6.1 传递和返回结构
7.6.2 另一个处理结构的函数示例
7.6.3 传递结构的地址
7.7 函数和string对象
7.8 函数与array对象
7.9 递归
7.9.1 包含一个递归调用的递归
7.9.2 包含多个递归调用的递归
7.10 函数指针
7.10.1 函数指针的基础知识
7.10.2 函数指针示例
7.10.3 深入探讨函数指针
7.10.4 使用typedef进行简化
7.11 总结
7.12 复习题
7.13 编程练习

第8章 函数探幽
8.1 C++内联函数
8.2 引用变量
8.2.1 创建引用变量
8.2.2 将引用用作函数参数
8.2.3 引用的属性和特别之处
8.2.4 将引用用于结构
8.2.5 将引用用于类对象
8.2.6 对象、继承和引用
8.2.7 何时使用引用参数
8.3 默认参数
8.4 函数重载
8.4.1 重载示例
8.4.2 何时使用函数重载
8.5 函数模板
8.5.1 重载的模板
8.5.2 模板的局限性
8.5.3 显式具体化
8.5.4 实例化和具体化
8.5.5 编译器选择使用哪个函数版本
8.5.6 模板函数的发展
8.6 总结
8.7 复习题
8.8 编程练习

第9章 内存模型和名称空间
9.1 单独编译
9.2 存储持续性、作用域和链接性
9.2.1 作用域和链接
9.2.2 自动存储持续性
9.2.3 静态持续变量
9.2.4 静态持续性、外部链接性
9.2.5 静态持续性、内部链接性
9.2.6 静态存储持续性、无链接性
9.2.7 说明符和限定符
9.2.8 函数和链接性
9.2.9 语言链接性
9.2.10 存储方案和动态分配
9.3 名称空间
9.3.1 传统的C++名称空间
9.3.2 新的名称空间特性
9.3.3 名称空间示例
9.3.4 名称空间及其前途
9.4 总结
9.5 复习题
9.6 编程练习

第10章 对象和类
10.1 过程性编程和面向对象编程
10.2 抽象和类
10.2.1 类型是什么
10.2.2 C++中的类
10.2.3 实现类成员函数
10.2.4 使用类
10.2.5 修改实现
10.2.6 小结
10.3 类的构造函数和析构函数
10.3.1 声明和定义构造函数
10.3.2 使用构造函数
10.3.3 默认构造函数
10.3.4 析构函数
10.3.5 改进Stock类
10.3.6 构造函数和析构函数小结
10.4 this指针
10.5 对象数组
10.6 类作用域
10.6.1 作用域为类的常量
10.6.2 作用域内枚举（C++11）
10.7 抽象数据类型
10.8 总结
10.9 复习题
10.11 编程练习

第11章 使用类
11.1 运算符重载
11.2 计算时间：一个运算符重载示例
11.2.1 添加加法运算符
11.2.2 重载限制
11.2.3 其他重载运算符
11.3 友元
11.3.1 创建友元
11.3.2 常用的友元：重载<<运算符
11.4 重载运算符：作为成员函数还是非成员函数
11.5 再谈重载：一个矢量类
11.5.1 使用状态成员
11.5.2 为Vector类重载算术运算符
11.5.3 对实现的说明
11.5.4 使用Vector类来模拟随机漫步
11.6 类的自动转换和强制类型转换
11.6.1 转换函数
11.6.2 转换函数和友元函数
11.7 总结
11.8 复习题
11.9 编程练习

第12章 类和动态内存分配
12.1 动态内存和类
12.1.1 复习示例和静态类成员
12.1.2 特殊成员函数
12.1.3 回到Stringbad：复制构造函数的哪里出了问题
12.1.4 Stringbad的其他问题：赋值运算符
12.2 改进后的新String类
12.2.1 修订后的默认构造函数
12.2.2 比较成员函数
12.2.3 使用中括号表示法访问字符
12.2.4 静态类成员函数
12.2.5 进一步重载赋值运算符
12.3 在构造函数中使用new时应注意的事项
12.3.1 应该和不应该
12.3.2 包含类成员的类的逐成员复制
12.4 有关返回对象的说明
12.4.1 返回指向const对象的引用
12.4.2 返回指向非const对象的引用
12.4.3 返回对象
12.4.4 返回const对象
12.5 使用指向对象的指针
12.5.1 再谈new和delete
12.5.2 指针和对象小结
12.5.3 再谈定位new运算符
12.6 复习各种技术
12.6.1 重载<<运算符
12.6.2 转换函数
12.6.3 其构造函数使用new的类
12.7 队列模拟
12.7.1 队列类
12.7.2 Customer类
12.7.3 ATM模拟
12.8 总结
12.9 复习题
12.10 编程练习

第13章 类继承
13.1 一个简单的基类
13.1.1 派生一个类
13.1.2 构造函数：访问权限的考虑
13.1.3 使用派生类
13.1.4 派生类和基类之间的特殊关系
13.2 继承：is-a关系
13.3 多态公有继承
13.3.1 开发Brass类和BrassPlus类
13.4 静态联编和动态联编
13.4.1 指针和引用类型的兼容性
13.4.2 虚成员函数和动态联编
13.4.3 有关虚函数注意事项
13.5 访问控制：protected
13.6 抽象基类
13.6.1 应用ABC概念
13.6.2 ABC理念
13.7 继承和动态内存分配
13.7.1 第一种情况：派生类不使用new
13.7.2 第二种情况：派生类使用new
13.7.3 使用动态内存分配和友元的继承示例
13.8 类设计回顾
13.8.1 编译器生成的成员函数
13.8.2 其他的类方法
13.8.3 公有继承的考虑因素
13.8.4 类函数小结
13.9 总结
13.10 复习题
13.11 编程练习

第14章 C++中的代码重用
14.1 包含对象成员的类
14.1.1 valarray类简介
14.1.2 Student类的设计
14.1.3 Student类示例
14.2 私有继承
14.2.1 Student类示例（新版本）
14.2.2 使用包含还是私有继承
14.2.3 保护继承
14.2.4 使用using重新定义访问权限
14.3 多重继承
14.3.1 有多少Worker
14.3.2 哪个方法
14.3.3 MI小结
14.4 类模板
14.4.1 定义类模板
14.4.2 使用模板类
14.4.3 深入探讨模板类
14.4.4 数组模板示例和非类型参数
14.4.5 模板多功能性
14.4.6 模板的具体化
14.4.7 成员模板
14.4.8 将模板用作参数
14.4.9 模板类和友元
14.4.10 模板别名（C++11）
14.5 总结
14.6 复习题
14.7 编程练习

第15章 友元、异常和其他
15.1 友元
15.1.1 友元类
15.1.2 友元成员函数
15.1.3 其他友元关系
15.2 嵌套类
15.2.1 嵌套类和访问权限
15.2.2 模板中的嵌套
15.3 异常
15.3.1 调用abort( )
15.3.2 返回错误码
15.3.3 异常机制
15.3.4 将对象用作异常类型
15.3.4 异常规范和C++11
15.3.5 栈解退
15.3.6 其他异常特性
15.3.7 exception类
15.3.8 异常、类和继承
15.3.9 异常何时会迷失方向
15.3.10 有关异常的注意事项
15.4 RTTI
15.4.1 RTTI的用途
15.4.2 RTTI的工作原理
15.5 类型转换运算符
15.6 总结
15.7 复习题
15.8 编程练习

第16章 string类和标准模板库
16.1 string类
16.1.1 构造字符串
16.1.2 string类输入
16.1.3 使用字符串
16.1.4 string还提供了哪些功能
16.1.5 字符串种类
16.2 智能指针模板类
16.2.1 使用智能指针
16.2.2 有关智能指针的注意事项
16.2.3 unique_ptr为何优于auto_ptr
16.2.4 选择智能指针
16.3 标准模板库
16.3.1 模板类vector
16.3.2 可对矢量执行的操作
16.3.3 对矢量可执行的其他操作
16.3.4 基于范围的for循环（C++11）
16.4 泛型编程
16.4.1 为何使用迭代器
16.4.2 迭代器类型
16.4.3 迭代器层次结构
16.4.4 概念、改进和模型
16.4.5 容器种类
16.4.4 关联容器
16.4.5 无序关联容器（C++11）
16.5 函数对象
16.5.1 函数符概念
16.5.2 预定义的函数符
16.5.3 自适应函数符和函数适配器
16.6 算法
16.6.1 算法组
16.6.2 算法的通用特征
16.6.3 STL和string类
16.6.4 函数和容器方法
16.6.5 使用STL
16.7 其他库
16.7.1 vector、valarray和array
16.7.2 模板initializer_list（C++11）
16.7.3 使用initializer_list
16.8 总结
16.9 复习题
16.10 编程练习

第17章 输入、输出和文件
17.1 C++输入和输出概述
17.1.1 流和缓冲区
17.1.2 流、缓冲区和iostream文件
17.1.3 重定向
17.2 使用cout进行输出
17.2.1 重载的<<运算符
17.2.2 其他ostream方法
17.2.3 刷新输出缓冲区
17.2.4 用cout进行格式化
17.3 使用cin进行输入
17.3.1 cin>>如何检查输入
17.3.2 流状态
17.3.3 其他istream类方法
17.3.4 其他istream方法
17.4 文件输入和输出
17.4.1 简单的文件I/O
17.4.2 流状态检查和is_open( )
17.4.3 打开多个文件
17.4.3 命令行处理技术
17.4.5 文件模式
17.4.6 随机存取
17.5 内核格式化
17.6 总结
17.7 复习题
17.8 编程练习

第18章 探讨C++新标准
18.1 复习前面介绍过的C++11功能
18.1.1 新类型
18.8.2 统一的初始化
18.1.3 声明
18.1.4 智能指针
18.1.5 异常规范方面的修改
18.1.6 作用域内枚举
18.1.7 对类的修改
18.1.8 模板和STL方面的修改
18.1.9 右值引用
18.2 移动语义和右值引用
18.2.1 为何需要移动语义
18.2.2 一个移动示例
18.2.3 移动构造函数解析
18.2.4 赋值
18.2.5 强制移动
18.3 新的类功能
18.3.1 特殊的成员函数
18.3.2 默认的方法和禁用的方法
18.3.3 委托构造函数
18.3.4 继承构造函数
18.3.5 管理虚方法：override和final
18.4 Lambda函数
18.4.1 比较函数指针、函数符和Lambda函数
18.4.2 为何使用lambda
18.5 包装器
18.5.1 包装器function及模板的低效性
18.5.2 修复问题
18.5.3 其他方式
18.6 可变参数模板
18.6.1 模板和函数参数包
18.6.2 展开参数包
18.6.3 在可变参数模板函数中使用递归
18.7 C++11新增的其他功能
18.7.1 并行编程
18.7.2 新增的库
18.7.3 低级编程
18.7.4 杂项
18.8 语言变化
18.8.1 Boost项目
18.8.2 TR1
18.8.3 使用Boost
18.9 接下来的任务
18.10 总结
18.11 复习题
18.12 编程练习
附录A 计数系统
A.1 十进制数
A.2 八进制整数
A.3 十六进制数
A.4 二进制数
A.5 二进制和十六进制
附录B C++保留字
B.1 C++关键字
B.2 替代标记
B.3 C++库保留名称
B.4 有特殊含义的标识符
附录C ASCII字符集
附录D 运算符优先级
附录E 其他运算符
E.1 按位运算符
E.1.1 移位运算符
E.1.2 逻辑按位运算符
E.1.3 按位运算符的替代表示
E.1.4 几种常用的按位运算符技术
E.2 成员解除引用运算符
E.3 alignof（C++11）
E.4 noexcept（C++11）
附录F 模板类string
F.1 13种类型和一个常量
F.2 数据信息、构造函数及其他
F.2.1 默认构造函数
F.2.2 使用C-风格字符串的构造函数
F.2.3 使用部分C-风格字符串的构造函数
F.2.4 使用左值引用的构造函数
F.2.5 使用右值引用的构造函数（C++11）
F.2.6 使用一个字符的n个副本的构造函数
F.2.7 使用区间的构造函数
F.2.8 使用初始化列表的构造函数（C++11）
F.2.9 内存杂记
F.3 字符串存取
F.4 基本赋值
F.5 字符串搜索
F.5.1 find( )系列
F.5.2 rfind( )系列
F.5.3 find_first_of( )系列
F.5.4 find_last_of( )系列
F.5.5 find_first_not_of( )系列
F.5.6 find_last_not_of( )系列
F.6 比较方法和函数
F.7 字符串修改方法
F.7.1 用于追加和相加的方法
F.7.2 其他赋值方法
F.7.3 插入方法
F.7.4 清除方法
F.7.5 替换方法
F.7.6 其他修改方法：copy( )和swap( )
F.8 输出和输入
附录G 标准模板库方法和函数
G.1 STL和C++11
G.1.1 新增的容器
G.1.2 对C++98容器所做的修改
G.2 大部分容器都有的成员
G.3 序列容器的其他成员
G.4 set和map的其他操作
G.4 无序关联容器（C++11）
G.5 STL函数
G.5.1 非修改式序列操作
G.5.2 修改式序列操作
G.5.3 排序和相关操作
G.5.4 数值运算
附录H 精选读物和网上资源
H.1 精选读物
H.2 网上资源
附录I 转换为ISO标准C++
I.1 使用一些预处理器编译指令的替代品
I.1.1 使用const而不是#define来定义常量
I.1.2 使用inline而不是# define来定义小型函数
I.2 使用函数原型
I.3 使用类型转换
I.4 熟悉C++特性
I.5 使用新的头文件
I.6 使用名称空间
I.7 使用智能指针
I.8 使用string类
I.9 使用STL
附录J 复习题答案
第2章复习题答案
第3章复习题答案
第4章复习题答案
第5章复习题答案
第6章复习题答案
第7章复习题答案
第8章复习题答案
第9章复习题答案
第10章复习题答案
第11章复习题答案
第12章复习题答案
第13章复习题答案
第14章复习题答案
第15章复习题答案
第16章复习题答案
第17章复习题答案
第18章复习题答案

《C Primer Plus 第6版 中文版》
第1章　初识C语言 1
1．1　C语言的起源 1
1．2 选择C语言的理由 1
1．2．1 设计特性 1
1．2．2 高效性 1
1．2．3 可移植性 2
1．2．4 强大而灵活 3
1．2．5 面向程序员 3
1．2．6 缺点 3
1．3 C语言的应用范围 3
1．4 计算机能做什么 4
1．5 高级计算机语言和编译器 5
1．6 语言标准 6
1．6．1 第1个ANSI/ISO C标准 6
1．6．2 C99标准 6
1．6．3 C11标准 7
1．7 使用C语言的7个步骤 7
1．7．1 第1步：定义程序的目标 8
1．7．2 第2步：设计程序 8
1．7．3 第3步：编写代码 8
1．7．4 第4步：编译 8
1．7．5 第5步：运行程序 9
1．7．6 第6步：测试和调试程序 9
1．7．7 第7步：维护和修改代码 9
1．7．8 说明 9
1．8 编程机制 10
1．8．1 目标代码文件、可执行文件和库 10
1．8．2 UNIX系统 11
1．8．3 GNU编译器集合和LLVM项目 13
1．8．4 Linux系统 13
1．8．5 PC的命令行编译器 14
1．8．6 集成开发环境（Windows） 14
1．8．7 Windows/Linux 15
1．8．8 Macintosh中的C 15
1．9 本书的组织结构 15
1．10 本书的约定 16
1．10．1 字体 16
1．10．2 程序输出 16
1．10．3 特殊元素 17
1．11 本章小结 17
1．12 复习题 18
1．13 编程练习 18
第2章　C语言概述 19
2．1 简单的C程序示例 19
2．2 示例解释 20
2．2．1 第1遍：快速概要 21
2．2．2 第2遍：程序细节 21
2．3 简单程序的结构 28
2．4 提高程序可读性的技巧 28
2．5 进一步使用C 29
2．5．1 程序说明 30
2．5．2 多条声明 30
2．5．3 乘法 30
2．5．4 打印多个值 30
2．6 多个函数 30
2．7 调试程序 32
2．7．1 语法错误 32
2．7．2 语义错误 33
2．7．3 程序状态 34
2．8 关键字和保留标识符 34
2．9 关键概念 35
2．10 本章小结 35
2．11 复习题 36
2．12 编程练习 37
第3章　数据和C 39
3．1 示例程序 39
3．2 变量与常量数据 42
3．3 数据：数据类型关键字 42
3．3．1 整数和浮点数 43
3．3．2 整数 43
3．3．3 浮点数 43
3．4 C语言基本数据类型 44
3．4．1 int类型 44
3．4．2 其他整数类型 47
3．4．3 使用字符：char类型 50
3．4．4 _Bool类型 54
3．4．5 可移植类型：stdint．h和inttypes．h 55
3．4．6 float、double和long double 56
3．4．7 复数和虚数类型 60
3．4．8 其他类型 60
3．4．9 类型大小 62
3．5 使用数据类型 63
3．6 参数和陷阱 63
3．7 转义序列示例 64
3．7．1 程序运行情况 65
3．7．2 刷新输出 65
3．8 关键概念 66
3．9 本章小结 66
3．10 复习题 67
3．11 编程练习 68
第4章　字符串和格式化输入/输出 71
4．1 前导程序 71
4．2 字符串简介 72
4．2．1 char类型数组和null字符 72
4．2．2 使用字符串 73
4．2．3 strlen()函数 74
4．3 常量和C预处理器 76
4．3．1 const限定符 78
4．3．2 明示常量 78
4．4 printf()和scanf() 80
4．4．1 printf()函数 80
4．4．2 使用printf() 81
4．4．3 printf()的转换说明修饰符 83
4．4．4 转换说明的意义 87
4．4．5 使用scanf() 92
4．4．6 printf()和scanf()的*修饰符 95
4．4．7 printf()的用法提示 97
4．5 关键概念 98
4．6 本章小结 98
4．7 复习题 99
4．8 编程练习 100
第5章　运算符、表达式和语句 103
5．1 循环简介 103
5．2 基本运算符 105
5．2．1 赋值运算符：= 105
5．2．2 加法运算符：+ 107
5．2．3 减法运算符：- 107
5．2．4 符号运算符：-和+ 107
5．2．5 乘法运算符：* 108
5．2．6 除法运算符：/ 110
5．2．7 运算符优先级 110
5．2．8 优先级和求值顺序 112
5．3 其他运算符 113
5．3．1 sizeof运算符和size_t类型 113
5．3．2 求模运算符：% 114
5．3．3 递增运算符：++ 115
5．3．4 递减运算符：-- 118
5．3．5 优先级 118
5．3．6 不要自作聪明 119
5．4 表达式和语句 120
5．4．1 表达式 120
5．4．2 语句 120
5．4．3 复合语句（块） 123
5．5 类型转换 124
5．6 带参数的函数 127
5．7 示例程序 129
5．8 关键概念 130
5．9 本章小结 130
5．10 复习题 131
5．11 编程练习 134
第6章　C控制语句：循环 137
6．1 再探while循环 137
6．1．1 程序注释 138
6．1．2 C风格读取循环 139
6．2 while语句 140
6．2．1 终止while循环 140
6．2．2 何时终止循环 141
6．2．3 while：入口条件循环 141
6．2．4 语法要点 141
6．3 用关系运算符和表达式比较大小 143
6．3．1 什么是真 144
6．3．2 其他真值 145
6．3．3 真值的问题 146
6．3．4 新的_Bool类型 147
6．3．5 优先级和关系运算符 148
6．4 不确定循环和计数循环 150
6．5 for循环 151
6．6 其他赋值运算符：+=、-=、*=、/=、%= 155
6．7 逗号运算符 156
6．8 出口条件循环：do while 159
6．9 如何选择循环 161
6．10 嵌套循环 162
6．10．1 程序分析 163
6．10．2 嵌套变式 163
6．11 数组简介 164
6．12 使用函数返回值的循环示例 166
6．12．1 程序分析 168
6．12．2 使用带返回值的函数 169
6．13 关键概念 169
6．14 本章小结 170
6．15 复习题 170
6．16 编程练习 174
第7章　C控制语句：分支和跳转 177
7．1 if语句 177
7．2 if else语句 179
7．2．1 另一个示例：介绍getchar()和putchar() 180
7．2．2 ctype．h系列的字符函数 182
7．2．3 多重选择else if 184
7．2．4 else与if配对 186
7．2．5 多层嵌套的if语句 187
7．3 逻辑运算符 190
7．3．1 备选拼写：iso646．h头文件 191
7．3．2 优先级 192
7．3．3 求值顺序 192
7．3．4 范围 193
7．4 一个统计单词的程序 194
7．5 条件运算符：?： 196
7．6 循环辅助：continue和break 198
7．6．1 continue语句 198
7．6．2 break语句 200
7．7 多重选择：switch和break 202
7．7．1 switch语句 204
7．7．2 只读每行的首字符 205
7．7．3 多重标签 206
7．7．4 switch和if else 208
7．8 goto语句 208
7．9 关键概念 211
7．10 本章小结 211
7．11 复习题 212
7．12 编程练习 214
第8章　字符输入/输出和输入验证 217
8．1 单字符I/O：getchar()和putchar() 217
8．2 缓冲区 218
8．3 结束键盘输入 219
8．3．1 文件、流和键盘输入 219
8．3．2 文件结尾 220
8．4 重定向和文件 222
8．5 创建更友好的用户界面 226
8．5．1 使用缓冲输入 226
8．5．2 混合数值和字符输入 228
8．6 输入验证 230
8．6．1 分析程序 234
8．6．2 输入流和数字 234
8．7 菜单浏览 235
8．7．1 任务 235
8．7．2 使执行更顺利 235
8．7．3 混合字符和数值输入 237
8．8 关键概念 240
8．9 本章小结 240
8．10 复习题 241
8．11 编程练习 241
第9章　函数 243
9．1 复习函数 243
9．1．1 创建并使用简单函数 244
9．1．2 分析程序 245
9．1．3 函数参数 247
9．1．4 定义带形式参数的函数 248
9．1．5 声明带形式参数函数的原型 249
9．1．6 调用带实际参数的函数 249
9．1．7 黑盒视角 250
9．1．8 使用return从函数中返回值 250
9．1．9 函数类型 252
9．2 ANSI C函数原型 253
9．2．1 问题所在 253
9．2．2 ANSI的解决方案 254
9．2．3 无参数和未指定参数 255
9．2．4 函数原型的优点 256
9．3 递归 256
9．3．1 演示递归 256
9．3．2 递归的基本原理 258
9．3．3 尾递归 258
9．3．4 递归和倒序计算 260
9．3．5 递归的优缺点 262
9．4 编译多源代码文件的程序 262
9．4．1 UNIX 263
9．4．2 Linux 263
9．4．3 DOS命令行编译器 263
9．4．4 Windows和苹果的IDE编译器 263
9．4．5 使用头文件 263
9．5 查找地址：&运算符 267
9．6 更改主调函数中的变量 268
9．7 指针简介 269
9．7．1 间接运算符：* 270
9．7．2 声明指针 270
9．7．3 使用指针在函数间通信 271
9．8 关键概念 274
9．9 本章小结 275
9．10　复习题 275
9．11 编程练习 276
第10章　数组和指针 277
10．1 数组 277
10．1．1 初始化数组 277
10．1．2 指定初始化器（C99） 281
10．1．3 给数组元素赋值 282
10．1．4 数组边界 282
10．1．5 指定数组的大小 284
10．2 多维数组 284
10．2．1 初始化二维数组 287
10．2．2 其他多维数组 288
10．3 指针和数组 288
10．4 函数、数组和指针 290
10．4．1 使用指针形参 293
10．4．2 指针表示法和数组表示法 294
10．5 指针操作 295
10．6 保护数组中的数据 298
10．6．1 对形式参数使用const 299
10．6．2　const的其他内容 300
10．7 指针和多维数组 302
10．7．1 指向多维数组的指针 304
10．7．2 指针的兼容性 305
10．7．3 函数和多维数组 306
10．8 变长数组（VLA） 309
10．9 复合字面量 312
10．10 关键概念 314
10．11 本章小结 315
10．12 复习题 316
10．13 编程练习 317
第11章　字符串和字符串函数 321
11．1 表示字符串和字符串I/O 321
11．1．1 在程序中定义字符串 322
11．1．2 指针和字符串 328
11．2 字符串输入 329
11．2．1 分配空间 329
11．2．2 不幸的gets()函数 330
11．2．3 gets()的替代品 331
11．2．4 scanf()函数 336
11．3 字符串输出 337
11．3．1 puts()函数 338
11．3．2 fputs()函数 339
11．3．3 printf()函数 339
11．4 自定义输入/输出函数 340
11．5 字符串函数 342
11．5．1 strlen()函数 342
11．5．2 strcat()函数 343
11．5．3 strncat()函数 345
11．5．4 strcmp()函数 346
11．5．5 strcpy()和strncpy()函数 351
11．5．6 sprintf()函数 356
11．5．7 其他字符串函数 357
11．6 字符串示例：字符串排序 359
11．6．1 排序指针而非字符串 360
11．6．2 选择排序算法 361
11．7 ctype．h字符函数和字符串 362
11．8 命令行参数 363
11．8．1 集成环境中的命令行参数 365
11．8．2 Macintosh中的命令行参数 365
11．9 把字符串转换为数字 365
11．10 关键概念 368
11．11 本章小结 368
11．12 复习题 369
11．13 编程练习 371
第12章　存储类别、链接和内存管理 373
12．1 存储类别 373
12．1．1 作用域 374
12．1．2 链接 376
12．1．3 存储期 376
12．1．4 自动变量 377
12．1．5 寄存器变量 380
12．1．6 块作用域的静态变量 381
12．1．7 外部链接的静态变量 382
12．1．8 内部链接的静态变量 386
12．1．9 多文件 386
12．1．10 存储类别说明符 387
12．1．11 存储类别和函数 389
12．1．12 存储类别的选择 389
12．2 随机数函数和静态变量 390
12．3 掷骰子 393
12．4 分配内存：malloc()和free() 396
12．4．1 free()的重要性 399
12．4．2 calloc()函数 400
12．4．3 动态内存分配和变长数组 400
12．4．4 存储类别和动态内存分配 401
12．5 ANSI C类型限定符 402
12．5．1 const类型限定符 403
12．5．2 volatile类型限定符 404
12．5．3 restrict类型限定符 405
12．5．4 _Atomic类型限定符（C11） 406
12．5．5 旧关键字的新位置 406
12．6　关键概念 407
12．7 本章小结 407
12．8 复习题 408
12．9 编程练习 409
第13章　文件输入/输出 413
13．1 与文件进行通信 413
13．1．1 文件是什么 413
13．1．2 文本模式和二进制模式 413
13．1．3 I/O的级别 415
13．1．4 标准文件 415
13．2 标准I/O 415
13．2．1 检查命令行参数 416
13．2．2 fopen()函数 416
13．2．3 getc()和putc()函数 417
13．2．4 文件结尾 418
13．2．5 fclose()函数 419
13．2．6 指向标准文件的指针 419
13．3 一个简单的文件压缩程序 419
13．4 文件I/O：fprintf()、fscanf()、fgets()和fputs() 421
13．4．1 fprintf()和fscanf()函数 421
13．4．2 fgets()和fputs()函数 422
13．5 随机访问：fseek()和ftell() 423
13．5．1 fseek()和ftell()的工作原理 424
13．5．2 二进制模式和文本模式 425
13．5．3 可移植性 425
13．5．4 fgetpos()和fsetpos()函数 426
13．6 标准I/O的机理 426
13．7 其他标准I/O函数 427
13．7．1 int ungetc(int c， FILE *fp)函数 427
13．7．2 int fflush()函数 428
13．7．3 int setvbuf()函数 428
13．7．4 二进制I/O：fread()和fwrite() 428
13．7．5 size_t fwrite()函数 429
13．7．6 size_t fread()函数 430
13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数 430
13．7．8 一个程序示例 430
13．7．9 用二进制I/O进行随机访问 433
13．8 关键概念 435
13．9 本章小结 435
13．10 复习题 435
13．11 编程练习 437
第14章　结构和其他数据形式 439
14．1 示例问题：创建图书目录 439
14．2 建立结构声明 441
14．3 定义结构变量 441
14．3．1 初始化结构 442
14．3．2 访问结构成员 443
14．3．3 结构的初始化器 443
14．4 结构数组 444
14．4．1 声明结构数组 446
14．4．2 标识结构数组的成员 447
14．4．3 程序讨论 447
14．5 嵌套结构 448
14．6 指向结构的指针 449
14．6．1 声明和初始化结构指针 450
14．6．2 用指针访问成员 451
14．7 向函数传递结构的信息 451
14．7．1 传递结构成员 451
14．7．2 传递结构的地址 452
14．7．3 传递结构 453
14．7．4 其他结构特性 454
14．7．5 结构和结构指针的选择 458
14．7．6 结构中的字符数组和字符指针 458
14．7．7 结构、指针和malloc() 459
14．7．8 复合字面量和结构（C99） 462
14．7．9 伸缩型数组成员（C99） 463
14．7．10 匿名结构（C11） 465
14．7．11 使用结构数组的函数 466
14．8 把结构内容保存到文件中 467
14．8．1 保存结构的程序示例 468
14．8．2 程序要点 470
14．9 链式结构 471
14．10 联合简介 472
14．10．1 使用联合 472
14．10．2 匿名联合（C11） 473
14．11 枚举类型 474
14．11．1 enum常量 475
14．11．2 默认值 475
14．11．3 赋值 475
14．11．4 enum的用法 476
14．11．5 共享名称空间 477
14．12 typedef简介 478
14．13 其他复杂的声明 479
14．14 函数和指针 481
14．15 关键概念 487
14．16 本章小结 487
14．17 复习题 488
14．18 编程练习 490
第15章　位操作 493
15．1 二进制数、位和字节 493
15．1．1 二进制整数 494
15．1．2 有符号整数 494
15．1．3 二进制浮点数 495
15．2 其他进制数 495
15．2．1 八进制 495
15．2．2 十六进制 496
15．3 C按位运算符 496
15．3．1 按位逻辑运算符 497
15．3．2 用法：掩码 498
15．3．3 用法：打开位（设置位） 498
15．3．4 用法：关闭位（清空位） 499
15．3．5 用法：切换位 499
15．3．6 用法：检查位的值 500
15．3．7 移位运算符 500
15．3．8 编程示例 501
15．3．9 另一个例子 503
15．4 位字段 505
15．4．1 位字段示例 506
15．4．2 位字段和按位运算符 509
15．5 对齐特性（C11） 515
15．6 关键概念 516
15．7 本章小结 516
15．8 复习题 517
15．9 编程练习 518
第16章　C预处理器和C库 521
16．1 翻译程序的第一步 521
16．2 明示常量：#define 522
16．2．1 记号 525
16．2．2 重定义常量 525
16．3 在#define中使用参数 525
16．3．1 用宏参数创建字符串：#运算符 527
16．3．2 预处理器黏合剂：##运算符 528
16．3．3 变参宏：．．．和_ _VA_ARGS_ _ 529
16．4 宏和函数的选择 530
16．5 文件包含：#include 531
16．5．1 头文件示例 531
16．5．2 使用头文件 533
16．6 其他指令 534
16．6．1 #undef指令 534
16．6．2 从C预处理器角度看已定义 534
16．6．3 条件编译 535
16．6．4 预定义宏 539
16．6．5 #line和#error 540
16．6．6 #pragma 540
16．6．7 泛型选择（C11） 541
16．7 内联函数（C99） 542
16．8 _Noreturn函数（C11） 544
16．9 C库 544
16．9．1 访问C库 544
16．9．2 使用库描述 545
16．10 数学库 546
16．10．1 三角问题 547
16．10．2 类型变体 548
16．10．3 tgmath．h库（C99） 550
16．11 通用工具库 550
16．11．1 exit()和atexit()函数 550
16．11．2 qsort()函数 552
16．12 断言库 556
16．12．1 assert的用法 556
16．12．2 _Static_assert（C11） 557
16．13 string．h库中的memcpy()和memmove() 558
16．14 可变参数：stdarg．h 560
16．15 关键概念 562
16．16 本章小结 562
16．17 复习题 562
16．18 编程练习 563
第17章　高级数据表示 567
17．1 研究数据表示 567
17．2 从数组到链表 570
17．2．1 使用链表 572
17．2．2 反思 576
17．3 抽象数据类型（ADT） 576
17．3．1 建立抽象 577
17．3．2 建立接口 578
17．3．3 使用接口 581
17．3．4 实现接口 583
17．4 队列ADT 589
17．4．1 定义队列抽象数据类型 590
17．4．2 定义一个接口 590
17．4．3 实现接口数据表示 591
17．4．4 测试队列 598
17．5 用队列进行模拟 600
17．6 链表和数组 605
17．7 二叉查找树 608
17．7．1 二叉树ADT 608
17．7．2 二叉查找树接口 609
17．7．3 二叉树的实现 611
17．7．4 使用二叉树 624
17．7．5 树的思想 628
17．8 其他说明 629
17．9 关键概念 630
17．10 本章小结 630
17．11 复习题 630
17．12 编程练习 631
附录A　复习题答案 633
附录B　参考资料 665
B．1 参考资料I：补充阅读 665
B．2 参考资料II：C运算符 667
B．3 参考资料III：基本类型和存储类别 671
B．4 参考资料IV：表达式、语句和程序流 675
B．5 参考资料V：新增C99和C11的ANSI C库 679
B．6 参考资料VI：扩展的整数类型 714
B．7 参考资料VII：扩展字符支持 716
B．8 参考资料VIII：C99/C11数值计算增强 720
B．9 参考资料IX：C和C++的区别 726

第1章 开始
1.1 编写一个简单的C++程序
1.1.1 编译、运行程序
1.2 初识输入输出
1.3 注释简介
1.4 控制流
1.4.1 while语句
1.4.2 for语句
1.4.3 读取数量不定的输入数据
1.4.4 if语句
1.5 类简介
1.5.1 Sales_item类
1.5.2 初识成员函数
1.6 书店程序
小结
术语表
第Ⅰ部分 C++基础

第2章 变量和基本类型
2.1 基本内置类型
2.1.1 算术类型
2.1.2 类型转换
2.1.3 字面值常量
2.2 变量
2.2.1 变量定义
2.2.2 变量声明和定义的关系
2.2.3 标识符
2.2.4 名字的作用域
2.3 复合类型
2.3.1 引用
2.3.2 指针
2.3.3 理解复合类型的声明
2.4 const限定符
2.4.1 const的引用
2.4.2 指针和const
2.4.3 顶层const
2.4.4 constexpr和常量表达式
2.5 处理类型
2.5.1 类型别名
2.5.2 auto类型说明符
2.5.3 decltype类型指示符
2.6 自定义数据结构
2.6.1 定义Sales_data类型
2.6.2 使用Sales_data类
2.6.3 编写自己的头文件
小结
术语表

第3章 字符串、向量和数组
3.1 命名空间的using声明
3.2 标准库类型string
3.2.1 定义和初始化string对象
3.2.2 string对象上的操作
3.2.3 处理string对象中的字符
3.3 标准库类型vector
3.3.1 定义和初始化vector对象
3.3.2 向vector对象中添加元素
3.3.3 其他vector操作
3.4 迭代器介绍
3.4.1 使用迭代器
3.4.2 迭代器运算
3.5 数组
3.5.1 定义和初始化内置数组
3.5.2 访问数组元素
3.5.3 指针和数组
3.5.4 C风格字符串
3.5.5 与旧代码的接口
3.6 多维数组
小结
术语表

第4章 表达式
4.1 基础
4.1.1 基本概念
4.1.2 优先级与结合律
4.1.3 求值顺序
4.2 算术运算符
4.3 逻辑和关系运算符
4.4 赋值运算符
4.5 递增和递减运算符
4.6 成员访问运算符
4.7 条件运算符
4.8 位运算符
4.9 sizeof运算符
4.10 逗号运算符
4.11 类型转换
4.11.1 算术转换
4.11.2 其他隐式类型转换
4.11.3 显式转换
4.12 运算符优先级表
小结
术语表

第5章 语句
5.1 简单语句
5.2 语句作用域
5.3 条件语句
5.3.1 if语句
5.3.2 switch语句
5.4 迭代语句
5.4.1 while语句
5.4.2 传统的for语句
5.4.3 范围for语句
5.4.4 do
5.5 跳转语句
5.5.1 break语句
5.5.2 continue语句
5.5.3 goto语句
5.6 TRY语句块和异常处理
5.6.1 throw表达式
5.6.2 try语句块
5.6.3 标准异常
小结
术语表

第6章 函数
6.1 函数基础
6.1.1 局部对象
6.1.2 函数声明
6.1.3 分离式编译
6.2 参数传递
6.2.1 传值参数
6.2.2 传引用参数
6.2.3 const形参和实参
6.2.4 数组形参
6.2.5 main：处理命令行选项
6.2.6 含有可变形参的函数
6.3 返回类型和return语句
6.3.1 无返回值函数
6.3.2 有返回值函数
6.3.3 返回数组指针
6.4 函数重载
6.4.1 重载与作用域
6.5 特殊用途语言特性
6.5.1 默认实参
6.5.2 内联函数和constexpr函数
6.5.3 调试帮助
6.6 函数匹配
6.6.1 实参类型转换
6.7 函数指针

1.1 C++历史背景
1.1.1 20世纪最伟大的发明
1.1.2 C++发展历程
1.1.3 C++中的杰出人物
1.2 常用开发环境
1.2.1 Visual C++ 6.0
1.2.2 Visual C++ 2008
1.2.3 GCC/G++
1.2.4 Dev-C
1.2.5 Eclipse
1.3 认知C++程序代码
1.4 C++工程项目文件
1.5 使用VC创建程序
1.6 编译与连接过程
1.7 C++的特点
1.8 小结

第2章 数据类型
视频讲解：1小时26分钟
2.1 第一个C++程序
2.1.1 #include指令
2.1.2 注释
2.1.3 main函数
2.1.4 函数体
2.1.5 函数返回值
2.2 常量及符号
2.2.1 整型常量
2.2.2 实型常量
2.2.3 字符常量
2.2.4 字符串常量
2.2.5 其他常量
2.3 变量
2.3.1 标识符
2.3.2 变量与变量说明
2.3.3 整型变量
2.3.4 实型变量
2.3.5 变量赋值
2.3.6 变量赋初值
2.3.7 字符变量
2.4 常用数据类型
2.4.1 定义数值类型
2.4.2 字符类型
2.4.3 布尔类型
2.5 数据输入与输出
2.5.1 控制台屏幕
2.5.2 C++语言中的流
2.5.3 流操作的控制
2.6 小结
2.7 实践与练习

第3章 表达式与语句
视频讲解：55分钟
3.1 运算符
3.1.1 算术运算符
3.1.2 关系运算符
3.1.3 逻辑运算符
3.1.4 赋值运算符
3.1.5 位运算符
3.1.6 移位运算符
3.1.7 sizeof运算符
3.1.8 条件运算符
3.1.9 逗号运算符
3.2 结合性和优先级
3.3 表达式
3.3.1 算术表达式
3.3.2 关系表达式
3.3.3 条件表达式
3.3.4 赋值表达式
3.3.5 逻辑表达式
3.3.6 逗号表达式
3.3.7 表达式中的类型转换
3.4 语句
3.5 判断左值与右值
3.6 小结
3.7 实践与练习

第4章 条件判断语句
视频讲解：35分钟
4.1 决策分支
4.2 判断语句
4.2.1 第一种形式的判断语句
4.2.2 第二种形式的判断语句
4.2.3 第三种形式的判断语句
4.3 使用条件运算符进行判断
4.4 switch语句
4.5 判断语句的嵌套
4.6 小结
4.7 实践与练习

第5章 循环语句
视频讲解：53分钟
5.1 while循环
5.2 do...while循环
5.3 while与do…while比较
5.4 for循环语句
5.5 循环控制
5.5.1 控制循环的变量
5.5.2 break语句
5.5.3 continue语句
5.5.4 goto语句
5.6 循环嵌套
5.7 循环应用实例
5.7.1 阿姆斯壮数
5.7.2 巴斯卡三角形
5.7.3 对输入的分数进行排名
5.8 小结
5.9 实践与练习

第6章 函数
视频讲解：1小时14分钟
6.1 函数概述
6.1.1 函数的定义
6.1.2 函数的声明
6.2 函数参数及返回值
6.2.1 返回值
6.2.2 空函数
6.2.3 形参与实参
6.2.4 默认参数
6.2.5 可变参数
6.3 函数调用
6.3.1 传值调用
6.3.2 嵌套调用
6.3.3 递归调用
6.4 变量作用域
6.5 重载函数
6.6 内联函数
6.7 变量的存储类别
6.7.1 auto变量
6.7.2 static变量
6.7.3 register变量
6.7.4 extern变量
6.8 小结
6.9 实践与练习

第7章 数组、指针和引用
视频讲解：1小时27分钟
7.1 一维数组
7.1.1 一维数组的声明
7.1.2 一维数组的引用
7.1.3 一维数组的初始化
7.2 二维数组
7.2.1 二维数组的声明
7.2.2 二维数组元素的引用
7.2.3 二维数组的初始化
7.3 字符数组
7.4 指针
7.4.1 变量与指针
7.4.2 指针运算符和取地址运算符
7.4.3 指针运算
7.4.4 指向空的指针与空类型指针
7.4.5 指向常量的指针与指针常量
7.5 指针与数组
7.5.1 数组的存储
7.5.2 指针与一维数组
7.5.3 指针与二维数组
7.5.4 指针与字符数组
7.6 指针在函数中的应用
7.6.1 传递地址
7.6.2 指向函数的指针
7.6.3 空指针调用函数
7.6.4 从函数中返回指针
7.7 指针数组
7.8 安全使用指针
7.8.1 内存分配
7.8.2 内存安全
7.9 引用
7.9.1 引用概述
7.9.2 使用引用传递参数
7.9.3 指针传递参数
7.9.4 数组做函数参数
7.9.5 右值引用传递参数
7.10 小结
7.11 实践与练习

第8章 构造数据类型
视频讲解：59分钟
8.1 结构体
8.1.1 结构体定义
8.1.2 结构体变量
8.1.3 结构体成员及初始化
8.1.4 结构体的嵌套
8.1.5 结构体大小
8.2 重命名数据类型
8.3 枚举类型的应用
8.4 类型推导
8.5 结构体与函数
8.5.1 结构体变量做函数参数
8.5.2 结构体指针做函数参数
8.6 结构体数组
8.6.1 结构体数组声明与引用
8.6.2 指针访问结构体数组
8.7 共用体
8.7.1 共用体的定义与声明
8.7.2 共用体的大小
8.7.3 共用体的特点
8.8 枚举类型
8.8.1 枚举类型的声明
8.8.2 枚举类型变量
8.8.3 枚举类型的运算
8.9 自定义数据类型
8.10 使用宏定义替换复杂的数据
8.11 小结
8.12 实践与练习

第2篇 核心技术
第9章 面向对象编程
视频讲解：32分钟
9.1 面向对象概述
9.2 面向对象与面向过程编程
9.2.1 面向过程编程
9.2.2 面向对象编程
9.2.3 面向对象的特点
9.3 统一建模语言
9.3.1 统一建模语言概述
9.3.2 统一建模语言的结构
9.3.3 面向对象的建模
9.4 小结

第10章 类和对象
视频讲解：1小时1分钟
10.1 C++类
10.1.1 类概述
10.1.2 类的声明与定义
10.1.3 类的实现
10.1.4 对象的声明
10.2 构造函数
10.2.1 构造函数概述
10.2.2 复制构造函数
10.3 析构函数
10.4 类成员
10.4.1 访问类成员
10.4.2 内联成员函数
10.4.3 静态类成员
10.4.4 隐藏的this指针
10.4.5 嵌套类
10.4.6 局部类
10.5 友元
10.5.1 友元概述
10.5.2 友元类
10.5.3 友元方法
10.6 命名空间
10.6.1 使用命名空间
10.6.2 定义命名空间
10.6.3 在多个文件中定义命名空间
10.6.4 定义嵌套的命名空间
10.6.5 定义未命名的命名空间
10.7 小结
10.8 实践与练习

第11章 继承与派生
视频讲解：57分钟
11.1 继承
11.1.1 类的继承
11.1.2 继承后可访问性
11.1.3 构造函数访问顺序
11.1.4 子类显式调用父类构造函数
11.1.5 子类隐藏父类的成员函数
11.2 重载运算符
11.2.1 重载运算符的必要性
11.2.2 重载运算符的形式与规则
11.2.3 重载运算符的运算
11.2.4 转换运算符
11.3 多重继承
11.3.1 多重继承的定义
11.3.2 二义性
11.3.3 多重继承的构造顺序
11.4 多态
11.4.1 虚函数概述
11.4.2 利用虚函数实现动态绑定
11.4.3 虚继承
11.5 抽象类
11.5.1 纯虚函数
11.5.2 实现抽象类中的成员函数
11.6 小结
11.7 实践与练习

第3篇 高级应用
第12章 模板
视频讲解：49分钟
12.1 函数模板
12.1.1 函数模板的定义
12.1.2 函数模板的作用
12.1.3 重载函数模板
12.2 类模板
12.2.1 类模板的定义与声明
12.2.2 简单类模板
12.2.3 默认模板参数
12.2.4 为具体类型的参数提供默认值
12.2.5 有界数组模板
12.3 模板的使用
12.3.1 定制类模板
12.3.2 定制类模板成员函数
12.3.3 模板部分定制
12.4 链表类模板
12.4.1 链表
12.4.2 链表类模板
12.4.3 类模板的静态数据成员
12.5 小结
12.6 实践与练习

第13章 STL标准模板库
视频讲解：35分钟
13.1 几种常见数据结构
13.1.1 简述STL
13.1.2 顺序线性结构
13.1.3 基本操作
13.1.4 栈结构
13.1.5 队列结构
13.1.6 链表结构
13.1.7 图结构
13.2 序列容器
13.2.1 对比容器适配器与容器
13.2.2 对比迭代器与容器
13.2.3 向量类模板
13.2.4 双端队列类模板
13.2.5 链表类模板
13.3 结合容器
13.3.1 set类模板
13.3.2 multiset类模板
13.3.3 map类模板
13.3.4 multimap类模板
13.4 算法
13.4.1 非修正序列算法
13.4.2 修正序列算法
13.4.3 排序算法
13.4.4 数值算法
13.5 迭代器
13.5.1 输出迭代器
13.5.2 输入迭代器
13.5.3 前向迭代器
13.5.4 双向迭代器
13.5.5 随机访问迭代器
13.6 lambda表达式
13.7 小结
13.8 实践与练习

第14章 RTTI与异常处理
视频讲解：22分钟
14.1 RTTI（运行时类型识别）
14.1.1 什么是RTTI
14.1.2 RTTI与引用
14.1.3 RTTI与多重继承
14.1.4 RTTI映射语法
14.2 异常处理
14.2.1 抛出异常
14.2.2 异常捕获
14.2.3 异常匹配
14.2.4 标准异常
14.3 小结

第15章 程序调试
视频讲解：33分钟


第16章 文件操作
视频讲解：58分钟


第17章 网络通信
视频讲解：39分钟

第4篇 项目实战
第18章 人事考勤管理系统
视频讲解：1小时32分钟


前言
第3版前言
第2版前言
第1版前言
第一部分　引言
第1章　致读者 2
1.1　本书结构 2
1.1.1　引言 2
1.1.2　基本特性 3
1.1.3　抽象机制 4
1.1.4　标准库 5
1.1.5　例子和参考文献 5
1.2　C++的设计 7
1.2.1　程序设计风格 8
1.2.2　类型检查 11
1.2.3　C兼容性 12
1.2.4　语言、库和系统 12
1.3　学习C++ 14
1.3.1　用C++编程 15
1.3.2　对C++程序员的建议 16
1.3.3　对C程序员的建议 16
1.3.4　对Java程序员的建议 17
1.4　C++的历史 18
1.4.1　大事年表 19
1.4.2　早期的C++ 19
1.4.3　1998标准 21
1.4.4　2011标准 23
1.4.5　C++的用途 26
1.5　建议 27
1.6　参考文献 28
第2章　C++概览：基础知识 32
2.1　引言 32
2.2　基本概念 33
2.2.1　Hello，World! 33
2.2.2　类型、变量和算术运算 34
2.2.3　常量 36
2.2.4　检验和循环 37
2.2.5　指针、数组和循环 38
2.3　用户自定义类型 40
2.3.1　结构 41
2.3.2　类 42
2.3.3　枚举 43
2.4　模块化 44
2.4.1　分离编译 45
2.4.2　名字空间 46
2.4.3　错误处理 47
2.5　附记 50
2.6　建议 50
第3章　C++概览：抽象机制 51
3.1　引言 51
3.2　类 51
3.2.1　具体类型 52
3.2.2　抽象类型 56
3.2.3　虚函数 58
3.2.4　类层次 59
3.3　拷贝和移动 62
3.3.1　拷贝容器 63
3.3.2　移动容器 64
3.3.3　资源管理 66
3.3.4　抑制操作 66
3.4　模板 67
3.4.1　参数化类型 67
3.4.2　函数模板 69
3.4.3　函数对象 69
3.4.4　可变参数模板 71
3.4.5　别名 72
3.5　建议 73
第4章　C++概览：容器与算法 74
4.1　标准库 74
4.1.1　标准库概述 75
4.1.2　标准库头文件与名字空间 75
4.2　字符串 77
4.3　I/O流 78
4.3.1　输出 78
4.3.2　输入 79
4.3.3　用户自定义类型的I/O 80
4.4　容器 81
4.4.1　vector 81
4.4.2　list 84
4.4.3　map 85
4.4.4　unordered_map 86
4.4.5　容器概述 86
4.5　算法 87
4.5.1　使用迭代器 88
4.5.2　迭代器类型 90
4.5.3　流迭代器 91
4.5.4　谓词 93
4.5.5　算法概述 93
4.5.6　容器算法 94
4.6　建议 94
第5章　C++概览：并发与实用功能 96
5.1　引言 96
5.2　资源管理 96
5.2.1　unique_ptr与shared_ptr 97
5.3　并发 99
5.3.1　任务和thread 99
5.3.2　传递参数 100
5.3.3　返回结果 100
5.3.4　共享数据 101
5.3.5　任务通信 103
5.4　小工具组件 106
5.4.1　时间 106
5.4.2　类型函数 107
5.4.3　pair和tuple 109
5.5　正则表达式 110
5.6　数学计算 111
5.6.1　数学函数和算法 111
5.6.2　复数 111
5.6.3　随机数 112
5.6.4　向量算术 113
5.6.5　数值限制 113
5.7　建议 114
第二部分　基本功能
第6章　类型与声明 116
6.1　ISO C++标准 116
6.1.1　实现 117
6.1.2　基本源程序字符集 118
6.2　类型 118
6.2.1　基本类型 119
6.2.2　布尔值 119
6.2.3　字符类型 121
6.2.4　整数类型 124
6.2.5　浮点数类型 126
6.2.6　前缀和后缀 127
6.2.7　void 128
6.2.8　类型尺寸 128
6.2.9　对齐 130
6.3　声明 131
6.3.1　声明的结构 133
6.3.2　声明多个名字 134
6.3.3　名字 134
6.3.4　作用域 136
6.3.5　初始化 138
6.3.6　推断类型：auto和decltype() 141
6.4　对象和值 144
6.4.1　左值和右值 144
6.4.2　对象的生命周期 145
6.5　类型别名 146
6.6　建议 147
第7章　指针、数组与引用 148
7.1　引言 148
7.2　指针 148
7.2.1　void* 149
7.2.2　nullptr 150
7.3　数组 150
7.3.1　数组的初始化器 152
7.3.2　字符串字面值常量 152
7.4　数组中的指针 155
7.4.1　数组漫游 156
7.4.2　多维数组 158
7.4.3　传递数组 159
7.5　指针与const 161
7.6　指针与所有权 163
7.7　引用 163
7.7.1　左值引用 164
7.7.2　右值引用 167
7.7.3　引用的引用 169
7.7.4　指针与引用 170
7.8　建议 172
第8章　结构、联合与枚举 173
8.1　引言 173
8.2　结构 173
8.2.1　struct的布局 175
8.2.2　struct的名字 176
8.2.3　结构与类 177
8.2.4　结构与数组 178
8.2.5　类型等价 180
8.2.6　普通旧数据 180
8.2.7　域 182
8.3　联合 183
8.3.1　联合与类 185
8.3.2　匿名union 186
8.4　枚举 188
8.4.1　enum class 188
8.4.2　普通的enum 191
8.4.3　未命名的enum 192
8.5　建议 193
第9章　语句 194
9.1　引言 194
9.2　语句概述 194
9.3　声明作为语句 195
9.4　选择语句 196
9.4.1　if语句 196
9.4.2　switch语句 198
9.4.3　条件中的声明 200
9.5　循环语句 201
9.5.1　范围for语句 201
9.5.2　for语句 202
9.5.3　while语句 203
9.5.4　do语句 203
9.5.5　退出循环 204
9.6　goto语句 204
9.7　注释与缩进 205
9.8　建议 207
第10章　表达式 208
10.1　引言 208
10.2　一个桌面计算器示例 208
10.2.1　分析器 209
10.2.2　输入 213
10.2.3　底层输入 216
10.2.4　错误处理 217
10.2.5　驱动程序 217
10.2.6　头文件 218
10.2.7　命令行参数 218
10.2.8　关于风格 220
10.3　运算符概述 220
10.3.1　结果 224
10.3.2　求值顺序 224
10.3.3　运算符优先级 225
10.3.4　临时对象 226
10.4　常量表达式 227
10.4.1　符号化常量 229
10.4.2　常量表达式中的const 229
10.4.3　字面值常量类型 229
10.4.4　引用参数 230
10.4.5　地址常量表达式 231
10.5　隐式类型转换 231
10.5.1　提升 231
10.5.2　类型转换 232
10.5.3　常用的算术类型转换 234
10.6　建议 235
第11章　选择适当的操作 236
11.1　其他运算符 236
11.1.1　逻辑运算符 236
11.1.2　位逻辑运算符 236
11.1.3　条件表达式 238
11.1.4　递增与递减 238
11.2　自由存储 240
11.2.1　内存管理 241
11.2.2　数组 243
11.2.3　获取内存空间 244
11.2.4　重载new 245
11.3　列表 247
11.3.1　实现模型 248
11.3.2　限定列表 249
11.3.3　未限定列表 249
11.4　lambda表达式 251
11.4.1　实现模型 251
11.4.2　lambda的替代品 252
11.4.3　捕获 254
11.4.4　调用与返回 257
11.4.5　lambda的类型 257
11.5　显式类型转换 258
11.5.1　构造 259
11.5.2　命名转换 261
11.5.3　C风格的转换 262
11.5.4　函数形式的转换 262
11.6　建议 263
第12章　函数 264
12.1　函数声明 264
12.1.1　为什么使用函数 265
12.1.2　函数声明的组成要件 265


1. 让自己习惯C++ 11

Accustoming Yourself to C++ 11

条款01：视C++ 为一个语言联邦 11

View C++ as a fedueration of languages 11

条款02：尽量以const, enum, inline替换 #define 13

Prefer consts,enums, and inlines to #defines. 13

条款03：尽可能使用const 17

Use const whenever possible. 17

条款04：确定对象被使用前已先被初始化 26

Make sure that objects are initialized before they're used. 26

2. 构造/析构/赋值运算 34

Constructors, Destructors, and Assignment Operators 34

条款05：了解C++ 默默编写并调用哪些函数 34

Know what functions C++ silently writes and calls. 34

条款06：若不想使用编译器自动生成的函数，就该明确拒绝 37

Explicitly disallow the use of compiler-generated functions you do not want. 37

条款07：为多态基类声明virtual析构函数 40

Declare destructors virtual in polymorphic base classes. 40

条款08：别让异常逃离析构函数 44

Prevent exceptions from leaving destructors. 44

条款09：绝不在构造和析构过程中调用virtual函数 48

Never call virtual functions during construction or destruction. 48

条款10：令operator= 返回一个reference to *this 52

Have assignment operators return a reference to *this. 52

条款11：在operator= 中处理「“自我赋值」” 53

Handle assignment to self in operator=. 53

条款12：复制对象时勿忘其每一个成分 57

Copy all parts of an object. 57

3. 资源管理 61

Resource Management 61

条款13：以对象管理资源 61

Use objects to manage resources. 61

条款14：在资源管理类中小心coping行为 66

Think carefully about copying behavior in resource-managing classes. 66

条款15：在资源管理类中提供对原始资源的访问 69

Provide access to raw resources in resource-managing classes. 69

条款16：成对使用new和delete时要采取相同形式 73

Use the same form in corresponding uses of new and delete. 73

条款17：以独立语句将newed对象置入智能指针 75

Store newed objects in smart pointers in standalone statements. 75

4. 设计与声明 78

Designs and Declarations 78

条款18：让接口容易被正确使用，不易被误用 78

Make interfaces easy to use correctly and hard to use incorrectly. 78

条款19：设计class犹如设计type 84

Treat class design as type design. 84

条款20：宁以pass-by-reference-to-const替换pass-by-value 86

Prefer pass-by-reference-to-const to pass-by-value. 86

条款21：必须返回对象时，别妄想返回其reference 90

Don't try to return a reference when you must return an object. 90

条款22：将成员变量声明为private 94

Declare data members private. 94

条款23：宁以non-member、non-friend替换member函数 98

Prefer non-member non-friend functions to member functions. 98

条款24：若所有参数皆需类型转换，请为此采用non-member函数 102

Declare non-member functions when type conversions should apply to all parameters. 102

条款25：考虑写出一个不抛异常的swap函数 106

Consider support for a non-throwing swap. 106

5. 实现 113

Implementations 113

条款26：尽可能延后变量定义式的出现时间 113

Postpone variable definitions as long as possible. 113

条款27：尽量少做转型动作 116

Minimize casting. 116

条款28：避免返回handles指向对象内部成分 123

Avoid returning "handles" to object internals. 123

条款29：为“「异常安全」”而努力是值得的 127

Strive for exception-safe code. 127

条款30：透彻了解inlining的里里外外 134

Understand the ins and outs of inlining. 134

条款31：将文件间的编译依存关系降至最低 140

Minimize compilation dependencies between files. 140

6. 继承与面向对象设计 149

Inheritance and Object-Oriented Design 149

条款32：确定你的public继承塑模出is-a关系 150

Make sure public inheritance models "is-a." 150

条款33：避免遮掩继承而来的名称 156

Avoid hiding inherited names. 156

条款34：区分接口继承和实现继承 161

Differentiate between inheritance of interface and inheritance of implementation. 161

条款35：考虑virtual函数以外的其它其他选择 169

Consider alternatives to virtual functions. 169

条款36：绝不重新定义继承而来的non-virtual函数 178

Never redefine an inherited non-virtual function. 178

条款37：绝不重新定义继承而来的缺省参数值 180

Never redefine a function's inherited default parameter value. 180

条款38：通过复合塑模出has-a或"根据某物实现出" 184

Model "has-a" or "is-implemented-in-terms-of" through composition. 184

条款39：明智而审慎地使用private继承 187

Use private inheritance judiciously. 187

条款40：明智而审慎地使用多重继承 192

Use multiple inheritance judiciously. 192

7. 模板与泛型编程 199

Templates and Generic Programming 199

条款41：了解隐式接口和编译期多态 199

Understand implicit interfaces and compile-time polymorphism. 199

条款42：了解typename的双重意义 203

Understand the two meanings of typename. 203

条款43：学习处理模板化基类内的名称 207

Know how to access names in templatized base classes. 207

条款44：将与参数无关的代码抽离templates 212

Factor parameter-independent code out of templates. 212

条款45：运用成员函数模板接受所有兼容类型 218

Use member function templates to accept "all compatible types." 218

条款46：需要类型转换时请为模板定义非成员函数 222

Define non-member functions inside templates when type conversions are desired. 222

条款47：请使用traits classes表现类型信息 226

Use traits classes for information about types. 226

条款48：认识template元编程 233

Be aware of template metaprogramming. 233

8. 定制new和delete 239

Customizing new and delete 239

条款49：了解new-handler的行为 240

Understand the behavior of the new-handler. 240

条款50：了解new和delete的合理替换时机 247

Understand when it makes sense to replace new and delete. 247

条款51：编写new和delete时需固守常规 252

Adhere to convention when writing new and delete. 252

条款52：写了placement new也要写placement delete 256

Write placement delete if you write placement new. 256

9. 杂项讨论 262

Miscellany 262

条款53：不要轻忽编译器的警告 262

Pay attention to compiler warnings. 262

条款54：让自己熟悉包括TR1在内的标准程序库 263

Familiarize yourself with the standard library, including TR1. 263

条款55：让自己熟悉Boost 269

Familiarize yourself with Boost. 269

A 本书之外 273

B 新旧版条款对映 277

1 关于本书
1．1 缘起
1．2 阅读前的必要基础
1．3 本书风格与结构
1．4 如何阅读本书
1．5 目前发展情势
1．6 范例代码及额外信息
1．7 反馈
2 C++ 及标准库简介
2．1 C++ Standard 的历史
2．1．1 C++11 Standard 常见疑问
2．1．2 C++98 和 C++11 的兼容性
2．2 复杂度与 Big-O 标记
3 语言新特性
3．1 C++11 语言新特性
3．1．1 微小但重要的语法提升
3．1．2 以 auto 完成类型自动推导
3．1．3 一致性初始化（Uniform Initialization）与初值列（Initializer List）
3．1．4 Range-Based for 循环
3．1．5 Move 语义和 Rvalue Reference
3．1．6 新式的字符串字面常量（String Literal）
3．1．7 关键字 noexcept
3．1．8 关键字 constexpr
3．1．9 崭新的 Template 特性
3．1．10 Lambda
3．1．11 关键字 decltype
3．1．12 新的函数声明语法（New Function Declaration Syntax）
3．1．13 带领域的（Scoped） Enumeration
3．1．14 新的基础类型（New Fundamental Data Type）
3．2 虽旧犹新的语言特性
3．2．1 基础类型的明确初始化（Explicit Initialization for Fundamental Type）
3．2．2 main()定义式
4 一般概念
4．1 命名空间（Namespace）std
4．2 头文件（Header File）
4．3 差错和异常（Error and Exception）的处理
4．3．1 标准的 Exception Class（异常类）
4．3．2 异常类（Exception Class）的成员
4．3．3 以 Class exception_ptr 传递异常
4．3．4 抛出标准异常
4．3．5 自标准异常类派生
4．4 Callable Object（可被调用的对象）
4．5 并发与多线程
4．6 分配器（Allocator）
5 通用工具
5．1 Pair 和 Tuple
5．1．1 Pair
5．1．2 Tuple（不定数的值组）
5．1．3 Tuple 的输入/输出
5．1．4 tuple 和 pair 转换
5．2 Smart Pointer（智能指针）
5．2．1 Class shared_ptr
5．2．2 Class weak_ptr
5．2．3 误用 Shared Pointer
5．2．4 细究 Shared Pointer 和 Weak Pointer
5．2．5 Class unique_ptr
5．2．6 细究 Class unique_ptr
5．2．7 Class auto_ptr
5．2．8 Smart Pointer 结语
5．3 数值的极值（Numeric Limit）
5．4 Type Trait 和 Type Utility
5．4．1 Type Trait 的目的
5．4．2 细究 Type Trait
5．4．3 Reference Wrapper（外覆器）
5．4．4 Function Type Wrapper（外覆器）
5．5 辅助函数
5．5．1 挑选最小值和最大值
5．5．2 两值互换（Swapping）
5．5．3 增补的"比较操作符"（Comparison Operator）
5．6 Class ratio＜＞ 的编译期分数运算
5．7 Clock 和 Timer
5．7．1 Chrono 程序库概观
5．7．2 Duration（时间段）
5．7．3 Clock（时钟）和 Timepoint（时间点）
5．7．4 C 和 POSIX 提供的 Date/Time 函数
5．7．5 以计时器停滞线程（Blocking with Timer）
5．8 头文件 ＜cstddef＞、＜cstdlib＞ 和 ＜cstring＞
5．8．1 ＜cstddef＞ 内的各项定义
5．8．2 ＜cstdlib＞ 内的各种定义
5．8．3 ＜cstring＞ 中的定义式
6 标准模板库
6．1 STL 组件（Component）
6．2 容器（Container）
6．2．1 序列式容器（Sequence Container）
6．2．2 关联式容器（Associative Container）
6．2．3 序容器（Unordered Container）
6．2．4 关联式数组（Associative Array）
6．2．5 其他容器
6．2．6 容器适配器（Container Adapter）
6．3 迭代器（Iterator）
6．3．1 关联式（ Associative ）及序 （ Unordered ）容器的更多实例
6．3．2 迭代器种类（Iterator Category）
6．4 算法（Algorithm）
6．4．1 区间（Range）
6．4．2 处理多重区间（Multiple Ranges）
6．5 迭代器之适配器（Iterator Adapter）
6．5．1 Insert Iterator（安插型迭代器）
6．5．2 Stream Iterator（串流迭代器）
6．5．3 Reverse Iterator（反向迭代器）
6．5．4 Move Iterator（搬移迭代器）
6．6 用户自定义的泛型函数（User-Defined Generic Function）
6．7 更易型算法（Manipulating Algorithm）
6．7．1 移除（Removing）元素
6．7．2 更易 Associative（关联式）和 Unordered（序）容器
6．7．3 算法 vs． 成员函数
6．8 以函数作为算法的实参
6．8．1 以函数作为算法实参的实例示范
6．8．2 判断式（Predicate）
6．9 使用 Lambda
6．10 函数对象（Function Object）
6．10．1 定义一个函数对象
6．10．2 预定义的函数对象
6．10．3 Binder
6．10．4 函数对象 vs． Lambda
6．11 容器内的元素
6．11．1 容器元素的必要条件
6．11．2 Value 语义 vs． Reference 语义
6．12 STL 内部的错误和异常
6．12．1 错误处理（Error Handling）
6．12．2 异常处理（Exception Handling）
6．13 扩展 STL
6．13．1 整合更多 Type
6．13．2 派生自 STL Type
7 STL 容器
7．1 容器的共通能力和共通操作
7．1．1 容器的共通能力
7．1．2 容器的共通操作
7．1．3 容器提供的类型
7．2 Array
7．2．1 Array 的能力
7．2．2 Array 的操作
7．2．3 把array当成 C-Style Array
7．2．4 异常处理（ Exception Handling ）
7．2．5 Tuple 接口
7．2．6 Array 运用实例
7．3 Vector
7．3．1 Vector 的能力
7．3．2 Vector 的操作
7．3．3 将 Vector 当作 C-Style Array 使用
7．3．4 异常处理（ Exception Handling ）
7．3．5 Vector 使用实例
7．3．6 Class vector＜bool＞
7．4 Deque
7．4．1 Deque 的能力
7．4．2 Deque 的操作函数
7．4．3 Exception Handling
7．4．4 Deque 运用实例
7．5 List
7．5．1 List 的能力
7．5．2 List 的操作
7．5．3 异常处理（ Exception Handling ）
7．5．4 List 运用实例
7．6 Forward List
7．6．1 Forward List 的能力
7．6．2 Forward List 的操作
7．6．3 异常处理（ Exception Handling ）
7．6．4 Forward List 运用实例
7．7 Set 和 Multiset
7．7．1 Set 和 Multiset 的能力
7．7．2 Set and Multiset 的操作函数
7．7．3 异常处理（ Exception Handling ）
7．7．4 Set 和 Multiset 运用实例
7．7．5 运行期指定排序准则
7．8 Map 和 Multimap
7．8．1 Map 和 Multimap 的能力
7．8．2 Map 和 Multimap 的操作函数
7．8．3 将 Map 视为关联式数组（ Associative Array ）
7．8．4 异常处理（ Exception Handling ）
7．8．5 Map 和 Multimap 运用实例
7．8．6 综合实例：运用 Map、 String 并于运行期指定排序准则
7．9 序容器（ Unordered Container ）
7．9．1 Unordered 容器的能力
7．9．2 创建和控制 Unordered 容器
7．9．3 Unordered 容器的其他操作
7．9．4 Bucket 接口
7．9．5 使用 Unordered Map 作为 Associative Array
7．9．6 异常处理（ Exception Handling ）
7．9．7 Unordered 容器的运用实例
7．10 其他 STL 容器
7．10．1 String 作为一种 STL 容器
7．10．2 C-Style Array 作为一种 STL 容器
7．11 实现 Reference 语义
7．12 各种容器的使用时机
8 细探 STL 容器成员
8．1 容器内的类型
8．2 创建、复制和销毁（ Create， Copy， and Destroy ）
8．3 非更易型操作（ Nonmodifying Operation ）
8．3．1 大小相关操作（ Size Operation ）
8．3．2 元素比较（ Comparison Operation ）
8．3．3 Associative 和 Unordered 容器特有的非更易型操作
8．4 赋值（ Assignment ）
8．5 元素直接访问（ Direct Element Access ）
8．6 "产出迭代器"之各项操作
8．7 安插和移除（ Inserting and Removing ）元素
8．7．1 安插单一元素（ Inserting Single Element ）
8．7．2 安插多重元素（ Inserting Multiple Elements ）
8．7．3 移除元素（ Removing Element ）
8．7．4 重设大小（ Resizing ）
8．8 List 和 Forward List 的特殊成员函数
8．8．1 特殊成员函数（针对 List 和 Forward List ）
8．8．2 特殊成员函数（只针对 Forward List ）
8．9 容器的策略接口（ Policy Interface ）
8．9．1 非更易型策略函数（ Nonmodifying Policy Function ）
8．9．2 更易型策略函数（ Modifying Policy Function ）
8．9．3 Unordered 容器的 Bucket 相关接口
8．10 对分配器（ Allocator ）的支持
8．10．1 基本的分配器成员（ Fundamental Allocator Member ）
8．10．2 带有"可选之分配器参数"的构造函数
9 STL 迭代器
9．1 迭代器头文件（ Header Files for Iterators ）
9．2 迭代器种类（ Iterator Category ）
9．2．1 Output 迭代器
9．2．2 Input 迭代器
9．2．3 Forward（前向）迭代器
9．2．4 Bidirectional（双向）迭代器
9．2．5 Random-Access（随机访问）迭代器
9．2．6 Vector 迭代器的递增（ Increment ）和递减（ Decrement ）
9．3 迭代器相关辅助函数
9．3．1 advance()
9．3．2 next()和prev()
9．3．3 distance()
9．3．4 iter_swap()
9．4 迭代器适配器（ Iterator Adapter ）
9．4．1 Reverse（反向）迭代器
9．4．2 Insert（安插型）迭代器
9．4．3 Stream（串流）迭代器
9．4．4 Move（搬移）迭代器
9．5 Iterator Trait（迭代器特性）
9．5．1 为迭代器编写泛型函数（ Generic Function ）
9．6 用户自定义（ User-Defined ）迭代器
10 STL 函数对象及 Lambda
10．1 Function Object（函数对象）的概念
10．1．1 以 Function Object 为排序准则（ Sorting Criterion ）
10．1．2 Function Object 拥有内部状态（ Internal State ）
10．1．3 for_each()的返回值
10．1．4 Predicate（判断式） vs． Function Object（函数对象）
10．2 预定义的 Function Object 和 Binder
10．2．1 预定义的 Function Object
10．2．2 Function Adapter 和 Binder
10．2．3 以 Function Adapter 搭配用户自定义的 Function Object
10．2．4 过时的（ Deprecated ） Function Adapter
10．3 运用 Lambda
10．3．1 Lambda vs． Binder
10．3．2 Lambda vs． 带有状态的（ Stateful ） Function Object
10．3．3 Lambda 调用全局函数和成员函数
10．3．4 Lambda 作为 Hash 函数、排序准则或相等准则
11 STL 算法
11．1 算法头文件（Header File）
11．2 算法概观
11．2．1 扼要介绍
11．2．2 算法分门别类
11．3 辅助函数
11．4 for_each() 算法
11．5 非更易型算法（Nonmodifying Algorithm）
11．5．1 元素计数
11．5．2 最小值和最大值
11．5．3 查找元素（Searching Element）
11．5．4 区间的比较
11．5．5 Predicate 用以检验区间
11．6 更易型算法（Modifying Algorithm）
11．6．1 复制元素（Copying Element）
11．6．2 搬移元素（Moving Element）
11．6．3 转换和结合元素（Transforming and Combining Element）
11．6．4 互换元素（Swapping Elements）
11．6．5 赋值（Assigning New Value）
11．6．6 替换元素（Replacing Element）
11．7 移除型算法（Removing Algorithm）
11．7．1 移除某些元素
11．7．2 移除重复元素
11．8 变序型算法（Mutating Algorithm）
11．8．1 反转元素次序（Reversing the Order of Elements）
11．8．2 旋转元素（Rotating Elements）
11．8．3 排列元素（Permuting Elements）
11．8．4 对元素重新洗牌（Shuffling Elements）
11．8．5 将元素向前搬（Moving Elements to the Front）
11．8．6 划分为两个子区间（Partition into Two Subranges）
11．9 排序算法（Sorting Algorithm）
11．9．1 对所有元素排序
11．9．2 局部排序（Partial Sorting）
11．9．3 根据第 {\itshape n} 个元素排序
11．9．4 Heap 算法
11．10 已序区间算法（Sorted-Range Algorithm）
11．10．1 查找元素（Searching Element）
11．10．2 合并元素（Merging Elements）
11．11 数值算法（Numeric Algorithm）
11．11．1 运算后产生结果
11．11．2 相对数列和绝对数列之间的转换
12 特殊容器
12．1 Stack（堆栈）
12．1．1 核心接口
12．1．2 Stack 运用实例
12．1．3 一个用户自定义的 Stack Class
12．1．4 细究 Class stack＜＞
12．2 Queue（队列）
12．2．1 核心接口
12．2．2 Queue 运用实例
12．2．3 一个用户自定义的 Queue Class
12．2．4 细究 Class queue＜＞
12．3 Priority Queue（带优先级的队列）
12．3．1 核心接口
12．3．2 Priority Queue 运用实例
12．3．3 细究 Class priority_queue＜＞
12．4 细究 Container Adapter
12．4．1 类型定义
12．4．2 构造函数（Constructor）
12．4．3 Priority Queue 额外提供的构造函数
12．4．4 各项操作（Operation）
12．5 Bitset
12．5．1 Bitset 运用实例
12．5．2 细究 Class bitset
13 字符串
13．1 String Class 的目的
13．1．1 例一：提炼临时文件名
13．1．2 例二：提炼单词并反向打印
13．2 String Class 细节描述
13．2．1 String 的各种相关类型
13．2．2 操作函数概览
13．2．3 构造函数和析构函数（Constructor and Destructor）
13．2．4 String 和 C-String
13．2．5 大小和容量（Size and Capacity）
13．2．6 元素访问（Element Access）
13．2．7 比较（Comparison）
13．2．8 更改内容（Modifier）
13．2．9 子字符串（Substring）及字符串接合（String Concatenation）
13．2．10 I/O 操作符
13．2．11 搜索和查找（Searching and Finding）
13．2．12 npos 的意义
13．2．13 数值转换（Numeric Conversion）
13．2．14 String 对迭代器的支持
13．2．15 国际化（Internationalization）
13．2．16 效率（Performance）
13．2．17 String 和 Vector
13．3 细究 String Class
13．3．1 类型定义和静态值
13．3．2 创建、复制、销毁（Create， Copy， and Destroy）
13．3．3 大小和容量（Size and Capacity）
13．3．4 比较（Comparison）
13．3．5 字符访问
13．3．6 产生 C-String 和字符数组（Character Array）
13．3．7 "改动"之相关操作（Modifying Operation）
13．3．8 查找（Searching and Finding）
13．3．9 子字符串（Substring）及字符串接合（String Concatenation）
13．3．10 I/O函数
13．3．11 数值转换（Numeric Conversion）
13．3．12 生成 Iterator
13．3．13 对 Allocator 的支持
14 正则表达式
14．1 Regex 的匹配和查找接口（Match and Search Interface）
14．2 处理"次表达式"（Subexpression）
14．3 Regex Iterator
14．4 Regex Token Iterator
14．5 用于替换的正则表达式
14．6 Regex Flag
14．7 Regex 的异常（Exception）
14．8 Regex ECMAScript 文法
14．9 其他文法
14．10 细究 Basic Regex 签名式
15 以 Stream 完成 I/O
15．1 I/O Stream 的共通基础（Common Background）
15．1．1 Stream 对象
15．1．2 Stream Class
15．1．3 全局的 Stream 对象
15．1．4 Stream 操作符
15．1．5 操控器（Manipulator）
15．1．6 一个简单例子
15．2 基本 Stream Class 和其对象
15．2．1 Class 及其层次体系
15．2．2 全局性的 Stream 对象
15．2．3 头文件
15．3 标准的 Stream 操作符 ＜＜ 和 ＞＞
15．3．1 Output 操作符 ＜＜
15．3．2 Input 操作符 ＞＞
15．3．3 特殊类型的 I/O
15．4 Stream 的状态（State）
15．4．1 表示" Stream 状态"的常量
15．4．2 用来"处理 Stream 状态"的成员函数
15．4．3 Stream 状态与 Boolean 条件测试
15．4．4 Stream 的状态和异常
15．5 标准 I/O 函数
15．5．1 Input 相关函数
15．5．2 Output 相关函数
15．5．3 实例
15．5．4 sentry 对象
15．6 操控器（Manipulator）
15．6．1 操控器概览
15．6．2 操控器如何运作
15．6．3 用户自定义的操控器
15．7 格式化（Formatting）
15．7．1 Format Flag（格式标志）
15．7．2 Boolean 的 I/O 格式
15．7．3 栏位宽度、填充字符、位置调整
15．7．4 正号与大写
15．7．5 数值基底（Numeric Base）
15．7．6 浮点数（Floating-Point）表示法
15．7．7 一般格式（General Formatting）定义
15．8 国际化（Internationalization）
15．9 文件访问（File Access）
15．9．1 File Stream Class
15．9．2 File Stream 的 Rvalue 和 Move 语义
15．9．3 File Flag（文件标志）
15．9．4 随机访问（Random Access）
15．9．5 使用文件描述器（File Descriptor）
15．10 为 String 而设计的 Stream Class
15．10．1 String Stream Class
15．10．2 String Stream 的 Move 语义
15．10．3 char* Stream Class
15．11 "用户自定义类型"之 I/O 操作符
15．11．1 实现一个 Output 操作符
15．11．2 实现一个 Input 操作符
15．11．3 以辅助函数完成 I/O
15．11．4 用户自定义之 Format Flag（格式标志）
15．11．5 用户自定义 I/O 操作符的规约（Convention）
15．12 连接 Input 和 Output Stream
15．12．1 以 tie() 完成松耦合（Loose Coupling）
15．12．2 以 Stream 缓冲区完成紧耦合（Tight Coupling）
15．12．3 将标准 Stream 重定向（Redirecting）
15．12．4 可读可写的 Stream
15．13 Stream Buffer Class
15．13．1 Stream 缓冲区接口
15．13．2 Stream 缓冲区的 Iterator
15．13．3 用户自定义之 Stream 缓冲区
15．14 关于效能（Performance）
15．14．1 与 C 标准串流同步（Synchronization with C＇s Standard Streams）
15．14．2 Stream 缓冲区内的缓冲机制
15．14．3 直接使用 Stream 缓冲区
16 国际化
16．1 字符编码和字符集
16．1．1 多字节（Multibyte）和宽字符（Wide-Character）文本
16．1．2 不同的字符集
16．1．3 在 C++ 中处理字符集
16．1．4 Character Trait
16．1．5 特殊字符的国际化
16．2 Locale（地域）概念
16．2．1 使用 Locale
16．2．2 Locale Facet
16．3 细究 Locale
16．4 细究 Facet
16．4．1 数值格式化（Numeric Formatting）
16．4．2 货币符号格式化（Monetary Formatting）
16．4．3 时间和日期格式化（Time and Date Formatting）
16．4．4 字符的分类和转换
16．4．5 字符串校勘（String Collation）
16．4．6 消息国际化（Internationalized Message）
17 数值
17．1 随机数及分布（Random Number and Distribution）
17．1．1 第一个例子
17．1．2 引擎（Engine）
17．1．3 细说引擎（Engine）
17．1．4 分布（Distribution）
17．1．5 细说分布（Distribution）
17．2 复数（Complex Number）
17．2．1 Class complex＜＞ 一般性质
17．2．2 Class complex＜＞ 运用实例
17．2．3 复数的各项操作
17．2．4 细说 Class complex＜＞
17．3 全局数值函数（Global Numeric Function）
17．4 Valarray
18 并发
18．1 高级接口：async() 和 Future
18．1．1 async() 和 Future 的第一个用例
18．1．2 实例：等待两个 Task
18．1．3 Shared Future
18．2 低层接口：Thread 和 Promise
18．2．1 Class std：：thread
18．2．2 Promise
18．2．3 Class packaged_task＜＞
18．3 细说启动线程（Starting a Thread）
18．3．1 细说 async()
18．3．2 细说 Future
18．3．3 细说 Shared Future
18．3．4 细说 Class std：：promise
18．3．5 细说 Class std：：packaged_task
18．3．6 细说 Class std：：thread
18．3．7 Namespace this_thread
18．4 线程同步化与 Concurrency（并发）问题
18．4．1 当心 Concurrency（并发）
18．4．2 Concurrent Data Access 为什么造成问题
18．4．3 什么情况下可能出错
18．4．4 解决问题所需要的性质（Feature）
18．5 Mutex 和 Lock
18．5．1 使用 Mutex 和 Lock
18．5．2 细说 Mutex 和 Lock
18．5．3 只调用一次
18．6 Condition Variable（条件变量）
18．6．1 Condition Variable（条件变量）的意图
18．6．2 Condition Variable（条件变量）的第一个完整例子
18．6．3 使用 Condition Variable（条件变量）实现多线程 Queue
18．6．4 细说 Condition Variable（条件变量）
18．7 Atomic
18．7．1 Atomic 用例
18．7．2 细说 Atomic 及其高级接口
18．7．3 Atomic 的 C-Style 接口
18．7．4 Atomic 的低层接口
19 分配器
19．1 以应用程序开发者的角度使用 Allocator
19．2 用户自定义的 Allocator
19．3 以程序库开发者的角度使用 Allocator
参考书目
新闻组及论坛（ Newsgroup and Forum ）
书籍和网站


1.1 抽象的过程
1.2 对象有一个接口
1.3 实现的隐藏
1.4 实现的重用
1.5 继承：重用接口
1.5.1 is-a 关系和is-like-a 关系
1.6 具有多态性的可互换对象
1.7 创建和销毁对象
1.8 异常处理：应对错误
1.9 分析和设计
1.9.1 第0阶段：制定计划
1.9.2 第1阶段：我们在做什么
1.9.3 第2阶段：我们将如何建立对象
1.9.4 第3阶段：创建核心
1.9.5 第4阶段：迭代用例
1.9.6 第5阶段：进化
1.9.7 计划的回报
1.10 极限编程
1.10.1 先写测试
1.10.2 结对编程
1.11 为什么c++会成功
1.11.1 一个较好的c
1.11.2 延续式的学习过程
1.11.3 效率
1.11.4 系统更容易表达和理解
1.11.5 尽量使用库
1.11.6 利用模板的源代码重用
1.11.7 错误处理
1.11.8 大型程序设计
1.12 为向oop转变而采取的策略
1.12.1 指导方针
1.12.2 管理的障碍
1.13 小结
第2章 对象的创建与使用
2.1 语言的翻译过程
2.1.1 解释器
2.1.2 编译器
2.1.3 编译过程
2.2 分段编译工具
2.2.1 声明与定义
2.2.2 连接
2.2.3 使用库文件
2.3 编写第一个c++程序
2.3.1 使用iostream类
2.3.2 名字空间
2.3.3 程序的基本结构
2.3.4 “hello， world！”
2.3.5 运行编译器
2.4 关于输入输出流
2.4.1 字符数组的拼接
2.4.2 读取输入数据
2.4.3 调用其他程序
2.5 字符串简介
2.6 文件的读写
2.7 vector简介
2.8 小结
2.9 练习
第3章 c++中的c
3.1 创建函数
3.1.1 函数的返回值
3.1.2 使用c的函数库
3.1.3 通过库管理器创建自己的库
3.2 执行控制语句
3.2.1 真和假
3.2.2 if-else语句
3.2.3 while语句
3.2.4 do-while语句
3.2.5 for语句
3.2.6 关键字break 和 continue
3.2.7 switch语句
3.2.8 使用和滥用goto
3.2.9 递归
3.3 运算符简介
3.3.1 优先级
3.3.2 自增和自减
3.4 数据类型简介
3.4.1 基本内建类型
3.4.2 bool类型与true和false
3.4.3 说明符
3.4.4 指针简介
3.4.5 修改外部对象
3.4.6 c++引用简介
3.4.7 用指针和引用作为修饰符
3.5 作用域
3.5.1 实时定义变量
3.6 指定存储空间分配
3.6.1 全局变量
3.6.2 局部变量
3.6.3 静态变量
3.6.4 外部变量
3.6.5 常量
3.6.6 volatile变量
3.7 运算符及其使用
3.7.1 赋值
3.7.2 数学运算符
3.7.3 关系运算符
3.7.4 逻辑运算符
3.7.5 位运算符
3.7.6 移位运算符
3.7.7 一元运算符
3.7.8 三元运算符
3.7.9 逗号运算符
3.7.10 使用运算符时的常见问题
3.7.11 转换运算符
3.7.12 c++的显式转换
3.7.13 sizeof-独立运算符
3.7.14 asm 关键字
3.7.15 显式运算符
3.8 创建复合类型
3.8.1 用typedef命名别名
3.8.2 用struct把变量结合在一起
3.8.3 用enum提高程度清晰度
3.8.4 用union节省内存
3.8.5 数组
3.9 调试技巧
3.9.1 调试标记
3.9.2 把变量和表达式转换成字符串
3.9.3 c语言assert（ ）宏
3.10 函数地址
3.10.1 定义函数指针
3.10.2 复杂的声明和定义
3.10.3 使用函数指针
3.10.4 指向函数的指针数组
3.11 make：管理分段编译
3.11.1 make的行为
3.11.2 本书中的makefile
3.11.3 makefile的一个例子
3.12 小结
3.13 练习
第4章 数据抽象
4.1 一个袖珍c库
4.1.1 动态存储分配
4.1.2 有害的猜测
4.2 哪儿出问题
4.3 基本对象
4.4 什么是对象
4.5 抽象数据类型
4.6 对象细节
4.7 头文件形式
4.7.1 头文件的重要性
4.7.2 多次声明问题
4.7.3 预处理器指示#define、#ifdef
和#endif
4.7.4 头文件的标准
4.7.5 头文件中的名字空间
4.7.6 在项目中使用头文件
4.8 嵌套结构
4.8.1 全局作用域解析
4.9 小结
4.10 练习
第5章 隐藏实现
5.1 设置限制
5.2 c++的访问控制
5.2.1 protected说明符
5.3 友元
5.3.1 嵌套友元
5.3.2 它是纯面向对象的吗
5.4 对象布局
5.5 类
5.5.1 用访问控制来修改stash
5.5.2 用访问控制来修改stack
5.6 句柄类
5.6.1 隐藏实现
5.6.2 减少重复编译
5.7 小结
5.8 练习
第6章 初始化与清除
6.1 用构造函数确保初始化
6.2 用析构函数确保清除
6.3 清除定义块
6.3.1 for循环
6.3.2 内存分配
6.4 带有构造函数和析构函数的stash
6.5 带有构造函数和析构函数的stack
6.6 聚合初始化
6.7 默认构造函数
6.8 小结
6.9 练习
第7章 函数重载与默认参数
7.1 名字修饰
7.1.1 用返回值重载
7.1.2 类型安全连接
7.2 重载的例子
7.3 联合
7.4 默认参数
7.4.1 占位符参数
7.5 选择重载还是默认参数
7.6 小结
7.7 练习
第8章 常量
8.1 值替代
8.1.1 头文件里的const
8.1.2 const的安全性
8.1.3 聚合
8.1.4 与c语言的区别
8.2 指针
8.2.1 指向const的指针
8.2.2 const指针
8.2.3 赋值和类型检查
8.3 函数参数和返回值
8.3.1 传递const值
8.3.2 返回const值
8.3.3 传递和返回地址
8.4 类
8.4.1 类里的const
8.4.2 编译期间类里的常量
8.4.3 const对象和成员函数
8.5 volatile
8.6 小结
8.7 练习
第9章 内联函数
9.1 预处理器的缺陷
9.1.1 宏和访问
9.2 内联函数
9.2.1 类内部的内联函数
9.2.2 访问函数
9.3 带内联函数的stash和stack
9.4 内联函数和编译器
9.4.1 限制
9.4.2 向前引用
9.4.3 在构造函数和析构函数里隐藏行为
9.5 减少混乱
9.6 预处理器的更多特征
9.6.1 标志粘贴
9.7 改进的错误检查
9.8 小结
9.9 练习
第10章 名字控制
10.1 来自c语言中的静态元素
10.1.1 函数内部的静态变量
10.1.2 控制连接
10.1.3 其他存储类型说明符
10.2 名字空间
10.2.1 创建一个名字空间
10.2.2 使用名字空间
10.2.3 名字空间的使用
10.3 c++中的静态成员
10.3.1 定义静态数据成员的存储
10.3.2 嵌套类和局部类
10.3.3 静态成员函数
10.4 静态初始化的相依性
10.4.1 怎么办
10.5 替代连接说明
10.6 小结
10.7 练习
第11章 引用和拷贝构造函数
11.1 c++中的指针
11.2 c++中的引用
11.2.1 函数中的引用
11.2.2 参数传递准则
11.3 拷贝构造函数
11.3.1 按值传递和返回
11.3.2 拷贝构造函数
11.3.3 默认拷贝构造函数
11.3.4 替代拷贝构造函数的方法
11.4 指向成员的指针
11.4.1 函数
11.5 小结
11.6 练习
第12章 运算符重载
12.1 两个极端
12.2 语法
12.3 可重载的运算符
12.3.1 一元运算符
12.3.2 二元运算符
12.3.3 参数和返回值
12.3.4 不常用的运算符
12.3.5 不能重载的运算符
12.4 非成员运算符
12.4.1 基本方针
12.5 重载赋值符
12.5.1 operator=的行为
12.6 自动类型转换
12.6.1 构造函数转换
12.6.2 运算符转换
12.6.3 类型转换例子
12.6.4 自动类型转换的缺陷
12.7 小结
12.8 练习
第13章 动态对象创建
13.1 对象创建
13.1.1 c从堆中获取存储单元的方法
13.1.2 operator new
13.1.3 operator delete
13.1.4 一个简单的例子
13.1.5 内存管理的开销
13.2 重新设计前面的例子
13.2.1 使用delete void*可能会出错
13.2.2 对指针的清除责任
13.2.3 指针的stash
13.3 用于数组的new和delete
13.3.1 使指针更像数组
13.4 耗尽内存
13.5 重载new和delete
13.5.1 重载全局new和delete
13.5.2 对于一个类重载new和delete
13.5.3 为数组重载new和delete
13.5.4 构造函数调用
13.5.5 定位new和delete
13.6 小结
13.7 练习
第14章 继承和组合
14.1 组合语法
14.2 继承语法
14.3 构造函数的初始化表达式表
14.3.1 成员对象初始化
14.3.2 在初始化表达式表中的内建类型
14.4 组合和继承的联合
14.4.1 构造函数和析构函数调用的次序
14.5 名字隐藏
14.6 非自动继承的函数
14.6.1 继承和静态成员函数
14.7 组合与继承的选择
14.7.1 子类型设置
14.7.2 私有继承
14.8 protected
14.8.1 protected继承
14.9 运算符的重载与继承
14.10 多重继承
14.11 渐增式开发
14.12 向上类型转换
14.12.1 为什么要“向上类型转换”
14.12.2 向上类型转换和拷贝构造函数
14.12.3 组合与继承（再论）
14.12.4 指针和引用的向上类型转换
14.12.5 危机
14.13 小结
14.14 练习
第15章 多态性和虚函数
15.1 c++程序员的演变
15.2 向上类型转换
15.3 问题
15.3.1 函数调用捆绑
15.4 虚函数
15.4.1 扩展性
15.5 c++如何实现晚捆绑
15.5.1 存放类型信息
15.5.2 虚函数功能图示
15.5.3 撩开面纱
15.5.4 安装vpointer
15.5.5 对象是不同的
15.6 为什么需要虚函数
15.7 抽象基类和纯虚函数
15.7.1 纯虚定义
15.8 继承和vtable
15.8.1 对象切片
15.9 重载和重新定义
15.9.1 变量返回类型
15.10 虚函数和构造函数
15.10.1 构造函数调用次序
15.10.2 虚函数在构造函数中的行为
15.11 析构函数和虚拟析构函数
15.11.1 纯虚析构函数
15.11.2 析构函数中的虚机制
15.11.3 创建基于对象的继承
15.12 运算符重载
15.13 向下类型转换
15.14 小结
15.15 练习
第16章 模板介绍
16.1 容器
16.1.1 容器的需求
16.2 模板综述
16.2.1 模板方法
16.3 模板语法
16.3.1 非内联函数定义
16.3.2 作为模板的intstack
16.3.3 模板中的常量
16.4 作为模板的stash和stack
16.4.1 模板化的指针stash
16.5 打开和关闭所有权
16.6 以值存放对象
16.7 迭代器简介
16.7.1 带有迭代器的栈
16.7.2 带有迭代器的pstash
16.8 为什么使用迭代器
16.8.1 函数模板
16.9 小结
16.10 练习
附录a 编码风格
附录b 编程准则
附录c 推荐读物
第2卷 实用编程技术
译者序
前言
第一部分 建立稳定的系统
第1章 异常处理
1.1 传统的错误处理
1.2 抛出异常
1.3 捕获异常
1.3.1 try块
1.3.2 异常处理器
1.3.3 终止和恢复
1.4 异常匹配
1.4.1 捕获所有异常
1.4.2 重新抛出异常
1.4.3 不捕获异常
1.5 清理
1.5.1 资源管理
1.5.2 使所有事物都成为对象
1.5.3 auto_ptr
1.5.4 函数级的try块
1.6 标准异常
1.7 异常规格说明
1.7.1 更好的异常规格说明
1.7.2 异常规格说明和继承
1.7.3 什么时候不使用异常规格说明
1.8 异常安全
1.9 在编程中使用异常
1.9.1 什么时候避免异常
1.9.2 异常的典型应用
1.10 使用异常造成的开销
1.11 小结
1.12 练习
第2章 防御性编程
2.1 断言
2.2 一个简单的单元测试框架
2.2.1 自动测试
2.2.2 testsuite框架
2.2.3 测试套件
2.2.4 测试框架的源代码
2.3 调试技术
2.3.1 用于代码跟踪的宏
2.3.2 跟踪文件
2.3.3 发现内存泄漏
2.4 小结
2.5 练习
第二部分 标准c++库
第3章 深入理解字符串
3.1 字符串的内部是什么
3.2 创建并初始化c++字符串
3.3 对字符串进行操作
3.3.1 追加、插入和连接字符串
3.3.2 替换字符串中的字符
3.3.3 使用非成员重载运算符连接
3.4 字符串的查找
3.4.1 反向查找
3.4.2 查找一组字符第1次或最后一次出现的位置
3.4.3 从字符串中删除字符
3.4.4 字符串的比较
3.4.5 字符串和字符的特性
3.5 字符串的应用
3.6 小结
3.7 练习
第4章 输入输出流
4.1 为什么引入输入输出流
4.2 救助输入输出流
4.2.1 插入符和提取符
4.2.2 通常用法
4.2.3 按行输入
4.3 处理流错误
4.4 文件输入输出流
4.4.1 一个文件处理的例子
4.4.2 打开模式
4.5 输入输出流缓冲
4.6 在输入输出流中定位
4.7 字符串输入输出流
4.7.1 输入字符串流
4.7.2 输出字符串流
4.8 输出流的格式化
4.8.1 格式化标志
4.8.2 格式化域
4.8.3 宽度、填充和精度设置
4.8.4 一个完整的例子
4.9 操纵算子
4.9.1 带参数的操纵算子
4.9.2 创建操纵算子
4.9.3 效用算子
4.10 输入输出流程序举例
4.10.1 维护类库的源代码
4.10.2 检测编译器错误
4.10.3 一个简单的数据记录器
4.11 国际化
4.11.1 宽字符流
4.11.2 区域性字符流
4.12 小结
4.13 练习
第5章 深入理解模板
5.1 模板参数
5.1.1 无类型模板参数
5.1.2 默认模板参数
5.1.3 模板类型的模板参数
5.1.4 typename关键字
5.1.5 以template关键字作为提示
5.1.6 成员模板
5.2 有关函数模板的几个问题
5.2.1 函数模板参数的类型推断
5.2.2 函数模板重载
5.2.3 以一个已生成的函数模板地址作为参数
5.2.4 将函数应用到stl序列容器中
5.2.5 函数模板的半有序
5.3 模板特化
5.3.1 显式特化
5.3.2 半特化
5.3.3 一个实例
5.3.4 防止模板代码膨胀
5.4 名称查找问题
5.4.1 模板中的名称
5.4.2 模板和友元
5.5 模板编程中的习语
5.5.1 特征
5.5.2 策略
5.5.3 奇特的递归模板模式
5.6 模板元编程
5.6.1 编译时编程
5.6.2 表达式模板
5.7 模板编译模型
5.7.1 包含模型
5.7.2 显式实例化
5.7.3 分离模型
5.8 小结
5.9 练习
第6章 通用算法
6.1 概述
6.1.1 判定函数
6.1.2 流迭代器
6.1.3 算法复杂性
6.2 函数对象
6.2.1 函数对象的分类
6.2.2 自动创建函数对象
6.2.3 可调整的函数对象
6.2.4 更多的函数对象例子
6.2.5 函数指针适配器
6.2.6 编写自己的函数对象适配器
6.3 stl算法目录
6.3.1 实例创建的支持工具
6.3.2 填充和生成
6.3.3 计数
6.3.4 操作序列
6.3.5 查找和替换
6.3.6 比较范围
6.3.7 删除元素
6.3.8 对已排序的序列进行排序和运算
6.3.9 堆运算
6.3.10 对某一范围内的所有元素进行运算
6.3.11 数值算法
6.3.12 通用实用程序
6.4 创建自己的stl风格算法
6.5 小结
6.6 练习
第7章 通用容器
7.1 容器和迭代器
7.2 概述
7.2.1 字符串容器
7.2.2 从stl容器继承
7.3 更多迭代器
7.3.1 可逆容器中的迭代器
7.3.2 迭代器的种类
7.3.3 预定义迭代器
7.4 基本序列容器：vector、list和deque
7.4.1 基本序列容器的操作
7.4.2 向量
7.4.3 双端队列
7.4.4 序列容器间的转换
7.4.5 被检查的随机访问
7.4.6 链表
7.4.7 交换序列
7.5 集合
7.6 堆栈
7.7 队列
7.8 优先队列
7.9 持有二进制位
7.9.1 bitset[n]
7.9.2 vector[bool]
7.10 关联式容器
7.10.1 用于关联式容器的发生器和填充器
7.10.2 不可思议的映像
7.10.3 多重映像和重复的关键字
7.10.4 多重集合
7.11 将stl容器联合使用
7.12 清除容器的指针
7.13 创建自己的容器
7.14 对stl的扩充
7.15 非stl容器
7.16 小结
7.17 练习
第三部分 专 题
第8章 运行时类型识别
8.1 运行时类型转换
8.2 typeid 操作符
8.2.1 类型转换到中间层次类型
8.2.2 void型指针
8.2.3 运用带模板的rtti
8.3 多重继承
8.4 合理使用rtti
8.5 rtti的机制和开销
8.6 小结
8.7 练习
第9章 多重继承
9.1 概论
9.2 接口继承
9.3 实现继承
9.4 重复子对象
9.5 虚基类
9.6 名字查找问题
9.7 避免使用多重继承
9.8 扩充一个接口
9.9 小结
9.10 练习
第10章 设计模式
10.1 模式的概念
10.2 模式分类
10.3 简化习语
10.3.1 信使
10.3.2 收集参数
10.4 单件
10.5 命令：选择操作
10.6 消除对象耦合
10.6.1 代理模式：作为其他对象的前端
10.6.2 状态模式：改变对象的行为
10.7 适配器模式
10.8 模板方法模式
10.9 策略模式：运行时选择算法
10.10 职责链模式：尝试采用一系列
策略模式
10.11 工厂模式：封装对象的创建
10.11.1 多态工厂
10.11.2 抽象工厂
10.11.3 虚构造函数
10.12 构建器模式：创建复杂对象
10.13 观察者模式
10.13.1 “内部类”方法
10.13.2 观察者模式举例
10.14 多重派遣
10.15 小结
10.16 练习
第11章 并发
11.1 动机
11.2 c++中的并发
11.3 定义任务
11.4 使用线程
11.4.1 创建有响应的用户界面
11.4.2 使用执行器简化工作
11.4.3 让步
11.4.4 休眠
11.4.5 优先权
11.5 共享有限资源
11.5.1 保证对象的存在
11.5.2 不恰当地访问资源
11.5.3 访问控制
11.5.4 使用保护简化编码
11.5.5 线程本地存储
11.6 终止任务
11.6.1 防止输入/输出流冲突
11.6.2 举例观赏植物园
11.6.3 阻塞时终止
11.6.4 中断
11.7 线程间协作
11.7.1 等待和信号
11.7.2 生产者-消费者关系
11.7.3 用队列解决线程处理的问题
11.7.4 广播
11.8 死锁
11.9 小结
11.10 练习


导读（Introduction）
基础议题（Basics）
条款1：仔细区别 pointers 和 references
Distinguish between pointers and references.
条款2：最好使用 C++ 转型操作符
Prefer C++-style casts.
条款3：绝对不要以多态（polymorphically）方式处理数组
Never treat arrays polymorphically.
条款4：非必要不提供 default constructor
Avoid gratuitous default constructors.
操作符（Operators）
条款5：对定制的"类型转换函数"保持警觉
Be wary of user-defined conversion functions.
条款6：区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式
Distinguish between prefix and postfix forms of increment and decrement operators.
条款7：千万不要重载＆＆，||和， 操作符
Never overload ＆＆， ||， or，.
条款8：了解各种不同意义的 new 和 delete
Understand the different meanings of new and delete

异常（Exceptions）
条款9：利用 destructors 避免泄漏资源
Use destructors to prevent resource leaks.
条款10：在 constructors 内阻止资源泄漏（resource leak）
Prevent resource leaks in constructors.
条款11：禁止异常（exceptions）流出 destructors 之外
Prevent exceptions from leaving destructors.
条款12：了解"抛出一个 exception"与"传递一个参数"或"调用一个虚函数"之间的差异
Understand how throwing an exception differs from passing a parameter or calling a virtual function.
条款13：以 by reference 方式捕捉 exceptions
Catch exceptions by reference.
条款14：明智运用 exception specifications
Use exception specifications judiciously.
条款15：了解异常处理（exception handling）的成本
Understand the costs of exception handling.

效率（Efficiency）
条款16：谨记 80-20 法则
Remember the 80-20 rule.
条款17：考虑使用 lazy evaluation（缓式评估）
Consider using lazy evaluation.
条款18：分期摊还预期的计算成本
Amortize the cost of expected computations.
条款19：了解临时对象的来源
Understand the origin of temporary objects.
条款20：协助完成"返回值优化（RVO）"
Facilitate the return value optimization.
条款21：利用重载技术（overload）避免隐式类型转换（implict type conversions）
Overload to avoid implicit type conversions.
条款22：考虑以操作符复合形式（op=）取代其独身形式（op）
Consider using op= instead of stand-alone op.
条款23：考虑使用其他程序库
Consider alternative libraries.
条款24：了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本
Understand the costs of virtual functions， multiple inheritance，virtual base classes， and RTTI.

技术（Techniques， Idioms， Patterns）
条款25：将 constructor 和 non-member functions 虚化
Virtualizing constructors and non-member functions.
条款26：限制某个 class 所能产生的对象数量
Limiting the number of objects of a class.
条款27：要求（或禁止）对象产生于 heap 之中
Requiring or prohibiting heap-based objects.
条款28：Smart Pointers（智能指针）
条款29：Reference counting（引用计数）
条款30：Proxy classes（替身类、代理类）
条款31：让函数根据一个以上的对象类型来决定如何虚化
Making functions virtual with respect to more than one object.

杂项讨论（Miscellany）
条款32：在未来时态下发展程序
Program in the future tense.
条款33：将非尾端类（non-leaf classes）设计为抽象类（abstract classes）
Make non-leaf classes abstract.
条款34：如何在同一个程序中结合 C++ 和 C
Understand how to combine C++ and C in the same program.
条款35：让自己习惯于标准 C++ 语言
Familiarize yourself with the language standard.
推荐读物
auto_ptr 实现代码
索引（一）（General Index）
索引（二）（Index of Example Classes，Functions，and Templtes）


https://mingw-w64.org/doku.php/download


如何搭建Eclipse C/C++ MinGW 环境
96  ffewi
 0.2 2018.04.30 19:06 字数 671 阅读 1375评论 1喜欢 4
准备工作

eclipse：eclipse-cpp-oxygen-3a-win32-x86_64.zip
CDT：cdt-9.3.3.zip
MinGW：mingw-w64.zip
JDK：jdk-8u171-windows-i586.exe or jdk-8u171-windows-x64.exe
下载地址：链接：https://pan.baidu.com/s/1AxCp7uN__oYzqEVwAWD70w 密码：o2t1

开始安装
步骤1：

由于运行eclipse需要java环境，并且Oxygen版本的eclipse对于JDK版本要求应该为1.8，所以先安装JDK1.8
运行JDK安装包自行安装，安装目录自定义。笔者目录：

C:\Program Files (x86)\Java\jdk1.8.0_171 【JDK】
C:\Program Files (x86)\Java\jre8 【JRE】
测试安装成功否：

D:\>java -version
java version "1.8.0_171"
Java(TM) SE Runtime Environment (build 1.8.0_171-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.171-b11, mixed mode)

D:\>
步骤2：

解压eclipse-cpp-oxygen-3a-win32-x86_64.zip 至自定义路径，笔者目录路径：

D:\developer\eclipse
运行eclipse.exe，是否能正常启动？

步骤3：

解压mingw-w64.zip 至自定义路径，笔者目录路径：

D:\environment\mingw
里面包含两个字文件夹：mingw-w64、msys

运行查看压缩包是否正常

Win+R运行CMD，进入解压目录中mingw-w64子目录mingw-w64\x86_64-4.9.2-posix-seh-rt_v3-rev1\mingw64\bin，
执行gcc -v,查看控制台输出，结尾行：

gcc version 4.9.2 (x86_64-posix-seh-rev1, Built by MinGW-W64 project)
进入msys\1.0\etc，编辑fstab文件：

#在这里添加mingw路径
#Win32_Path     Mount_Point
D:/environment/mingw/mingw-w64/x86_64-4.9.2-posix-seh-rt_v3-rev1/mingw64        /mingw
提示：如果此目录下没有fstab，复制fatab.sample再进行编辑。

运行D:\environment\mingw\msys\1.0\msys.bat，键入gcc -v,查看输出：

$ gcc -v
    ...
    ...
 gcc version 4.9.2 (x86_64-posix-seh-rev1, Built by MinGW-W64 project)
至此，C/C++ 运行环境调试成功！

步骤4：

配置eclipse MINGW_HOME和MSYS_HOME:

Window --> Preferences --> C/C++ --> Build --> Environment
Variable	Value
MINGW_HOME	D:\environment\mingw\mingw-w64\x86_64-4.9.2-posix-seh-rt_v3-rev1\mingw64
MSYS_HOME	D:\environment\mingw\msys\1.0
配置Toolchains：

Window --> Preferences --> C/C++ --> Core Build Toolchains
User Defined Toolchains：

Compiler：D:\environment\mingw\mingw-w64\x86_64-4.9.2-posix-seh-rt_v3-rev1\mingw64\bin\gcc.exe
Operating System：WIN7
CPU Architecture：

步骤5：

安装eclipse CDT插件：

Help --> Install New Software...
Work with 键入CDT安装地址进行安装。笔者下载的离线安装包直接键入： jar:file:/D:/tools/cdt-9.3.3.zip!/。
不知道需要安装那些功能可以Select All进行安装。

至此，Eclise + C环境 就已经全部设置完毕！

新建C Project

Project Explorer 区域右键New --> C/C++ Project --> C Managed Build

Project name: 自定义（例如：hello-c）。
Project type：Executable --> Hello World ANSI C Project
Toolchains：MinGW GCC

点击Finish即自动创建了一个Hello C项目示例。

hello-c.c

#include <stdio.h>
#include <stdlib.h>

int main(void) {
    puts("Hello C Language!"); /* prints Hello C Language! */
    return EXIT_SUCCESS;
}

如何运行？

在Eclipse中，要运行项目中的*.c文件，首先要编译出二进制文件，上面新建的项目没有进行编译，结构为：

hello-c
    + Includs // C 的类库
    + src // *.c 源码
        - hello-c.c // 创建项目时自动生成的文件
选中项目Ctrl+B 或者 右键项目Build Project，此时项目目录为

hello-c
    + Binaries // 编译的二进制*.exe 可执行文件
    + Includs // C 的类库
    + src // *.c 源码
        - hello-c.c // 创建项目时自动生成的文件
    + Debug // 编译输出目录路径
控制台编译消息：

16:06:22 **** Incremental Build of configuration Debug for project hello-c ****
Info: Internal Builder is used for build
gcc -O0 -g3 -Wall -c -fmessage-length=0 -o "src\\hello-c.o" "..\\src\\hello-c.c"
gcc -o hello-c.exe "src\\hello-c.o"

16:06:22 Build Finished (took 402ms)
此时，这个项目就可以运行了。选中hello-c.c 右键 Run As --> Local C/C++ Application。即可看到输出：

Hello C Language!

===========

很多学过java的程序员在使用微软的那一系列开发工具时大都不是很适应，VS系列体积庞大，反应极慢。由此很多人会想到小巧好使的eclipse。下面就来看看如何在eclipse下写C++程序，以及支持C++11新标准。

1.需要的安装工具

1）eclipse C++版本（JDK当然必不可少，这个许多java基础书籍上都有介绍如何配置环境变量，在此处本人不在多说）。下载地址：http://www.eclipse.org/downloads/packages/eclipse-ide-cc-developers/keplersr2



2）MinGW：用它作为C++和C的编译器。下载地址：nuwen.net/mingw.html





下载MinGW后双击文件自解压，自动生成MinGW文件夹。（在此处本人默认你的MinGW文件夹位于C盘根目录）





2.MinGW的环境变量配置

1）path=C:\MinGW\bin;C:\MinGW\libexec\gcc\x86_64-w64-mingw32\4.8.2

注：如果你的环境变量已经有path这一项，那么你最好不要再新建path，直接将C:\MinGW\bin;C:\MinGW\libexec\gcc\x86_64-w64-mingw32\4.8.2;加到最前面即可，否则你原有的path路径会被破坏：比如你在cmd下输入ipconfig，ping这些命令都会不支持

2)  LIBRARY_PATH=C:\MinGW\lib

3)  C_INCLUDEDE_PATH=C:\MinGW\include

4)  CPLUS_INCLUDE_PATH=C:\MinGW\include\c++\4.8.2;C:\MinGW\include\c++\4.8.2\backward;C:\MinGW\include



此时打开命令行输入gcc -v

显示

说明你的环境变量配置成功！



3.打开eclipse_cpp版本

1）





2）



3）



4）



5）写几句代码试试：

复制代码
 1 #include  <iostream>
 2 #include <list>
 3 using namespace std;
 4
 5 int main(int argc, char **argv)
 6 {
 7     //C++11列表初始化
 8     list<int> il={1,2,3,4,5,6};
 9
10     //基于范围的for语句
11     for(auto i:il)
12     {
13         cout<<i<<" ";
14     }
15     cout<<endl;
16 }
复制代码


6）先别急着运行，先构建在运行。







7）运行结果











最后在说明一点：在我的机器环境下C++11新标准可以支持，如果你的eclipse版本不是很新或者你用的不是我这个版本的编译器，那新标准很可能不支持。可参见：http://hkllzh.iteye.com/blog/1620352





第1章 C语言概述1
1.1 C语言的历史1
1.1.1 起源1
1.1.2 标准化1
1.1.3 基于C的语言2
1.2 C语言的优缺点3
1.2.1 C语言的优点3
1.2.2 C语言的缺点3
1.2.3 高效地使用C语言4
问与答5

第2章 C语言基本概念7
2.1 编写一个简单的C程序7
程序显示双关语7
2.1.1 编译和链接8
2.1.2 集成开发环境8
2.2 简单程序的一般形式9
2.2.1 指令9
2.2.2 函数9
2.2.3 语句10
2.2.4 显示字符串10
2.3 注释11
2.4 变量和赋值12
2.4.1 类型12
2.4.2 声明13
2.4.3 赋值13
2.4.4 显示变量的值14
程序计算箱子的空间重量14
2.4.5 初始化15
2.4.6 显示表达式的值16
2.5 读入输入16
程序计算箱子的空间重量（改进版）16
2.6 定义常量的名字17
程序华氏温度转换为摄氏温度17
2.7 标识符18
2.8 C程序的书写规范19
问与答21
练习题23
编程题24

第3章 格式化输入/输出26
3.1 printf函数26
3.1.1 转换说明27
程序用printf函数格式化数28
3.1.2 转义序列28
3.2 scanf函数29
3.2.1 scanf函数的工作方法30
3.2.2 格式串中的普通字符31
3.2.3 易混淆的printf函数和scanf函数32
程序分数相加32
问与答33
练习题34
编程题35

第4章 表达式36
4.1 算术运算符36
程序计算通用产品代码的校验位38
4.2 赋值运算符39
4.2.1 简单赋值40
4.2.2 左值41
4.2.3 复合赋值41
4.3 自增运算符和自减运算符42
4.4 表达式求值43
4.5 表达式语句45
问与答45
练习题47
编程题49

第5章 选择语句50
5.1 逻辑表达式50
5.1.1 关系运算符50
5.1.2 判等运算符51
5.1.3 逻辑运算符51
5.2 if语句52
5.2.1 复合语句53
5.2.2 else子句53
5.2.3 级联式if语句54
程序计算股票经纪人的佣金55
5.2.4 “悬空else”的问题56
5.2.5 条件表达式57
5.2.6 C89中的布尔值58
5.2.7 C99中的布尔值58
5.3 switch语句59
程序显示法定格式的日期61
问与答62
练习题65
编程题67

第6章 循环69
6.1 while语句69
程序显示平方表71
程序数列求和71
6.2 do语句72
程序计算整数的位数73
6.3 for语句73
6.3.1 for语句的惯用法74
6.3.2 在for语句中省略表达式75
6.3.3 C99中的for语句75
6.3.4 逗号运算符76
程序显示平方表（改进版）77
6.4 退出循环78
6.4.1 break语句78
6.4.2 continue语句78
6.4.3 goto语句79
程序账簿结算80
6.5 空语句81
问与答83
练习题84
编程题85

第7章 基本类型88
7.1 整数类型88
7.1.1 C99中的整数类型90
7.1.2 整数常量90
7.1.3 C99中的整数常量91
7.1.4 整数溢出91
7.1.5 读/写整数91
程序数列求和（改进版）92
7.2 浮点类型93
7.2.1 浮点常量94
7.2.2 读/写浮点数94
7.3 字符类型94
7.3.1 字符操作95
7.3.2 有符号字符和无符号字符95
7.3.3 算术类型96
7.3.4 转义序列96
7.3.5 字符处理函数97
7.3.6 用scanf和printf读/写字符98
7.3.7 用getchar和putchar读/写字符98
程序确定消息的长度99
7.4 类型转换100
7.4.1 常用算术转换101
7.4.2 赋值过程中的转换102
7.4.3 C99中的隐式转换103
7.4.4 强制类型转换103
7.5 类型定义105
7.5.1 类型定义的优点105
7.5.2 类型定义和可移植性105
7.6 sizeof运算符106
问与答107
练习题109
编程题110

第8章 数组113
8.1 一维数组113
8.1.1 数组下标113
程序数列反向115
8.1.2 数组初始化115
8.1.3 指定初始化式116
程序检查数中重复出现的数字116
8.1.4 对数组使用sizeof运算符117
程序计算利息118
8.2 多维数组119
8.2.1 多维数组初始化120
8.2.2 常量数组121
程序发牌121
8.3 C99中的变长数组122
问与答123
练习题124
编程题125

第9章 函数129
9.1 函数的定义和调用129
程序计算平均值129
程序显示倒计数130
程序显示双关语（改进版）131
9.1.1 函数定义132
9.1.2 函数调用133
程序判定素数134
9.2 函数声明135
9.3 实际参数136
9.3.1 实际参数的转换137
9.3.2 数组型实际参数138
9.3.3 变长数组形式参数140
9.3.4 在数组参数声明中使用static141
9.3.5 复合字面量141
9.4 return语句142
9.5 程序终止143
9.6 递归144
程序快速排序146
问与答147
练习题150
编程题153

第10章 程序结构155
10.1 局部变量155
10.1.1 静态局部变量156
10.1.2 形式参数156
10.2 外部变量156
10.2.1 示例：用外部变量实现栈156
10.2.2 外部变量的利与弊157
程序猜数158
10.3 程序块161
10.4 作用域162
10.5 构建C程序163
程序给一手牌分类163
问与答169
练习题169
编程题170

第11章 指针172
11.1 指针变量172
11.2 取地址运算符和间接寻址运算符173
11.2.1 取地址运算符173
11.2.2 间接寻址运算符174
11.3 指针赋值174
11.4 指针作为参数176
程序找出数组中的最大元素和最小元素177
11.5 指针作为返回值179
问与答180
练习题181
编程题182

第12章 指针和数组184
12.1 指针的算术运算184
12.1.1 指针加上整数185
12.1.2 指针减去整数185
12.1.3 两个指针相减186
12.1.4 指针比较186
12.1.5 指向复合常量的指针186
12.2 指针用于数组处理186
12.3 用数组名作为指针188程序数列反向（改进版）189
12.3.1 数组型实际参数（改进版）189
12.3.2 用指针作为数组名191
12.4 指针和多维数组191
12.4.1 处理多维数组的元素191
12.4.2 处理多维数组的行192
12.4.3 处理多维数组的列192
12.4.4 用多维数组名作为指针192
12.5 C99中的指针和变长数组193
问与答194
练习题195
编程题197

第13章 字符串198
13.1 字符串字面量198
13.1.1 字符串字面量中的转义序列198
13.1.2 延续字符串字面量199
13.1.3 如何存储字符串字面量199
13.1.4 字符串字面量的操作200
13.1.5 字符串字面量与字符常量200
13.2 字符串变量200
13.2.1 初始化字符串变量201
13.2.2 字符数组与字符指针202
13.3 字符串的读和写203
13.3.1 用printf函数和puts函数写字符串203
13.3.2 用scanf函数和gets函数读字符串203
13.3.3 逐个字符读字符串204
13.4 访问字符串中的字符205
13.5 使用C语言的字符串库206
13.5.1 strcpy函数207
13.5.2 strlen函数208
13.5.3 strcat函数208
13.5.4 strcmp函数209程序显示一个月的提醒列表209
13.6 字符串惯用法211
13.6.1 搜索字符串的结尾211
13.6.2 复制字符串213
13.7 字符串数组214
程序核对行星的名字217
问与答218
练习题220
编程题222

第14章 预处理器225
14.1 预处理器的工作原理225
14.2 预处理指令227
14.3 宏定义227
14.3.1 简单的宏227
14.3.2 带参数的宏229
14.3.3 #运算符231
14.3.4 ##运算符231
14.3.5 宏的通用属性232
14.3.6 宏定义中的圆括号233
14.3.7 创建较长的宏233
14.3.8 预定义宏234
14.3.9 C99中新增的预定义宏235
14.3.10 空的宏参数236
14.3.11 参数个数可变的宏236
14.3.12 __func__标识符237
14.4 条件编译237
14.4.1 #if指令和#endif指令238
14.4.2 defined运算符238
14.4.3 #ifdef指令和#ifndef指令239
14.4.4 #elif指令和#else指令239
14.4.5 使用条件编译240
14.5 其他指令240
14.5.1 #error指令240
14.5.2 #line指令241
14.5.3 #pragma指令242
14.5.4 _Pragma运算符242
问与答243
练习题245

第15章 编写大型程序248
15.1 源文件248
15.2 头文件249
15.2.1 #include指令249
15.2.2 共享宏定义和类型定义250
15.2.3 共享函数原型251
15.2.4 共享变量声明252
15.2.5 嵌套包含253
15.2.6 保护头文件253
15.2.7 头文件中的#error指令254
15.3 把程序划分成多个文件254程序文本格式化255
15.4 构建多文件程序260
15.4.1 makefile260
15.4.2 链接期间的错误262
15.4.3 重新构建程序262
15.4.4 在程序外定义宏264
问与答264
练习题265
编程题266

第16章 结构、联合和枚举267
16.1 结构变量267
16.1.1 结构变量的声明267
16.1.2 结构变量的初始化269
16.1.3 指定初始化269
16.1.4 对结构的操作270
16.2 结构类型270
16.2.1 结构标记的声明271
16.2.2 结构类型的定义272
16.2.3 结构作为参数和返回值272
16.2.4 复合字面量273
16.3 嵌套的数组和结构274
16.3.1 嵌套的结构274
16.3.2 结构数组274
16.3.3 结构数组的初始化275程序维护零件数据库275
16.4 联合281
16.4.1 用联合来节省空间282
16.4.2 用联合来构造混合的数据结构284
16.4.3 为联合添加“标记字段”284
16.5 枚举285
16.5.1 枚举标记和类型名286
16.5.2 枚举作为整数286
16.5.3 用枚举声明“标记字段”286
问与答287
练习题289
编程题293

第17章 指针的高级应用294
17.1 动态存储分配294
17.1.1 内存分配函数294
17.1.2 空指针295
17.2 动态分配字符串296
……
第18章 声明 327
第19章 程序设计 345
第20章 底层程序设计 363
第21章 标准库 377
第22章 输入/输出 384
第23章 库对数值和字符数据的支持 419
第24章 错误处理 446
第25章 国际化特性 456
第26章 其他库函数 482
第27章 C99对数学计算的新增支持 503
附录A C语言运算符 524
附录B C99与C89的比较 525
附录C C89与经典C的比较 529
附录D 标准库函数 532
附录E ASCII字符集 569
参考文献 570



第1章 导言
1.1 入门
1.2 变量与算术表态式
1.3 for语句
1.4 符号常量
1.5 字符输入/输出
1.6 数组
1.7 函数
1.8 参数——传值调用
1.9 字符数组
1.10 外部变量与作用域
第2章 类型、运算符与表达式
2.1 变量名
2.2 数据类型及长度
2.3 常量
2.4 声明
2.5 算术运算符
2.6 关系运算符与逻辑运算符
2.7 类型转换
2.8 自增运算符与自减运算符
2.9 按位运算符
2.10 赋值运算符与表达式
2.11 条件表达式
2.12 运算符优先级与求值次序
第3章 控制流
3.1 语句与程序块
3.2 if-else语句
3.3 else-if语句
3.4 switch语句
3.5 whil循环与for特环
3.6 do-while循环
3.7 break语句与continue语句
3.8 goto语句与标号
第4章 涵数与程序结构
第5章 指针与数组
第6章 结构
第7章 输入与输出
第8章 UNIX系统接口
附录A 参考手册
附录B 标准库
附录C 变更小结

==========
第1章 C语言编程
1.1 C语言
1.2 标准库
1.3 学习C
1.4 创建C程序
1.4.1 编辑
1.4.2 编译
1.4.3 链接
1.4.4 执行
1.5 创建第一个程序
1.6 编辑第一个程序
1.7 处理错误
1.8 剖析一个简单的程序
1.8.1 注释
1.8.2 预处理指令
1.8.3 定义main()函数
1.8.4 关键字
1.8.5 函数体
1.8.6 输出信息
1.8.7 参数
1.8.8 控制符
1.8.9 三字母序列
1.9 预处理器
1.10 用C语言开发程序
1.10.1 了解问题
1.10.2 详细设计
1.10.3 实施
1.10.4 测试
1.11 函数及模块化编程
1.12 常见错误
1.13 要点
1.14 小结
1.15 习题

第2章 编程初步
2.1 计算机的内存
2.2 什么是变量
2.3 存储整数的变量
2.3.1 变量的使用
2.3.2 变量的初始化
2.4 变量与内存
2.4.1 带符号的整数类型
2.4.2 无符号的整数类型
2.4.3 指定整数常量
2.5 使用浮点数
2.6 浮点数变量
2.6.1 使用浮点数完成除法运算
2.6.2 控制输出中的小数位数
2.6.3 控制输出的字段宽度
2.7 较复杂的表达式
2.8 定义命名常量
2.8.1 极限值
2.8.2 sizeof运算符
2.9 选择正确的类型
2.10 强制类型转换
2.10.1 自动转换类型
2.10.2 隐式类型转换的规则
2.10.3 赋值语句中的隐式类型转换
2.11 再谈数值数据类型
2.11.1 字符类型
2.11.2 字符的输入输出
2.11.3 枚举
2.11.4 存储布尔值的变量
2.12 赋值操作的op=形式
2.13 数学函数
2.14 设计一个程序
2.14.1 问题
2.14.2 分析
2.14.3 解决方案
2.15 小结
2.16 练习

第3章 条件判断
3.1 判断过程
3.1.1 算术比较
3.1.2 基本的if语句
3.1.3 扩展if语句：if-else
3.1.4 在if语句中使用代码块
3.1.5 嵌套的if语句
3.1.6 测试字符
3.1.7 逻辑运算符
3.1.8 条件运算符
3.1.9 运算符的优先级
3.2 多项选择问题
3.2.1 给多项选择使用else-if语句
3.2.2 switch语句
3.2.3 goto语句
3.3 按位运算符
3.3.1 按位运算符的op=用法
3.3.2 使用按位运算符
3.4 设计程序
3.4.1 问题
3.4.2 分析
3.4.3 解决方案
3.5 小结
3.6 练习

第4章 循环
4.1 循环
4.2 递增和递减运算符
4.3 for循环
4.4 for循环的一般语法
4.5 再谈递增和递减运算符
4.5.1 递增运算符
4.5.2 递增运算符的前置和后置形式
4.5.3 递减运算符
4.6 再论for循环
4.6.1 修改for循环变量
4.6.2 没有参数的for循环
4.6.3 循环内的break语句
4.6.4 使用for循环限制输入
4.6.5 生成伪随机整数
4.6.6 再谈循环控制选项
4.6.7 浮点类型的循环控制变量
4.7 while循环
4.8 嵌套循环
4.9 嵌套循环和goto语句
4.10 do-while循环
4.11 continue语句
4.12 设计程序
4.12.1 问题
4.12.2 分析
4.12.3 解决方案
4.13 小结
4.14 习题

第5章 数组
5.1 数组简介
5.1.1 不用数组的程序
5.1.2 什么是数组
5.1.3 使用数组
5.2 寻址运算符
5.3 数组和地址
5.4 数组的初始化
5.5 确定数组的大小
5.6 多维数组
5.7 多维数组的初始化
5.8 变长数组
5.9 设计一个程序
5.9.1 问题
5.9.2 分析
5.9.3 解决方案
5.10 小结
5.11 习题

第6章 字符串和文本的应用
6.1 什么是字符串
6.2 存储字符串的变量
6.3 字符串操作
6.3.1 检查对C11的支持
6.3.2 确定字符串的长度
6.3.3 复制字符串
6.3.4 连接字符串
6.3.5 比较字符串
6.3.6 搜索字符串
6.3.7 单元化字符串
6.3.8 将换行符读入字符串
6.4 分析和转换字符串
6.4.1 转换字符的大小写形式
6.4.2 将字符串转换成数值
6.5 设计一个程序
6.5.1 问题
6.5.2 分析
6.5.3 解决方案
6.6 小结
6.7 习题

第7章 指针
7.1 指针初探
7.1.1 声明指针
7.1.2 通过指针访问值
7.1.3 使用指针
7.1.4 指向常量的指针
7.1.5 常量指针
7.1.6 指针的命名
7.2 数组和指针
7.3 多维数组
7.3.1 多维数组和指针
7.3.2 访问数组元素
7.4 内存的使用
7.4.1 动态内存分配：malloc()函数
7.4.2 释放动态分配的内存
7.4.3 用calloc()函数分配内存
7.4.4 扩展动态分配的内存
7.5 使用指针处理字符串
7.5.1 使用指针数组
7.5.2 指针和数组记号
7.6 设计程序
7.6.1 问题
7.6.2 分析
7.6.3 解决方案
7.7 小结
7.8 习题

第8章 编程的结构
8.1 程序的结构
8.1.1 变量的作用域和生存期
8.1.2 变量的作用域和函数
8.2 函数
8.2.1 定义函数
8.2.2 return语句
8.3 按值传递机制
8.4 函数原型
8.5 指针用作参数和返回值
8.5.1 常量参数
8.5.2 返回指针的风险
8.6 小结
8.7 习题

第9章 函数再探
9.1 函数指针
9.1.1 声明函数指针
9.1.2 通过函数指针调用函数
9.1.3 函数指针的数组
9.1.4 作为变元的函数指针
9.2 函数中的变量
9.2.1 静态变量：函数内部的追踪
9.2.2 在函数之间共享变量
9.3 调用自己的函数：递归
9.4 变元个数可变的函数
9.4.1 复制va_list
9.4.2 长度可变的变元列表的基本规则
9.5 main()函数
9.6 结束程序
9.6.1 abort()函数
9.6.2 exit()和atexit()函数
9.6.3 _Exit()函数
9.6.4 quick_exit()和at_quick_exit()函数
9.7 提高性能
9.7.1 内联声明函数
9.7.2 使用restrict关键字
9.7.3 _Noreturn函数限定符
9.8 设计程序
9.8.1 问题
9.8.2 分析
9.8.3 解决方案
9.9 小结
9.10 习题

第10章 基本输入和输出操作
10.1 输入和输出流
10.2 标准流
10.3 键盘输入
10.3.1 格式化键盘输入
10.3.2 输入格式控制字符串
10.3.3 输入格式字符串中的字符
10.3.4 输入浮点数的各种变化
10.3.5 读取十六进制和八进制值
10.3.6 用scanf_s()读取字符
10.3.7 从键盘上输入字符串
10.3.8 单个字符的键盘输入
10.4 屏幕输出
10.4.1 使用printf_s()的格式化输出
10.4.2 转义序列
10.4.3 整数输出
10.4.4 输出浮点数
10.4.5 字符输出
10.5 其他输出函数
10.5.1 屏幕的非格式化输出
10.5.2 数组的格式化输出
10.5.3 数组的格式化输入
10.6 小结
10.7 习题

第11章 结构化数据
11.1 数据结构：使用struct
11.1.1 定义结构类型和结构变量
11.1.2 访问结构成员
11.1.3 未命名的结构
11.1.4 结构数组
11.1.5 表达式中的结构成员
11.1.6 结构指针
11.1.7 为结构动态分配内存
11.2 再探结构成员
11.2.1 将一个结构作为另一个结构的成员
11.2.2 声明结构中的结构
11.2.3 将结构指针用作结构成员
11.2.4 双向链表
11.2.5 结构中的位字段
11.3 结构与函数
11.3.1 结构作为函数的变元
11.3.2 结构指针作为函数变元
11.3.3 作为函数返回值的结构
11.3.4 二叉树
11.4 共享内存
11.5 设计程序
11.5.1 问题
11.5.2 分析
11.5.3 解决方案
11.6 小结
11.7 习题

第12章 处理文件
12.1 文件的概念
12.1.1 文件中的位置
12.1.2 文件流
12.2 文件访问
12.2.1 打开文件
12.2.2 缓存文件操作
12.2.3 文件重命名
12.2.4 关闭文件
12.2.5 删除文件
12.3 写入文本文件
12.4 读取文本文件
12.5 在文本文件中读写字符串
12.6 格式化文件的输入输出
12.6.1 格式化文件输出
12.6.2 格式化文件输入
12.7 错误处理
12.8 再探文本文件操作模式
12.9 freopen_s()函数
12.10 二进制文件的输入输出
12.10.1 以二进制模式打开文件
12.10.2 写入二进制文件
12.10.3 读取二进制文件
12.11 在文件中移动
12.11.1 文件定位操作
12.11.2 找出我们在文件中的位置
12.11.3 在文件中设定位置
12.12 使用临时文件
12.12.1 创建临时文件
12.12.2 创建唯一的文件名
12.13 更新二进制文件
12.13.1 修改文件的内容
12.13.2 从键盘输入创建记录
12.13.3 将记录写入文件
12.13.4 从文件中读取记录
12.13.5 写入文件
12.13.6 列出文件内容
12.13.7 更新已有的文件内容
12.14 文件打开模式小结
12.15 设计程序
12.15.1 问题
12.15.2 分析
12.15.3 解决方案
12.16 小结
12.17 习题

第13章 支持功能
13.1 预处理
13.1.1 在程序中包含头文件
13.1.2 定义自己的头文件
13.1.3 管理多个源文件
13.1.4 外部变量
13.1.5 静态函数
13.1.6 替换程序源代码
13.2 宏
13.2.1 看起来像函数的宏
13.2.2 字符串作为宏参数
13.2.3 在宏展开式中结合两个变元
13.3 多行上的预处理器指令
13.3.1 预处理器逻辑指令
13.3.2 条件编译
13.3.3 测试多个条件
13.3.4 取消定义的标识符
13.3.5 测试标识符的指定值的指令
13.3.6 多项选择
13.3.7 标准预处理宏
13.4 调试方法
13.4.1 集成的调试器
13.4.2 调试阶段的预处理器
13.4.3 断言
13.5 日期和时间函数
13.5.1 获取时间值
13.5.2 获取日期
13.5.3 确定某一天是星期几
13.6 小结
13.7 习题

第14章 高级专用主题
14.1 使用国际字符集
14.1.1 理解Unicode
14.1.2 设置区域
14.1.3 宽字符类型wchar_t
14.1.4 宽字符串的操作
14.1.5 宽字符的文件流操作
14.1.6 存储Unicode字符的固定大小类型
14.2 用于可移植性的专用整数类型
14.2.1 固定宽度的整型
14.2.2 最小宽度的整型
14.2.3 最大宽度的整型
14.3 复数类型
14.3.1 复数基础
14.3.2 复数类型和操作
14.4 用线程编程
14.4.1 创建线程
14.4.2 退出线程
14.4.3 把一个线程连接到另一个线程上
14.4.4 挂起线程
14.4.5 管理线程对数据的访问
14.5 小结
附录A 计算机中的数学知识
附录B ASCII字符代码定义
附录C C语言中的保留字
附录D 输入输出格式说明符
附录E 标准库头文件

==============


